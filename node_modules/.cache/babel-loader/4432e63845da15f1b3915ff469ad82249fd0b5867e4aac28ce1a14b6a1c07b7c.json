{"ast":null,"code":"const AgErrorBarSupportedSeriesTypes = ['bar', 'line', 'scatter'];\n\n/**\r\n * Internal Use Only: Used to ensure this file is treated as a module until we can use moduleDetection flag in Ts v4.7\r\n */\nconst __FORCE_MODULE_DETECTION$1 = 0;\n\n/**\r\n * The interval methods don't mutate Date parameters.\r\n */\nclass TimeInterval {\n  constructor(_encode, _decode, _rangeCallback) {\n    this._encode = _encode;\n    this._decode = _decode;\n    this._rangeCallback = _rangeCallback;\n  }\n  /**\r\n   * Returns a new date representing the latest interval boundary date before or equal to date.\r\n   * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.\r\n   * @param date\r\n   */\n  floor(date) {\n    const d = new Date(date);\n    const e = this._encode(d);\n    return this._decode(e);\n  }\n  /**\r\n   * Returns a new date representing the earliest interval boundary date after or equal to date.\r\n   * @param date\r\n   */\n  ceil(date) {\n    const d = new Date(Number(date) - 1);\n    const e = this._encode(d);\n    return this._decode(e + 1);\n  }\n  /**\r\n   * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).\r\n   * @param start Range start.\r\n   * @param stop Range end.\r\n   * @param extend If specified, the requested range will be extended to the closest \"nice\" values.\r\n   */\n  range(start, stop, extend) {\n    var _a;\n    const rangeCallback = (_a = this._rangeCallback) === null || _a === void 0 ? void 0 : _a.call(this, start, stop);\n    const e0 = this._encode(extend ? this.floor(start) : this.ceil(start));\n    const e1 = this._encode(extend ? this.ceil(stop) : this.floor(stop));\n    if (e1 < e0) {\n      return [];\n    }\n    const range = [];\n    for (let e = e0; e <= e1; e++) {\n      const d = this._decode(e);\n      range.push(d);\n    }\n    rangeCallback === null || rangeCallback === void 0 ? void 0 : rangeCallback();\n    return range;\n  }\n}\nclass CountableTimeInterval extends TimeInterval {\n  getOffset(snapTo, step) {\n    const s = typeof snapTo === 'number' || snapTo instanceof Date ? this._encode(new Date(snapTo)) : 0;\n    return Math.floor(s) % step;\n  }\n  /**\r\n   * Returns a filtered view of this interval representing every step'th date.\r\n   * It can be a number of minutes, hours, days etc.\r\n   * Must be a positive integer.\r\n   * @param step\r\n   */\n  every(step, options) {\n    let offset = 0;\n    let rangeCallback;\n    const {\n      snapTo = 'start'\n    } = options !== null && options !== void 0 ? options : {};\n    if (typeof snapTo === 'string') {\n      const initialOffset = offset;\n      rangeCallback = (start, stop) => {\n        const s = snapTo === 'start' ? start : stop;\n        offset = this.getOffset(s, step);\n        return () => offset = initialOffset;\n      };\n    } else if (typeof snapTo === 'number') {\n      offset = this.getOffset(new Date(snapTo), step);\n    } else if (snapTo instanceof Date) {\n      offset = this.getOffset(snapTo, step);\n    }\n    const encode = date => {\n      const e = this._encode(date);\n      return Math.floor((e - offset) / step);\n    };\n    const decode = encoded => {\n      return this._decode(encoded * step + offset);\n    };\n    return new TimeInterval(encode, decode, rangeCallback);\n  }\n}\nfunction encode$b(date) {\n  return date.getTime();\n}\nfunction decode$b(encoded) {\n  return new Date(encoded);\n}\nconst millisecond = new CountableTimeInterval(encode$b, decode$b);\n\n// Common time unit sizes in milliseconds.\nnew Date(0).getFullYear();\nconst durationSecond = 1000;\nconst durationMinute = durationSecond * 60;\nconst durationHour = durationMinute * 60;\nconst durationDay = durationHour * 24;\nconst durationWeek = durationDay * 7;\nconst durationMonth = durationDay * 30;\nconst durationYear = durationDay * 365;\nconst offset$2 = new Date().getTimezoneOffset() * durationMinute;\nfunction encode$a(date) {\n  return Math.floor((date.getTime() - offset$2) / durationSecond);\n}\nfunction decode$a(encoded) {\n  return new Date(offset$2 + encoded * durationSecond);\n}\nconst second = new CountableTimeInterval(encode$a, decode$a);\nconst offset$1 = new Date().getTimezoneOffset() * durationMinute;\nfunction encode$9(date) {\n  return Math.floor((date.getTime() - offset$1) / durationMinute);\n}\nfunction decode$9(encoded) {\n  return new Date(offset$1 + encoded * durationMinute);\n}\nconst minute = new CountableTimeInterval(encode$9, decode$9);\nconst offset = new Date().getTimezoneOffset() * durationMinute;\nfunction encode$8(date) {\n  return Math.floor((date.getTime() - offset) / durationHour);\n}\nfunction decode$8(encoded) {\n  return new Date(offset + encoded * durationHour);\n}\nconst hour = new CountableTimeInterval(encode$8, decode$8);\nfunction encode$7(date) {\n  const tzOffsetMs = date.getTimezoneOffset() * 60000;\n  return Math.floor((date.getTime() - tzOffsetMs) / durationDay);\n}\nfunction decode$7(encoded) {\n  const d = new Date(1970, 0, 1);\n  d.setDate(d.getDate() + encoded);\n  return d;\n}\nconst day = new CountableTimeInterval(encode$7, decode$7);\n\n// Set date to n-th day of the week.\nfunction weekday(n) {\n  const base = new Date(2023, 0, 1 + n).getTime();\n  function encode(date) {\n    const dateMs = date.getTime();\n    return Math.floor((dateMs - base) / durationWeek);\n  }\n  function decode(encoded) {\n    const d = new Date(base);\n    d.setDate(d.getDate() + encoded * 7);\n    return d;\n  }\n  return new CountableTimeInterval(encode, decode);\n}\nconst sunday = weekday(0);\nconst monday = weekday(1);\nconst tuesday = weekday(2);\nconst wednesday = weekday(3);\nconst thursday = weekday(4);\nconst friday = weekday(5);\nconst saturday = weekday(6);\nfunction encode$6(date) {\n  return date.getFullYear() * 12 + date.getMonth();\n}\nfunction decode$6(encoded) {\n  const year = Math.floor(encoded / 12);\n  const month = encoded - year * 12;\n  return new Date(year, month, 1);\n}\nconst month = new CountableTimeInterval(encode$6, decode$6);\nfunction encode$5(date) {\n  return date.getFullYear();\n}\nfunction decode$5(encoded) {\n  // Note: assigning years through the constructor\n  // will break for years 0 - 99 AD (will turn 1900's).\n  const d = new Date();\n  d.setFullYear(encoded);\n  d.setMonth(0, 1);\n  d.setHours(0, 0, 0, 0);\n  return d;\n}\nconst year = new CountableTimeInterval(encode$5, decode$5);\nfunction encode$4(date) {\n  return Math.floor(date.getTime() / durationMinute);\n}\nfunction decode$4(encoded) {\n  return new Date(encoded * durationMinute);\n}\nconst utcMinute = new CountableTimeInterval(encode$4, decode$4);\nfunction encode$3(date) {\n  return Math.floor(date.getTime() / durationHour);\n}\nfunction decode$3(encoded) {\n  return new Date(encoded * durationHour);\n}\nconst utcHour = new CountableTimeInterval(encode$3, decode$3);\nfunction encode$2(date) {\n  return Math.floor(date.getTime() / durationDay);\n}\nfunction decode$2(encoded) {\n  const d = new Date(0);\n  d.setUTCDate(d.getUTCDate() + encoded);\n  d.setUTCHours(0, 0, 0, 0);\n  return d;\n}\nconst utcDay = new CountableTimeInterval(encode$2, decode$2);\nfunction encode$1(date) {\n  return date.getUTCFullYear() * 12 + date.getUTCMonth();\n}\nfunction decode$1(encoded) {\n  const year = Math.floor(encoded / 12);\n  const month = encoded - year * 12;\n  return new Date(Date.UTC(year, month, 1));\n}\nconst utcMonth = new CountableTimeInterval(encode$1, decode$1);\nfunction encode(date) {\n  return date.getUTCFullYear();\n}\nfunction decode(encoded) {\n  // Note: assigning years through the constructor\n  // will break for years 0 - 99 AD (will turn 1900's).\n  const d = new Date();\n  d.setUTCFullYear(encoded);\n  d.setUTCMonth(0, 1);\n  d.setUTCHours(0, 0, 0, 0);\n  return d;\n}\nconst utcYear = new CountableTimeInterval(encode, decode);\nvar index = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  millisecond: millisecond,\n  second: second,\n  minute: minute,\n  hour: hour,\n  day: day,\n  sunday: sunday,\n  monday: monday,\n  tuesday: tuesday,\n  wednesday: wednesday,\n  thursday: thursday,\n  friday: friday,\n  saturday: saturday,\n  month: month,\n  year: year,\n  utcMinute: utcMinute,\n  utcHour: utcHour,\n  utcDay: utcDay,\n  utcMonth: utcMonth,\n  utcYear: utcYear\n});\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\n}\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nconst enterpriseModule = {\n  isEnterprise: false\n};\nclass BaseModuleInstance {\n  constructor() {\n    this.destroyFns = [];\n  }\n  destroy() {\n    for (const destroyFn of this.destroyFns) {\n      destroyFn();\n    }\n  }\n}\nconst REGISTERED_MODULES = [];\nfunction registerModule(module) {\n  const otherModule = REGISTERED_MODULES.find(other => {\n    return module.type === other.type && module.optionsKey === other.optionsKey && module.identifier === other.identifier;\n  });\n  if (otherModule) {\n    if (module.packageType === 'enterprise' && otherModule.packageType === 'community') {\n      // Replace the community module with an enterprise version\n      const index = REGISTERED_MODULES.indexOf(otherModule);\n      REGISTERED_MODULES.splice(index, 1, module);\n    }\n  } else {\n    // Simply register the module\n    REGISTERED_MODULES.push(module);\n  }\n}\nfunction hasRegisteredEnterpriseModules() {\n  return REGISTERED_MODULES.some(m => m.packageType === 'enterprise');\n}\nconst MODULE_CONFLICTS = new Map();\nfunction registerModuleConflicts(source, targets) {\n  MODULE_CONFLICTS.set(source, targets);\n}\nfunction extent(values) {\n  const {\n    length\n  } = values;\n  if (length === 0) {\n    return undefined;\n  }\n  let min = Infinity;\n  let max = -Infinity;\n  for (let i = 0; i < length; i++) {\n    let v = values[i];\n    if (v instanceof Date) {\n      v = v.getTime();\n    }\n    if (typeof v !== 'number') {\n      continue;\n    }\n    if (v < min) {\n      min = v;\n    }\n    if (v > max) {\n      max = v;\n    }\n  }\n  const extent = [min, max];\n  if (extent.some(v => !isFinite(v))) {\n    return undefined;\n  }\n  return extent;\n}\nfunction normalisedExtent(d, min, max) {\n  return normalisedExtentWithMetadata(d, min, max).extent;\n}\nfunction normalisedExtentWithMetadata(d, min, max) {\n  var _a;\n  let clipped = false;\n  if (d.length > 2) {\n    d = (_a = extent(d)) !== null && _a !== void 0 ? _a : [NaN, NaN];\n  }\n  if (!isNaN(min)) {\n    clipped || (clipped = min > d[0]);\n    d = [min, d[1]];\n  }\n  if (!isNaN(max)) {\n    clipped || (clipped = max < d[1]);\n    d = [d[0], max];\n  }\n  if (d[0] > d[1]) {\n    d = [];\n  }\n  return {\n    extent: d,\n    clipped\n  };\n}\nfunction arraysEqual(a, b) {\n  if (a == null || b == null || a.length !== b.length) {\n    return false;\n  }\n  for (let i = 0; i < a.length; i++) {\n    if (Array.isArray(a[i]) && Array.isArray(b[i])) {\n      if (!arraysEqual(a[i], b[i])) {\n        return false;\n      }\n    } else if (a[i] !== b[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction toArray(value) {\n  if (typeof value === 'undefined') {\n    return [];\n  }\n  return Array.isArray(value) ? value : [value];\n}\nconst doOnceFlags = {};\n/**\r\n * If the key was passed before, then doesn't execute the func\r\n */\nfunction doOnce(func, key) {\n  if (doOnceFlags[key]) {\n    return;\n  }\n  func();\n  doOnceFlags[key] = true;\n}\n\n/* eslint-disable no-console */\nconst Logger = {\n  log(...logContent) {\n    console.log(...logContent);\n  },\n  warn(message, ...logContent) {\n    console.warn(`AG Charts - ${message}`, ...logContent);\n  },\n  error(message, ...logContent) {\n    if (typeof message === 'object') {\n      console.error(`AG Charts error`, message, ...logContent);\n    } else {\n      console.error(`AG Charts - ${message}`, ...logContent);\n    }\n  },\n  table(...logContent) {\n    console.table(...logContent);\n  },\n  warnOnce(message, ...logContent) {\n    doOnce(() => Logger.warn(message, ...logContent), `Logger.warn: ${message}`);\n  },\n  errorOnce(message, ...logContent) {\n    doOnce(() => Logger.error(message, ...logContent), `Logger.warn: ${message}`);\n  }\n};\nfunction windowValue(name) {\n  /**\r\n   * Redeclaration of window that is safe for use with Gatsby server-side (webpack) compilation.\r\n   */\n  const WINDOW = typeof window !== 'undefined' ? window :\n  // typeof global !== 'undefined' ? (global as any) :\n  undefined;\n  return WINDOW === null || WINDOW === void 0 ? void 0 : WINDOW[name];\n}\nconst LONG_TIME_PERIOD_THRESHOLD = 2000;\nlet timeOfLastLog = Date.now();\nconst logTimeGap = () => {\n  const timeSinceLastLog = Date.now() - timeOfLastLog;\n  if (timeSinceLastLog > LONG_TIME_PERIOD_THRESHOLD) {\n    const prettyDuration = (Math.floor(timeSinceLastLog / 100) / 10).toFixed(1);\n    Logger.log(`**** ${prettyDuration}s since last log message ****`);\n  }\n  timeOfLastLog = Date.now();\n};\nconst Debug = {\n  create(...debugSelectors) {\n    return (...logContent) => {\n      if (Debug.check(...debugSelectors)) {\n        if (typeof logContent[0] === 'function') {\n          logContent = toArray(logContent[0]());\n        }\n        logTimeGap();\n        Logger.log(...logContent);\n      }\n    };\n  },\n  check(...debugSelectors) {\n    if (debugSelectors.length === 0) {\n      debugSelectors.push(true);\n    }\n    const chartDebug = toArray(windowValue('agChartsDebug'));\n    return chartDebug.some(selector => debugSelectors.includes(selector));\n  }\n};\nconst BREAK_TRANSFORM_CHAIN = Symbol('BREAK');\nconst CONFIG_KEY = '__decorator_config';\nfunction initialiseConfig(target, propertyKeyOrSymbol, propertyKey, valueStoreKey) {\n  if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {\n    Object.defineProperty(target, CONFIG_KEY, {\n      value: {}\n    });\n  }\n  const config = target[CONFIG_KEY];\n  if (config[propertyKey] != null) {\n    return config[propertyKey];\n  }\n  config[propertyKey] = {\n    setters: [],\n    getters: []\n  };\n  const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);\n  const prevSet = descriptor === null || descriptor === void 0 ? void 0 : descriptor.set;\n  const prevGet = descriptor === null || descriptor === void 0 ? void 0 : descriptor.get;\n  const getter = function () {\n    var _a, _b;\n    let value = prevGet ? prevGet.call(this) : this[valueStoreKey];\n    for (const transformFn of (_b = (_a = config[propertyKey]) === null || _a === void 0 ? void 0 : _a.getters) !== null && _b !== void 0 ? _b : []) {\n      value = transformFn(this, propertyKeyOrSymbol, value);\n      if (value === BREAK_TRANSFORM_CHAIN) {\n        return undefined;\n      }\n    }\n    return value;\n  };\n  const setter = function (value) {\n    var _a, _b;\n    const setters = (_b = (_a = config[propertyKey]) === null || _a === void 0 ? void 0 : _a.setters) !== null && _b !== void 0 ? _b : [];\n    let oldValue;\n    if (setters.some(f => f.length > 2)) {\n      // Lazily retrieve old value.\n      oldValue = prevGet ? prevGet.call(this) : this[valueStoreKey];\n    }\n    for (const transformFn of setters) {\n      value = transformFn(this, propertyKeyOrSymbol, value, oldValue);\n      if (value === BREAK_TRANSFORM_CHAIN) {\n        return;\n      }\n    }\n    if (prevSet) {\n      prevSet.call(this, value);\n    } else {\n      this[valueStoreKey] = value;\n    }\n  };\n  Object.defineProperty(target, propertyKeyOrSymbol, {\n    set: setter,\n    get: getter,\n    enumerable: true,\n    configurable: false\n  });\n  return config[propertyKey];\n}\nfunction addTransformToInstanceProperty(setTransform, getTransform) {\n  return (target, propertyKeyOrSymbol) => {\n    const propertyKey = propertyKeyOrSymbol.toString();\n    const valueStoreKey = `__${propertyKey}`;\n    const {\n      getters,\n      setters\n    } = initialiseConfig(target, propertyKeyOrSymbol, propertyKey, valueStoreKey);\n    setters.push(setTransform);\n    if (getTransform) {\n      getters.unshift(getTransform);\n    }\n  };\n}\nfunction isDecoratedObject(target) {\n  return typeof target !== 'undefined' && CONFIG_KEY in target;\n}\nfunction listDecoratedProperties(target) {\n  const targets = new Set();\n  while (isDecoratedObject(target)) {\n    targets.add(target === null || target === void 0 ? void 0 : target[CONFIG_KEY]);\n    target = Object.getPrototypeOf(target);\n  }\n  return Array.from(targets).flatMap(configMap => Object.keys(configMap));\n}\nfunction extractDecoratedProperties(target) {\n  return listDecoratedProperties(target).reduce((result, key) => {\n    var _a;\n    result[key] = (_a = target[key]) !== null && _a !== void 0 ? _a : null;\n    return result;\n  }, {});\n}\nfunction createDeprecationWarning() {\n  return (key, message) => {\n    const msg = [`Property [${key}] is deprecated.`, message].filter(v => v != null).join(' ');\n    Logger.warnOnce(msg);\n  };\n}\nconst CLASS_INSTANCE_TYPE = 'class-instance';\n/**\r\n * Performs a JSON-diff between a source and target JSON structure.\r\n *\r\n * On a per property basis, takes the target property value where:\r\n * - types are different.\r\n * - type is primitive.\r\n * - type is array and length or content have changed.\r\n *\r\n * Recurses for object types.\r\n *\r\n * @param source starting point for diff\r\n * @param target target for diff vs. source\r\n *\r\n * @returns `null` if no differences, or an object with the subset of properties that have changed.\r\n */\nfunction jsonDiff(source, target) {\n  const sourceType = classify(source);\n  const targetType = classify(target);\n  if (targetType === 'array') {\n    const targetArray = target;\n    if (sourceType !== 'array' || source.length !== targetArray.length) {\n      return [...targetArray];\n    }\n    if (targetArray.some((targetElement, i) => jsonDiff(source === null || source === void 0 ? void 0 : source[i], targetElement) != null)) {\n      return [...targetArray];\n    }\n    return null;\n  }\n  if (targetType === 'primitive') {\n    if (sourceType !== 'primitive') {\n      return Object.assign({}, target);\n    }\n    if (source !== target) {\n      return target;\n    }\n    return null;\n  }\n  const lhs = source || {};\n  const rhs = target || {};\n  const allProps = new Set([...Object.keys(lhs), ...Object.keys(rhs)]);\n  let propsChangedCount = 0;\n  const result = {};\n  for (const prop of allProps) {\n    // Cheap-and-easy equality check.\n    if (lhs[prop] === rhs[prop]) {\n      continue;\n    }\n    const take = v => {\n      result[prop] = v;\n      propsChangedCount++;\n    };\n    const lhsType = classify(lhs[prop]);\n    const rhsType = classify(rhs[prop]);\n    if (lhsType !== rhsType) {\n      // Types changed, just take RHS.\n      take(rhs[prop]);\n      continue;\n    }\n    if (rhsType === 'primitive' || rhsType === null) {\n      take(rhs[prop]);\n      continue;\n    }\n    if (rhsType === 'array' && lhs[prop].length !== rhs[prop].length) {\n      // Arrays are different sizes, so just take target array.\n      take(rhs[prop]);\n      continue;\n    }\n    if (rhsType === CLASS_INSTANCE_TYPE) {\n      // Don't try to do anything tricky with array diffs!\n      take(rhs[prop]);\n      continue;\n    }\n    if (rhsType === 'function' && lhs[prop] !== rhs[prop]) {\n      take(rhs[prop]);\n      continue;\n    }\n    const diff = jsonDiff(lhs[prop], rhs[prop]);\n    if (diff !== null) {\n      take(diff);\n    }\n  }\n  return propsChangedCount === 0 ? null : result;\n}\n/**\r\n * Special value used by `jsonMerge` to signal that a property should be removed from the merged\r\n * output.\r\n */\nconst DELETE = Symbol('<delete-property>');\nconst NOT_SPECIFIED = Symbol('<unspecified-property>');\n/**\r\n * Merge together the provide JSON object structures, with the precedence of application running\r\n * from higher indexes to lower indexes.\r\n *\r\n * Deep-clones all objects to avoid mutation of the inputs changing the output object. For arrays,\r\n * just performs a deep-clone of the entire array, no merging of elements attempted.\r\n *\r\n * @param json all json objects to merge\r\n * @param opts merge options\r\n * @param opts.avoidDeepClone contains a list of properties where deep clones should be avoided\r\n *\r\n * @returns the combination of all the json inputs\r\n */\nfunction jsonMerge(json, opts) {\n  var _a;\n  const avoidDeepClone = (_a = opts === null || opts === void 0 ? void 0 : opts.avoidDeepClone) !== null && _a !== void 0 ? _a : [];\n  const jsonTypes = json.map(v => classify(v));\n  if (jsonTypes.some(v => v === 'array')) {\n    // Clone final array.\n    const finalValue = json[json.length - 1];\n    if (Array.isArray(finalValue)) {\n      return finalValue.map(v => {\n        const type = classify(v);\n        if (type === 'array') return jsonMerge([[], v], opts);\n        if (type === 'object') return jsonMerge([{}, v], opts);\n        return v;\n      });\n    }\n    return finalValue;\n  }\n  const result = {};\n  const props = new Set(json.map(v => v != null ? Object.keys(v) : []).reduce((r, n) => r.concat(n), []));\n  for (const nextProp of props) {\n    const values = json.map(j => {\n      if (j != null && typeof j === 'object' && nextProp in j) {\n        return j[nextProp];\n      }\n      return NOT_SPECIFIED;\n    }).filter(v => v !== NOT_SPECIFIED);\n    if (values.length === 0) {\n      continue;\n    }\n    const lastValue = values[values.length - 1];\n    if (lastValue === DELETE) {\n      continue;\n    }\n    const types = values.map(v => classify(v));\n    const type = types[0];\n    if (types.some(t => t !== type)) {\n      // Short-circuit if mismatching types.\n      result[nextProp] = lastValue;\n      continue;\n    }\n    if ((type === 'array' || type === 'object') && !avoidDeepClone.includes(nextProp)) {\n      result[nextProp] = jsonMerge(values, opts);\n    } else if (type === 'array') {\n      // Arrays need to be shallow copied to avoid external mutation and allow jsonDiff to\n      // detect changes.\n      result[nextProp] = [...lastValue];\n    } else {\n      // Just directly assign/overwrite.\n      result[nextProp] = lastValue;\n    }\n  }\n  return result;\n}\n/**\r\n * Recursively apply a JSON object into a class-hierarchy, optionally instantiating certain classes\r\n * by property name.\r\n *\r\n * @param target to apply source JSON properties into\r\n * @param source to be applied\r\n * @param params\r\n * @param params.path path for logging/error purposes, to aid with pinpointing problems\r\n * @param params.matcherPath path for pattern matching, to lookup allowedTypes override.\r\n * @param params.skip property names to skip from the source\r\n * @param params.constructors dictionary of property name to class constructors for properties that\r\n *                            require object construction\r\n * @param params.constructedArrays map stores arrays which items should be initialised\r\n *                                 using a class constructor\r\n * @param params.allowedTypes overrides by path for allowed property types\r\n */\nfunction jsonApply(target, source, params = {}) {\n  var _a, _b, _c;\n  const {\n    path = undefined,\n    matcherPath = path ? path.replace(/(\\[[0-9+]+])/i, '[]') : undefined,\n    skip = [],\n    constructors = {},\n    constructedArrays = new WeakMap(),\n    allowedTypes = {},\n    idx\n  } = params;\n  if (target == null) {\n    throw new Error(`AG Charts - target is uninitialised: ${path !== null && path !== void 0 ? path : '<root>'}`);\n  }\n  if (source == null) {\n    return target;\n  }\n  const targetAny = target;\n  if (idx != null && '_declarationOrder' in targetAny) {\n    targetAny['_declarationOrder'] = idx;\n  }\n  const targetType = classify(target);\n  for (const property in source) {\n    const propertyMatcherPath = `${matcherPath ? matcherPath + '.' : ''}${property}`;\n    if (skip.indexOf(propertyMatcherPath) >= 0) {\n      continue;\n    }\n    const newValue = source[property];\n    const propertyPath = `${path ? path + '.' : ''}${property}`;\n    const targetClass = targetAny.constructor;\n    const currentValue = targetAny[property];\n    let ctr = (_a = constructors[propertyMatcherPath]) !== null && _a !== void 0 ? _a : constructors[property];\n    try {\n      const currentValueType = classify(currentValue);\n      const newValueType = classify(newValue);\n      if (targetType === CLASS_INSTANCE_TYPE && !(property in target || Object.prototype.hasOwnProperty.call(targetAny, property))) {\n        Logger.warn(`unable to set [${propertyPath}] in ${targetClass === null || targetClass === void 0 ? void 0 : targetClass.name} - property is unknown`);\n        continue;\n      }\n      const allowableTypes = (_b = allowedTypes[propertyMatcherPath]) !== null && _b !== void 0 ? _b : [currentValueType];\n      if (currentValueType === CLASS_INSTANCE_TYPE && newValueType === 'object') {\n        // Allowed, this is the common case! - do not error.\n      } else if (currentValueType != null && newValueType != null && !allowableTypes.includes(newValueType)) {\n        Logger.warn(`unable to set [${propertyPath}] in ${targetClass === null || targetClass === void 0 ? void 0 : targetClass.name} - can't apply type of [${newValueType}], allowed types are: [${allowableTypes}]`);\n        continue;\n      }\n      if (newValueType === 'array') {\n        ctr = (_c = ctr !== null && ctr !== void 0 ? ctr : constructedArrays.get(currentValue)) !== null && _c !== void 0 ? _c : constructors[`${propertyMatcherPath}[]`];\n        if (ctr != null) {\n          const newValueArray = newValue;\n          targetAny[property] = newValueArray.map((v, idx) => jsonApply(new ctr(), v, Object.assign(Object.assign({}, params), {\n            path: propertyPath,\n            matcherPath: propertyMatcherPath + '[]',\n            idx\n          })));\n        } else {\n          targetAny[property] = newValue;\n        }\n      } else if (newValueType === CLASS_INSTANCE_TYPE) {\n        targetAny[property] = newValue;\n      } else if (newValueType === 'object') {\n        if (currentValue != null) {\n          jsonApply(currentValue, newValue, Object.assign(Object.assign({}, params), {\n            path: propertyPath,\n            matcherPath: propertyMatcherPath,\n            idx: undefined\n          }));\n        } else if (ctr != null) {\n          targetAny[property] = jsonApply(new ctr(), newValue, Object.assign(Object.assign({}, params), {\n            path: propertyPath,\n            matcherPath: propertyMatcherPath,\n            idx: undefined\n          }));\n        } else {\n          targetAny[property] = newValue;\n        }\n      } else {\n        targetAny[property] = newValue;\n      }\n    } catch (error) {\n      Logger.warn(`unable to set [${propertyPath}] in [${targetClass === null || targetClass === void 0 ? void 0 : targetClass.name}]; nested error is: ${error.message}`);\n    }\n  }\n  return target;\n}\n/**\r\n * Walk the given JSON object graphs, invoking the visit() callback for every object encountered.\r\n * Arrays are descended into without a callback, however their elements will have the visit()\r\n * callback invoked if they are objects.\r\n *\r\n * @param json to traverse\r\n * @param visit callback for each non-primitive and non-array object found\r\n * @param opts\r\n * @param opts.skip property names to skip when walking\r\n * @param jsons to traverse in parallel\r\n */\nfunction jsonWalk(json, visit, opts, ...jsons) {\n  const jsonType = classify(json);\n  const {\n    skip = []\n  } = opts !== null && opts !== void 0 ? opts : {};\n  if (jsonType === 'array') {\n    visit(jsonType, json, ...jsons);\n    json.forEach((element, index) => {\n      jsonWalk(element, visit, opts, ...(jsons !== null && jsons !== void 0 ? jsons : []).map(o => o === null || o === void 0 ? void 0 : o[index]));\n    });\n    return;\n  }\n  if (jsonType !== 'object') {\n    return;\n  }\n  visit(jsonType, json, ...jsons);\n  for (const property in json) {\n    if (skip.includes(property)) {\n      continue;\n    }\n    const value = json[property];\n    const otherValues = jsons === null || jsons === void 0 ? void 0 : jsons.map(o => o === null || o === void 0 ? void 0 : o[property]);\n    const valueType = classify(value);\n    if (valueType === 'object' || valueType === 'array') {\n      jsonWalk(value, visit, opts, ...otherValues);\n    }\n  }\n}\nconst isBrowser = typeof window !== 'undefined';\n/**\r\n * Classify the type of value to assist with handling for merge purposes.\r\n */\nfunction classify(value) {\n  if (value == null) {\n    return null;\n  }\n  if (isBrowser && value instanceof HTMLElement) {\n    return 'primitive';\n  }\n  if (Array.isArray(value)) {\n    return 'array';\n  }\n  if (value instanceof Date) {\n    return 'primitive';\n  }\n  if (typeof value === 'object' && value.constructor === Object) {\n    return 'object';\n  }\n  if (typeof value === 'function') {\n    return 'function';\n  }\n  if (typeof value === 'object' && value.constructor != null) {\n    return CLASS_INSTANCE_TYPE;\n  }\n  return 'primitive';\n}\nconst twoPi = Math.PI * 2;\n/**\r\n * Normalize the given angle to be in the [0, 2π) interval.\r\n * @param radians Angle in radians.\r\n */\nfunction normalizeAngle360(radians) {\n  radians %= twoPi;\n  radians += twoPi;\n  radians %= twoPi;\n  return radians;\n}\nfunction normalizeAngle360Inclusive(radians) {\n  radians %= twoPi;\n  radians += twoPi;\n  if (radians !== twoPi) {\n    radians %= twoPi;\n  }\n  return radians;\n}\n/**\r\n * Normalize the given angle to be in the [-π, π) interval.\r\n * @param radians Angle in radians.\r\n */\nfunction normalizeAngle180(radians) {\n  radians %= twoPi;\n  if (radians < -Math.PI) {\n    radians += twoPi;\n  } else if (radians >= Math.PI) {\n    radians -= twoPi;\n  }\n  return radians;\n}\nfunction toRadians(degrees) {\n  return degrees / 180 * Math.PI;\n}\nfunction toDegrees(radians) {\n  return radians / Math.PI * 180;\n}\n/**\r\n * Returns a rotation angle between two other angles.\r\n * @param angle0 Angle in radians.\r\n * @param angle1 Angle in radians.\r\n * @returns Angle in radians.\r\n */\nfunction angleBetween(angle0, angle1) {\n  angle0 = normalizeAngle360(angle0);\n  angle1 = normalizeAngle360(angle1);\n  return angle1 - angle0 + (angle0 > angle1 ? 2 * Math.PI : 0);\n}\nfunction clamp$1(x, min, max) {\n  return Math.max(min, Math.min(max, x));\n}\n/**\r\n * Maps a discrete domain to a continuous numeric range.\r\n */\nclass BandScale {\n  constructor() {\n    this.type = 'band';\n    this.cache = null;\n    this.cacheProps = ['_domain', 'range', '_paddingInner', '_paddingOuter', 'round', 'interval'];\n    /**\r\n     * Maps datum to its index in the {@link domain} array.\r\n     * Used to check for duplicate datums (not allowed).\r\n     */\n    this.index = new Map();\n    /**\r\n     * The output range values for datum at each index.\r\n     */\n    this.ordinalRange = [];\n    /**\r\n     * Contains unique datums only. Since `{}` is used in place of `Map`\r\n     * for IE11 compatibility, the datums are converted `toString` before\r\n     * the uniqueness check.\r\n     */\n    this._domain = [];\n    this.range = [0, 1];\n    this._bandwidth = 1;\n    this._rawBandwidth = 1;\n    /**\r\n     * The ratio of the range that is reserved for space between bands.\r\n     */\n    this._paddingInner = 0;\n    /**\r\n     * The ratio of the range that is reserved for space before the first\r\n     * and after the last band.\r\n     */\n    this._paddingOuter = 0;\n    this.round = false;\n  }\n  didChange() {\n    const {\n      cache\n    } = this;\n    const didChange = !cache || this.cacheProps.some(p => this[p] !== cache[p]);\n    if (didChange) {\n      this.cache = {};\n      this.cacheProps.forEach(p => this.cache[p] = this[p]);\n      return true;\n    }\n    return false;\n  }\n  refresh() {\n    if (this.didChange()) {\n      this.update();\n    }\n  }\n  set domain(values) {\n    const domain = [];\n    this.index = new Map();\n    const index = this.index;\n    // In case one wants to have duplicate domain values, for example, two 'Italy' categories,\n    // one should use objects rather than strings for domain values like so:\n    // { toString: () => 'Italy' }\n    // { toString: () => 'Italy' }\n    values.forEach(value => {\n      if (index.get(value) === undefined) {\n        index.set(value, domain.push(value) - 1);\n      }\n    });\n    this._domain = domain;\n  }\n  get domain() {\n    return this._domain;\n  }\n  ticks() {\n    this.refresh();\n    const {\n      interval = 1\n    } = this;\n    const step = Math.abs(Math.round(interval));\n    return this._domain.filter((_, i) => i % step === 0);\n  }\n  convert(d) {\n    this.refresh();\n    const i = this.index.get(d);\n    if (i === undefined) {\n      return NaN;\n    }\n    const r = this.ordinalRange[i];\n    if (r === undefined) {\n      return NaN;\n    }\n    return r;\n  }\n  invert(position) {\n    this.refresh();\n    const index = this.ordinalRange.findIndex(p => p === position);\n    return this.domain[index];\n  }\n  get bandwidth() {\n    this.refresh();\n    return this._bandwidth;\n  }\n  get rawBandwidth() {\n    this.refresh();\n    return this._rawBandwidth;\n  }\n  set padding(value) {\n    value = clamp$1(value, 0, 1);\n    this._paddingInner = value;\n    this._paddingOuter = value;\n  }\n  get padding() {\n    return this._paddingInner;\n  }\n  set paddingInner(value) {\n    this._paddingInner = clamp$1(value, 0, 1);\n  }\n  get paddingInner() {\n    return this._paddingInner;\n  }\n  set paddingOuter(value) {\n    this._paddingOuter = clamp$1(value, 0, 1);\n  }\n  get paddingOuter() {\n    return this._paddingOuter;\n  }\n  update() {\n    const count = this._domain.length;\n    if (count === 0) {\n      return;\n    }\n    const round = this.round;\n    const paddingInner = this._paddingInner;\n    const paddingOuter = this._paddingOuter;\n    const [r0, r1] = this.range;\n    const width = r1 - r0;\n    const rawStep = width / Math.max(1, count + 2 * paddingOuter - paddingInner);\n    const step = round ? Math.floor(rawStep) : rawStep;\n    const fullBandWidth = step * (count - paddingInner);\n    const x0 = r0 + (width - fullBandWidth) / 2;\n    const start = round ? Math.round(x0) : x0;\n    const bw = step * (1 - paddingInner);\n    const bandwidth = round ? Math.round(bw) : bw;\n    const rawBandwidth = rawStep * (1 - paddingInner);\n    const values = [];\n    for (let i = 0; i < count; i++) {\n      values.push(start + step * i);\n    }\n    this._bandwidth = bandwidth;\n    this._rawBandwidth = rawBandwidth;\n    this.ordinalRange = values;\n  }\n}\nfunction clamp(min, value, max) {\n  return Math.min(max, Math.max(min, value));\n}\nfunction isEqual(a, b, epsilon = 1e-10) {\n  return Math.abs(a - b) < epsilon;\n}\nfunction isNegative(a) {\n  return Math.sign(a) < 0 || Object.is(a, -0);\n}\nfunction round$1(value, decimals = 2) {\n  const pow = Math.pow(10, decimals);\n  return Math.round(value * pow) / pow;\n}\n/**\r\n * `Number.toFixed(n)` always formats a number so that it has `n` digits after the decimal point.\r\n * For example, `Number(0.00003427).toFixed(2)` returns `0.00`.\r\n * That's not very helpful, because all the meaningful information is lost.\r\n * In this case we would want the formatted value to have at least two significant digits: `0.000034`,\r\n * not two fraction digits.\r\n * @param value\r\n * @param fractionOrSignificantDigits\r\n */\nfunction toFixed(value, fractionOrSignificantDigits = 2) {\n  const power = Math.floor(Math.log(Math.abs(value)) / Math.LN10);\n  if (power >= 0 || !isFinite(power)) {\n    return value.toFixed(fractionOrSignificantDigits); // fraction digits\n  }\n\n  return value.toFixed(Math.abs(power) - 1 + fractionOrSignificantDigits); // significant digits\n}\n/**\r\n * Returns the mathematically correct n modulus of m. For context, the JS % operator is remainder\r\n * NOT modulus, which is why this is needed.\r\n */\nfunction mod(n, m) {\n  if (n >= 0) {\n    return Math.floor(n % m);\n  }\n  return Math.floor(n % m + m);\n}\nclass Color {\n  /**\r\n   * Every color component should be in the [0, 1] range.\r\n   * Some easing functions (such as elastic easing) can overshoot the target value by some amount.\r\n   * So, when animating colors, if the source or target color components are already near\r\n   * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color\r\n   * component value to end up outside of that range mid-animation. For this reason the constructor\r\n   * performs range checking/constraining.\r\n   * @param r Red component.\r\n   * @param g Green component.\r\n   * @param b Blue component.\r\n   * @param a Alpha (opacity) component.\r\n   */\n  constructor(r, g, b, a = 1) {\n    // NaN is treated as 0\n    this.r = clamp(0, r || 0, 1);\n    this.g = clamp(0, g || 0, 1);\n    this.b = clamp(0, b || 0, 1);\n    this.a = clamp(0, a || 0, 1);\n  }\n  /**\r\n   * A color string can be in one of the following formats to be valid:\r\n   * - #rgb\r\n   * - #rrggbb\r\n   * - rgb(r, g, b)\r\n   * - rgba(r, g, b, a)\r\n   * - CSS color name such as 'white', 'orange', 'cyan', etc.\r\n   */\n  static validColorString(str) {\n    if (str.indexOf('#') >= 0) {\n      return !!Color.parseHex(str);\n    }\n    if (str.indexOf('rgb') >= 0) {\n      return !!Color.stringToRgba(str);\n    }\n    return !!Color.nameToHex[str.toLowerCase()];\n  }\n  /**\r\n   * The given string can be in one of the following formats:\r\n   * - #rgb\r\n   * - #rrggbb\r\n   * - rgb(r, g, b)\r\n   * - rgba(r, g, b, a)\r\n   * - CSS color name such as 'white', 'orange', 'cyan', etc.\r\n   * @param str\r\n   */\n  static fromString(str) {\n    // hexadecimal notation\n    if (str.indexOf('#') >= 0) {\n      // there can be some leading whitespace\n      return Color.fromHexString(str);\n    }\n    // color name\n    const hex = Color.nameToHex[str.toLowerCase()];\n    if (hex) {\n      return Color.fromHexString(hex);\n    }\n    // rgb(a) notation\n    if (str.indexOf('rgb') >= 0) {\n      return Color.fromRgbaString(str);\n    }\n    throw new Error(`Invalid color string: '${str}'`);\n  }\n  static tryParseFromString(str) {\n    try {\n      return Color.fromString(str);\n    } catch (e) {\n      Logger.warnOnce(`invalid color string: '${str}'.`);\n      return Color.fromArray([0, 0, 0]);\n    }\n  }\n  // See https://drafts.csswg.org/css-color/#hex-notation\n  static parseHex(input) {\n    input = input.replace(/ /g, '').slice(1);\n    let parts;\n    switch (input.length) {\n      case 6:\n      case 8:\n        parts = [];\n        for (let i = 0; i < input.length; i += 2) {\n          parts.push(parseInt(`${input[i]}${input[i + 1]}`, 16));\n        }\n        break;\n      case 3:\n      case 4:\n        parts = input.split('').map(p => parseInt(p, 16)).map(p => p + p * 16);\n        break;\n    }\n    if ((parts === null || parts === void 0 ? void 0 : parts.length) >= 3 && parts.every(p => p >= 0)) {\n      if (parts.length === 3) {\n        parts.push(255);\n      }\n      return parts;\n    }\n  }\n  static fromHexString(str) {\n    const values = Color.parseHex(str);\n    if (values) {\n      const [r, g, b, a] = values;\n      return new Color(r / 255, g / 255, b / 255, a / 255);\n    }\n    throw new Error(`Malformed hexadecimal color string: '${str}'`);\n  }\n  static stringToRgba(str) {\n    // Find positions of opening and closing parentheses.\n    let [po, pc] = [NaN, NaN];\n    for (let i = 0; i < str.length; i++) {\n      const c = str[i];\n      if (!po && c === '(') {\n        po = i;\n      } else if (c === ')') {\n        pc = i;\n        break;\n      }\n    }\n    const contents = po && pc && str.substring(po + 1, pc);\n    if (!contents) {\n      return;\n    }\n    const parts = contents.split(',');\n    const rgba = [];\n    for (let i = 0; i < parts.length; i++) {\n      const part = parts[i];\n      let value = parseFloat(part);\n      if (isNaN(value)) {\n        return;\n      }\n      if (part.indexOf('%') >= 0) {\n        // percentage r, g, or b value\n        value = Math.max(0, Math.min(100, value));\n        value /= 100;\n      } else {\n        if (i === 3) {\n          // alpha component\n          value = Math.max(0, Math.min(1, value));\n        } else {\n          // absolute r, g, or b value\n          value = Math.max(0, Math.min(255, value));\n          value /= 255;\n        }\n      }\n      rgba.push(value);\n    }\n    return rgba;\n  }\n  static fromRgbaString(str) {\n    const rgba = Color.stringToRgba(str);\n    if (rgba) {\n      if (rgba.length === 3) {\n        return new Color(rgba[0], rgba[1], rgba[2]);\n      } else if (rgba.length === 4) {\n        return new Color(rgba[0], rgba[1], rgba[2], rgba[3]);\n      }\n    }\n    throw new Error(`Malformed rgb/rgba color string: '${str}'`);\n  }\n  static fromArray(arr) {\n    if (arr.length === 4) {\n      return new Color(arr[0], arr[1], arr[2], arr[3]);\n    }\n    if (arr.length === 3) {\n      return new Color(arr[0], arr[1], arr[2]);\n    }\n    throw new Error('The given array should contain 3 or 4 color components (numbers).');\n  }\n  static fromHSB(h, s, b, alpha = 1) {\n    const rgb = Color.HSBtoRGB(h, s, b);\n    return new Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static fromHSL(h, s, l, alpha = 1) {\n    const rgb = Color.HSLtoRGB(h, s, l);\n    return new Color(rgb[0], rgb[1], rgb[2], alpha);\n  }\n  static padHex(str) {\n    // Can't use `padStart(2, '0')` here because of IE.\n    return str.length === 1 ? '0' + str : str;\n  }\n  toHexString() {\n    let hex = '#' + Color.padHex(Math.round(this.r * 255).toString(16)) + Color.padHex(Math.round(this.g * 255).toString(16)) + Color.padHex(Math.round(this.b * 255).toString(16));\n    if (this.a < 1) {\n      hex += Color.padHex(Math.round(this.a * 255).toString(16));\n    }\n    return hex;\n  }\n  toRgbaString(fractionDigits = 3) {\n    const components = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];\n    const k = Math.pow(10, fractionDigits);\n    if (this.a !== 1) {\n      components.push(Math.round(this.a * k) / k);\n      return `rgba(${components.join(', ')})`;\n    }\n    return `rgb(${components.join(', ')})`;\n  }\n  toString() {\n    if (this.a === 1) {\n      return this.toHexString();\n    }\n    return this.toRgbaString();\n  }\n  toHSB() {\n    return Color.RGBtoHSB(this.r, this.g, this.b);\n  }\n  static RGBtoHSL(r, g, b) {\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n    const l = (max + min) / 2;\n    let h;\n    let s;\n    if (max === min) {\n      // Achromatic\n      h = NaN;\n      s = 0;\n    } else {\n      const delta = max - min;\n      s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);\n      if (max === r) {\n        h = (g - b) / delta + (g < b ? 6 : 0);\n      } else if (max === g) {\n        h = (b - r) / delta + 2;\n      } else {\n        h = (r - g) / delta + 4;\n      }\n      h *= 360 / 6;\n    }\n    return [h, s, l];\n  }\n  static HSLtoRGB(h, s, l) {\n    if (s === 0) {\n      // Achromatic\n      return [l, l, l];\n    }\n    const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    const p = 2 * l - q;\n    function hueToRgb(t) {\n      if (t < 0) t += 1;\n      if (t > 1) t -= 1;\n      if (t < 1 / 6) return p + (q - p) * 6 * t;\n      if (t < 1 / 2) return q;\n      if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n      return p;\n    }\n    const r = hueToRgb(h / 360 + 1 / 3);\n    const g = hueToRgb(h / 360);\n    const b = hueToRgb(h / 360 - 1 / 3);\n    return [r, g, b];\n  }\n  /**\r\n   * Converts the given RGB triple to an array of HSB (HSV) components.\r\n   * The hue component will be `NaN` for achromatic colors.\r\n   */\n  static RGBtoHSB(r, g, b) {\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n    const S = max !== 0 ? (max - min) / max : 0;\n    let H = NaN;\n    // min == max, means all components are the same\n    // and the color is a shade of gray with no hue (H is NaN)\n    if (min !== max) {\n      const delta = max - min;\n      const rc = (max - r) / delta;\n      const gc = (max - g) / delta;\n      const bc = (max - b) / delta;\n      if (r === max) {\n        H = bc - gc;\n      } else if (g === max) {\n        H = 2.0 + rc - bc;\n      } else {\n        H = 4.0 + gc - rc;\n      }\n      H /= 6.0;\n      if (H < 0) {\n        H = H + 1.0;\n      }\n    }\n    return [H * 360, S, max];\n  }\n  /**\r\n   * Converts the given HSB (HSV) triple to an array of RGB components.\r\n   */\n  static HSBtoRGB(H, S, B) {\n    if (isNaN(H)) {\n      H = 0;\n    }\n    H = (H % 360 + 360) % 360 / 360; // normalize hue to [0, 360] interval, then scale to [0, 1]\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    if (S === 0) {\n      r = g = b = B;\n    } else {\n      const h = (H - Math.floor(H)) * 6;\n      const f = h - Math.floor(h);\n      const p = B * (1 - S);\n      const q = B * (1 - S * f);\n      const t = B * (1 - S * (1 - f));\n      switch (h >> 0 // discard the floating point part of the number\n      ) {\n        case 0:\n          r = B;\n          g = t;\n          b = p;\n          break;\n        case 1:\n          r = q;\n          g = B;\n          b = p;\n          break;\n        case 2:\n          r = p;\n          g = B;\n          b = t;\n          break;\n        case 3:\n          r = p;\n          g = q;\n          b = B;\n          break;\n        case 4:\n          r = t;\n          g = p;\n          b = B;\n          break;\n        case 5:\n          r = B;\n          g = p;\n          b = q;\n          break;\n      }\n    }\n    return [r, g, b];\n  }\n  derive(hueShift, saturationFactor, brightnessFactor, opacityFactor) {\n    const hsb = Color.RGBtoHSB(this.r, this.g, this.b);\n    let b = hsb[2];\n    if (b == 0 && brightnessFactor > 1.0) {\n      b = 0.05;\n    }\n    const h = ((hsb[0] + hueShift) % 360 + 360) % 360;\n    const s = Math.max(Math.min(hsb[1] * saturationFactor, 1.0), 0.0);\n    b = Math.max(Math.min(b * brightnessFactor, 1.0), 0.0);\n    const a = Math.max(Math.min(this.a * opacityFactor, 1.0), 0.0);\n    const rgba = Color.HSBtoRGB(h, s, b);\n    rgba.push(a);\n    return Color.fromArray(rgba);\n  }\n  brighter() {\n    return this.derive(0, 1.0, 1.0 / 0.7, 1.0);\n  }\n  darker() {\n    return this.derive(0, 1.0, 0.7, 1.0);\n  }\n  static interpolate(color, other) {\n    const c0 = Color.tryParseFromString(color);\n    const c1 = Color.tryParseFromString(other);\n    return t => {\n      const i = (x, y) => x * (1 - t) + y * t;\n      const c = new Color(i(c0.r, c1.r), i(c0.g, c1.g), i(c0.b, c1.b), i(c0.a, c1.a));\n      return c.toString();\n    };\n  }\n}\n/**\r\n * CSS Color Module Level 4:\r\n * https://drafts.csswg.org/css-color/#named-colors\r\n */\nColor.nameToHex = Object.freeze({\n  aliceblue: '#F0F8FF',\n  antiquewhite: '#FAEBD7',\n  aqua: '#00FFFF',\n  aquamarine: '#7FFFD4',\n  azure: '#F0FFFF',\n  beige: '#F5F5DC',\n  bisque: '#FFE4C4',\n  black: '#000000',\n  blanchedalmond: '#FFEBCD',\n  blue: '#0000FF',\n  blueviolet: '#8A2BE2',\n  brown: '#A52A2A',\n  burlywood: '#DEB887',\n  cadetblue: '#5F9EA0',\n  chartreuse: '#7FFF00',\n  chocolate: '#D2691E',\n  coral: '#FF7F50',\n  cornflowerblue: '#6495ED',\n  cornsilk: '#FFF8DC',\n  crimson: '#DC143C',\n  cyan: '#00FFFF',\n  darkblue: '#00008B',\n  darkcyan: '#008B8B',\n  darkgoldenrod: '#B8860B',\n  darkgray: '#A9A9A9',\n  darkgreen: '#006400',\n  darkgrey: '#A9A9A9',\n  darkkhaki: '#BDB76B',\n  darkmagenta: '#8B008B',\n  darkolivegreen: '#556B2F',\n  darkorange: '#FF8C00',\n  darkorchid: '#9932CC',\n  darkred: '#8B0000',\n  darksalmon: '#E9967A',\n  darkseagreen: '#8FBC8F',\n  darkslateblue: '#483D8B',\n  darkslategray: '#2F4F4F',\n  darkslategrey: '#2F4F4F',\n  darkturquoise: '#00CED1',\n  darkviolet: '#9400D3',\n  deeppink: '#FF1493',\n  deepskyblue: '#00BFFF',\n  dimgray: '#696969',\n  dimgrey: '#696969',\n  dodgerblue: '#1E90FF',\n  firebrick: '#B22222',\n  floralwhite: '#FFFAF0',\n  forestgreen: '#228B22',\n  fuchsia: '#FF00FF',\n  gainsboro: '#DCDCDC',\n  ghostwhite: '#F8F8FF',\n  gold: '#FFD700',\n  goldenrod: '#DAA520',\n  gray: '#808080',\n  green: '#008000',\n  greenyellow: '#ADFF2F',\n  grey: '#808080',\n  honeydew: '#F0FFF0',\n  hotpink: '#FF69B4',\n  indianred: '#CD5C5C',\n  indigo: '#4B0082',\n  ivory: '#FFFFF0',\n  khaki: '#F0E68C',\n  lavender: '#E6E6FA',\n  lavenderblush: '#FFF0F5',\n  lawngreen: '#7CFC00',\n  lemonchiffon: '#FFFACD',\n  lightblue: '#ADD8E6',\n  lightcoral: '#F08080',\n  lightcyan: '#E0FFFF',\n  lightgoldenrodyellow: '#FAFAD2',\n  lightgray: '#D3D3D3',\n  lightgreen: '#90EE90',\n  lightgrey: '#D3D3D3',\n  lightpink: '#FFB6C1',\n  lightsalmon: '#FFA07A',\n  lightseagreen: '#20B2AA',\n  lightskyblue: '#87CEFA',\n  lightslategray: '#778899',\n  lightslategrey: '#778899',\n  lightsteelblue: '#B0C4DE',\n  lightyellow: '#FFFFE0',\n  lime: '#00FF00',\n  limegreen: '#32CD32',\n  linen: '#FAF0E6',\n  magenta: '#FF00FF',\n  maroon: '#800000',\n  mediumaquamarine: '#66CDAA',\n  mediumblue: '#0000CD',\n  mediumorchid: '#BA55D3',\n  mediumpurple: '#9370DB',\n  mediumseagreen: '#3CB371',\n  mediumslateblue: '#7B68EE',\n  mediumspringgreen: '#00FA9A',\n  mediumturquoise: '#48D1CC',\n  mediumvioletred: '#C71585',\n  midnightblue: '#191970',\n  mintcream: '#F5FFFA',\n  mistyrose: '#FFE4E1',\n  moccasin: '#FFE4B5',\n  navajowhite: '#FFDEAD',\n  navy: '#000080',\n  oldlace: '#FDF5E6',\n  olive: '#808000',\n  olivedrab: '#6B8E23',\n  orange: '#FFA500',\n  orangered: '#FF4500',\n  orchid: '#DA70D6',\n  palegoldenrod: '#EEE8AA',\n  palegreen: '#98FB98',\n  paleturquoise: '#AFEEEE',\n  palevioletred: '#DB7093',\n  papayawhip: '#FFEFD5',\n  peachpuff: '#FFDAB9',\n  peru: '#CD853F',\n  pink: '#FFC0CB',\n  plum: '#DDA0DD',\n  powderblue: '#B0E0E6',\n  purple: '#800080',\n  rebeccapurple: '#663399',\n  red: '#FF0000',\n  rosybrown: '#BC8F8F',\n  royalblue: '#4169E1',\n  saddlebrown: '#8B4513',\n  salmon: '#FA8072',\n  sandybrown: '#F4A460',\n  seagreen: '#2E8B57',\n  seashell: '#FFF5EE',\n  sienna: '#A0522D',\n  silver: '#C0C0C0',\n  skyblue: '#87CEEB',\n  slateblue: '#6A5ACD',\n  slategray: '#708090',\n  slategrey: '#708090',\n  snow: '#FFFAFA',\n  springgreen: '#00FF7F',\n  steelblue: '#4682B4',\n  tan: '#D2B48C',\n  teal: '#008080',\n  thistle: '#D8BFD8',\n  tomato: '#FF6347',\n  transparent: '#00000000',\n  turquoise: '#40E0D0',\n  violet: '#EE82EE',\n  wheat: '#F5DEB3',\n  white: '#FFFFFF',\n  whitesmoke: '#F5F5F5',\n  yellow: '#FFFF00',\n  yellowgreen: '#9ACD32'\n});\n\n/* eslint-disable sonarjs/no-duplicate-string */\nfunction Validate(predicate) {\n  return addTransformToInstanceProperty((target, prop, v) => {\n    var _a, _b, _c;\n    if (predicate(v, {\n      target\n    })) {\n      return v;\n    }\n    const cleanKey = prop.toString().replace(/^_*/, '');\n    let targetClass = (_b = (_a = target.constructor) === null || _a === void 0 ? void 0 : _a.className) !== null && _b !== void 0 ? _b : (_c = target.constructor) === null || _c === void 0 ? void 0 : _c.name;\n    if ((targetClass === null || targetClass === void 0 ? void 0 : targetClass.length) < 3) {\n      targetClass = null;\n    }\n    const targetClassName = targetClass ? `of [${targetClass}] ` : '';\n    if (predicate.message) {\n      Logger.warn(`Property [${cleanKey}] ${targetClassName}cannot be set to [${stringify(v)}]; ${predicate.message}, ignoring.`);\n    } else {\n      Logger.warn(`Property [${cleanKey}] ${targetClassName}cannot be set to [${stringify(v)}], ignoring.`);\n    }\n    return BREAK_TRANSFORM_CHAIN;\n  });\n}\nfunction stringify(value) {\n  if (typeof value === 'number' && isNaN(value)) return 'NaN';\n  if (value === Infinity) return 'Infinity';\n  if (value === -Infinity) return '-Infinity';\n  return JSON.stringify(value);\n}\nfunction predicateWithMessage(predicate, message) {\n  predicate.message = message;\n  return predicate;\n}\nconst OPTIONAL = (v, ctx, predicate) => v === undefined || predicate(v, ctx);\nconst ARRAY = (length, predicate) => {\n  return predicateWithMessage((v, ctx) => Array.isArray(v) && (length ? v.length === length : true) && (predicate ? v.every(e => predicate(e, ctx)) : true), `expecting an Array`);\n};\nconst OPT_ARRAY = length => {\n  return predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, ARRAY(length)), 'expecting an optional Array');\n};\nconst NON_EMPTY_ARRAY = predicateWithMessage(v => Array.isArray(v) && v.length > 0, `expecting a non-empty Array`);\nconst OPT_NON_EMPTY_ARRAY = () => {\n  return predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, NON_EMPTY_ARRAY), 'expecting an optional non-empty Array');\n};\nconst AND = (...predicates) => {\n  return predicateWithMessage((v, ctx) => predicates.every(p => p(v, ctx)), predicates.map(p => p.message).filter(m => m != null).join(' AND '));\n};\nconst OR = (...predicates) => {\n  return predicateWithMessage((v, ctx) => predicates.some(p => p(v, ctx)), predicates.map(p => p.message).filter(m => m != null).join(' OR '));\n};\nconst isComparable = v => {\n  return v != null && !isNaN(v);\n};\nconst LESS_THAN = otherField => predicateWithMessage((v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v < ctx.target[otherField], `expected to be less than ${otherField}`);\nconst GREATER_THAN = otherField => predicateWithMessage((v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v > ctx.target[otherField], `expected to be greater than ${otherField}`);\nconst FUNCTION = predicateWithMessage(v => typeof v === 'function', 'expecting a Function');\nconst OPT_FUNCTION = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, FUNCTION), `expecting an optional Function`);\nconst BOOLEAN = predicateWithMessage(v => v === true || v === false, 'expecting a Boolean');\nconst OPT_BOOLEAN = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, BOOLEAN), 'expecting an optional Boolean');\nconst STRING = predicateWithMessage(v => typeof v === 'string', 'expecting a String');\nconst OPT_STRING = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, STRING), 'expecting an optional String');\nconst DATE = predicateWithMessage(v => v instanceof Date && !isNaN(+v), 'expecting a Date object');\nconst OPT_DATE = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, DATE), 'expecting an optional Date');\nconst DATE_ARRAY = predicateWithMessage(ARRAY(undefined, DATE), 'expecting an Array of Date objects');\nconst DATETIME_MS = NUMBER$1(0);\nconst OPT_DATETIME_MS = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, DATETIME_MS), 'expecting an optional number');\nconst OPT_DATE_OR_DATETIME_MS = OR(OPT_DATE, OPT_DATETIME_MS);\nconst colorMessage = `A color string can be in one of the following formats to be valid: #rgb, #rrggbb, rgb(r, g, b), rgba(r, g, b, a) or a CSS color name such as 'white', 'orange', 'cyan', etc`;\nconst COLOR_STRING = predicateWithMessage(v => {\n  if (typeof v !== 'string') {\n    return false;\n  }\n  return Color.validColorString(v);\n}, `expecting a color String. ${colorMessage}`);\nconst OPT_COLOR_STRING = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, COLOR_STRING), `expecting an optional color String. ${colorMessage}`);\nconst COLOR_STRING_ARRAY = predicateWithMessage(ARRAY(undefined, COLOR_STRING), `expecting an Array of color strings. ${colorMessage}`);\nconst OPT_COLOR_STRING_ARRAY = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, COLOR_STRING_ARRAY), `expecting an optional Array of color strings. ${colorMessage}`);\nfunction numberMessage(prefix = `expecting a finite Number`, min, max) {\n  let message = prefix;\n  if (min !== undefined && max !== undefined) {\n    message += ` between ${min} and ${max} inclusive`;\n  } else if (min !== undefined) {\n    message += ` greater than or equal to ${min}`;\n  } else if (max !== undefined) {\n    message += ` less than or equal to ${max}`;\n  }\n  return message;\n}\nfunction NUMBER$1(min, max) {\n  const message = numberMessage(undefined, min, max);\n  return predicateWithMessage(v => typeof v === 'number' && Number.isFinite(v) && (min !== undefined ? v >= min : true) && (max !== undefined ? v <= max : true), message);\n}\nfunction OPT_NUMBER(min, max) {\n  const message = numberMessage('expecting an optional finite Number', min, max);\n  return predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, NUMBER$1(min, max)), message);\n}\nfunction NUMBER_OR_NAN(min, max) {\n  // Can be NaN or finite number\n  const message = numberMessage(undefined, min, max);\n  return predicateWithMessage(v => typeof v === 'number' && (isNaN(v) || Number.isFinite(v) && (min !== undefined ? v >= min : true) && (max !== undefined ? v <= max : true)), message);\n}\nconst NUMBER_ARRAY = predicateWithMessage(ARRAY(undefined, NUMBER$1()), 'expecting an Array of numbers');\nconst OPT_NUMBER_ARRAY = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, NUMBER_ARRAY), 'expecting an optional Array of numbers');\nconst STRING_ARRAY = predicateWithMessage(ARRAY(undefined, STRING), 'expecting an Array of strings');\nconst OPT_STRING_ARRAY = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, STRING_ARRAY), 'expecting an optional Array of strings');\nfunction STRING_UNION(...values) {\n  const message = `expecting one of: ${values.join(', ')}`;\n  return predicateWithMessage(v => typeof v === 'string' && values.indexOf(v) >= 0, message);\n}\nconst BOOLEAN_ARRAY = predicateWithMessage(ARRAY(undefined, BOOLEAN), 'expecting an Array of boolean values');\nconst OPT_BOOLEAN_ARRAY = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, BOOLEAN_ARRAY), 'expecting an optional Array of boolean values');\nconst FONT_WEIGHTS = ['normal', 'bold', 'bolder', 'lighter'];\nconst FONT_STYLE = predicateWithMessage(v => v === 'normal' || v === 'italic' || v === 'oblique', `expecting a font style keyword such as 'normal', 'italic' or 'oblique'`);\nconst OPT_FONT_STYLE = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, FONT_STYLE), `expecting an optional font style keyword such as 'normal', 'italic' or 'oblique'`);\nconst FONT_WEIGHT = predicateWithMessage(v => FONT_WEIGHTS.includes(v) || typeof v === 'number' && isFinite(v), `expecting a font weight keyword such as 'normal', 'bold' or 'bolder' or a numeric value such as 100, 300 or 600`);\nconst OPT_FONT_WEIGHT = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, FONT_WEIGHT), `expecting an optional font weight keyword such as 'normal', 'bold' or 'bolder' or a numeric value such as 100, 300 or 600`);\nconst LINE_DASH = predicateWithMessage(ARRAY(undefined, NUMBER$1(0)), 'expecting an Array of numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels.');\nconst OPT_LINE_DASH = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, LINE_DASH), 'expecting an optional Array of numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels.');\nconst LINE_CAPS = ['butt', 'round', 'square'];\nconst LINE_CAP = predicateWithMessage(v => LINE_CAPS.includes(v), `expecting a line cap keyword such as 'butt', 'round' or 'square'`);\nconst OPT_LINE_CAP = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, LINE_CAP), `expecting an optional line cap keyword such as 'butt', 'round' or 'square'`);\nconst LINE_JOINS = ['round', 'bevel', 'miter'];\nconst LINE_JOIN = predicateWithMessage(v => LINE_JOINS.includes(v), `expecting a line join keyword such as 'round', 'bevel' or 'miter'`);\nconst OPT_LINE_JOIN = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, LINE_JOIN), `expecting an optional line join keyword such as 'round', 'bevel' or 'miter'`);\nconst POSITIONS = ['top', 'right', 'bottom', 'left'];\nconst POSITION = predicateWithMessage(v => POSITIONS.includes(v), `expecting a position keyword such as 'top', 'right', 'bottom' or 'left`);\nconst INTERACTION_RANGES = ['exact', 'nearest'];\nconst INTERACTION_RANGE = predicateWithMessage(v => typeof v === 'number' && Number.isFinite(v) || INTERACTION_RANGES.includes(v), `expecting an interaction range of 'exact', 'nearest' or a number`);\nconst TEXT_WRAPS = ['never', 'always', 'hyphenate', 'on-space'];\nconst TEXT_WRAP = predicateWithMessage(v => TEXT_WRAPS.includes(v), `expecting a text wrap strategy keyword such as 'never', 'always', 'hyphenate', or 'on-space'`);\nconst OVERFLOW_STRAGEGIES = ['ellipsis', 'hide'];\nconst OVERFLOW_STRATEGY = predicateWithMessage(v => OVERFLOW_STRAGEGIES.includes(v), `expecting an overflow strategy keyword such as 'ellipsis', or 'hide'`);\nconst TEXT_ALIGNS = ['left', 'center', 'right'];\nconst TEXT_ALIGN = predicateWithMessage(v => TEXT_ALIGNS.includes(v), `expecting a text align keyword such as 'left', 'center', or 'right'`);\nconst VERTICAL_ALIGNS = ['top', 'middle', 'bottom'];\nconst VERTICAL_ALIGN = predicateWithMessage(v => VERTICAL_ALIGNS.includes(v), `expecting a text align keyword such as 'top', 'middle', or 'bottom'`);\nconst DIRECTIONS = ['horizontal', 'vertical'];\nconst DIRECTION = predicateWithMessage(v => DIRECTIONS.includes(v), `expecting a direction keyword such as 'horizontal' or 'vertical'`);\nconst OPT_DIRECTION = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, DIRECTION), `expecting an optional direction keyword such as 'horizontal' or 'vertical'`);\nvar ChartAxisDirection;\n(function (ChartAxisDirection) {\n  ChartAxisDirection[\"X\"] = \"x\";\n  ChartAxisDirection[\"Y\"] = \"y\";\n})(ChartAxisDirection || (ChartAxisDirection = {}));\nvar RedrawType;\n(function (RedrawType) {\n  RedrawType[RedrawType[\"NONE\"] = 0] = \"NONE\";\n  // Canvas doesn't need clearing, an incremental re-rerender is sufficient.\n  RedrawType[RedrawType[\"TRIVIAL\"] = 1] = \"TRIVIAL\";\n  // Group needs clearing, a semi-incremental re-render is sufficient.\n  RedrawType[RedrawType[\"MINOR\"] = 2] = \"MINOR\";\n  // Canvas needs to be cleared for these redraw types.\n  RedrawType[RedrawType[\"MAJOR\"] = 3] = \"MAJOR\";\n})(RedrawType || (RedrawType = {}));\n/** @returns true if new Function() is disabled in the current execution context. */\nfunction functionConstructorAvailable() {\n  try {\n    new Function('return true');\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nconst STRING_FUNCTION_USEABLE = functionConstructorAvailable();\nfunction SceneChangeDetection(opts) {\n  const {\n    changeCb,\n    convertor\n  } = opts !== null && opts !== void 0 ? opts : {};\n  return function (target, key) {\n    // `target` is either a constructor (static member) or prototype (instance member)\n    const privateKey = `__${key}`;\n    if (target[key]) {\n      return;\n    }\n    if (STRING_FUNCTION_USEABLE && changeCb == null && convertor == null) {\n      prepareFastGetSet(target, key, privateKey, opts);\n    } else {\n      prepareSlowGetSet(target, key, privateKey, opts);\n    }\n  };\n}\nfunction prepareFastGetSet(target, key, privateKey, opts) {\n  const {\n    redraw = RedrawType.TRIVIAL,\n    type = 'normal',\n    checkDirtyOnAssignment = false\n  } = opts !== null && opts !== void 0 ? opts : {};\n  // Optimised code-path.\n  // Remove all conditional logic from runtime - generate a setter with the exact necessary\n  // steps, as these setters are called a LOT during update cycles.\n  const setterJs = new Function('value', `\n        const oldValue = this.${privateKey};\n        if (value !== oldValue) {\n            this.${privateKey} = value;\n            ${type === 'normal' ? `this.markDirty(this, ${redraw});` : ''}\n            ${type === 'transform' ? `this.markDirtyTransform(${redraw});` : ''}\n            ${type === 'path' ? `if (!this._dirtyPath) { this._dirtyPath = true; this.markDirty(this, ${redraw}); }` : ''}\n            ${type === 'font' ? `if (!this._dirtyFont) { this._dirtyFont = true; this.markDirty(this, ${redraw}); }` : ''}\n        }\n        ${checkDirtyOnAssignment ? `if (value != null && value._dirty > ${RedrawType.NONE}) { this.markDirty(value, value._dirty); }` : ''}\n`);\n  const getterJs = new Function(`return this.${privateKey};`);\n  Object.defineProperty(target, key, {\n    set: setterJs,\n    get: getterJs,\n    enumerable: true,\n    configurable: true\n  });\n}\nfunction prepareSlowGetSet(target, key, privateKey, opts) {\n  const {\n    redraw = RedrawType.TRIVIAL,\n    type = 'normal',\n    changeCb,\n    convertor,\n    checkDirtyOnAssignment = false\n  } = opts !== null && opts !== void 0 ? opts : {};\n  // Unoptimised but 'safe' code-path, for environments with CSP headers and no 'unsafe-eval'.\n  // We deliberately do not support debug branches found in the optimised path above, since\n  // for large data-set series performance deteriorates with every extra branch here.\n  const setter = function (value) {\n    const oldValue = this[privateKey];\n    value = convertor ? convertor(value) : value;\n    if (value !== oldValue) {\n      this[privateKey] = value;\n      if (type === 'normal') this.markDirty(this, redraw);\n      if (type === 'transform') this.markDirtyTransform(redraw);\n      if (type === 'path' && !this._dirtyPath) {\n        this._dirtyPath = true;\n        this.markDirty(this, redraw);\n      }\n      if (type === 'font' && !this._dirtyFont) {\n        this._dirtyFont = true;\n        this.markDirty(this, redraw);\n      }\n      if (changeCb) changeCb(this);\n    }\n    if (checkDirtyOnAssignment && value != null && value._dirty > RedrawType.NONE) this.markDirty(value, value._dirty);\n  };\n  const getter = function () {\n    return this[privateKey];\n  };\n  Object.defineProperty(target, key, {\n    set: setter,\n    get: getter,\n    enumerable: true,\n    configurable: true\n  });\n}\nclass ChangeDetectable {\n  constructor() {\n    this._dirty = RedrawType.MAJOR;\n  }\n  markDirty(_source, type = RedrawType.TRIVIAL) {\n    if (this._dirty > type) {\n      return;\n    }\n    this._dirty = type;\n  }\n  markClean(_opts) {\n    this._dirty = RedrawType.NONE;\n  }\n  isDirty() {\n    return this._dirty > RedrawType.NONE;\n  }\n}\nconst ID_MAP = {};\nfunction resetIds() {\n  for (const key in ID_MAP) {\n    delete ID_MAP[key];\n  }\n}\nfunction createId(instance) {\n  var _a;\n  const constructor = instance.constructor;\n  const className = Object.prototype.hasOwnProperty.call(constructor, 'className') ? constructor.className : constructor.name;\n  if (!className) {\n    throw new Error(`The ${constructor} is missing the 'className' property.`);\n  }\n  const nextId = ((_a = ID_MAP[className]) !== null && _a !== void 0 ? _a : 0) + 1;\n  ID_MAP[className] = nextId;\n  return className + '-' + nextId;\n}\nfunction nearestSquared(point, objects, maxDistanceSquared = Infinity) {\n  const result = {\n    nearest: undefined,\n    distanceSquared: maxDistanceSquared\n  };\n  for (const obj of objects) {\n    const thisDistance = obj.distanceSquared(point);\n    if (thisDistance === 0) {\n      return {\n        nearest: obj,\n        distanceSquared: 0\n      };\n    } else if (thisDistance < result.distanceSquared) {\n      result.nearest = obj;\n      result.distanceSquared = thisDistance;\n    }\n  }\n  return result;\n}\nfunction nearestSquaredInContainer(point, container, maxDistanceSquared = Infinity) {\n  const tpoint = container.transformPoint(point.x, point.y);\n  const result = {\n    nearest: undefined,\n    distanceSquared: maxDistanceSquared\n  };\n  for (const child of container.children) {\n    const {\n      nearest,\n      distanceSquared\n    } = child.nearestSquared(tpoint, result.distanceSquared);\n    if (distanceSquared === 0) {\n      return {\n        nearest,\n        distanceSquared\n      };\n    } else if (distanceSquared < result.distanceSquared) {\n      result.nearest = nearest;\n      result.distanceSquared = distanceSquared;\n    }\n  }\n  return result;\n}\nclass BBox {\n  constructor(x, y, width, height) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n  clone() {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this;\n    return new BBox(x, y, width, height);\n  }\n  equals(other) {\n    return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;\n  }\n  containsPoint(x, y) {\n    return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;\n  }\n  collidesBBox(other) {\n    return this.x < other.x + other.width && this.x + this.width > other.x && this.y < other.y + other.height && this.y + this.height > other.y;\n  }\n  isInfinite() {\n    return Math.abs(this.x) === Infinity || Math.abs(this.y) === Infinity || Math.abs(this.width) === Infinity || Math.abs(this.height) === Infinity;\n  }\n  distanceSquared(point) {\n    if (this.containsPoint(point.x, point.y)) {\n      return 0;\n    }\n    const dx = point.x - Math.max(this.x, Math.min(point.x, this.x + this.width));\n    const dy = point.y - Math.max(this.y, Math.min(point.y, this.y + this.height));\n    return dx * dx + dy * dy;\n  }\n  static nearestBox(point, boxes) {\n    return nearestSquared(point, boxes);\n  }\n  shrink(amount, position) {\n    const apply = (pos, amt) => {\n      switch (pos) {\n        case 'top':\n          this.y += amt;\n        // eslint-disable-next-line no-fallthrough\n        case 'bottom':\n          this.height -= amt;\n          break;\n        case 'left':\n          this.x += amt;\n        // eslint-disable-next-line no-fallthrough\n        case 'right':\n          this.width -= amt;\n          break;\n        case 'vertical':\n          this.y += amt;\n          this.height -= amt * 2;\n          break;\n        case 'horizontal':\n          this.x += amt;\n          this.width -= amt * 2;\n          break;\n        case undefined:\n          this.x += amt;\n          this.width -= amt * 2;\n          this.y += amt;\n          this.height -= amt * 2;\n          break;\n        // Unknown position - do nothing.\n      }\n    };\n\n    if (typeof amount === 'number') {\n      apply(position, amount);\n    } else {\n      Object.entries(amount).forEach(([pos, amt]) => apply(pos, amt));\n    }\n    return this;\n  }\n  grow(amount, position) {\n    if (typeof amount === 'number') {\n      this.shrink(-amount, position);\n    } else {\n      const paddingCopy = Object.assign({}, amount);\n      for (const key in paddingCopy) {\n        paddingCopy[key] *= -1;\n      }\n      this.shrink(paddingCopy);\n    }\n    return this;\n  }\n  static merge(boxes) {\n    let left = Infinity;\n    let top = Infinity;\n    let right = -Infinity;\n    let bottom = -Infinity;\n    boxes.forEach(box => {\n      if (box.x < left) {\n        left = box.x;\n      }\n      if (box.y < top) {\n        top = box.y;\n      }\n      if (box.x + box.width > right) {\n        right = box.x + box.width;\n      }\n      if (box.y + box.height > bottom) {\n        bottom = box.y + box.height;\n      }\n    });\n    return new BBox(left, top, right - left, bottom - top);\n  }\n}\nBBox.zero = new BBox(0, 0, 0, 0);\n\n/**\r\n * As of Jan 8, 2019, Firefox still doesn't implement\r\n * `getTransform(): DOMMatrix;`\r\n * `setTransform(transform?: DOMMatrix2DInit)`\r\n * in the `CanvasRenderingContext2D`.\r\n * Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=928150\r\n * IE11 and Edge 44 also don't have the support.\r\n * Thus this class, to keep track of the current transform and\r\n * combine transformations.\r\n * Standards:\r\n * https://html.spec.whatwg.org/dev/canvas.html\r\n * https://www.w3.org/TR/geometry-1/\r\n */\nclass Matrix {\n  get e() {\n    return [...this.elements];\n  }\n  constructor(elements = [1, 0, 0, 1, 0, 0]) {\n    this.elements = elements;\n  }\n  setElements(elements) {\n    const e = this.elements;\n    // `this.elements = elements.slice()` is 4-5 times slower\n    // (in Chrome 71 and FF 64) than manually copying elements,\n    // since slicing allocates new memory.\n    // The performance of passing parameters individually\n    // vs as an array is about the same in both browsers, so we\n    // go with a single (array of elements) parameter, because\n    // `setElements(elements)` and `setElements([a, b, c, d, e, f])`\n    // calls give us roughly the same performance, versus\n    // `setElements(...elements)` and `setElements(a, b, c, d, e, f)`,\n    // where the spread operator causes a 20-30x performance drop\n    // (30x when compiled to ES5's `.apply(this, elements)`\n    //  20x when used natively).\n    e[0] = elements[0];\n    e[1] = elements[1];\n    e[2] = elements[2];\n    e[3] = elements[3];\n    e[4] = elements[4];\n    e[5] = elements[5];\n    return this;\n  }\n  get identity() {\n    const e = this.elements;\n    return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 1 && e[4] === 0 && e[5] === 0;\n  }\n  /**\r\n   * Performs the AxB matrix multiplication and saves the result\r\n   * to `C`, if given, or to `A` otherwise.\r\n   */\n  AxB(A, B, C) {\n    const a = A[0] * B[0] + A[2] * B[1],\n      b = A[1] * B[0] + A[3] * B[1],\n      c = A[0] * B[2] + A[2] * B[3],\n      d = A[1] * B[2] + A[3] * B[3],\n      e = A[0] * B[4] + A[2] * B[5] + A[4],\n      f = A[1] * B[4] + A[3] * B[5] + A[5];\n    C = C !== null && C !== void 0 ? C : A;\n    C[0] = a;\n    C[1] = b;\n    C[2] = c;\n    C[3] = d;\n    C[4] = e;\n    C[5] = f;\n  }\n  /**\r\n   * The `other` matrix gets post-multiplied to the current matrix.\r\n   * Returns the current matrix.\r\n   * @param other\r\n   */\n  multiplySelf(other) {\n    this.AxB(this.elements, other.elements);\n    return this;\n  }\n  /**\r\n   * The `other` matrix gets post-multiplied to the current matrix.\r\n   * Returns a new matrix.\r\n   * @param other\r\n   */\n  multiply(other) {\n    const elements = new Array(6);\n    this.AxB(this.elements, other.elements, elements);\n    return new Matrix(elements);\n  }\n  preMultiplySelf(other) {\n    this.AxB(other.elements, this.elements, this.elements);\n    return this;\n  }\n  /**\r\n   * Returns the inverse of this matrix as a new matrix.\r\n   */\n  inverse() {\n    const el = this.elements;\n    let a = el[0],\n      b = el[1],\n      c = el[2],\n      d = el[3];\n    const e = el[4],\n      f = el[5];\n    const rD = 1 / (a * d - b * c); // reciprocal of determinant\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    return new Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n  }\n  /**\r\n   * Save the inverse of this matrix to the given matrix.\r\n   */\n  inverseTo(other) {\n    const el = this.elements;\n    let a = el[0],\n      b = el[1],\n      c = el[2],\n      d = el[3];\n    const e = el[4],\n      f = el[5];\n    const rD = 1 / (a * d - b * c); // reciprocal of determinant\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);\n    return this;\n  }\n  invertSelf() {\n    const el = this.elements;\n    let a = el[0],\n      b = el[1],\n      c = el[2],\n      d = el[3];\n    const e = el[4],\n      f = el[5];\n    const rD = 1 / (a * d - b * c); // reciprocal of determinant\n    a *= rD;\n    b *= rD;\n    c *= rD;\n    d *= rD;\n    el[0] = d;\n    el[1] = -b;\n    el[2] = -c;\n    el[3] = a;\n    el[4] = c * f - d * e;\n    el[5] = b * e - a * f;\n    return this;\n  }\n  transformPoint(x, y) {\n    const e = this.elements;\n    return {\n      x: x * e[0] + y * e[2] + e[4],\n      y: x * e[1] + y * e[3] + e[5]\n    };\n  }\n  transformBBox(bbox, target) {\n    const elements = this.elements;\n    const xx = elements[0];\n    const xy = elements[1];\n    const yx = elements[2];\n    const yy = elements[3];\n    const h_w = bbox.width * 0.5;\n    const h_h = bbox.height * 0.5;\n    const cx = bbox.x + h_w;\n    const cy = bbox.y + h_h;\n    const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);\n    const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);\n    if (!target) {\n      target = new BBox(0, 0, 0, 0);\n    }\n    target.x = cx * xx + cy * yx + elements[4] - w;\n    target.y = cx * xy + cy * yy + elements[5] - h;\n    target.width = w + w;\n    target.height = h + h;\n    return target;\n  }\n  toContext(ctx) {\n    // It's fair to say that matrix multiplications are not cheap.\n    // However, updating path definitions on every frame isn't either, so\n    // it may be cheaper to just translate paths. It's also fair to\n    // say, that most paths will have to be re-rendered anyway, say\n    // rectangle paths in a bar chart, where an animation would happen when\n    // the data set changes and existing bars are morphed into new ones.\n    // Or a pie chart, where old sectors are also morphed into new ones.\n    // Same for the line chart. The only plausible case where translating\n    // existing paths would be enough, is the scatter chart, where marker\n    // icons, typically circles, stay the same size. But if circle radii\n    // are bound to some data points, even circle paths would have to be\n    // updated. And thus it makes sense to optimize for fewer matrix\n    // transforms, where transform matrices of paths are mostly identity\n    // matrices and `x`/`y`, `centerX`/`centerY` and similar properties\n    // are used to define a path at specific coordinates. And only groups\n    // are used to collectively apply a transform to a set of nodes.\n    // If the matrix is mostly identity (95% of the time),\n    // the `if (this.isIdentity)` check can make this call 3-4 times\n    // faster on average: https://jsperf.com/matrix-check-first-vs-always-set\n    if (this.identity) {\n      return;\n    }\n    const e = this.elements;\n    ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\n  }\n  static flyweight(sourceMatrix) {\n    return Matrix.instance.setElements(sourceMatrix.elements);\n  }\n  static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {\n    // Assume that centers of scaling and rotation are at the origin.\n    const [bbcx, bbcy] = [0, 0];\n    const sx = scalingX;\n    const sy = scalingY;\n    let scx;\n    let scy;\n    if (sx === 1 && sy === 1) {\n      scx = 0;\n      scy = 0;\n    } else {\n      scx = (opts === null || opts === void 0 ? void 0 : opts.scalingCenterX) == null ? bbcx : opts === null || opts === void 0 ? void 0 : opts.scalingCenterX;\n      scy = (opts === null || opts === void 0 ? void 0 : opts.scalingCenterY) == null ? bbcy : opts === null || opts === void 0 ? void 0 : opts.scalingCenterY;\n    }\n    const r = rotation;\n    const cos = Math.cos(r);\n    const sin = Math.sin(r);\n    let rcx;\n    let rcy;\n    if (r === 0) {\n      rcx = 0;\n      rcy = 0;\n    } else {\n      rcx = (opts === null || opts === void 0 ? void 0 : opts.rotationCenterX) == null ? bbcx : opts === null || opts === void 0 ? void 0 : opts.rotationCenterX;\n      rcy = (opts === null || opts === void 0 ? void 0 : opts.rotationCenterY) == null ? bbcy : opts === null || opts === void 0 ? void 0 : opts.rotationCenterY;\n    }\n    const tx = translationX;\n    const ty = translationY;\n    // The transform matrix `M` is a result of the following transformations:\n    // 1) translate the center of scaling to the origin\n    // 2) scale\n    // 3) translate back\n    // 4) translate the center of rotation to the origin\n    // 5) rotate\n    // 6) translate back\n    // 7) translate\n    //         (7)          (6)             (5)             (4)           (3)           (2)           (1)\n    //     | 1 0 tx |   | 1 0 rcx |   | cos -sin 0 |   | 1 0 -rcx |   | 1 0 scx |   | sx 0 0 |   | 1 0 -scx |\n    // M = | 0 1 ty | * | 0 1 rcy | * | sin  cos 0 | * | 0 1 -rcy | * | 0 1 scy | * | 0 sy 0 | * | 0 1 -scy |\n    //     | 0 0  1 |   | 0 0  1  |   |  0    0  1 |   | 0 0  1   |   | 0 0  1  |   | 0  0 0 |   | 0 0  1   |\n    // Translation after steps 1-4 above:\n    const tx4 = scx * (1 - sx) - rcx;\n    const ty4 = scy * (1 - sy) - rcy;\n    matrix.setElements([cos * sx, sin * sx, -sin * sy, cos * sy, cos * tx4 - sin * ty4 + rcx + tx, sin * tx4 + cos * ty4 + rcy + ty]);\n    return matrix;\n  }\n  static fromContext(ctx) {\n    const domMatrix = ctx.getTransform();\n    return new Matrix([domMatrix.a, domMatrix.b, domMatrix.c, domMatrix.d, domMatrix.e, domMatrix.f]);\n  }\n}\nMatrix.instance = new Matrix();\nvar PointerEvents;\n(function (PointerEvents) {\n  PointerEvents[PointerEvents[\"All\"] = 0] = \"All\";\n  PointerEvents[PointerEvents[\"None\"] = 1] = \"None\";\n})(PointerEvents || (PointerEvents = {}));\nconst zIndexChangedCallback = o => {\n  if (o.parent) {\n    o.parent.dirtyZIndex = true;\n  }\n  o.zIndexChanged();\n};\n/**\r\n * Abstract scene graph node.\r\n * Each node can have zero or one parent and belong to zero or one scene.\r\n */\nclass Node extends ChangeDetectable {\n  /**\r\n   * Some arbitrary data bound to the node.\r\n   */\n  get datum() {\n    var _a, _b;\n    return (_a = this._datum) !== null && _a !== void 0 ? _a : (_b = this._parent) === null || _b === void 0 ? void 0 : _b.datum;\n  }\n  get previousDatum() {\n    return this._previousDatum;\n  }\n  set datum(datum) {\n    if (this._datum !== datum) this._previousDatum = this._datum;\n    this._datum = datum;\n  }\n  _setLayerManager(value) {\n    this._layerManager = value;\n    this._debug = value === null || value === void 0 ? void 0 : value.debug;\n    for (const child of this._children) {\n      child._setLayerManager(value);\n    }\n    for (const child of this._virtualChildren) {\n      child._setLayerManager(value);\n    }\n  }\n  get layerManager() {\n    return this._layerManager;\n  }\n  get parent() {\n    return this._parent;\n  }\n  get children() {\n    if (this._virtualChildren.length === 0) return this._children;\n    const result = [...this._children];\n    for (const next of this._virtualChildren) {\n      result.push(...next.children);\n    }\n    return result;\n  }\n  get virtualChildren() {\n    return this._virtualChildren;\n  }\n  hasVirtualChildren() {\n    return this._virtualChildren.length > 0;\n  }\n  setProperties(styles, pickKeys) {\n    const keys = pickKeys !== null && pickKeys !== void 0 ? pickKeys : Object.keys(styles);\n    for (const key of keys) {\n      this[key] = styles[key];\n    }\n    return this;\n  }\n  /**\r\n   * Appends one or more new node instances to this parent.\r\n   * If one needs to:\r\n   * - move a child to the end of the list of children\r\n   * - move a child from one parent to another (including parents in other scenes)\r\n   * one should use the {@link insertBefore} method instead.\r\n   * @param nodes A node or nodes to append.\r\n   */\n  append(nodes) {\n    // Passing a single parameter to an open-ended version of `append`\n    // would be 30-35% slower than this.\n    if (!Array.isArray(nodes)) {\n      nodes = [nodes];\n    }\n    for (const node of nodes) {\n      if (node.parent) {\n        throw new Error(`${node} already belongs to another parent: ${node.parent}.`);\n      }\n      if (node.layerManager) {\n        throw new Error(`${node} already belongs to a scene: ${node.layerManager}.`);\n      }\n      if (this.childSet[node.id]) {\n        // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\n        throw new Error(`Duplicate ${node.constructor.name} node: ${node}`);\n      }\n      if (node.isVirtual) {\n        this._virtualChildren.push(node);\n      } else {\n        this._children.push(node);\n      }\n      this.childSet[node.id] = true;\n      node._parent = this;\n      node._setLayerManager(this.layerManager);\n    }\n    this.dirtyZIndex = true;\n    this.markDirty(this, RedrawType.MAJOR);\n  }\n  appendChild(node) {\n    this.append(node);\n    return node;\n  }\n  removeChild(node) {\n    const error = () => {\n      throw new Error(`The node to be removed is not a child of this node.`);\n    };\n    if (node.parent !== this) {\n      error();\n    }\n    if (node.isVirtual) {\n      const i = this._virtualChildren.indexOf(node);\n      if (i < 0) error();\n      this._virtualChildren.splice(i, 1);\n    } else {\n      const i = this._children.indexOf(node);\n      if (i < 0) error();\n      this._children.splice(i, 1);\n    }\n    delete this.childSet[node.id];\n    node._parent = undefined;\n    node._setLayerManager();\n    this.dirtyZIndex = true;\n    this.markDirty(node, RedrawType.MAJOR);\n    return node;\n  }\n  calculateCumulativeMatrix() {\n    this.computeTransformMatrix();\n    const matrix = Matrix.flyweight(this.matrix);\n    let parent = this.parent;\n    while (parent) {\n      parent.computeTransformMatrix();\n      matrix.preMultiplySelf(parent.matrix);\n      parent = parent.parent;\n    }\n    return matrix;\n  }\n  transformPoint(x, y) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.invertSelf().transformPoint(x, y);\n  }\n  inverseTransformPoint(x, y) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.transformPoint(x, y);\n  }\n  transformBBox(bbox) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.invertSelf().transformBBox(bbox);\n  }\n  inverseTransformBBox(bbox) {\n    const matrix = this.calculateCumulativeMatrix();\n    return matrix.transformBBox(bbox);\n  }\n  markDirtyTransform() {\n    this.dirtyTransform = true;\n    this.markDirty(this, RedrawType.MAJOR);\n  }\n  constructor({\n    isVirtual,\n    tag\n  } = {}) {\n    super();\n    /** Unique number to allow creation order to be easily determined. */\n    this.serialNumber = Node._nextSerialNumber++;\n    /**\r\n     * Unique node ID in the form `ClassName-NaturalNumber`.\r\n     */\n    this.id = createId(this);\n    /**\r\n     * To simplify the type system (especially in Selections) we don't have the `Parent` node\r\n     * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\r\n     * But we still need to distinguish regular leaf nodes from container leafs somehow.\r\n     */\n    this.isContainerNode = false;\n    this._virtualChildren = [];\n    this._children = [];\n    // Used to check for duplicate nodes.\n    this.childSet = {}; // new Set<Node>()\n    // These matrices may need to have package level visibility\n    // for performance optimization purposes.\n    this.matrix = new Matrix();\n    this.inverseMatrix = new Matrix();\n    this.dirtyTransform = false;\n    this.scalingX = 1;\n    this.scalingY = 1;\n    /**\r\n     * The center of scaling.\r\n     * The default value of `null` means the scaling center will be\r\n     * determined automatically, as the center of the bounding box\r\n     * of a node.\r\n     */\n    this.scalingCenterX = null;\n    this.scalingCenterY = null;\n    this.rotationCenterX = null;\n    this.rotationCenterY = null;\n    /**\r\n     * Rotation angle in radians.\r\n     * The value is set as is. No normalization to the [-180, 180) or [0, 360)\r\n     * interval is performed.\r\n     */\n    this.rotation = 0;\n    this.translationX = 0;\n    this.translationY = 0;\n    this.visible = true;\n    this.dirtyZIndex = false;\n    this.zIndex = 0;\n    /** Discriminators for render order within a zIndex. */\n    this.zIndexSubOrder = undefined;\n    this.pointerEvents = PointerEvents.All;\n    this.isVirtual = isVirtual !== null && isVirtual !== void 0 ? isVirtual : false;\n    this.tag = tag !== null && tag !== void 0 ? tag : NaN;\n  }\n  containsPoint(_x, _y) {\n    return false;\n  }\n  /**\r\n   * Hit testing method.\r\n   * Recursively checks if the given point is inside this node or any of its children.\r\n   * Returns the first matching node or `undefined`.\r\n   * Nodes that render later (show on top) are hit tested first.\r\n   */\n  pickNode(x, y) {\n    var _a;\n    if (!this.visible || this.pointerEvents === PointerEvents.None || !this.containsPoint(x, y)) {\n      return;\n    }\n    const children = this.children;\n    if (children.length > 1000) {\n      // Try to optimise which children to interrogate; BBox calculation is an approximation\n      // for more complex shapes, so discarding items based on this will save a lot of\n      // processing when the point is nowhere near the child.\n      for (let i = children.length - 1; i >= 0; i--) {\n        const child = children[i];\n        const containsPoint = (_a = child.computeTransformedBBox()) === null || _a === void 0 ? void 0 : _a.containsPoint(x, y);\n        const hit = containsPoint ? child.pickNode(x, y) : undefined;\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (children.length) {\n      // Nodes added later should be hit-tested first,\n      // as they are rendered on top of the previously added nodes.\n      for (let i = children.length - 1; i >= 0; i--) {\n        const hit = children[i].pickNode(x, y);\n        if (hit) {\n          return hit;\n        }\n      }\n    } else if (!this.isContainerNode) {\n      // a leaf node, but not a container leaf\n      return this;\n    }\n  }\n  findNodes(predicate) {\n    const result = predicate(this) ? [this] : [];\n    for (const child of this.children) {\n      const childResult = child.findNodes(predicate);\n      if (childResult) {\n        result.push(...childResult);\n      }\n    }\n    return result;\n  }\n  computeBBox() {\n    return;\n  }\n  computeTransformedBBox() {\n    const bbox = this.computeBBox();\n    if (!bbox) {\n      return undefined;\n    }\n    this.computeTransformMatrix();\n    const matrix = Matrix.flyweight(this.matrix);\n    let parent = this.parent;\n    while (parent) {\n      parent.computeTransformMatrix();\n      matrix.preMultiplySelf(parent.matrix);\n      parent = parent.parent;\n    }\n    matrix.transformBBox(bbox, bbox);\n    return bbox;\n  }\n  computeTransformMatrix() {\n    if (!this.dirtyTransform) {\n      return;\n    }\n    const {\n      matrix,\n      scalingX,\n      scalingY,\n      rotation,\n      translationX,\n      translationY,\n      scalingCenterX,\n      scalingCenterY,\n      rotationCenterX,\n      rotationCenterY\n    } = this;\n    Matrix.updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, {\n      scalingCenterX,\n      scalingCenterY,\n      rotationCenterX,\n      rotationCenterY\n    });\n    matrix.inverseTo(this.inverseMatrix);\n    this.dirtyTransform = false;\n  }\n  render(renderCtx) {\n    const {\n      stats\n    } = renderCtx;\n    this._dirty = RedrawType.NONE;\n    if (stats) stats.nodesRendered++;\n  }\n  clearBBox(ctx) {\n    const bbox = this.computeBBox();\n    if (bbox == null) {\n      return;\n    }\n    const {\n      x,\n      y,\n      width,\n      height\n    } = bbox;\n    const topLeft = this.transformPoint(x, y);\n    const bottomRight = this.transformPoint(x + width, y + height);\n    ctx.clearRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);\n  }\n  markDirty(_source, type = RedrawType.TRIVIAL, parentType = type) {\n    if (this._dirty > type) {\n      return;\n    }\n    if (this._dirty === type && type === parentType) {\n      return;\n    }\n    this._dirty = type;\n    if (this.parent) {\n      this.parent.markDirty(this, parentType);\n    } else if (this.layerManager) {\n      this.layerManager.markDirty();\n    }\n  }\n  get dirty() {\n    return this._dirty;\n  }\n  markClean(opts) {\n    const {\n      force = false,\n      recursive = true\n    } = opts !== null && opts !== void 0 ? opts : {};\n    if (this._dirty === RedrawType.NONE && !force) {\n      return;\n    }\n    this._dirty = RedrawType.NONE;\n    if (recursive !== false) {\n      for (const child of this._virtualChildren) {\n        child.markClean({\n          force\n        });\n      }\n    }\n    if (recursive === true) {\n      for (const child of this._children) {\n        child.markClean({\n          force\n        });\n      }\n    }\n  }\n  visibilityChanged() {\n    // Override point for sub-classes to react to visibility changes.\n  }\n  get nodeCount() {\n    let count = 1;\n    let dirtyCount = this._dirty >= RedrawType.NONE || this.dirtyTransform ? 1 : 0;\n    let visibleCount = this.visible ? 1 : 0;\n    const countChild = child => {\n      const {\n        count: childCount,\n        visibleCount: childVisibleCount,\n        dirtyCount: childDirtyCount\n      } = child.nodeCount;\n      count += childCount;\n      visibleCount += childVisibleCount;\n      dirtyCount += childDirtyCount;\n    };\n    for (const child of this._children) {\n      countChild(child);\n    }\n    for (const child of this._virtualChildren) {\n      countChild(child);\n    }\n    return {\n      count,\n      visibleCount,\n      dirtyCount\n    };\n  }\n  zIndexChanged() {\n    // Override point for sub-classes.\n  }\n}\nNode._nextSerialNumber = 0;\n__decorate([SceneChangeDetection({\n  type: 'transform'\n}), __metadata(\"design:type\", Number)], Node.prototype, \"scalingX\", void 0);\n__decorate([SceneChangeDetection({\n  type: 'transform'\n}), __metadata(\"design:type\", Number)], Node.prototype, \"scalingY\", void 0);\n__decorate([SceneChangeDetection({\n  type: 'transform'\n}), __metadata(\"design:type\", Object)], Node.prototype, \"scalingCenterX\", void 0);\n__decorate([SceneChangeDetection({\n  type: 'transform'\n}), __metadata(\"design:type\", Object)], Node.prototype, \"scalingCenterY\", void 0);\n__decorate([SceneChangeDetection({\n  type: 'transform'\n}), __metadata(\"design:type\", Object)], Node.prototype, \"rotationCenterX\", void 0);\n__decorate([SceneChangeDetection({\n  type: 'transform'\n}), __metadata(\"design:type\", Object)], Node.prototype, \"rotationCenterY\", void 0);\n__decorate([SceneChangeDetection({\n  type: 'transform'\n}), __metadata(\"design:type\", Number)], Node.prototype, \"rotation\", void 0);\n__decorate([SceneChangeDetection({\n  type: 'transform'\n}), __metadata(\"design:type\", Number)], Node.prototype, \"translationX\", void 0);\n__decorate([SceneChangeDetection({\n  type: 'transform'\n}), __metadata(\"design:type\", Number)], Node.prototype, \"translationY\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR,\n  changeCb: o => o.visibilityChanged()\n}), __metadata(\"design:type\", Boolean)], Node.prototype, \"visible\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.TRIVIAL,\n  changeCb: zIndexChangedCallback\n}), __metadata(\"design:type\", Number)], Node.prototype, \"zIndex\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.TRIVIAL,\n  changeCb: zIndexChangedCallback\n})\n/** Discriminators for render order within a zIndex. */, __metadata(\"design:type\", Array)], Node.prototype, \"zIndexSubOrder\", void 0);\nclass DropShadow extends ChangeDetectable {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    this.color = 'rgba(0, 0, 0, 0.5)';\n    this.xOffset = 0;\n    this.yOffset = 0;\n    this.blur = 5;\n  }\n}\n__decorate([Validate(BOOLEAN), SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Object)], DropShadow.prototype, \"enabled\", void 0);\n__decorate([Validate(COLOR_STRING), SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Object)], DropShadow.prototype, \"color\", void 0);\n__decorate([Validate(NUMBER$1()), SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Object)], DropShadow.prototype, \"xOffset\", void 0);\n__decorate([Validate(NUMBER$1()), SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Object)], DropShadow.prototype, \"yOffset\", void 0);\n__decorate([Validate(NUMBER$1(0)), SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Object)], DropShadow.prototype, \"blur\", void 0);\nconst MOBILE = [/Android/i, /webOS/i, /iPhone/i, /iPad/i, /iPod/i, /BlackBerry/i, /Windows Phone/i];\nfunction isDesktop() {\n  if (typeof navigator === 'undefined') {\n    return true;\n  }\n  const userAgent = navigator.userAgent;\n  return !MOBILE.some(r => r.test(userAgent));\n}\n\n/**\r\n * Wraps the native Canvas element and overrides its CanvasRenderingContext2D to\r\n * provide resolution independent rendering based on `window.devicePixelRatio`.\r\n */\nclass HdpiCanvas {\n  // The width/height attributes of the Canvas element default to\n  // 300/150 according to w3.org.\n  constructor(opts) {\n    this._enabled = true;\n    // `NaN` is deliberate here, so that overrides are always applied\n    // and the `resetTransform` inside the `resize` method works in IE11.\n    this._pixelRatio = NaN;\n    this._width = 0;\n    this._height = 0;\n    const {\n      document,\n      window,\n      width = 600,\n      height = 300,\n      domLayer = false,\n      zIndex = 0,\n      name = undefined,\n      overrideDevicePixelRatio = undefined\n    } = opts;\n    this.document = document;\n    this.window = window;\n    HdpiCanvas.document = document;\n    // Create canvas and immediately apply width + height to avoid out-of-memory\n    // errors on iOS/iPadOS Safari.\n    this.element = document.createElement('canvas');\n    this.element.width = width;\n    this.element.height = height;\n    this.realContext = this.element.getContext('2d');\n    this.imageSource = this.realContext.canvas;\n    const {\n      style\n    } = this.element;\n    style.userSelect = 'none';\n    style.display = 'block';\n    if (domLayer) {\n      style.position = 'absolute';\n      style.zIndex = String(zIndex);\n      style.top = '0';\n      style.left = '0';\n      style.pointerEvents = 'none';\n      style.opacity = `1`;\n      if (name) {\n        this.element.id = name;\n      }\n    }\n    this.context = this.setPixelRatio(overrideDevicePixelRatio);\n    this.resize(width, height);\n  }\n  set container(value) {\n    if (this._container !== value) {\n      this.remove();\n      if (value) {\n        value.appendChild(this.element);\n      }\n      this._container = value;\n    }\n  }\n  get container() {\n    return this._container;\n  }\n  set enabled(value) {\n    this.element.style.display = value ? 'block' : 'none';\n    this._enabled = !!value;\n  }\n  get enabled() {\n    return this._enabled;\n  }\n  remove() {\n    const {\n      parentNode\n    } = this.element;\n    if (parentNode != null) {\n      parentNode.removeChild(this.element);\n    }\n  }\n  destroy() {\n    this.element.remove();\n    // Workaround memory allocation quirks in iOS Safari by resizing to 0x0 and clearing.\n    // See https://bugs.webkit.org/show_bug.cgi?id=195325.\n    this.element.width = 0;\n    this.element.height = 0;\n    this.context.clearRect(0, 0, 0, 0);\n    Object.freeze(this);\n  }\n  snapshot() {\n    // No-op for compatibility with HdpiOffscreenCanvas.\n  }\n  clear() {\n    this.context.save();\n    this.context.resetTransform();\n    this.context.clearRect(0, 0, this.width, this.height);\n    this.context.restore();\n  }\n  toImage() {\n    const img = this.document.createElement('img');\n    img.src = this.getDataURL();\n    return img;\n  }\n  getDataURL(type) {\n    return this.element.toDataURL(type);\n  }\n  /**\r\n   * @param fileName The name of the downloaded file.\r\n   * @param fileFormat The file format, the default is `image/png`\r\n   */\n  download(fileName, fileFormat = 'image/png') {\n    fileName = (fileName !== null && fileName !== void 0 ? fileName : '').trim() || 'image';\n    const dataUrl = this.getDataURL(fileFormat);\n    const document = this.document;\n    const a = document.createElement('a');\n    a.href = dataUrl;\n    a.download = fileName;\n    a.style.display = 'none';\n    document.body.appendChild(a); // required for the `click` to work in Firefox\n    a.click();\n    document.body.removeChild(a);\n  }\n  get pixelRatio() {\n    return this._pixelRatio;\n  }\n  /**\r\n   * Changes the pixel ratio of the Canvas element to the given value,\r\n   * or uses the window.devicePixelRatio (default), then resizes the Canvas\r\n   * element accordingly (default).\r\n   */\n  setPixelRatio(ratio) {\n    let pixelRatio = ratio !== null && ratio !== void 0 ? ratio : this.window.devicePixelRatio;\n    if (!isDesktop()) {\n      // Mobile browsers have stricter memory limits, we reduce rendering resolution to\n      // improve stability on mobile browsers. iOS Safari 12->16 are pain-points since they\n      // have memory allocation quirks - see https://bugs.webkit.org/show_bug.cgi?id=195325.\n      pixelRatio = 1;\n    }\n    this._pixelRatio = pixelRatio;\n    return HdpiCanvas.overrideScale(this.realContext, pixelRatio);\n  }\n  set pixelated(value) {\n    this.element.style.imageRendering = value ? 'pixelated' : 'auto';\n  }\n  get pixelated() {\n    return this.element.style.imageRendering === 'pixelated';\n  }\n  get width() {\n    return this._width;\n  }\n  get height() {\n    return this._height;\n  }\n  resize(width, height) {\n    if (!(width > 0 && height > 0)) {\n      return;\n    }\n    const {\n      element,\n      context,\n      pixelRatio\n    } = this;\n    element.width = Math.round(width * pixelRatio);\n    element.height = Math.round(height * pixelRatio);\n    element.style.width = width + 'px';\n    element.style.height = height + 'px';\n    context.resetTransform();\n    this._width = width;\n    this._height = height;\n  }\n  static get textMeasuringContext() {\n    if (this._textMeasuringContext) {\n      return this._textMeasuringContext;\n    }\n    const canvas = this.document.createElement('canvas');\n    this._textMeasuringContext = canvas.getContext('2d');\n    return this._textMeasuringContext;\n  }\n  static get svgText() {\n    if (this._svgText) {\n      return this._svgText;\n    }\n    const xmlns = 'http://www.w3.org/2000/svg';\n    const svg = document.createElementNS(xmlns, 'svg');\n    svg.setAttribute('width', '100');\n    svg.setAttribute('height', '100');\n    // Add a descriptive class name in case someone sees this SVG element\n    // in devtools and wonders about its purpose:\n    if (svg.classList) {\n      svg.classList.add('text-measuring-svg');\n    } else {\n      svg.setAttribute('class', 'text-measuring-svg');\n    }\n    svg.style.position = 'absolute';\n    svg.style.top = '-1000px';\n    svg.style.visibility = 'hidden';\n    const svgText = document.createElementNS(xmlns, 'text');\n    svgText.setAttribute('x', '0');\n    svgText.setAttribute('y', '30');\n    svgText.setAttribute('text', 'black');\n    svg.appendChild(svgText);\n    document.body.appendChild(svg);\n    this._svgText = svgText;\n    return svgText;\n  }\n  static get has() {\n    if (this._has) {\n      return this._has;\n    }\n    const isChrome = typeof navigator === 'undefined' || navigator.userAgent.indexOf('Chrome') > -1;\n    const isFirefox = typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Firefox') > -1;\n    const isSafari = !isChrome && typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Safari') > -1;\n    this._has = Object.freeze({\n      textMetrics: this.textMeasuringContext.measureText('test').actualBoundingBoxDescent !== undefined &&\n      // Firefox implemented advanced TextMetrics object in v74:\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1102584\n      // but it's buggy, so we'll keep using the SVG for text measurement in Firefox for now.\n      !isFirefox && !isSafari,\n      getTransform: this.textMeasuringContext.getTransform !== undefined\n    });\n    return this._has;\n  }\n  static measureText(text, font, textBaseline, textAlign) {\n    const ctx = this.textMeasuringContext;\n    ctx.font = font;\n    ctx.textBaseline = textBaseline;\n    ctx.textAlign = textAlign;\n    return ctx.measureText(text);\n  }\n  /**\r\n   * Returns the width and height of the measured text.\r\n   * @param text The single-line text to measure.\r\n   * @param font The font shorthand string.\r\n   */\n  static getTextSize(text, font) {\n    if (this.has.textMetrics) {\n      const ctx = this.textMeasuringContext;\n      ctx.font = font;\n      const metrics = ctx.measureText(text);\n      return {\n        width: metrics.width,\n        height: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent\n      };\n    } else {\n      return this.measureSvgText(text, font);\n    }\n  }\n  static measureSvgText(text, font) {\n    const cache = this.textSizeCache;\n    const fontCache = cache[font];\n    // Note: consider not caching the size of numeric strings.\n    // For example: if (isNaN(+text)) { // skip\n    if (fontCache) {\n      const size = fontCache[text];\n      if (size) {\n        return size;\n      }\n    } else {\n      cache[font] = {};\n    }\n    const svgText = this.svgText;\n    svgText.style.font = font;\n    svgText.textContent = text;\n    // `getBBox` returns an instance of `SVGRect` with the same `width` and `height`\n    // measurements as `DOMRect` instance returned by the `getBoundingClientRect`.\n    // But the `SVGRect` instance has half the properties of the `DOMRect`,\n    // so we use the `getBBox` method.\n    const bbox = svgText.getBBox();\n    const size = {\n      width: bbox.width,\n      height: bbox.height\n    };\n    cache[font][text] = size;\n    return size;\n  }\n  static overrideScale(ctx, scale) {\n    let depth = 0;\n    const overrides = {\n      save() {\n        this.$save();\n        depth++;\n      },\n      restore() {\n        if (depth > 0) {\n          this.$restore();\n          depth--;\n        } else {\n          throw new Error('AG Charts - Unable to restore() past depth 0');\n        }\n      },\n      setTransform(a, b, c, d, e, f) {\n        if (typeof a === 'object') {\n          this.$setTransform(a);\n        } else {\n          this.$setTransform(a * scale, b * scale, c * scale, d * scale, e * scale, f * scale);\n        }\n      },\n      resetTransform() {\n        // As of Jan 8, 2019, `resetTransform` is still an \"experimental technology\",\n        // and doesn't work in IE11 and Edge 44.\n        this.$setTransform(scale, 0, 0, scale, 0, 0);\n      },\n      verifyDepthZero() {\n        if (depth !== 0) {\n          throw new Error('AG Charts - Save/restore depth is non-zero: ' + depth);\n        }\n      }\n    };\n    for (const name in overrides) {\n      if (Object.prototype.hasOwnProperty.call(overrides, name)) {\n        // Save native methods under prefixed names,\n        // if this hasn't been done by the previous overrides already.\n        if (!ctx['$' + name]) {\n          ctx['$' + name] = ctx[name];\n        }\n        // Replace native methods with overrides,\n        // or previous overrides with the new ones.\n        ctx[name] = overrides[name];\n      }\n    }\n    return ctx;\n  }\n}\nHdpiCanvas.document = globalThis.document;\nHdpiCanvas.textSizeCache = {};\nclass Gradient {\n  constructor() {\n    this.stops = [];\n  }\n}\nclass LinearGradient extends Gradient {\n  constructor() {\n    super(...arguments);\n    this.angle = 0;\n  }\n  createGradient(ctx, bbox) {\n    // Gradient 0° angle starts at top according to CSS spec\n    const angleOffset = 90;\n    const {\n      stops,\n      angle\n    } = this;\n    const radians = normalizeAngle360(toRadians(angle + angleOffset));\n    const cos = Math.cos(radians);\n    const sin = Math.sin(radians);\n    const w = bbox.width;\n    const h = bbox.height;\n    const cx = bbox.x + w * 0.5;\n    const cy = bbox.y + h * 0.5;\n    if (w > 0 && h > 0) {\n      const diagonal = Math.sqrt(h * h + w * w) / 2;\n      const diagonalAngle = Math.atan2(h, w);\n      let quarteredAngle;\n      if (radians < Math.PI / 2) {\n        quarteredAngle = radians;\n      } else if (radians < Math.PI) {\n        quarteredAngle = Math.PI - radians;\n      } else if (radians < 3 * Math.PI / 2) {\n        quarteredAngle = radians - Math.PI;\n      } else {\n        quarteredAngle = 2 * Math.PI - radians;\n      }\n      const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));\n      const gradient = ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);\n      stops.forEach(stop => {\n        gradient.addColorStop(stop.offset, stop.color);\n      });\n      return gradient;\n    }\n    return 'black';\n  }\n}\nconst LINEAR_GRADIENT_REGEXP = /^linear-gradient\\((.*?)deg,\\s*(.*?)\\s*\\)$/i;\nclass Shape extends Node {\n  constructor() {\n    super(...arguments);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.fill = Shape.defaultStyles.fill;\n    /**\r\n     * Note that `strokeStyle = null` means invisible stroke,\r\n     * while `lineWidth = 0` means no stroke, and sometimes this can mean different things.\r\n     * For example, a rect shape with an invisible stroke may not align to the pixel grid\r\n     * properly because the stroke affects the rules of alignment, and arc shapes forming\r\n     * a pie chart will have a gap between them if they have an invisible stroke, whereas\r\n     * there would be not gap if there was no stroke at all.\r\n     * The preferred way of making the stroke invisible is setting the `lineWidth` to zero,\r\n     * unless specific looks that is achieved by having an invisible stroke is desired.\r\n     */\n    this.stroke = Shape.defaultStyles.stroke;\n    this.strokeWidth = Shape.defaultStyles.strokeWidth;\n    this.lineDash = Shape.defaultStyles.lineDash;\n    this.lineDashOffset = Shape.defaultStyles.lineDashOffset;\n    this.lineCap = Shape.defaultStyles.lineCap;\n    this.lineJoin = Shape.defaultStyles.lineJoin;\n    this.opacity = Shape.defaultStyles.opacity;\n    this.fillShadow = Shape.defaultStyles.fillShadow;\n  }\n  /**\r\n   * Restores the default styles introduced by this subclass.\r\n   */\n  restoreOwnStyles() {\n    const styles = this.constructor.defaultStyles;\n    const keys = Object.getOwnPropertyNames(styles);\n    // getOwnPropertyNames is about 2.5 times faster than\n    // for..in with the hasOwnProperty check and in this\n    // case, where most properties are inherited, can be\n    // more than an order of magnitude faster.\n    for (let i = 0, n = keys.length; i < n; i++) {\n      const key = keys[i];\n      this[key] = styles[key];\n    }\n  }\n  updateGradient() {\n    const {\n      fill\n    } = this;\n    let linearGradientMatch;\n    if ((fill === null || fill === void 0 ? void 0 : fill.startsWith('linear-gradient')) && (linearGradientMatch = LINEAR_GRADIENT_REGEXP.exec(fill))) {\n      const angle = parseFloat(linearGradientMatch[1]);\n      const colors = [];\n      const colorsPart = linearGradientMatch[2];\n      const colorRegex = /(#[0-9a-f]+)|(rgba?\\(.+?\\))|([a-z]+)/gi;\n      let c;\n      while (c = colorRegex.exec(colorsPart)) {\n        colors.push(c[0]);\n      }\n      this.gradient = new LinearGradient();\n      this.gradient.angle = angle;\n      this.gradient.stops = colors.map((color, index) => {\n        const offset = index / (colors.length - 1);\n        return {\n          offset,\n          color\n        };\n      });\n    } else {\n      this.gradient = undefined;\n    }\n  }\n  /**\r\n   * Returns a device-pixel aligned coordinate (or length if length is supplied).\r\n   *\r\n   * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle\r\n   * of a device pixel.\r\n   */\n  align(start, length) {\n    var _a, _b, _c;\n    const pixelRatio = (_c = (_b = (_a = this.layerManager) === null || _a === void 0 ? void 0 : _a.canvas) === null || _b === void 0 ? void 0 : _b.pixelRatio) !== null && _c !== void 0 ? _c : 1;\n    const alignedStart = Math.round(start * pixelRatio) / pixelRatio;\n    if (length == undefined) {\n      return alignedStart;\n    }\n    if (length === 0) {\n      return 0;\n    }\n    if (length < 1) {\n      // Avoid hiding crisp shapes\n      return Math.ceil(length * pixelRatio) / pixelRatio;\n    }\n    // Account for the rounding of alignedStart by increasing length to compensate before\n    // alignment.\n    return Math.round((length + start) * pixelRatio) / pixelRatio - alignedStart;\n  }\n  fillStroke(ctx) {\n    this.renderFill(ctx);\n    this.renderStroke(ctx);\n  }\n  renderFill(ctx) {\n    if (this.fill) {\n      const {\n        globalAlpha\n      } = ctx;\n      this.applyFill(ctx);\n      this.applyFillAlpha(ctx);\n      this.applyShadow(ctx);\n      ctx.fill();\n      ctx.globalAlpha = globalAlpha;\n    }\n    ctx.shadowColor = 'rgba(0, 0, 0, 0)';\n  }\n  applyFill(ctx) {\n    if (this.gradient) {\n      ctx.fillStyle = this.gradient.createGradient(ctx, this.computeBBox());\n    } else {\n      ctx.fillStyle = this.fill;\n    }\n  }\n  applyFillAlpha(ctx) {\n    const {\n      globalAlpha\n    } = ctx;\n    ctx.globalAlpha = globalAlpha * this.opacity * this.fillOpacity;\n  }\n  applyShadow(ctx) {\n    var _a, _b;\n    // The canvas context scaling (depends on the device's pixel ratio)\n    // has no effect on shadows, so we have to account for the pixel ratio\n    // manually here.\n    const pixelRatio = (_b = (_a = this.layerManager) === null || _a === void 0 ? void 0 : _a.canvas.pixelRatio) !== null && _b !== void 0 ? _b : 1;\n    const fillShadow = this.fillShadow;\n    if (fillShadow === null || fillShadow === void 0 ? void 0 : fillShadow.enabled) {\n      ctx.shadowColor = fillShadow.color;\n      ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n      ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n      ctx.shadowBlur = fillShadow.blur * pixelRatio;\n    }\n  }\n  renderStroke(ctx) {\n    if (this.stroke && this.strokeWidth) {\n      const {\n        globalAlpha\n      } = ctx;\n      ctx.strokeStyle = this.stroke;\n      ctx.globalAlpha = globalAlpha * this.opacity * this.strokeOpacity;\n      ctx.lineWidth = this.strokeWidth;\n      if (this.lineDash) {\n        ctx.setLineDash(this.lineDash);\n      }\n      if (this.lineDashOffset) {\n        ctx.lineDashOffset = this.lineDashOffset;\n      }\n      if (this.lineCap) {\n        ctx.lineCap = this.lineCap;\n      }\n      if (this.lineJoin) {\n        ctx.lineJoin = this.lineJoin;\n      }\n      ctx.stroke();\n      ctx.globalAlpha = globalAlpha;\n    }\n  }\n  containsPoint(x, y) {\n    return this.isPointInPath(x, y);\n  }\n}\n/**\r\n * Defaults for style properties. Note that properties that affect the position\r\n * and shape of the node are not considered style properties, for example:\r\n * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.\r\n * Can be used to reset to the original styling after some custom styling\r\n * has been applied (using the `restoreOwnStyles` method).\r\n * These static defaults are meant to be inherited by subclasses.\r\n */\nShape.defaultStyles = Object.assign({}, {\n  fill: 'black',\n  stroke: undefined,\n  strokeWidth: 0,\n  lineDash: undefined,\n  lineDashOffset: 0,\n  lineCap: undefined,\n  lineJoin: undefined,\n  opacity: 1,\n  fillShadow: undefined\n});\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR\n}), __metadata(\"design:type\", Number)], Shape.prototype, \"fillOpacity\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR\n}), __metadata(\"design:type\", Number)], Shape.prototype, \"strokeOpacity\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR,\n  changeCb: s => s.updateGradient()\n}), __metadata(\"design:type\", Object)], Shape.prototype, \"fill\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR\n}), __metadata(\"design:type\", Object)], Shape.prototype, \"stroke\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR\n}), __metadata(\"design:type\", Number)], Shape.prototype, \"strokeWidth\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR\n}), __metadata(\"design:type\", Object)], Shape.prototype, \"lineDash\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR\n}), __metadata(\"design:type\", Number)], Shape.prototype, \"lineDashOffset\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR\n}), __metadata(\"design:type\", String)], Shape.prototype, \"lineCap\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR\n}), __metadata(\"design:type\", String)], Shape.prototype, \"lineJoin\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR,\n  convertor: v => Math.min(1, Math.max(0, v))\n}), __metadata(\"design:type\", Number)], Shape.prototype, \"opacity\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR,\n  checkDirtyOnAssignment: true\n}), __metadata(\"design:type\", Object)], Shape.prototype, \"fillShadow\", void 0);\nconst ellipsis = '\\u2026';\nfunction SceneFontChangeDetection(opts) {\n  const {\n    redraw = RedrawType.MAJOR,\n    changeCb\n  } = opts !== null && opts !== void 0 ? opts : {};\n  return SceneChangeDetection({\n    redraw,\n    type: 'font',\n    changeCb\n  });\n}\nclass Text extends Shape {\n  constructor() {\n    super(...arguments);\n    this.x = 0;\n    this.y = 0;\n    this.lines = [];\n    this.text = undefined;\n    this._dirtyFont = true;\n    this.fontSize = 10;\n    this.fontFamily = 'sans-serif';\n    this.textAlign = Text.defaultStyles.textAlign;\n    this.textBaseline = Text.defaultStyles.textBaseline;\n    // TextMetrics are used if lineHeight is not defined.\n    this.lineHeight = undefined;\n  }\n  _setLines() {\n    this.lines = splitText(this.text);\n  }\n  get font() {\n    if (this._font == null || this._dirtyFont) {\n      this._dirtyFont = false;\n      this._font = getFont(this);\n    }\n    return this._font;\n  }\n  computeBBox() {\n    return HdpiCanvas.has.textMetrics ? getPreciseBBox(this.lines, this.x, this.y, this) : getApproximateBBox(this.lines, this.x, this.y, this);\n  }\n  getLineHeight(line) {\n    var _a, _b;\n    if (this.lineHeight) return this.lineHeight;\n    if (HdpiCanvas.has.textMetrics) {\n      const metrics = HdpiCanvas.measureText(line, this.font, this.textBaseline, this.textAlign);\n      return ((_a = metrics.fontBoundingBoxAscent) !== null && _a !== void 0 ? _a : metrics.emHeightAscent) + ((_b = metrics.fontBoundingBoxDescent) !== null && _b !== void 0 ? _b : metrics.emHeightDescent);\n    }\n    return HdpiCanvas.getTextSize(line, this.font).height;\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const bbox = this.computeBBox();\n    return bbox ? bbox.containsPoint(point.x, point.y) : false;\n  }\n  render(renderCtx) {\n    const {\n      ctx,\n      forceRender,\n      stats\n    } = renderCtx;\n    if (this.dirty === RedrawType.NONE && !forceRender) {\n      if (stats) stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    if (!this.lines.length || !this.layerManager) {\n      if (stats) stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.computeTransformMatrix();\n    this.matrix.toContext(ctx);\n    const {\n      fill,\n      stroke,\n      strokeWidth\n    } = this;\n    ctx.font = this.font;\n    ctx.textAlign = this.textAlign;\n    ctx.textBaseline = this.textBaseline;\n    const pixelRatio = this.layerManager.canvas.pixelRatio || 1;\n    const {\n      globalAlpha\n    } = ctx;\n    if (fill) {\n      ctx.fillStyle = fill;\n      ctx.globalAlpha = globalAlpha * this.opacity * this.fillOpacity;\n      const {\n        fillShadow\n      } = this;\n      if (fillShadow === null || fillShadow === void 0 ? void 0 : fillShadow.enabled) {\n        ctx.shadowColor = fillShadow.color;\n        ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\n        ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\n        ctx.shadowBlur = fillShadow.blur * pixelRatio;\n      }\n      this.renderLines((line, x, y) => ctx.fillText(line, x, y));\n    }\n    if (stroke && strokeWidth) {\n      ctx.strokeStyle = stroke;\n      ctx.lineWidth = strokeWidth;\n      ctx.globalAlpha = globalAlpha * this.opacity * this.strokeOpacity;\n      const {\n        lineDash,\n        lineDashOffset,\n        lineCap,\n        lineJoin\n      } = this;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      this.renderLines((line, x, y) => ctx.strokeText(line, x, y));\n    }\n    super.render(renderCtx);\n  }\n  renderLines(renderCallback) {\n    const {\n      lines,\n      x,\n      y\n    } = this;\n    const lineHeights = this.lines.map(line => this.getLineHeight(line));\n    const totalHeight = lineHeights.reduce((a, b) => a + b, 0);\n    let offsetY = -(totalHeight - lineHeights[0]) * getVerticalOffset(this.textBaseline);\n    for (let i = 0; i < lines.length; i++) {\n      renderCallback(lines[i], x, y + offsetY);\n      offsetY += lineHeights[i];\n    }\n  }\n  static wrap(text, maxWidth, maxHeight, textProps, wrapping, overflow = 'ellipsis') {\n    var _a;\n    const canOverflow = overflow !== 'hide';\n    const font = getFont(textProps);\n    const measurer = createTextMeasurer(font);\n    const lines = text.split(/\\r?\\n/g);\n    if (lines.length === 0) {\n      return '';\n    }\n    if (wrapping === 'never') {\n      return (_a = Text.truncateLine(lines[0], maxWidth, measurer, canOverflow ? 'auto' : 'never')) !== null && _a !== void 0 ? _a : '';\n    }\n    const result = [];\n    let cumulativeHeight = 0;\n    for (const line of lines) {\n      const wrappedLine = Text.wrapLine(line, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight, canOverflow);\n      if (wrappedLine == null) {\n        return '';\n      }\n      result.push(wrappedLine.result);\n      cumulativeHeight = wrappedLine.cumulativeHeight;\n      if (wrappedLine.truncated) {\n        break;\n      }\n    }\n    return result.join('\\n').trim();\n  }\n  static wrapLine(text, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight, canOverflow) {\n    text = text.trim();\n    if (!text) {\n      return {\n        result: '',\n        truncated: false,\n        cumulativeHeight\n      };\n    }\n    const initialSize = measurer.size(text);\n    if (initialSize.width <= maxWidth) {\n      // Text fits into a single line\n      return {\n        result: text,\n        truncated: false,\n        cumulativeHeight: cumulativeHeight + initialSize.height\n      };\n    }\n    if (initialSize.height > maxHeight || measurer.width('W') > maxWidth) {\n      // Not enough space for a single line or character\n      return canOverflow ? {\n        result: '',\n        truncated: true,\n        cumulativeHeight\n      } : undefined;\n    }\n    const words = text.split(/\\s+/g);\n    const wrapResult = Text.wrapLineSequentially(words, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight, canOverflow);\n    if (wrapResult == null) {\n      return undefined;\n    }\n    cumulativeHeight = wrapResult.cumulativeHeight;\n    let {\n      lines\n    } = wrapResult;\n    if (!(wrapResult.wordsBrokenOrTruncated || wrapResult.linesTruncated)) {\n      // If no word breaks or truncations, try the balanced wrapping\n      const linesCount = wrapResult.lines.length;\n      const balanced = Text.wrapLineBalanced(words, maxWidth, measurer, linesCount);\n      if (balanced.length === lines.length) {\n        // Some lines can't be balanced properly because of unusually long words\n        lines = balanced;\n      }\n    }\n    const wrappedText = lines.map(ln => ln.join(' ')).join('\\n');\n    return {\n      result: wrappedText,\n      truncated: wrapResult.linesTruncated,\n      cumulativeHeight\n    };\n  }\n  static breakWord(word, firstLineWidth, maxWidth, hyphens, measurer) {\n    const isPunctuationAt = index => Text.punctuationMarks.includes(word[index]);\n    const h = hyphens ? measurer.width('-') : 0;\n    const breaks = [];\n    let partWidth = 0;\n    let p = 0;\n    for (let i = 0; i < word.length; i++) {\n      const c = word[i];\n      const w = measurer.width(c);\n      const limit = p === 0 ? firstLineWidth : maxWidth;\n      if (partWidth + w + h > limit) {\n        breaks.push(i);\n        partWidth = 0;\n        p++;\n      }\n      partWidth += w;\n    }\n    const parts = [];\n    let start = 0;\n    for (const index of breaks) {\n      let part = word.substring(start, index);\n      if (hyphens && part.length > 0 && !isPunctuationAt(index - 1) && !isPunctuationAt(index)) {\n        part += '-';\n      }\n      parts.push(part);\n      start = index;\n    }\n    parts.push(word.substring(start));\n    return parts;\n  }\n  static truncateLine(text, maxWidth, measurer, ellipsisMode) {\n    text = text.trimEnd();\n    const lineWidth = measurer.width(text);\n    if (lineWidth > maxWidth && ellipsisMode === 'never') {\n      return undefined;\n    } else if (lineWidth <= maxWidth && ellipsisMode !== 'force') {\n      return text;\n    }\n    const ellipsisWidth = measurer.width(ellipsis);\n    let trunc = text;\n    let truncWidth = lineWidth;\n    while (trunc.length > 0 && truncWidth + ellipsisWidth > maxWidth) {\n      // Ensure there is no space between the ellipsis and last letter\n      trunc = trunc.slice(0, -1).trimEnd();\n      truncWidth = measurer.width(trunc);\n    }\n    if (truncWidth + ellipsisWidth <= maxWidth) {\n      return `${trunc}${ellipsis}`;\n    } else {\n      return undefined;\n    }\n  }\n  static wrapLineSequentially(words, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight, canOverflow) {\n    const {\n      fontSize = 0,\n      lineHeight = fontSize * Text.defaultLineHeightRatio\n    } = textProps;\n    const breakWord = wrapping === 'always' || wrapping === 'hyphenate';\n    const hyphenate = wrapping === 'hyphenate';\n    const spaceWidth = measurer.width(' ');\n    let wordsBrokenOrTruncated = false;\n    let linesTruncated = false;\n    const lines = [];\n    let currentLine = [];\n    let lineWidth = 0;\n    const getReturnValue = () => ({\n      lines,\n      linesTruncated,\n      wordsBrokenOrTruncated,\n      cumulativeHeight\n    });\n    const truncateLastLine = () => {\n      if (!canOverflow) {\n        return undefined;\n      }\n      const lastLine = currentLine.join(' ');\n      const trunc = Text.truncateLine(lastLine, maxWidth, measurer, 'force');\n      if (trunc == null) {\n        return undefined;\n      }\n      currentLine.splice(0, currentLine.length, trunc);\n      linesTruncated = true;\n      return getReturnValue();\n    };\n    const addNewLine = () => {\n      const expectedHeight = cumulativeHeight + lineHeight;\n      if (expectedHeight >= maxHeight) {\n        return false;\n      }\n      // Add new line\n      currentLine = [];\n      lineWidth = 0;\n      cumulativeHeight = expectedHeight;\n      lines.push(currentLine);\n      return true;\n    };\n    if (!addNewLine()) {\n      return truncateLastLine();\n    }\n    for (let i = 0; i < words.length; i++) {\n      const word = words[i];\n      const wordWidth = measurer.width(word);\n      const expectedSpaceWidth = currentLine.length === 0 ? 0 : spaceWidth;\n      const expectedLineWidth = lineWidth + expectedSpaceWidth + wordWidth;\n      if (expectedLineWidth <= maxWidth) {\n        // If the word fits, add it to the current line\n        currentLine.push(word);\n        lineWidth = expectedLineWidth;\n        continue;\n      }\n      if (wordWidth <= maxWidth) {\n        // If the word is not too long, put it onto new line\n        if (!addNewLine()) {\n          return truncateLastLine();\n        }\n        currentLine.push(word);\n        lineWidth = wordWidth;\n        continue;\n      }\n      // Handle a long word\n      wordsBrokenOrTruncated = true;\n      if (breakWord) {\n        // Break the word into parts\n        const availWidth = maxWidth - lineWidth - expectedSpaceWidth;\n        const parts = Text.breakWord(word, availWidth, maxWidth, hyphenate, measurer);\n        for (let p = 0; p < parts.length; p++) {\n          const part = parts[p];\n          part && currentLine.push(part);\n          if (p === parts.length - 1) {\n            lineWidth = measurer.width(part);\n          } else if (!addNewLine()) {\n            return truncateLastLine();\n          }\n        }\n      } else if (canOverflow) {\n        // Truncate the word\n        if (!addNewLine()) {\n          return truncateLastLine();\n        }\n        const trunc = Text.truncateLine(word, maxWidth, measurer, 'force');\n        if (trunc == null) {\n          return undefined;\n        }\n        currentLine.push(trunc);\n        if (i < words.length - 1) {\n          linesTruncated = true;\n        }\n        break;\n      } else {\n        return undefined;\n      }\n    }\n    return getReturnValue();\n  }\n  static wrapLineBalanced(words, maxWidth, measurer, linesCount) {\n    const totalWordsWidth = words.reduce((sum, w) => sum + measurer.width(w), 0);\n    const spaceWidth = measurer.width(' ');\n    const totalSpaceWidth = spaceWidth * (words.length - linesCount - 2);\n    const averageLineWidth = (totalWordsWidth + totalSpaceWidth) / linesCount;\n    const lines = [];\n    let currentLine = [];\n    let lineWidth = measurer.width(words[0]);\n    let newLine = true;\n    for (const word of words) {\n      const width = measurer.width(word);\n      if (newLine) {\n        // New line\n        currentLine = [];\n        currentLine.push(word);\n        lineWidth = width;\n        newLine = false;\n        lines.push(currentLine);\n        continue;\n      }\n      const expectedLineWidth = lineWidth + spaceWidth + width;\n      if (expectedLineWidth <= averageLineWidth) {\n        // Keep adding words to the line\n        currentLine.push(word);\n        lineWidth = expectedLineWidth;\n      } else if (expectedLineWidth <= maxWidth) {\n        // Add the last word to the line\n        currentLine.push(word);\n        newLine = true;\n      } else {\n        // Put the word onto the next line\n        currentLine = [word];\n        lineWidth = width;\n        lines.push(currentLine);\n      }\n    }\n    return lines;\n  }\n  setFont(props) {\n    this.fontFamily = props.fontFamily;\n    this.fontSize = props.fontSize;\n    this.fontStyle = props.fontStyle;\n    this.fontWeight = props.fontWeight;\n  }\n  setAlign(props) {\n    this.textAlign = props.textAlign;\n    this.textBaseline = props.textBaseline;\n  }\n}\nText.className = 'Text';\n// The default line spacing for document editors is usually 1.15\nText.defaultLineHeightRatio = 1.15;\nText.defaultStyles = Object.assign({}, Shape.defaultStyles, {\n  textAlign: 'start',\n  fontStyle: undefined,\n  fontWeight: undefined,\n  fontSize: 10,\n  fontFamily: 'sans-serif',\n  textBaseline: 'alphabetic'\n});\nText.ellipsis = ellipsis;\nText.punctuationMarks = ['.', ',', '-', ':', ';', '!', '?', `'`, '\"', '(', ')'];\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Number)], Text.prototype, \"x\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Number)], Text.prototype, \"y\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR,\n  changeCb: o => o._setLines()\n}), __metadata(\"design:type\", String)], Text.prototype, \"text\", void 0);\n__decorate([SceneFontChangeDetection(), __metadata(\"design:type\", String)], Text.prototype, \"fontStyle\", void 0);\n__decorate([SceneFontChangeDetection(), __metadata(\"design:type\", String)], Text.prototype, \"fontWeight\", void 0);\n__decorate([SceneFontChangeDetection(), __metadata(\"design:type\", Number)], Text.prototype, \"fontSize\", void 0);\n__decorate([SceneFontChangeDetection(), __metadata(\"design:type\", String)], Text.prototype, \"fontFamily\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", String)], Text.prototype, \"textAlign\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", String)], Text.prototype, \"textBaseline\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Number)], Text.prototype, \"lineHeight\", void 0);\nfunction createTextMeasurer(font) {\n  const cache = new Map();\n  const getTextSize = text => HdpiCanvas.getTextSize(text, font);\n  const getLineWidth = text => {\n    if (cache.has(text)) {\n      return cache.get(text);\n    }\n    const {\n      width\n    } = getTextSize(text);\n    cache.set(text, width);\n    return width;\n  };\n  return {\n    size: getTextSize,\n    width: getLineWidth\n  };\n}\nfunction getFont(fontProps) {\n  const {\n    fontFamily,\n    fontSize,\n    fontStyle,\n    fontWeight\n  } = fontProps;\n  return [fontStyle !== null && fontStyle !== void 0 ? fontStyle : '', fontWeight !== null && fontWeight !== void 0 ? fontWeight : '', fontSize + 'px', fontFamily].join(' ').trim();\n}\nfunction measureText(lines, x, y, textProps) {\n  return HdpiCanvas.has.textMetrics ? getPreciseBBox(lines, x, y, textProps) : getApproximateBBox(lines, x, y, textProps);\n}\nfunction getPreciseBBox(lines, x, y, textProps) {\n  var _a, _b;\n  let left = 0;\n  let top = 0;\n  let width = 0;\n  let height = 0;\n  // Distance between first and last base lines.\n  let baselineDistance = 0;\n  const font = getFont(textProps);\n  const {\n    lineHeight,\n    textBaseline = Text.defaultStyles.textBaseline,\n    textAlign = Text.defaultStyles.textAlign\n  } = textProps;\n  for (let i = 0; i < lines.length; i++) {\n    const metrics = HdpiCanvas.measureText(lines[i], font, textBaseline, textAlign);\n    left = Math.max(left, metrics.actualBoundingBoxLeft);\n    width = Math.max(width, metrics.width);\n    if (i == 0) {\n      top += metrics.actualBoundingBoxAscent;\n      height += metrics.actualBoundingBoxAscent;\n    } else {\n      baselineDistance += (_a = metrics.fontBoundingBoxAscent) !== null && _a !== void 0 ? _a : metrics.emHeightAscent;\n    }\n    if (i == lines.length - 1) {\n      height += metrics.actualBoundingBoxDescent;\n    } else {\n      baselineDistance += (_b = metrics.fontBoundingBoxDescent) !== null && _b !== void 0 ? _b : metrics.emHeightDescent;\n    }\n  }\n  if (lineHeight !== undefined) {\n    baselineDistance = (lines.length - 1) * lineHeight;\n  }\n  height += baselineDistance;\n  top += baselineDistance * getVerticalOffset(textBaseline);\n  return new BBox(x - left, y - top, width, height);\n}\nfunction getApproximateBBox(lines, x, y, textProps) {\n  let width = 0;\n  let firstLineHeight = 0;\n  // Distance between first and last base lines.\n  let baselineDistance = 0;\n  const font = getFont(textProps);\n  const {\n    lineHeight,\n    textBaseline = Text.defaultStyles.textBaseline,\n    textAlign = Text.defaultStyles.textAlign\n  } = textProps;\n  if (lines.length > 0) {\n    const lineSize = HdpiCanvas.getTextSize(lines[0], font);\n    width = lineSize.width;\n    firstLineHeight = lineSize.height;\n  }\n  for (let i = 1; i < lines.length; i++) {\n    const lineSize = HdpiCanvas.getTextSize(lines[i], font);\n    width = Math.max(width, lineSize.width);\n    baselineDistance += lineHeight !== null && lineHeight !== void 0 ? lineHeight : lineSize.height;\n  }\n  switch (textAlign) {\n    case 'end':\n    case 'right':\n      x -= width;\n      break;\n    case 'center':\n      x -= width / 2;\n  }\n  switch (textBaseline) {\n    case 'alphabetic':\n      y -= firstLineHeight * 0.7 + baselineDistance * 0.5;\n      break;\n    case 'middle':\n      y -= firstLineHeight * 0.45 + baselineDistance * 0.5;\n      break;\n    case 'ideographic':\n      y -= firstLineHeight + baselineDistance;\n      break;\n    case 'hanging':\n      y -= firstLineHeight * 0.2 + baselineDistance * 0.5;\n      break;\n    case 'bottom':\n      y -= firstLineHeight + baselineDistance;\n      break;\n  }\n  return new BBox(x, y, width, firstLineHeight + baselineDistance);\n}\nfunction getVerticalOffset(textBaseline) {\n  switch (textBaseline) {\n    case 'top':\n    case 'hanging':\n      return 0;\n    case 'bottom':\n    case 'alphabetic':\n    case 'ideographic':\n      return 1;\n    case 'middle':\n      return 0.5;\n  }\n}\nfunction splitText(text) {\n  return typeof text === 'string' ? text.split(/\\r?\\n/g) : [];\n}\nfunction ProxyOnWrite(proxyProperty) {\n  return addTransformToInstanceProperty((target, _, value) => {\n    target[proxyProperty] = value;\n    return value;\n  });\n}\nfunction ProxyPropertyOnWrite(childName, childProperty) {\n  return addTransformToInstanceProperty((target, key, value) => {\n    target[childName][childProperty !== null && childProperty !== void 0 ? childProperty : key] = value;\n    return value;\n  });\n}\n/**\r\n * Allows side-effects to be triggered on property write.\r\n *\r\n * @param opts.newValue called when a new value is set - never called for undefined values.\r\n * @param opts.oldValue called with the old value before a new value is set - never called for\r\n *                      undefined values.\r\n * @param opts.changeValue called on any change to the value - always called.\r\n */\nfunction ActionOnSet(opts) {\n  const {\n    newValue: newValueFn,\n    oldValue: oldValueFn,\n    changeValue: changeValueFn\n  } = opts;\n  return addTransformToInstanceProperty((target, _, newValue, oldValue) => {\n    if (newValue !== oldValue) {\n      if (oldValue !== undefined) {\n        oldValueFn === null || oldValueFn === void 0 ? void 0 : oldValueFn.call(target, oldValue);\n      }\n      if (newValue !== undefined) {\n        newValueFn === null || newValueFn === void 0 ? void 0 : newValueFn.call(target, newValue);\n      }\n      changeValueFn === null || changeValueFn === void 0 ? void 0 : changeValueFn.call(target, newValue, oldValue);\n    }\n    return newValue;\n  });\n}\nclass Caption {\n  constructor() {\n    this.node = new Text();\n    this.enabled = false;\n    this.text = undefined;\n    this.fontSize = 10;\n    this.fontFamily = 'sans-serif';\n    this.maxWidth = undefined;\n    this.maxHeight = undefined;\n    this.wrapping = 'always';\n    const node = this.node;\n    node.textAlign = 'center';\n    node.pointerEvents = PointerEvents.None;\n  }\n  computeTextWrap(containerWidth, containerHeight) {\n    var _a, _b;\n    const {\n      text,\n      wrapping\n    } = this;\n    const maxWidth = Math.min((_a = this.maxWidth) !== null && _a !== void 0 ? _a : Infinity, containerWidth);\n    const maxHeight = (_b = this.maxHeight) !== null && _b !== void 0 ? _b : containerHeight;\n    if (!isFinite(maxWidth) && !isFinite(maxHeight)) {\n      this.node.text = text;\n      return;\n    }\n    const wrapped = Text.wrap(text !== null && text !== void 0 ? text : '', maxWidth, maxHeight, this, wrapping);\n    this.node.text = wrapped;\n  }\n}\nCaption.SMALL_PADDING = 10;\nCaption.LARGE_PADDING = 20;\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Object)], Caption.prototype, \"enabled\", void 0);\n__decorate([Validate(OPT_STRING), ProxyPropertyOnWrite('node'), __metadata(\"design:type\", String)], Caption.prototype, \"text\", void 0);\n__decorate([Validate(OPT_FONT_STYLE), ProxyPropertyOnWrite('node'), __metadata(\"design:type\", Object)], Caption.prototype, \"fontStyle\", void 0);\n__decorate([Validate(OPT_FONT_WEIGHT), ProxyPropertyOnWrite('node'), __metadata(\"design:type\", Object)], Caption.prototype, \"fontWeight\", void 0);\n__decorate([Validate(NUMBER$1(0)), ProxyPropertyOnWrite('node'), __metadata(\"design:type\", Number)], Caption.prototype, \"fontSize\", void 0);\n__decorate([Validate(STRING), ProxyPropertyOnWrite('node'), __metadata(\"design:type\", String)], Caption.prototype, \"fontFamily\", void 0);\n__decorate([Validate(OPT_COLOR_STRING), ProxyPropertyOnWrite('node', 'fill'), __metadata(\"design:type\", Object)], Caption.prototype, \"color\", void 0);\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], Caption.prototype, \"spacing\", void 0);\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], Caption.prototype, \"lineHeight\", void 0);\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], Caption.prototype, \"maxWidth\", void 0);\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], Caption.prototype, \"maxHeight\", void 0);\n__decorate([Validate(TEXT_WRAP), __metadata(\"design:type\", String)], Caption.prototype, \"wrapping\", void 0);\nclass AxisTitle {\n  constructor() {\n    this.enabled = false;\n    this.text = undefined;\n    this.spacing = Caption.SMALL_PADDING;\n    this.fontStyle = undefined;\n    this.fontWeight = undefined;\n    this.fontSize = 10;\n    this.fontFamily = 'sans-serif';\n    this.wrapping = 'always';\n    this.formatter = undefined;\n  }\n}\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Object)], AxisTitle.prototype, \"enabled\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], AxisTitle.prototype, \"text\", void 0);\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], AxisTitle.prototype, \"spacing\", void 0);\n__decorate([Validate(OPT_FONT_STYLE), __metadata(\"design:type\", String)], AxisTitle.prototype, \"fontStyle\", void 0);\n__decorate([Validate(OPT_FONT_WEIGHT), __metadata(\"design:type\", String)], AxisTitle.prototype, \"fontWeight\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], AxisTitle.prototype, \"fontSize\", void 0);\n__decorate([Validate(STRING), __metadata(\"design:type\", String)], AxisTitle.prototype, \"fontFamily\", void 0);\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], AxisTitle.prototype, \"color\", void 0);\n__decorate([Validate(TEXT_WRAP), __metadata(\"design:type\", String)], AxisTitle.prototype, \"wrapping\", void 0);\n__decorate([Validate(OPT_FUNCTION), __metadata(\"design:type\", Function)], AxisTitle.prototype, \"formatter\", void 0);\n\n/**\r\n * Zip two arrays into an object of keys and values, or an object of keys with a single value.\r\n */\nfunction zipObject(keys, values) {\n  const zipped = {};\n  if (Array.isArray(values)) {\n    for (let i = 0; i < keys.length; i++) {\n      zipped[`${keys[i]}`] = values[i];\n    }\n  } else {\n    for (let i = 0; i < keys.length; i++) {\n      zipped[`${keys[i]}`] = values;\n    }\n  }\n  return zipped;\n}\nfunction interpolateNumber(a, b) {\n  return d => Number(a) * (1 - d) + Number(b) * d;\n}\nfunction interpolateColor(a, b) {\n  if (typeof a === 'string') {\n    try {\n      a = Color.fromString(a);\n    } catch (e) {\n      a = Color.fromArray([0, 0, 0]);\n    }\n  }\n  if (typeof b === 'string') {\n    try {\n      b = Color.fromString(b);\n    } catch (e) {\n      b = Color.fromArray([0, 0, 0]);\n    }\n  }\n  const red = interpolateNumber(a.r, b.r);\n  const green = interpolateNumber(a.g, b.g);\n  const blue = interpolateNumber(a.b, b.b);\n  const alpha = interpolateNumber(a.a, b.a);\n  return d => Color.fromArray([red(d), green(d), blue(d), alpha(d)]).toRgbaString();\n}\nconst linear = n => n;\nconst easeIn = n => 1 - Math.cos(n * Math.PI / 2);\nconst easeOut = n => Math.sin(n * Math.PI / 2);\nconst easeInOut = n => -(Math.cos(n * Math.PI) - 1) / 2;\nconst easeInQuad = n => n * n;\nconst easeOutQuad = n => 1 - Math.pow(1 - n, 2);\nconst easeInOutQuad = n => n < 0.5 ? 2 * n * n : 1 - Math.pow(-2 * n + 2, 2) / 2;\nvar easing = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  linear: linear,\n  easeIn: easeIn,\n  easeOut: easeOut,\n  easeInOut: easeInOut,\n  easeInQuad: easeInQuad,\n  easeOutQuad: easeOutQuad,\n  easeInOutQuad: easeInOutQuad\n});\nconst QUICK_TRANSITION = 0.2;\nconst INITIAL_LOAD = {\n  animationDuration: 1,\n  animationDelay: 0\n};\nconst REMOVE_PHASE = {\n  animationDuration: 0.25,\n  animationDelay: 0\n};\nconst UPDATE_PHASE = {\n  animationDuration: 0.5,\n  animationDelay: 0.25\n};\nconst ADD_PHASE = {\n  animationDuration: 0.25,\n  animationDelay: 0.75\n};\nconst LABEL_PHASE = {\n  animationDuration: QUICK_TRANSITION,\n  animationDelay: 1\n};\nvar RepeatType;\n(function (RepeatType) {\n  RepeatType[\"Loop\"] = \"loop\";\n  RepeatType[\"Reverse\"] = \"reverse\";\n})(RepeatType || (RepeatType = {}));\nfunction isNodeArray(array) {\n  return array.every(n => n instanceof Node);\n}\nclass Animation {\n  constructor(opts) {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n    this.elapsed = 0;\n    this.iteration = 0;\n    this.isPlaying = false;\n    this.isReverse = false;\n    // animation configuration\n    this.id = opts.id;\n    this.groupId = opts.groupId;\n    this.autoplay = (_a = opts.autoplay) !== null && _a !== void 0 ? _a : true;\n    this.delay = (_b = opts.delay) !== null && _b !== void 0 ? _b : 0;\n    this.duration = (_c = opts.duration) !== null && _c !== void 0 ? _c : 1000;\n    this.ease = (_d = opts.ease) !== null && _d !== void 0 ? _d : linear;\n    this.repeat = (_e = opts.repeat) !== null && _e !== void 0 ? _e : 0;\n    this.repeatType = (_f = opts.repeatType) !== null && _f !== void 0 ? _f : RepeatType.Loop;\n    // user defined event listeners\n    this.onComplete = opts.onComplete;\n    this.onPlay = opts.onPlay;\n    this.onStop = opts.onStop;\n    this.onRepeat = opts.onRepeat;\n    this.onUpdate = opts.onUpdate;\n    // animation interpolator based on `from` & `to` types\n    this.interpolate = this.createInterpolator(opts.from, opts.to);\n    if (opts.skip === true) {\n      (_g = this.onUpdate) === null || _g === void 0 ? void 0 : _g.call(this, opts.to, false, this);\n      (_h = this.onStop) === null || _h === void 0 ? void 0 : _h.call(this, this);\n      (_j = this.onComplete) === null || _j === void 0 ? void 0 : _j.call(this, this);\n    } else if (this.autoplay) {\n      this.play();\n      // Initialise the animation immediately without requesting a frame to prevent flashes\n      (_k = this.onUpdate) === null || _k === void 0 ? void 0 : _k.call(this, opts.from, true, this);\n    }\n  }\n  play() {\n    var _a;\n    if (!this.isPlaying) {\n      this.isPlaying = true;\n      (_a = this.onPlay) === null || _a === void 0 ? void 0 : _a.call(this, this);\n    }\n    return this;\n  }\n  pause() {\n    if (this.isPlaying) {\n      this.isPlaying = false;\n    }\n    return this;\n  }\n  stop() {\n    var _a;\n    if (this.isPlaying) {\n      this.isPlaying = false;\n      (_a = this.onStop) === null || _a === void 0 ? void 0 : _a.call(this, this);\n    }\n    return this;\n  }\n  reset(opts) {\n    const deltaState = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);\n    this.interpolate = this.createInterpolator(deltaState, opts.to);\n    this.elapsed = 0;\n    this.iteration = 0;\n    if (typeof opts.delay === 'number') {\n      this.delay = opts.delay;\n    }\n    if (typeof opts.duration === 'number') {\n      this.duration = opts.duration;\n    }\n    if (typeof opts.ease === 'function') {\n      this.ease = opts.ease;\n    }\n    return this;\n  }\n  update(time) {\n    var _a, _b, _c;\n    this.elapsed += time;\n    if (this.elapsed <= this.delay) {\n      return this;\n    }\n    const value = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);\n    (_a = this.onUpdate) === null || _a === void 0 ? void 0 : _a.call(this, value, false, this);\n    if (this.elapsed - this.delay >= this.duration) {\n      if (this.iteration < this.repeat) {\n        this.iteration++;\n        this.elapsed = (this.elapsed - this.delay) % this.duration + this.delay;\n        if (this.repeatType === RepeatType.Reverse) {\n          this.isReverse = !this.isReverse;\n        }\n        (_b = this.onRepeat) === null || _b === void 0 ? void 0 : _b.call(this, this);\n      } else {\n        this.stop();\n        (_c = this.onComplete) === null || _c === void 0 ? void 0 : _c.call(this, this);\n      }\n    }\n    return this;\n  }\n  get delta() {\n    return this.ease(clamp(0, (this.elapsed - this.delay) / this.duration, 1));\n  }\n  createInterpolator(from, to) {\n    if (typeof to !== 'object') {\n      return this.interpolateValue(from, to);\n    }\n    const interpolatorEntries = Object.keys(to).map(key => [key, this.interpolateValue(from[key], to[key])]);\n    return d => {\n      const result = {};\n      for (const [key, interpolator] of interpolatorEntries) {\n        result[key] = interpolator(d);\n      }\n      return result;\n    };\n  }\n  interpolateValue(a, b) {\n    try {\n      switch (typeof a) {\n        case 'number':\n          return interpolateNumber(a, b);\n        case 'string':\n          return interpolateColor(a, b);\n      }\n    } catch (e) {\n      // Error-case handled below.\n    }\n    throw new Error(`Unable to interpolate values: ${a}, ${b}`);\n  }\n}\nconst NODE_UPDATE_PHASES = ['removed', 'updated', 'added'];\nconst FROM_TO_MIXINS = {\n  added: ADD_PHASE,\n  updated: UPDATE_PHASE,\n  removed: REMOVE_PHASE,\n  unknown: INITIAL_LOAD\n};\n/**\r\n * Implements a per-node \"to/from\" animation, with support for detection of added/moved/removed\r\n * nodes.\r\n *\r\n * @param id prefix for all animation ids generated by this call\r\n * @param animationManager used to schedule generated animations\r\n * @param selections contains nodes to be animated\r\n * @param fromFn callback to determine per-node starting properties\r\n * @param toFn callback to determine per-node final properties\r\n * @param extraOpts optional additional animation properties to pass to AnimationManager#animate.\r\n * @param getDatumId optional per-datum 'id' generation function for diff calculation - must be\r\n *                   specified iff diff is specified\r\n * @param diff optional diff from a DataModel to use to detect added/moved/removed cases\r\n */\nfunction fromToMotion(groupId, subId, animationManager, selectionsOrNodes, fns, getDatumId, diff) {\n  const {\n    defaultDuration\n  } = animationManager;\n  const {\n    fromFn,\n    toFn,\n    intermediateFn\n  } = fns;\n  const isNodes = isNodeArray(selectionsOrNodes);\n  const nodes = isNodes ? selectionsOrNodes : [];\n  const selections = !isNodes ? selectionsOrNodes : [];\n  // Dynamic case with varying add/update/remove behavior.\n  const ids = {\n    added: {},\n    removed: {}\n  };\n  if (getDatumId && diff) {\n    ids.added = zipObject(diff.added, true);\n    ids.removed = zipObject(diff.removed, true);\n  }\n  const processNodes = (liveNodes, nodes) => {\n    var _a, _b;\n    let prevFromProps;\n    let liveNodeIndex = 0;\n    let nodeIndex = 0;\n    for (const node of nodes) {\n      const isLive = liveNodes[liveNodeIndex] === node;\n      const ctx = {\n        last: nodeIndex >= nodes.length - 1,\n        lastLive: liveNodeIndex >= liveNodes.length - 1,\n        prev: nodes[nodeIndex - 1],\n        prevFromProps,\n        prevLive: liveNodes[liveNodeIndex - 1],\n        next: nodes[nodeIndex + 1],\n        nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)]\n      };\n      const animationId = `${groupId}_${subId}_${node.id}`;\n      animationManager.stopByAnimationId(animationId);\n      let status = 'unknown';\n      if (!isLive) {\n        status = 'removed';\n      } else if (getDatumId && diff) {\n        status = calculateStatus(node, node.datum, getDatumId, ids);\n      }\n      const _c = fromFn(node, node.datum, status, ctx),\n        {\n          animationDelay: delay,\n          animationDuration: duration,\n          start = {},\n          finish = {}\n        } = _c,\n        from = __rest(_c, [\"animationDelay\", \"animationDuration\", \"start\", \"finish\"]);\n      const _d = toFn(node, node.datum, status, ctx),\n        {\n          animationDelay: toDelay,\n          animationDuration: toDuration,\n          start: toStart = {},\n          finish: toFinish = {}\n        } = _d,\n        to = __rest(_d, [\"animationDelay\", \"animationDuration\", \"start\", \"finish\"]);\n      animationManager.animate({\n        id: animationId,\n        groupId,\n        from: from,\n        to: to,\n        ease: easeOut,\n        onPlay: () => {\n          node.setProperties(Object.assign(Object.assign({}, start), toStart));\n        },\n        onUpdate(props) {\n          node.setProperties(props);\n          if (intermediateFn) {\n            node.setProperties(intermediateFn(node, node.datum, status, ctx));\n          }\n        },\n        onStop: () => {\n          node.setProperties(Object.assign(Object.assign(Object.assign({}, to), finish), toFinish));\n        },\n        duration: ((_a = duration !== null && duration !== void 0 ? duration : toDuration) !== null && _a !== void 0 ? _a : 1) * defaultDuration,\n        delay: ((_b = delay !== null && delay !== void 0 ? delay : toDelay) !== null && _b !== void 0 ? _b : 0) * defaultDuration\n      });\n      if (isLive) {\n        liveNodeIndex++;\n      }\n      nodeIndex++;\n      prevFromProps = from;\n    }\n  };\n  let selectionIndex = 0;\n  for (const selection of selections) {\n    const nodes = selection.nodes();\n    const liveNodes = nodes.filter(n => !selection.isGarbage(n));\n    processNodes(liveNodes, nodes);\n    // Only perform selection cleanup once.\n    animationManager.animate({\n      id: `${groupId}_${subId}_selection_${selectionIndex}`,\n      groupId,\n      from: 0,\n      to: 1,\n      ease: easeOut,\n      onStop() {\n        selection.cleanup();\n      }\n    });\n    selectionIndex++;\n  }\n  processNodes(nodes, nodes);\n}\n/**\r\n * Implements a batch \"to/from\" animation.\r\n *\r\n * @param id prefix for all animation ids generated by this call\r\n * @param animationManager used to schedule generated animations\r\n * @param selectionsOrNodes contains nodes to be animated\r\n * @param from node starting properties\r\n * @param to node final properties\r\n * @param extraOpts optional additional animation properties to pass to AnimationManager#animate.\r\n */\nfunction staticFromToMotion(groupId, subId, animationManager, selectionsOrNodes, from, to, extraOpts = {}) {\n  const isNodes = isNodeArray(selectionsOrNodes);\n  const nodes = isNodes ? selectionsOrNodes : [];\n  const selections = !isNodes ? selectionsOrNodes : [];\n  const {\n    animationDelay = 0,\n    animationDuration = 1,\n    start = {},\n    finish = {}\n  } = extraOpts;\n  const {\n    defaultDuration\n  } = animationManager;\n  // Simple static to/from case, we can batch updates.\n  animationManager.animate({\n    id: `${groupId}_${subId}`,\n    groupId,\n    from,\n    to,\n    ease: easeOut,\n    onPlay: () => {\n      for (const node of nodes) {\n        node.setProperties(start);\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties(start);\n        }\n      }\n    },\n    onUpdate(props) {\n      for (const node of nodes) {\n        node.setProperties(props);\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties(props);\n        }\n      }\n    },\n    onStop: () => {\n      for (const node of nodes) {\n        node.setProperties(Object.assign(Object.assign({}, to), finish));\n      }\n      for (const selection of selections) {\n        for (const node of selection.nodes()) {\n          node.setProperties(Object.assign(Object.assign({}, to), finish));\n        }\n      }\n    },\n    duration: animationDuration * defaultDuration,\n    delay: animationDelay * defaultDuration\n  });\n}\nfunction calculateStatus(node, datum, getDatumId, ids) {\n  const id = getDatumId(node, datum);\n  if (ids.added[id]) {\n    return 'added';\n  } else if (ids.removed[id]) {\n    return 'removed';\n  }\n  return 'updated';\n}\nvar fromToMotion$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  NODE_UPDATE_PHASES: NODE_UPDATE_PHASES,\n  FROM_TO_MIXINS: FROM_TO_MIXINS,\n  fromToMotion: fromToMotion,\n  staticFromToMotion: staticFromToMotion\n});\nconst group = content => `(${content})`;\nconst optionalGroup = content => `${group(content)}?`;\nconst nonCapturingGroup = content => optionalGroup(`?:${content}`);\nconst formatRegEx = (() => {\n  const fill = '.';\n  const align = '[<>=^]';\n  const sign = '[+\\\\-( ]';\n  const symbol = '[$€£¥₣₹#]';\n  const zero = '0';\n  const width = '\\\\d+';\n  const comma = ',';\n  const precision = '\\\\d+';\n  const tilde = '~';\n  const type = '[%a-z]';\n  return new RegExp(['^', nonCapturingGroup(`${optionalGroup(fill)}${group(align)}`), optionalGroup(sign), optionalGroup(symbol), optionalGroup(zero), optionalGroup(width), optionalGroup(comma), nonCapturingGroup(`\\\\.${group(precision)}`), optionalGroup(tilde), optionalGroup(type), '$'].join(''), 'i');\n})();\nconst surroundedRegEx = (() => {\n  const prefix = '.*?';\n  const content = '.+?';\n  const suffix = '.*?';\n  return new RegExp(['^', group(prefix), `#\\\\{${group(content)}\\\\}`, group(suffix), '$'].join(''));\n})();\nfunction parseFormatter(formatter) {\n  let prefix;\n  let suffix;\n  const surrounded = surroundedRegEx.exec(formatter);\n  if (surrounded) {\n    [, prefix, formatter, suffix] = surrounded;\n  }\n  const match = formatRegEx.exec(formatter);\n  if (!match) {\n    throw new Error(`The number formatter is invalid: ${formatter}`);\n  }\n  const [, fill, align, sign, symbol, zero, width, comma, precision, trim, type] = match;\n  return {\n    fill,\n    align,\n    sign,\n    symbol,\n    zero,\n    width: parseInt(width),\n    comma,\n    precision: parseInt(precision),\n    trim: Boolean(trim),\n    type,\n    prefix,\n    suffix\n  };\n}\nfunction format(formatter) {\n  const options = typeof formatter === 'string' ? parseFormatter(formatter) : formatter;\n  const {\n    fill,\n    align,\n    sign = '-',\n    symbol,\n    zero,\n    width,\n    comma,\n    type,\n    prefix = '',\n    suffix = '',\n    precision\n  } = options;\n  let {\n    trim\n  } = options;\n  const precisionIsNaN = precision === undefined || isNaN(precision);\n  let formatBody;\n  if (!type) {\n    formatBody = decimalTypes['g'];\n    trim = true;\n  } else if (type in decimalTypes && type in integerTypes) {\n    formatBody = precisionIsNaN ? integerTypes[type] : decimalTypes[type];\n  } else if (type in decimalTypes) {\n    formatBody = decimalTypes[type];\n  } else if (type in integerTypes) {\n    formatBody = integerTypes[type];\n  } else {\n    throw new Error(`The number formatter type is invalid: ${type}`);\n  }\n  let formatterPrecision;\n  if (precision == null || precisionIsNaN) {\n    formatterPrecision = type ? 6 : 12;\n  } else {\n    formatterPrecision = precision;\n  }\n  return n => {\n    let result = formatBody(n, formatterPrecision);\n    if (trim) {\n      result = removeTrailingZeros(result);\n    }\n    if (comma) {\n      result = insertSeparator(result, comma);\n    }\n    result = addSign(n, result, sign);\n    if (symbol && symbol !== '#') {\n      result = `${symbol}${result}`;\n    }\n    if (symbol === '#' && type === 'x') {\n      result = `0x${result}`;\n    }\n    if (type === 's') {\n      result = `${result}${getSIPrefix(n)}`;\n    }\n    if (type === '%' || type === 'p') {\n      result = `${result}%`;\n    }\n    if (width != null && !isNaN(width)) {\n      result = addPadding(result, width, fill !== null && fill !== void 0 ? fill : zero, align);\n    }\n    result = `${prefix}${result}${suffix}`;\n    return result;\n  };\n}\nconst absFloor = n => Math.floor(Math.abs(n));\nconst integerTypes = {\n  b: n => absFloor(n).toString(2),\n  c: n => String.fromCharCode(n),\n  d: n => Math.round(Math.abs(n)).toFixed(0),\n  o: n => absFloor(n).toString(8),\n  x: n => absFloor(n).toString(16),\n  X: n => integerTypes.x(n).toUpperCase(),\n  n: n => integerTypes.d(n),\n  '%': n => `${absFloor(n * 100).toFixed(0)}`\n};\nconst decimalTypes = {\n  e: (n, f) => Math.abs(n).toExponential(f),\n  E: (n, f) => decimalTypes.e(n, f).toUpperCase(),\n  f: (n, f) => Math.abs(n).toFixed(f),\n  F: (n, f) => decimalTypes.f(n, f).toUpperCase(),\n  g: (n, f) => {\n    if (n === 0) {\n      return '0';\n    }\n    const a = Math.abs(n);\n    const p = Math.floor(Math.log10(a));\n    if (p >= -4 && p < f) {\n      return a.toFixed(f - 1 - p);\n    }\n    return a.toExponential(f - 1);\n  },\n  G: (n, f) => decimalTypes.g(n, f).toUpperCase(),\n  n: (n, f) => decimalTypes.g(n, f),\n  p: (n, f) => decimalTypes.r(n * 100, f),\n  r: (n, f) => {\n    if (n === 0) {\n      return '0';\n    }\n    const a = Math.abs(n);\n    const p = Math.floor(Math.log10(a));\n    const q = p - (f - 1);\n    if (q <= 0) {\n      return a.toFixed(-q);\n    }\n    const x = Math.pow(10, q);\n    return (Math.round(a / x) * x).toFixed();\n  },\n  s: (n, f) => {\n    const p = getSIPrefixPower(n);\n    return decimalTypes.r(n / Math.pow(10, p), f);\n  },\n  '%': (n, f) => decimalTypes.f(n * 100, f)\n};\nfunction removeTrailingZeros(numString) {\n  return numString.replace(/\\.0+$/, '').replace(/(\\.[1-9])0+$/, '$1');\n}\nfunction insertSeparator(numString, separator) {\n  let dotIndex = numString.indexOf('.');\n  if (dotIndex < 0) {\n    dotIndex = numString.length;\n  }\n  const integerChars = numString.substring(0, dotIndex).split('');\n  const fractionalPart = numString.substring(dotIndex);\n  for (let i = integerChars.length - 3; i > 0; i -= 3) {\n    integerChars.splice(i, 0, separator);\n  }\n  return `${integerChars.join('')}${fractionalPart}`;\n}\nfunction getSIPrefix(n) {\n  return siPrefixes[getSIPrefixPower(n)];\n}\nfunction getSIPrefixPower(n) {\n  const power = Math.log10(Math.abs(n));\n  const p = Math.floor(power / 3) * 3;\n  return Math.max(minSIPrefix, Math.min(maxSIPrefix, p));\n}\nconst minSIPrefix = -24;\nconst maxSIPrefix = 24;\nconst siPrefixes = {\n  [minSIPrefix]: 'y',\n  [-21]: 'z',\n  [-18]: 'a',\n  [-15]: 'f',\n  [-12]: 'p',\n  [-9]: 'n',\n  [-6]: 'µ',\n  [-3]: 'm',\n  [0]: '',\n  [3]: 'k',\n  [6]: 'M',\n  [9]: 'G',\n  [12]: 'T',\n  [15]: 'P',\n  [18]: 'E',\n  [21]: 'Z',\n  [maxSIPrefix]: 'Y'\n};\nconst minusSign = '\\u2212';\nfunction addSign(num, numString, signType = '') {\n  if (signType === '(') {\n    return num >= 0 ? numString : `(${numString})`;\n  }\n  const plusSign = signType === '+' ? '+' : '';\n  return `${num >= 0 ? plusSign : minusSign}${numString}`;\n}\nfunction addPadding(numString, width, fill = ' ', align = '>') {\n  let result = numString;\n  if (align === '>' || !align) {\n    result = result.padStart(width, fill);\n  } else if (align === '<') {\n    result = result.padEnd(width, fill);\n  } else if (align === '^') {\n    const padWidth = Math.max(0, width - result.length);\n    const padLeft = Math.ceil(padWidth / 2);\n    const padRight = Math.floor(padWidth / 2);\n    result = result.padStart(padLeft + result.length, fill);\n    result = result.padEnd(padRight + result.length, fill);\n  }\n  return result;\n}\nfunction tickFormat(ticks, formatter) {\n  const options = parseFormatter(formatter !== null && formatter !== void 0 ? formatter : ',f');\n  const {\n    precision\n  } = options;\n  if (precision == null || isNaN(precision)) {\n    if (options.type === 'f' || options.type === '%') {\n      options.precision = Math.max(...ticks.map(x => {\n        if (typeof x !== 'number' || x === 0) {\n          return 0;\n        }\n        const l = Math.floor(Math.log10(Math.abs(x)));\n        const digits = options.type ? 6 : 12;\n        const exp = x.toExponential(digits - 1).replace(/\\.?0+e/, 'e');\n        const dotIndex = exp.indexOf('.');\n        if (dotIndex < 0) {\n          return l >= 0 ? 0 : -l;\n        }\n        const s = exp.indexOf('e') - dotIndex;\n        return Math.max(0, s - l - 1);\n      }));\n    } else if (!options.type || options.type in decimalTypes) {\n      options.precision = Math.max(...ticks.map(x => {\n        if (typeof x !== 'number') {\n          return 0;\n        }\n        const exp = x.toExponential((options.type ? 6 : 12) - 1).replace(/\\.?0+e/, 'e');\n        return exp.substring(0, exp.indexOf('e')).replace('.', '').length;\n      }));\n    }\n  }\n  const f = format(options);\n  return n => f(Number(n));\n}\nfunction ticks(start, stop, count, minCount, maxCount) {\n  if (count < 2) {\n    return range$1(start, stop, stop - start);\n  }\n  const step = tickStep(start, stop, count, minCount, maxCount);\n  if (isNaN(step)) {\n    return new NumericTicks(0);\n  }\n  start = Math.ceil(start / step) * step;\n  stop = Math.floor(stop / step) * step;\n  return range$1(start, stop, step);\n}\nconst tickMultipliers = [1, 2, 5, 10];\nfunction tickStep(a, b, count, minCount = 0, maxCount = Infinity) {\n  const rawStep = (b - a) / count;\n  const power = Math.floor(Math.log10(rawStep));\n  const step = Math.pow(10, power);\n  const m = tickMultipliers.map(multiplier => {\n    const s = multiplier * step;\n    const c = Math.ceil((b - a) / s);\n    const isWithinBounds = c >= minCount && c <= maxCount;\n    const diffCount = Math.abs(c - count);\n    return {\n      multiplier,\n      isWithinBounds,\n      diffCount\n    };\n  }).sort((a, b) => {\n    if (a.isWithinBounds !== b.isWithinBounds) {\n      return a.isWithinBounds ? -1 : 1;\n    }\n    return a.diffCount - b.diffCount;\n  })[0].multiplier;\n  if (!m || isNaN(m)) {\n    return NaN;\n  }\n  return m * step;\n}\nfunction singleTickDomain(a, b) {\n  const power = Math.floor(Math.log10(b - a));\n  const step = Math.pow(10, power);\n  return tickMultipliers.map(multiplier => {\n    const s = multiplier * step;\n    const start = Math.floor(a / s) * s;\n    const end = Math.ceil(b / s) * s;\n    const error = 1 - (b - a) / (end - start);\n    const domain = [start, end];\n    return {\n      error,\n      domain\n    };\n  }).sort((a, b) => a.error - b.error)[0].domain;\n}\nclass NumericTicks extends Array {\n  constructor(fractionDigits, elements) {\n    super();\n    if (elements) {\n      for (let i = 0, n = elements.length; i < n; i++) {\n        this[i] = elements[i];\n      }\n    }\n    this.fractionDigits = fractionDigits;\n  }\n}\nfunction range$1(start, stop, step) {\n  const countDigits = expNo => {\n    var _a, _b;\n    const parts = expNo.split('e');\n    return Math.max(((_b = (_a = parts[0].split('.')[1]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) - Number(parts[1]), 0);\n  };\n  const fractionalDigits = countDigits((step % 1).toExponential());\n  const f = Math.pow(10, fractionalDigits);\n  const n = Math.ceil((stop - start) / step);\n  const values = new NumericTicks(fractionalDigits);\n  for (let i = 0; i <= n; i++) {\n    const value = start + step * i;\n    values.push(Math.round(value * f) / f);\n  }\n  return values;\n}\nclass ContinuousScale {\n  static is(value) {\n    return value instanceof ContinuousScale;\n  }\n  constructor(domain, range) {\n    this.domain = domain;\n    this.range = range;\n    this.nice = false;\n    this.tickCount = ContinuousScale.defaultTickCount;\n    this.minTickCount = 0;\n    this.maxTickCount = Infinity;\n    this.niceDomain = [];\n    this.defaultClampMode = 'raw';\n    this.cache = null;\n    this.cacheProps = ['domain', 'range', 'nice', 'tickCount', 'minTickCount', 'maxTickCount'];\n  }\n  transform(x) {\n    return x;\n  }\n  transformInvert(x) {\n    return x;\n  }\n  calcBandwidth(smallestInterval = 1) {\n    const domain = this.getDomain();\n    const maxRange = Math.max(...this.range);\n    const intervals = (domain[1] - domain[0]) / smallestInterval + 1;\n    // The number of intervals/bands is used to determine the width of individual bands by dividing the available range.\n    // Allow a maximum number of bands to ensure the step does not fall below 1 pixel.\n    // This means there could be some overlap of the bands in the chart.\n    const maxBands = Math.floor(maxRange); // A minimum of 1px per bar/column means the maximum number of bands will equal the available range\n    const bands = Math.min(intervals, maxBands);\n    return maxRange / Math.max(1, bands);\n  }\n  fromDomain(d) {\n    if (typeof d === 'number') {\n      return d;\n    } else if (d instanceof Date) {\n      return d.getTime();\n    }\n    return NaN;\n  }\n  getDomain() {\n    if (this.nice) {\n      this.refresh();\n      if (this.niceDomain.length) {\n        return this.niceDomain;\n      }\n    }\n    return this.domain;\n  }\n  convert(x, opts) {\n    var _a;\n    const clampMode = (_a = opts === null || opts === void 0 ? void 0 : opts.clampMode) !== null && _a !== void 0 ? _a : this.defaultClampMode;\n    if (!this.domain || this.domain.length < 2) {\n      return NaN;\n    }\n    this.refresh();\n    const domain = this.getDomain().map(d => this.transform(d));\n    const [d0, d1] = domain;\n    const {\n      range\n    } = this;\n    const [r0, r1] = range;\n    x = this.transform(x);\n    if (clampMode === 'clamped') {\n      if (x < d0) {\n        return r0;\n      } else if (x > d1) {\n        return r1;\n      }\n    }\n    if (d0 === d1) {\n      return (r0 + r1) / 2;\n    } else if (x === d0) {\n      return r0;\n    } else if (x === d1) {\n      return r1;\n    }\n    return r0 + (this.fromDomain(x) - this.fromDomain(d0)) / (this.fromDomain(d1) - this.fromDomain(d0)) * (r1 - r0);\n  }\n  invert(x) {\n    this.refresh();\n    const domain = this.getDomain().map(d => this.transform(d));\n    const [d0, d1] = domain;\n    const {\n      range\n    } = this;\n    const [r0, r1] = range;\n    const isReversed = r0 > r1;\n    const rMin = isReversed ? r1 : r0;\n    const rMax = isReversed ? r0 : r1;\n    let d;\n    if (x < rMin) {\n      return isReversed ? d1 : d0;\n    } else if (x > rMax) {\n      return isReversed ? d0 : d1;\n    } else if (r0 === r1) {\n      d = this.toDomain((this.fromDomain(d0) + this.fromDomain(d1)) / 2);\n    } else {\n      d = this.toDomain(this.fromDomain(d0) + (x - r0) / (r1 - r0) * (this.fromDomain(d1) - this.fromDomain(d0)));\n    }\n    return this.transformInvert(d);\n  }\n  didChange() {\n    const {\n      cache\n    } = this;\n    const didChange = !cache || this.cacheProps.some(p => this[p] !== cache[p]);\n    if (didChange) {\n      this.cache = {};\n      this.cacheProps.forEach(p => this.cache[p] = this[p]);\n      return true;\n    }\n    return false;\n  }\n  refresh() {\n    if (this.didChange()) {\n      this.update();\n    }\n  }\n  getPixelRange() {\n    const range = this.range.slice().sort((a, b) => a - b);\n    return range[1] - range[0];\n  }\n  isDenseInterval({\n    start,\n    stop,\n    interval,\n    count\n  }) {\n    const domain = stop - start;\n    const availableRange = this.getPixelRange();\n    const step = typeof interval === 'number' ? interval : 1;\n    count !== null && count !== void 0 ? count : count = domain / step;\n    if (count >= availableRange) {\n      Logger.warn(`the configured tick interval results in more than 1 tick per pixel, ignoring. Supply a larger tick interval or omit this configuration.`);\n      return true;\n    }\n    return false;\n  }\n}\nContinuousScale.defaultTickCount = 5;\nContinuousScale.defaultMaxTickCount = 6;\n\n/**\r\n * Maps continuous domain to a continuous range.\r\n */\nclass LinearScale extends ContinuousScale {\n  constructor() {\n    super([0, 1], [0, 1]);\n    this.type = 'linear';\n  }\n  toDomain(d) {\n    return d;\n  }\n  ticks() {\n    var _a;\n    const count = (_a = this.tickCount) !== null && _a !== void 0 ? _a : ContinuousScale.defaultTickCount;\n    if (!this.domain || this.domain.length < 2 || count < 1 || this.domain.some(d => !isFinite(d))) {\n      return [];\n    }\n    this.refresh();\n    const [d0, d1] = this.getDomain();\n    const {\n      interval\n    } = this;\n    if (interval) {\n      const step = Math.abs(interval);\n      if (!this.isDenseInterval({\n        start: d0,\n        stop: d1,\n        interval: step\n      })) {\n        return range$1(d0, d1, step);\n      }\n    }\n    return ticks(d0, d1, count, this.minTickCount, this.maxTickCount);\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  getTickStep(start, stop) {\n    var _a, _b;\n    const count = (_a = this.tickCount) !== null && _a !== void 0 ? _a : ContinuousScale.defaultTickCount;\n    return (_b = this.interval) !== null && _b !== void 0 ? _b : tickStep(start, stop, count, this.minTickCount, this.maxTickCount);\n  }\n  /**\r\n   * Extends the domain so that it starts and ends on nice round values.\r\n   */\n  updateNiceDomain() {\n    var _a;\n    const count = (_a = this.tickCount) !== null && _a !== void 0 ? _a : ContinuousScale.defaultTickCount;\n    let [start, stop] = this.domain;\n    if (count < 1) {\n      this.niceDomain = [start, stop];\n      return;\n    }\n    if (count === 1) {\n      this.niceDomain = singleTickDomain(start, stop);\n      return;\n    }\n    const maxAttempts = 4;\n    let prev0 = start;\n    let prev1 = stop;\n    for (let i = 0; i < maxAttempts; i++) {\n      const step = this.getTickStep(start, stop);\n      const [d0, d1] = this.domain;\n      if (step >= 1) {\n        start = Math.floor(d0 / step) * step;\n        stop = Math.ceil(d1 / step) * step;\n      } else {\n        // Prevent floating point error\n        const s = 1 / step;\n        start = Math.floor(d0 * s) / s;\n        stop = Math.ceil(d1 * s) / s;\n      }\n      if (start === prev0 && stop === prev1) {\n        break;\n      }\n      prev0 = start;\n      prev1 = stop;\n    }\n    this.niceDomain = [start, stop];\n  }\n  tickFormat({\n    ticks,\n    specifier\n  }) {\n    return tickFormat(ticks !== null && ticks !== void 0 ? ticks : this.ticks(), specifier);\n  }\n}\nfunction ascendingStringNumberUndefined(a, b) {\n  let diff = 0;\n  if (typeof a === 'number' && typeof b === 'number') {\n    diff = a - b;\n  } else if (typeof a === 'string' && typeof b === 'string') {\n    diff = a.localeCompare(b);\n  } else if (a == null && b == null) ;else if (a == null) {\n    diff = -1;\n  } else if (b == null) {\n    diff = 1;\n  } else {\n    diff = String(a).localeCompare(String(b));\n  }\n  return diff;\n}\nfunction compoundAscending(a, b, comparator) {\n  const toLiteral = v => {\n    if (typeof v === 'function') {\n      return v();\n    }\n    return v;\n  };\n  for (const idx in a) {\n    const diff = comparator(toLiteral(a[idx]), toLiteral(b[idx]));\n    if (diff !== 0) {\n      return diff;\n    }\n  }\n  return 0;\n}\nclass Group extends Node {\n  zIndexChanged() {\n    var _a;\n    if (this.layer) {\n      (_a = this._layerManager) === null || _a === void 0 ? void 0 : _a.moveLayer(this.layer, this.zIndex, this.zIndexSubOrder);\n    }\n  }\n  isLayer() {\n    return this.layer != null;\n  }\n  constructor(opts) {\n    var _a;\n    super({\n      isVirtual: opts === null || opts === void 0 ? void 0 : opts.isVirtual\n    });\n    this.opts = opts;\n    this.opacity = 1;\n    this.lastBBox = undefined;\n    const {\n      zIndex,\n      zIndexSubOrder\n    } = opts !== null && opts !== void 0 ? opts : {};\n    this.isContainerNode = true;\n    if (zIndex !== undefined) {\n      this.zIndex = zIndex;\n    }\n    if (zIndexSubOrder !== undefined) {\n      this.zIndexSubOrder = zIndexSubOrder;\n    }\n    this.name = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.name;\n  }\n  _setLayerManager(scene) {\n    var _a, _b;\n    if (this._layerManager && this.layer) {\n      this._layerManager.removeLayer(this.layer);\n      this.layer = undefined;\n    }\n    if (this.layer) {\n      throw new Error('AG Charts - unable to deregister scene rendering layer!');\n    }\n    super._setLayerManager(scene);\n    if (scene && ((_a = this.opts) === null || _a === void 0 ? void 0 : _a.layer)) {\n      const {\n        zIndex,\n        zIndexSubOrder,\n        name\n      } = (_b = this.opts) !== null && _b !== void 0 ? _b : {};\n      const getComputedOpacity = () => this.getComputedOpacity();\n      const getVisibility = () => this.getVisibility();\n      this.layer = scene.addLayer({\n        zIndex,\n        zIndexSubOrder,\n        name,\n        getComputedOpacity,\n        getVisibility\n      });\n    }\n  }\n  getComputedOpacity() {\n    let opacity = 1;\n    let node = this;\n    do {\n      if (node instanceof Group) {\n        opacity *= node.opacity;\n      }\n    } while (node = node.parent);\n    return opacity;\n  }\n  getVisibility() {\n    let node = this;\n    let visible = this.visible;\n    while (node = node.parent) {\n      if (node.visible) {\n        continue;\n      }\n      visible = node.visible;\n    }\n    return visible;\n  }\n  visibilityChanged() {\n    if (this.layer) {\n      this.layer.enabled = this.visible;\n    }\n  }\n  markDirty(source, type = RedrawType.TRIVIAL) {\n    if (this.isVirtual) {\n      // Always percolate directly for virtual nodes - they don't exist for rendering purposes.\n      super.markDirty(source, type);\n      return;\n    }\n    // Downgrade dirty-ness percolated to parent in special cases.\n    let parentType = type;\n    if (type < RedrawType.MINOR || this.layer != null) {\n      parentType = RedrawType.TRIVIAL;\n    }\n    super.markDirty(source, type, parentType);\n  }\n  // We consider a group to be boundless, thus any point belongs to it.\n  containsPoint(_x, _y) {\n    return true;\n  }\n  computeBBox() {\n    this.computeTransformMatrix();\n    return Group.computeBBox(this.children);\n  }\n  computeTransformedBBox() {\n    return this.computeBBox();\n  }\n  render(renderCtx) {\n    var _a, _b;\n    const {\n      opts: {\n        name = undefined\n      } = {},\n      _debug: debug = () => {}\n    } = this;\n    const {\n      dirty,\n      dirtyZIndex,\n      layer,\n      children,\n      clipRect,\n      dirtyTransform\n    } = this;\n    let {\n      ctx,\n      forceRender,\n      clipBBox\n    } = renderCtx;\n    const {\n      resized,\n      stats\n    } = renderCtx;\n    const canvasCtxTransform = ctx.getTransform();\n    const isDirty = dirty >= RedrawType.MINOR || dirtyZIndex || resized;\n    let isChildDirty = isDirty;\n    let isChildLayerDirty = false;\n    for (const child of children) {\n      isChildDirty || (isChildDirty = child.layerManager == null && child.dirty >= RedrawType.TRIVIAL);\n      isChildLayerDirty || (isChildLayerDirty = child.layerManager != null && child.dirty >= RedrawType.TRIVIAL);\n      if (isChildDirty) {\n        break;\n      }\n    }\n    if (name) {\n      debug({\n        name,\n        group: this,\n        isDirty,\n        isChildDirty,\n        dirtyTransform,\n        renderCtx,\n        forceRender\n      });\n    }\n    if (dirtyTransform) {\n      forceRender = 'dirtyTransform';\n    } else if (layer) {\n      // If bounding-box of a layer changes, force re-render.\n      const currentBBox = this.computeBBox();\n      if (this.lastBBox === undefined || !this.lastBBox.equals(currentBBox)) {\n        forceRender = 'dirtyTransform';\n        this.lastBBox = currentBBox;\n      }\n    }\n    if (!isDirty && !isChildDirty && !isChildLayerDirty && !forceRender) {\n      if (name && stats) {\n        debug({\n          name,\n          result: 'skipping',\n          renderCtx,\n          counts: this.nodeCount,\n          group: this\n        });\n      }\n      if (layer && stats) {\n        stats.layersSkipped++;\n        stats.nodesSkipped += this.nodeCount.count;\n      }\n      this.markClean({\n        recursive: false\n      });\n      // Nothing to do.\n      return;\n    }\n    const groupVisible = this.visible;\n    if (layer) {\n      // Switch context to the canvas layer we use for this group.\n      ctx = layer.context;\n      ctx.save();\n      ctx.resetTransform();\n      if (forceRender !== 'dirtyTransform') {\n        forceRender = isChildDirty || dirtyZIndex;\n      }\n      if (forceRender) layer.clear();\n      if (clipBBox) {\n        // clipBBox is in the canvas coordinate space, when we hit a layer we apply the new clipping at which point there are no transforms in play\n        const {\n          width,\n          height,\n          x,\n          y\n        } = clipBBox;\n        debug(() => ({\n          name,\n          clipBBox,\n          ctxTransform: ctx.getTransform(),\n          renderCtx,\n          group: this\n        }));\n        this.clipCtx(ctx, x, y, width, height);\n      }\n      ctx.setTransform(canvasCtxTransform);\n    } else {\n      // Only apply opacity if this isn't a distinct layer - opacity will be applied\n      // at composition time.\n      ctx.globalAlpha *= this.opacity;\n    }\n    // A group can have `scaling`, `rotation`, `translation` properties\n    // that are applied to the canvas context before children are rendered,\n    // so all children can be transformed at once.\n    this.computeTransformMatrix();\n    this.matrix.toContext(ctx);\n    if (clipRect) {\n      // clipRect is in the group's coordinate space\n      const {\n        x,\n        y,\n        width,\n        height\n      } = clipRect;\n      ctx.save();\n      debug(() => ({\n        name,\n        clipRect,\n        ctxTransform: ctx.getTransform(),\n        renderCtx,\n        group: this\n      }));\n      this.clipCtx(ctx, x, y, width, height);\n      // clipBBox is in the canvas coordinate space, when we hit a layer we apply the new clipping at which point there are no transforms in play\n      clipBBox = this.matrix.transformBBox(clipRect);\n    }\n    const hasVirtualChildren = this.hasVirtualChildren();\n    if (dirtyZIndex) {\n      this.sortChildren(children);\n      if (forceRender !== 'dirtyTransform') forceRender = true;\n    } else if (hasVirtualChildren) {\n      this.sortChildren(children);\n    }\n    // Reduce churn if renderCtx is identical.\n    const renderContextChanged = forceRender !== renderCtx.forceRender || clipBBox !== renderCtx.clipBBox || ctx !== renderCtx.ctx;\n    const childRenderContext = renderContextChanged ? Object.assign(Object.assign({}, renderCtx), {\n      ctx,\n      forceRender,\n      clipBBox\n    }) : renderCtx;\n    // Render visible children.\n    let skipped = 0;\n    for (const child of children) {\n      if (!child.visible || !groupVisible) {\n        // Skip invisible children, but make sure their dirty flag is reset.\n        child.markClean();\n        if (stats) skipped += child.nodeCount.count;\n        continue;\n      }\n      if (!forceRender && child.dirty === RedrawType.NONE) {\n        // Skip children that don't need to be redrawn.\n        if (stats) skipped += child.nodeCount.count;\n        continue;\n      }\n      // Render marks this node (and children) as clean - no need to explicitly markClean().\n      ctx.save();\n      child.render(childRenderContext);\n      ctx.restore();\n    }\n    if (stats) stats.nodesSkipped += skipped;\n    // Render marks this node as clean - no need to explicitly markClean().\n    super.render(renderCtx);\n    if (clipRect) {\n      ctx.restore();\n    }\n    if (hasVirtualChildren) {\n      // Mark virtual nodes as clean and their virtual children - all other nodes have already\n      // been visited and marked clean.\n      for (const child of this.virtualChildren) {\n        child.markClean({\n          recursive: 'virtual'\n        });\n      }\n    }\n    if (layer) {\n      if (stats) stats.layersRendered++;\n      ctx.restore();\n      if (forceRender) layer.snapshot();\n      // Check for save/restore depth of zero!\n      (_b = (_a = layer.context).verifyDepthZero) === null || _b === void 0 ? void 0 : _b.call(_a);\n    }\n    if (name && stats) {\n      debug({\n        name,\n        result: 'rendered',\n        skipped,\n        renderCtx,\n        counts: this.nodeCount,\n        group: this\n      });\n    }\n  }\n  sortChildren(children) {\n    this.dirtyZIndex = false;\n    children.sort((a, b) => {\n      var _a, _b;\n      return compoundAscending([a.zIndex, ...((_a = a.zIndexSubOrder) !== null && _a !== void 0 ? _a : [undefined, undefined]), a.serialNumber], [b.zIndex, ...((_b = b.zIndexSubOrder) !== null && _b !== void 0 ? _b : [undefined, undefined]), b.serialNumber], ascendingStringNumberUndefined);\n    });\n  }\n  clipCtx(ctx, x, y, width, height) {\n    ctx.beginPath();\n    ctx.moveTo(x, y);\n    ctx.lineTo(x + width, y);\n    ctx.lineTo(x + width, y + height);\n    ctx.lineTo(x, y + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n  static computeBBox(nodes) {\n    let left = Infinity;\n    let right = -Infinity;\n    let top = Infinity;\n    let bottom = -Infinity;\n    nodes.forEach(n => {\n      if (!n.visible) {\n        return;\n      }\n      const bbox = n.computeTransformedBBox();\n      if (!bbox) {\n        return;\n      }\n      const x = bbox.x;\n      const y = bbox.y;\n      if (x < left) {\n        left = x;\n      }\n      if (y < top) {\n        top = y;\n      }\n      if (x + bbox.width > right) {\n        right = x + bbox.width;\n      }\n      if (y + bbox.height > bottom) {\n        bottom = y + bbox.height;\n      }\n    });\n    return new BBox(left, top, right - left, bottom - top);\n  }\n  /**\r\n   * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and\r\n   * sets this group's clipRect to the transformed bbox.\r\n   * @param bbox clipRect bbox in the canvas coordinate space.\r\n   */\n  setClipRectInGroupCoordinateSpace(bbox) {\n    this.clipRect = bbox ? this.transformBBox(bbox) : undefined;\n  }\n}\nGroup.className = 'Group';\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR,\n  convertor: v => Math.min(1, Math.max(0, v))\n}), __metadata(\"design:type\", Number)], Group.prototype, \"opacity\", void 0);\nclass Selection {\n  static select(parent, classOrFactory, garbageCollection = true) {\n    return new Selection(parent, classOrFactory, garbageCollection);\n  }\n  static selectAll(parent, predicate) {\n    const results = [];\n    const traverse = node => {\n      if (predicate(node)) {\n        results.push(node);\n      }\n      node.children.forEach(traverse);\n    };\n    traverse(parent);\n    return results;\n  }\n  static selectByClass(node, Class) {\n    return Selection.selectAll(node, node => node instanceof Class);\n  }\n  static selectByTag(node, tag) {\n    return Selection.selectAll(node, node => node.tag === tag);\n  }\n  constructor(parentNode, classOrFactory, autoCleanup = true) {\n    this.parentNode = parentNode;\n    this.autoCleanup = autoCleanup;\n    this.garbageBin = new Set();\n    this._nodesMap = new Map();\n    this._nodes = [];\n    this.data = [];\n    this.debug = Debug.create(true, 'scene', 'scene:selections');\n    this.nodeFactory = Object.prototype.isPrototypeOf.call(Node, classOrFactory) ? () => new classOrFactory() : classOrFactory;\n  }\n  createNode(datum, initializer, idx) {\n    const node = this.nodeFactory(datum);\n    node.datum = datum;\n    initializer === null || initializer === void 0 ? void 0 : initializer(node);\n    if (idx != null) {\n      this._nodes.splice(idx, 0, node);\n    } else {\n      this._nodes.push(node);\n    }\n    this.parentNode.appendChild(node);\n    return node;\n  }\n  /**\r\n   * Update the data in a selection. If an `getDatumId()` function is provided, maintain a list of ids related to\r\n   * the nodes. Otherwise, take the more efficient route of simply creating and destroying nodes at the end\r\n   * of the array.\r\n   */\n  update(data, initializer, getDatumId) {\n    if (this.garbageBin.size > 0) {\n      this.debug(`Selection - update() called with pending garbage: ${data}`);\n    }\n    if (getDatumId) {\n      const dataMap = new Map(data.map((datum, idx) => [getDatumId(datum), [datum, idx]]));\n      for (const [node, datumId] of this._nodesMap.entries()) {\n        if (dataMap.has(datumId)) {\n          const [newDatum] = dataMap.get(datumId);\n          node.datum = newDatum;\n          this.garbageBin.delete(node);\n          dataMap.delete(datumId);\n        } else {\n          this.garbageBin.add(node);\n        }\n      }\n      for (const [datumId, [datum, idx]] of dataMap.entries()) {\n        this._nodesMap.set(this.createNode(datum, initializer, idx), datumId);\n      }\n    } else {\n      const maxLength = Math.max(data.length, this.data.length);\n      for (let i = 0; i < maxLength; i++) {\n        if (i >= data.length) {\n          this.garbageBin.add(this._nodes[i]);\n        } else if (i >= this._nodes.length) {\n          this.createNode(data[i], initializer);\n        } else {\n          this._nodes[i].datum = data[i];\n          this.garbageBin.delete(this._nodes[i]);\n        }\n      }\n    }\n    this.data = data.slice();\n    if (this.autoCleanup) {\n      this.cleanup();\n    }\n    return this;\n  }\n  cleanup() {\n    if (this.garbageBin.size === 0) {\n      return this;\n    }\n    this._nodes = this._nodes.filter(node => {\n      if (this.garbageBin.has(node)) {\n        this._nodesMap.delete(node);\n        this.garbageBin.delete(node);\n        this.parentNode.removeChild(node);\n        return false;\n      }\n      return true;\n    });\n    return this;\n  }\n  clear() {\n    this.update([]);\n    return this;\n  }\n  isGarbage(node) {\n    return this.garbageBin.has(node);\n  }\n  hasGarbage() {\n    return this.garbageBin.size > 0;\n  }\n  each(iterate) {\n    this._nodes.forEach((node, i) => iterate(node, node.datum, i));\n    return this;\n  }\n  *[Symbol.iterator]() {\n    for (let index = 0; index < this._nodes.length; index++) {\n      const node = this._nodes[index];\n      const datum = this._nodes[index].datum;\n      yield {\n        node,\n        datum,\n        index\n      };\n    }\n  }\n  select(predicate) {\n    return Selection.selectAll(this.parentNode, predicate);\n  }\n  selectByClass(Class) {\n    return Selection.selectByClass(this.parentNode, Class);\n  }\n  selectByTag(tag) {\n    return Selection.selectByTag(this.parentNode, tag);\n  }\n  nodes() {\n    return this._nodes;\n  }\n}\nclass Line extends Shape {\n  constructor(opts = {}) {\n    super(opts);\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.restoreOwnStyles();\n  }\n  set x(value) {\n    this.x1 = value;\n    this.x2 = value;\n  }\n  set y(value) {\n    this.y1 = value;\n    this.y2 = value;\n  }\n  computeBBox() {\n    return new BBox(Math.min(this.x1, this.x2), Math.min(this.y1, this.y2), Math.abs(this.x2 - this.x1), Math.abs(this.y2 - this.y1));\n  }\n  isPointInPath(px, py) {\n    if (this.x1 === this.x2 || this.y1 === this.y2) {\n      const {\n        x,\n        y\n      } = this.transformPoint(px, py);\n      return this.computeBBox().grow(this.strokeWidth / 2).containsPoint(x, y);\n    }\n    return false;\n  }\n  render(renderCtx) {\n    var _a;\n    const {\n      ctx,\n      forceRender,\n      stats\n    } = renderCtx;\n    if (this.dirty === RedrawType.NONE && !forceRender) {\n      if (stats) stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.computeTransformMatrix();\n    this.matrix.toContext(ctx);\n    let {\n      x1,\n      y1,\n      x2,\n      y2\n    } = this;\n    // Align to the pixel grid if the line is strictly vertical\n    // or horizontal (but not both, i.e. a dot).\n    if (x1 === x2) {\n      const x = Math.round(x1) + Math.floor(this.strokeWidth) % 2 / 2;\n      x1 = x;\n      x2 = x;\n    } else if (y1 === y2) {\n      const y = Math.round(y1) + Math.floor(this.strokeWidth) % 2 / 2;\n      y1 = y;\n      y2 = y;\n    }\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n    this.fillStroke(ctx);\n    (_a = this.fillShadow) === null || _a === void 0 ? void 0 : _a.markClean();\n    super.render(renderCtx);\n  }\n}\nLine.className = 'Line';\nLine.defaultStyles = Object.assign({}, Shape.defaultStyles, {\n  fill: undefined,\n  strokeWidth: 1\n});\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Number)], Line.prototype, \"x1\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Number)], Line.prototype, \"y1\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Number)], Line.prototype, \"x2\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Number)], Line.prototype, \"y2\", void 0);\n\n/**\r\n * Finds the roots of a parametric linear equation in `t`,\r\n * where `t` lies in the interval of `[0,1]`.\r\n */\nfunction linearRoot(a, b) {\n  const t = -b / a;\n  return a !== 0 && t >= 0 && t <= 1 ? [t] : [];\n}\n/**\r\n * Finds the roots of a parametric quadratic equation in `t`,\r\n * where `t` lies in the interval of `[0,1]`.\r\n */\nfunction quadraticRoots(a, b, c) {\n  if (a === 0) {\n    return linearRoot(b, c);\n  }\n  const D = b * b - 4 * a * c; // The polynomial's discriminant.\n  const roots = [];\n  if (D === 0) {\n    // A single real root.\n    const t = -b / (2 * a);\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n  } else if (D > 0) {\n    // A pair of distinct real roots.\n    const rD = Math.sqrt(D);\n    const t1 = (-b - rD) / (2 * a);\n    const t2 = (-b + rD) / (2 * a);\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n  }\n  // else -> Complex roots.\n  return roots;\n}\n/**\r\n * Finds the roots of a parametric cubic equation in `t`,\r\n * where `t` lies in the interval of `[0,1]`.\r\n * Returns an array of parametric intersection locations along the cubic,\r\n * excluding out-of-bounds intersections (before or after the end point\r\n * or in the imaginary plane).\r\n * An adaptation of http://www.particleincell.com/blog/2013/cubic-line-intersection/\r\n */\nfunction cubicRoots(a, b, c, d) {\n  if (a === 0) {\n    return quadraticRoots(b, c, d);\n  }\n  const A = b / a;\n  const B = c / a;\n  const C = d / a;\n  const Q = (3 * B - A * A) / 9;\n  const R = (9 * A * B - 27 * C - 2 * A * A * A) / 54;\n  const D = Q * Q * Q + R * R; // The polynomial's discriminant.\n  const third = 1 / 3;\n  const roots = [];\n  if (D >= 0) {\n    // Complex or duplicate roots.\n    const rD = Math.sqrt(D);\n    const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);\n    const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);\n    const Im = Math.abs(Math.sqrt(3) * (S - T) / 2); // Complex part of the root pair.\n    const t = -third * A + (S + T); // A real root.\n    if (t >= 0 && t <= 1) {\n      roots.push(t);\n    }\n    if (Im === 0) {\n      const t = -third * A - (S + T) / 2; // The real part of a complex root.\n      if (t >= 0 && t <= 1) {\n        roots.push(t);\n      }\n    }\n  } else {\n    // Distinct real roots.\n    const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));\n    const thirdA = third * A;\n    const twoSqrtQ = 2 * Math.sqrt(-Q);\n    const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;\n    const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;\n    const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;\n    if (t1 >= 0 && t1 <= 1) {\n      roots.push(t1);\n    }\n    if (t2 >= 0 && t2 <= 1) {\n      roots.push(t2);\n    }\n    if (t3 >= 0 && t3 <= 1) {\n      roots.push(t3);\n    }\n  }\n  return roots;\n}\n\n/**\r\n * Returns the intersection point for the given pair of line segments, or null,\r\n * if the segments are parallel or don't intersect.\r\n * Based on http://paulbourke.net/geometry/pointlineplane/\r\n */\nfunction segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\n  const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);\n  if (d === 0) {\n    // The lines are parallel.\n    return null;\n  }\n  const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;\n  const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;\n  if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n    return {\n      x: ax1 + ua * (ax2 - ax1),\n      y: ay1 + ua * (ay2 - ay1)\n    };\n  }\n  return null; // The intersection point is outside either or both segments.\n}\n/**\r\n * Returns intersection points of the given cubic curve and the line segment.\r\n * Takes in x/y components of cubic control points and line segment start/end points\r\n * as parameters.\r\n */\nfunction cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {\n  const intersections = [];\n  // Find line equation coefficients.\n  const A = y1 - y2;\n  const B = x2 - x1;\n  const C = x1 * (y2 - y1) - y1 * (x2 - x1);\n  // Find cubic Bezier curve equation coefficients from control points.\n  const bx = bezierCoefficients(px1, px2, px3, px4);\n  const by = bezierCoefficients(py1, py2, py3, py4);\n  const a = A * bx[0] + B * by[0]; // t^3\n  const b = A * bx[1] + B * by[1]; // t^2\n  const c = A * bx[2] + B * by[2]; // t\n  const d = A * bx[3] + B * by[3] + C; // 1\n  const roots = cubicRoots(a, b, c, d);\n  // Verify that the roots are within bounds of the linear segment.\n  for (const t of roots) {\n    const tt = t * t;\n    const ttt = t * tt;\n    // Find the cartesian plane coordinates for the parametric root `t`.\n    const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];\n    const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];\n    // The parametric cubic roots we found are intersection points\n    // with an infinite line, and so the x/y coordinates above are as well.\n    // Make sure the x/y is also within the bounds of the given segment.\n    let s;\n    if (x1 !== x2) {\n      s = (x - x1) / (x2 - x1);\n    } else {\n      // the line is vertical\n      s = (y - y1) / (y2 - y1);\n    }\n    if (s >= 0 && s <= 1) {\n      intersections.push({\n        x,\n        y\n      });\n    }\n  }\n  return intersections;\n}\n/**\r\n * Returns the given coordinates vector multiplied by the coefficient matrix\r\n * of the parametric cubic Bézier equation.\r\n */\nfunction bezierCoefficients(P1, P2, P3, P4) {\n  return [\n  // Bézier expressed as matrix operations:\n  -P1 + 3 * P2 - 3 * P3 + P4, 3 * P1 - 6 * P2 + 3 * P3, -3 * P1 + 3 * P2, P1 //                 | 1  0  0  0| |P4|\n  ];\n}\n/**\r\n * Returns intersection points of the arc and the line segment.\r\n * Takes in arc parameters and line segment start/end points.\r\n */\nfunction arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {\n  // Solving the quadratic equation:\n  // 1. y = k * x + y0\n  // 2. (x - cx)^2 + (y - cy)^2 = r^2\n  const k = (y2 - y1) / (x2 - x1);\n  const y0 = y1 - k * x1;\n  const a = Math.pow(k, 2) + 1;\n  const b = 2 * (k * (y0 - cy) - cx);\n  const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);\n  const d = Math.pow(b, 2) - 4 * a * c;\n  if (d < 0) {\n    return [];\n  }\n  const i1x = (-b + Math.sqrt(d)) / 2 / a;\n  const i2x = (-b - Math.sqrt(d)) / 2 / a;\n  const intersections = [];\n  [i1x, i2x].forEach(x => {\n    const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);\n    if (!isXInsideLine) {\n      return;\n    }\n    const y = k * x + y0;\n    const a1 = normalizeAngle360(startAngle);\n    let a2 = normalizeAngle360(endAngle);\n    let a = normalizeAngle360(Math.atan2(y, x));\n    // Order angles clockwise after the start angle\n    if (a2 <= a1) {\n      a2 += 2 * Math.PI;\n    }\n    if (a < a1) {\n      a += 2 * Math.PI;\n    }\n    if (counterClockwise !== (a >= a1 && a <= a2)) {\n      intersections.push({\n        x,\n        y\n      });\n    }\n  });\n  return intersections;\n}\nfunction isPointInSector(x, y, sector) {\n  const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\n  const {\n    innerRadius,\n    outerRadius\n  } = sector;\n  if (sector.startAngle === sector.endAngle || radius < Math.min(innerRadius, outerRadius) || radius > Math.max(innerRadius, outerRadius)) {\n    return false;\n  }\n  const startAngle = normalizeAngle180(sector.startAngle);\n  const endAngle = normalizeAngle180(sector.endAngle);\n  const angle = Math.atan2(y, x);\n  // Sector can cross axis start\n  return startAngle < endAngle ? angle <= endAngle && angle >= startAngle : angle <= endAngle && angle >= -Math.PI || angle >= startAngle && angle <= Math.PI;\n}\nfunction lineCollidesSector(line, sector) {\n  const {\n    startAngle,\n    endAngle,\n    innerRadius,\n    outerRadius\n  } = sector;\n  const outerStart = {\n    x: outerRadius * Math.cos(startAngle),\n    y: outerRadius * Math.sin(startAngle)\n  };\n  const outerEnd = {\n    x: outerRadius * Math.cos(endAngle),\n    y: outerRadius * Math.sin(endAngle)\n  };\n  const innerStart = innerRadius === 0 ? {\n    x: 0,\n    y: 0\n  } : {\n    x: innerRadius * Math.cos(startAngle),\n    y: innerRadius * Math.sin(startAngle)\n  };\n  const innerEnd = innerRadius === 0 ? {\n    x: 0,\n    y: 0\n  } : {\n    x: innerRadius * Math.cos(endAngle),\n    y: innerRadius * Math.sin(endAngle)\n  };\n  return segmentIntersection(line.start.x, line.start.y, line.end.x, line.end.y, outerStart.x, outerStart.y, innerStart.x, innerStart.y) != null || segmentIntersection(line.start.x, line.start.y, line.end.x, line.end.y, outerEnd.x, outerEnd.y, innerEnd.x, innerEnd.y) != null || arcIntersections(0, 0, outerRadius, startAngle, endAngle, true, line.start.x, line.start.y, line.end.x, line.end.y).length > 0;\n}\nfunction boxCollidesSector(box, sector) {\n  const topLeft = {\n    x: box.x,\n    y: box.y\n  };\n  const topRight = {\n    x: box.x + box.width,\n    y: box.y\n  };\n  const bottomLeft = {\n    x: box.x,\n    y: box.y + box.height\n  };\n  const bottomRight = {\n    x: box.x + box.width,\n    y: box.y + box.height\n  };\n  return lineCollidesSector({\n    start: topLeft,\n    end: topRight\n  }, sector) || lineCollidesSector({\n    start: bottomLeft,\n    end: bottomRight\n  }, sector);\n}\nvar Command;\n(function (Command) {\n  Command[Command[\"Move\"] = 0] = \"Move\";\n  Command[Command[\"Line\"] = 1] = \"Line\";\n  Command[Command[\"Arc\"] = 2] = \"Arc\";\n  Command[Command[\"Curve\"] = 3] = \"Curve\";\n  Command[Command[\"ClosePath\"] = 4] = \"ClosePath\";\n})(Command || (Command = {}));\nclass Path2D {\n  constructor() {\n    // The methods of this class will likely be called many times per animation frame,\n    // and any allocation can trigger a GC cycle during animation, so we attempt\n    // to minimize the number of allocations.\n    this.previousCommands = [];\n    this.previousParams = [];\n    this.previousClosedPath = false;\n    this.commands = [];\n    this.params = [];\n    this._closedPath = false;\n  }\n  isDirty() {\n    if (this._closedPath !== this.previousClosedPath) {\n      return true;\n    }\n    if (this.previousCommands.length !== this.commands.length) {\n      return true;\n    }\n    if (this.previousParams.length !== this.params.length) {\n      return true;\n    }\n    for (let i = 0; i < this.commands.length; i++) {\n      if (this.commands[i] !== this.previousCommands[i]) {\n        return true;\n      }\n    }\n    for (let i = 0; i < this.params.length; i++) {\n      if (this.params[i] !== this.previousParams[i]) {\n        return true;\n      }\n    }\n    return false;\n  }\n  draw(ctx) {\n    const commands = this.commands;\n    const params = this.params;\n    let j = 0;\n    ctx.beginPath();\n    for (const command of commands) {\n      switch (command) {\n        case Command.Move:\n          ctx.moveTo(params[j++], params[j++]);\n          break;\n        case Command.Line:\n          ctx.lineTo(params[j++], params[j++]);\n          break;\n        case Command.Curve:\n          ctx.bezierCurveTo(params[j++], params[j++], params[j++], params[j++], params[j++], params[j++]);\n          break;\n        case Command.Arc:\n          ctx.arc(params[j++], params[j++], params[j++], params[j++], params[j++], params[j++] === 1);\n          break;\n        case Command.ClosePath:\n          ctx.closePath();\n          break;\n      }\n    }\n    if (commands.length === 0) {\n      ctx.closePath();\n    }\n  }\n  moveTo(x, y) {\n    if (this.xy) {\n      this.xy[0] = x;\n      this.xy[1] = y;\n    } else {\n      this.xy = [x, y];\n    }\n    this.commands.push(Command.Move);\n    this.params.push(x, y);\n  }\n  lineTo(x, y) {\n    if (this.xy) {\n      this.commands.push(Command.Line);\n      this.params.push(x, y);\n      this.xy[0] = x;\n      this.xy[1] = y;\n    } else {\n      this.moveTo(x, y);\n    }\n  }\n  rect(x, y, width, height) {\n    this.moveTo(x, y);\n    this.lineTo(x + width, y);\n    this.lineTo(x + width, y + height);\n    this.lineTo(x, y + height);\n    this.closePath();\n  }\n  arc(x, y, r, sAngle, eAngle, antiClockwise = false) {\n    const endX = x + r * Math.cos(eAngle);\n    const endY = y + r * Math.sin(eAngle);\n    if (this.xy) {\n      this.xy[0] = endX;\n      this.xy[1] = endY;\n    } else {\n      this.xy = [endX, endY];\n    }\n    this.commands.push(Command.Arc);\n    this.params.push(x, y, r, sAngle, eAngle, antiClockwise ? 1 : 0);\n  }\n  cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {\n    if (!this.xy) {\n      this.moveTo(cx1, cy1);\n    }\n    this.commands.push(Command.Curve);\n    this.params.push(cx1, cy1, cx2, cy2, x, y);\n    if (this.xy) {\n      this.xy[0] = x;\n      this.xy[1] = y;\n    }\n  }\n  get closedPath() {\n    return this._closedPath;\n  }\n  closePath() {\n    if (this.xy) {\n      this.xy = undefined;\n      this.commands.push(Command.ClosePath);\n      this._closedPath = true;\n    }\n  }\n  clear({\n    trackChanges\n  } = {\n    trackChanges: false\n  }) {\n    if (trackChanges) {\n      this.previousCommands = this.commands;\n      this.previousParams = this.params;\n      this.previousClosedPath = this._closedPath;\n      this.commands = [];\n      this.params = [];\n    } else {\n      this.commands.length = 0;\n      this.params.length = 0;\n    }\n    this.xy = undefined;\n    this._closedPath = false;\n  }\n  isPointInPath(x, y) {\n    const commands = this.commands;\n    const params = this.params;\n    const cn = commands.length;\n    // Hit testing using ray casting method, where the ray's origin is some point\n    // outside the path. In this case, an offscreen point that is remote enough, so that\n    // even if the path itself is large and is partially offscreen, the ray's origin\n    // will likely be outside the path anyway. To test if the given point is inside the\n    // path or not, we cast a ray from the origin to the given point and check the number\n    // of intersections of this segment with the path. If the number of intersections is\n    // even, then the ray both entered and exited the path an equal number of times,\n    // therefore the point is outside the path, and inside the path, if the number of\n    // intersections is odd. Since the path is compound, we check if the ray segment\n    // intersects with each of the path's segments, which can be either a line segment\n    // (one or no intersection points) or a Bézier curve segment (up to 3 intersection\n    // points).\n    const ox = -10000;\n    const oy = -10000;\n    // the starting point of the  current path\n    let sx = NaN;\n    let sy = NaN;\n    // the previous point of the current path\n    let px = 0;\n    let py = 0;\n    let intersectionCount = 0;\n    for (let ci = 0, pi = 0; ci < cn; ci++) {\n      switch (commands[ci]) {\n        case Command.Move:\n          if (!isNaN(sx) && segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\n            intersectionCount++;\n          }\n          px = params[pi++];\n          sx = px;\n          py = params[pi++];\n          sy = py;\n          break;\n        case Command.Line:\n          if (segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y)) {\n            intersectionCount++;\n          }\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case Command.Curve:\n          intersectionCount += cubicSegmentIntersections(px, py, params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], ox, oy, x, y).length;\n          px = params[pi - 2];\n          py = params[pi - 1];\n          break;\n        case Command.Arc:\n          const cx = params[pi++];\n          const cy = params[pi++];\n          const r = params[pi++];\n          const startAngle = params[pi++];\n          const endAngle = params[pi++];\n          const counterClockwise = Boolean(params[pi++]);\n          intersectionCount += arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, ox, oy, x, y).length;\n          px = cx + Math.cos(endAngle) * r;\n          py = cy + Math.sin(endAngle) * r;\n          break;\n        case Command.ClosePath:\n          if (!isNaN(sx) && segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\n            intersectionCount++;\n          }\n          break;\n      }\n    }\n    return intersectionCount % 2 === 1;\n  }\n  getPoints() {\n    const {\n      commands,\n      params\n    } = this;\n    const coords = [];\n    let pi = 0;\n    for (let ci = 0; ci < commands.length; ci++) {\n      switch (commands[ci]) {\n        case Command.Move:\n        case Command.Line:\n          coords.push({\n            x: params[pi++],\n            y: params[pi++]\n          });\n          break;\n        case Command.Curve:\n          pi += 4;\n          coords.push({\n            x: params[pi++],\n            y: params[pi++]\n          });\n          break;\n        case Command.Arc:\n          coords.push({\n            x: params[pi++],\n            y: params[pi++]\n          });\n          pi += 4;\n          break;\n        case Command.ClosePath:\n          break;\n      }\n    }\n    return coords;\n  }\n}\nfunction ScenePathChangeDetection(opts) {\n  const {\n    redraw = RedrawType.MAJOR,\n    changeCb,\n    convertor\n  } = opts !== null && opts !== void 0 ? opts : {};\n  return SceneChangeDetection({\n    redraw,\n    type: 'path',\n    convertor,\n    changeCb\n  });\n}\nclass Path extends Shape {\n  constructor() {\n    super(...arguments);\n    /**\r\n     * Declare a path to retain for later rendering and hit testing\r\n     * using custom Path2D class. Think of it as a TypeScript version\r\n     * of the native Path2D (with some differences) that works in all browsers.\r\n     */\n    this.path = new Path2D();\n    this.clipScalingX = 1;\n    this.clipScalingY = 1;\n    /**\r\n     * The path only has to be updated when certain attributes change.\r\n     * For example, if transform attributes (such as `translationX`)\r\n     * are changed, we don't have to update the path. The `dirtyPath` flag\r\n     * is how we keep track if the path has to be updated or not.\r\n     */\n    this._dirtyPath = true;\n  }\n  set dirtyPath(value) {\n    if (this._dirtyPath !== value) {\n      this._dirtyPath = value;\n      if (value) {\n        this.markDirty(this, RedrawType.MAJOR);\n      }\n    }\n  }\n  get dirtyPath() {\n    return this._dirtyPath;\n  }\n  checkPathDirty() {\n    var _a, _b, _c, _d;\n    if (this._dirtyPath) {\n      return;\n    }\n    this.dirtyPath = this.path.isDirty() || ((_b = (_a = this.fillShadow) === null || _a === void 0 ? void 0 : _a.isDirty()) !== null && _b !== void 0 ? _b : false) || ((_d = (_c = this.clipPath) === null || _c === void 0 ? void 0 : _c.isDirty()) !== null && _d !== void 0 ? _d : false);\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    return this.path.closedPath && this.path.isPointInPath(point.x, point.y);\n  }\n  isDirtyPath() {\n    // Override point for more expensive dirty checks.\n    return false;\n  }\n  updatePath() {\n    // Override point for subclasses.\n  }\n  clip(ctx, op) {\n    const transform = ctx.getTransform();\n    const clipScale = this.clipScalingX !== 1 || this.clipScalingY !== 1;\n    if (clipScale) {\n      ctx.scale(this.clipScalingX, this.clipScalingY);\n    }\n    op();\n    if (clipScale) {\n      ctx.setTransform(transform);\n    }\n  }\n  render(renderCtx) {\n    var _a;\n    const {\n      ctx,\n      forceRender,\n      stats\n    } = renderCtx;\n    if (this.dirty === RedrawType.NONE && !forceRender) {\n      if (stats) stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.computeTransformMatrix();\n    this.matrix.toContext(ctx);\n    if (this.dirtyPath || this.isDirtyPath()) {\n      this.updatePath();\n      this.dirtyPath = false;\n    }\n    if (this.clipPath && this.clipMode != null) {\n      ctx.save();\n      if (this.clipMode === 'normal') {\n        this.clip(ctx, () => {\n          var _a;\n          // Bound the shape rendered to the clipping path.\n          (_a = this.clipPath) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n          ctx.clip();\n        });\n      }\n      if (this.clipScalingX > 0 && this.clipScalingY > 0) {\n        this.path.draw(ctx);\n        this.fillStroke(ctx);\n      }\n      if (this.clipMode === 'punch-out') {\n        this.clip(ctx, () => {\n          var _a, _b;\n          // Bound the shape rendered to the clipping path.\n          (_a = this.clipPath) === null || _a === void 0 ? void 0 : _a.draw(ctx);\n          ctx.clip();\n          // Fallback values, but practically these should never be used.\n          const {\n            x = -10000,\n            y = -10000,\n            width = 20000,\n            height = 20000\n          } = (_b = this.computeBBox()) !== null && _b !== void 0 ? _b : {};\n          ctx.clearRect(x, y, width, height);\n        });\n      }\n      ctx.restore();\n    } else {\n      this.path.draw(ctx);\n      this.fillStroke(ctx);\n    }\n    (_a = this.fillShadow) === null || _a === void 0 ? void 0 : _a.markClean();\n    super.render(renderCtx);\n  }\n}\nPath.className = 'Path';\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Path2D)], Path.prototype, \"clipPath\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", String)], Path.prototype, \"clipMode\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Object)], Path.prototype, \"clipScalingX\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Object)], Path.prototype, \"clipScalingY\", void 0);\nclass Sector extends Path {\n  constructor() {\n    super(...arguments);\n    this.centerX = 0;\n    this.centerY = 0;\n    this.innerRadius = 10;\n    this.outerRadius = 20;\n    this.startAngle = 0;\n    this.endAngle = Math.PI * 2;\n    this.angleOffset = 0;\n    this.inset = 0;\n  }\n  computeBBox() {\n    const radius = this.outerRadius;\n    return new BBox(this.centerX - radius, this.centerY - radius, radius * 2, radius * 2);\n  }\n  updatePath() {\n    const path = this.path;\n    const {\n      angleOffset,\n      inset\n    } = this;\n    const startAngle = this.startAngle + angleOffset;\n    const endAngle = this.endAngle + angleOffset;\n    const fullPie = Math.abs(this.endAngle - this.startAngle) >= 2 * Math.PI;\n    const centerX = this.centerX;\n    const centerY = this.centerY;\n    path.clear();\n    if (fullPie) {\n      const baseInnerRadius = this.innerRadius <= 0 ? 0 : this.innerRadius + inset;\n      const innerRadius = Math.min(baseInnerRadius, this.outerRadius - inset);\n      const outerRadius = Math.max(baseInnerRadius, this.outerRadius - inset);\n      path.arc(centerX, centerY, outerRadius, startAngle, endAngle);\n      if (innerRadius > 0) {\n        path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));\n        path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);\n      }\n    } else {\n      const innerRadius = Math.min(this.innerRadius + inset, this.outerRadius - inset);\n      const outerRadius = Math.max(this.innerRadius + inset, this.outerRadius - inset);\n      const innerAngleOffset = innerRadius > 0 ? inset / innerRadius : 0;\n      const outerAngleOffset = outerRadius > 0 ? inset / outerRadius : 0;\n      const sweep = Math.abs(endAngle - startAngle);\n      const outerAngleExceeded = sweep < 2 * outerAngleOffset;\n      if (outerAngleExceeded) return;\n      const innerAngleExceeded = innerRadius <= inset || sweep < 2 * innerAngleOffset;\n      if (innerAngleExceeded) {\n        // Draw a wedge on a cartesian co-ordinate with radius `sweep`\n        // Inset from bottom - i.e. y = innerRadius\n        // Inset the top - i.e. y = (x - x0) * tan(sweep)\n        // Form a right angle from the wedge with hypotenuse x0 and an opposite side of innerRadius\n        // Gives x0 = inset * sin(sweep)\n        // y = inset = (x - inset * sin(sweep)) * tan(sweep) - solve for x\n        // This formula has limits (i.e. sweep being >= a quarter turn),\n        // but the bounds for x should be [innerRadius, outerRadius)\n        const x = Math.abs(sweep) < Math.PI * 0.5 ? inset * (1 + Math.cos(sweep)) / Math.sin(sweep) : NaN;\n        // r = sqrt(x**2 + y**2)\n        let r;\n        if (x > 0 && x < outerRadius) {\n          // Even within the formula limits, floating point precision isn't always enough,\n          // so ensure we never go less than the inner radius\n          r = Math.max(Math.hypot(inset, x), innerRadius);\n        } else {\n          // Formula limits exceeded - just use the inner radius\n          r = innerRadius;\n        }\n        const midAngle = (startAngle + endAngle) * 0.5;\n        path.moveTo(centerX + r * Math.cos(midAngle), centerY + r * Math.sin(midAngle));\n      } else {\n        path.moveTo(centerX + innerRadius * Math.cos(startAngle + innerAngleOffset), centerY + innerRadius * Math.sin(startAngle + innerAngleOffset));\n      }\n      path.arc(centerX, centerY, outerRadius, startAngle + outerAngleOffset, endAngle - outerAngleOffset);\n      if (innerAngleExceeded) ;else if (innerRadius > 0) {\n        path.arc(centerX, centerY, innerRadius, endAngle - innerAngleOffset, startAngle + innerAngleOffset, true);\n      } else {\n        path.lineTo(centerX, centerY);\n      }\n    }\n    path.closePath();\n    this.dirtyPath = false;\n  }\n  isPointInPath(x, y) {\n    const {\n      angleOffset\n    } = this;\n    const startAngle = this.startAngle + angleOffset;\n    const endAngle = this.endAngle + angleOffset;\n    const innerRadius = Math.min(this.innerRadius, this.outerRadius);\n    const outerRadius = Math.max(this.innerRadius, this.outerRadius);\n    const point = this.transformPoint(x, y);\n    return isPointInSector(point.x, point.y, {\n      startAngle,\n      endAngle,\n      innerRadius,\n      outerRadius\n    });\n  }\n}\nSector.className = 'Sector';\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Sector.prototype, \"centerX\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Sector.prototype, \"centerY\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Sector.prototype, \"innerRadius\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Sector.prototype, \"outerRadius\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Sector.prototype, \"startAngle\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Sector.prototype, \"endAngle\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Sector.prototype, \"angleOffset\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Sector.prototype, \"inset\", void 0);\nfunction deepMerge(target, source) {\n  if (isPlainObject(target) && isPlainObject(source)) {\n    const result = {};\n    Object.keys(target).forEach(key => {\n      if (key in source) {\n        result[key] = deepMerge(target[key], source[key]);\n      } else {\n        result[key] = target[key];\n      }\n    });\n    Object.keys(source).forEach(key => {\n      if (!(key in target)) {\n        result[key] = source[key];\n      }\n    });\n    return result;\n  }\n  if (Array.isArray(target) && !Array.isArray(source) || isObjectLike(target) && !isObjectLike(source)) {\n    return target;\n  }\n  return source;\n}\nfunction isObjectLike(value) {\n  return typeof value === 'object' && value !== null;\n}\nfunction isObject(value) {\n  return isObjectLike(value) && !Array.isArray(value);\n}\nfunction isPlainObject(x) {\n  return isObject(x) && x.constructor === Object;\n}\nfunction mergeDefaults(...sources) {\n  var _a;\n  const target = {};\n  for (const source of sources) {\n    if (!source) continue;\n    const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);\n    for (const key of keys) {\n      if (isObject(target[key]) && isObject(source[key])) {\n        target[key] = mergeDefaults(target[key], source[key]);\n      } else {\n        (_a = target[key]) !== null && _a !== void 0 ? _a : target[key] = source[key];\n      }\n    }\n  }\n  return target;\n}\n// Similar to Object.assign, but only copy an explicit set of keys.\nfunction partialAssign(keysToCopy, target, source) {\n  if (source === undefined) {\n    return target;\n  }\n  for (const key of keysToCopy) {\n    const value = source[key];\n    if (value !== undefined) {\n      target[key] = value;\n    }\n  }\n  return target;\n}\nlet element = null;\nfunction sanitizeHtml(text) {\n  if (text == null) {\n    return undefined;\n  } else if (text === '') {\n    return '';\n  }\n  element !== null && element !== void 0 ? element : element = document.createElement('div');\n  element.textContent = String(text);\n  return element.innerHTML;\n}\nconst isString = v => typeof v === 'string';\nconst isStringObject = v => !!v && Object.prototype.hasOwnProperty.call(v, 'toString') && isString(v.toString());\nconst isDate = v => v instanceof Date && !isNaN(+v);\nfunction isDiscrete(value) {\n  return isString(value) || isStringObject(value);\n}\nfunction isContinuous(value) {\n  const isNumberObject = v => !!v && Object.prototype.hasOwnProperty.call(v, 'valueOf') && isNumber(v.valueOf());\n  const isDate = v => v instanceof Date && !isNaN(+v);\n  return isNumber(value) || isNumberObject(value) || isDate(value);\n}\nfunction checkDatum(value, isContinuousScale) {\n  if (isContinuousScale && isContinuous(value)) {\n    return value;\n  } else if (!isContinuousScale) {\n    if (!isDiscrete(value)) {\n      return String(value);\n    }\n    return value;\n  }\n  return undefined;\n}\nconst isNumber = v => typeof v === 'number' && Number.isFinite(v);\nconst memorizedFns = new Map();\nfunction memo(params, fnGenerator) {\n  var _a, _b, _c;\n  const serialisedParams = JSON.stringify(params, null, 0);\n  if (!memorizedFns.has(fnGenerator)) {\n    memorizedFns.set(fnGenerator, new Map());\n  }\n  if (!((_a = memorizedFns.get(fnGenerator)) === null || _a === void 0 ? void 0 : _a.has(serialisedParams))) {\n    (_b = memorizedFns.get(fnGenerator)) === null || _b === void 0 ? void 0 : _b.set(serialisedParams, fnGenerator(params));\n  }\n  return (_c = memorizedFns.get(fnGenerator)) === null || _c === void 0 ? void 0 : _c.get(serialisedParams);\n}\nconst SMALLEST_KEY_INTERVAL = {\n  type: 'reducer',\n  property: 'smallestKeyInterval',\n  initialValue: Infinity,\n  reducer: () => {\n    let prevX = NaN;\n    return (smallestSoFar = Infinity, next) => {\n      const nextX = next.keys[0];\n      const interval = Math.abs(nextX - prevX);\n      prevX = nextX;\n      if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {\n        return interval;\n      }\n      return smallestSoFar;\n    };\n  }\n};\nconst AGG_VALUES_EXTENT = {\n  type: 'processor',\n  property: 'aggValuesExtent',\n  calculate: processedData => {\n    var _a, _b, _c, _d;\n    const result = [...((_b = (_a = processedData.domain.aggValues) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : [0, 0])];\n    for (const [min, max] of (_d = (_c = processedData.domain.aggValues) === null || _c === void 0 ? void 0 : _c.slice(1)) !== null && _d !== void 0 ? _d : []) {\n      if (min < result[0]) {\n        result[0] = min;\n      }\n      if (max > result[1]) {\n        result[1] = max;\n      }\n    }\n    return result;\n  }\n};\nconst SORT_DOMAIN_GROUPS = {\n  type: 'processor',\n  property: 'sortedGroupDomain',\n  calculate: ({\n    domain: {\n      groups\n    }\n  }) => {\n    if (groups == null) return undefined;\n    return [...groups].sort((a, b) => {\n      for (let i = 0; i < a.length; i++) {\n        const result = a[i] - b[i];\n        if (result !== 0) {\n          return result;\n        }\n      }\n      return 0;\n    });\n  }\n};\nfunction normaliseFnBuilder({\n  normaliseTo,\n  mode\n}) {\n  const normalise = (val, extent) => {\n    const result = val * normaliseTo / extent;\n    if (result >= 0) {\n      return Math.min(normaliseTo, result);\n    }\n    return Math.max(-normaliseTo, result);\n  };\n  return () => () => (values, valueIndexes) => {\n    const valuesExtent = [0, 0];\n    for (const valueIdx of valueIndexes) {\n      const value = values[valueIdx];\n      const valIdx = value < 0 ? 0 : 1;\n      if (mode === 'sum') {\n        valuesExtent[valIdx] += value;\n      } else if (valIdx === 0) {\n        valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], value);\n      } else {\n        valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], value);\n      }\n    }\n    const extent = Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);\n    for (const valueIdx of valueIndexes) {\n      values[valueIdx] = normalise(values[valueIdx], extent);\n    }\n  };\n}\nfunction normaliseGroupTo(scope, matchGroupIds, normaliseTo, mode = 'sum') {\n  return {\n    scopes: [scope.id],\n    type: 'group-value-processor',\n    matchGroupIds,\n    adjust: memo({\n      normaliseTo,\n      mode\n    }, normaliseFnBuilder)\n  };\n}\nfunction normalisePropertyFnBuilder({\n  normaliseTo,\n  zeroDomain,\n  rangeMin,\n  rangeMax\n}) {\n  const normaliseSpan = normaliseTo[1] - normaliseTo[0];\n  const normalise = (val, start, span) => {\n    const result = normaliseTo[0] + (val - start) / span * normaliseSpan;\n    if (span === 0) return zeroDomain;\n    if (result >= normaliseTo[1]) return normaliseTo[1];\n    if (result < normaliseTo[0]) return normaliseTo[0];\n    return result;\n  };\n  return () => (pData, pIdx) => {\n    let [start, end] = pData.domain.values[pIdx];\n    if (rangeMin != null) start = rangeMin;\n    if (rangeMax != null) end = rangeMax;\n    const span = end - start;\n    pData.domain.values[pIdx] = [normaliseTo[0], normaliseTo[1]];\n    for (const group of pData.data) {\n      let groupValues = group.values;\n      if (pData.type === 'ungrouped') {\n        groupValues = [groupValues];\n      }\n      for (const values of groupValues) {\n        values[pIdx] = normalise(values[pIdx], start, span);\n      }\n    }\n  };\n}\nfunction normalisePropertyTo(scope, property, normaliseTo, zeroDomain, rangeMin, rangeMax) {\n  return {\n    scopes: [scope.id],\n    type: 'property-value-processor',\n    property,\n    adjust: memo({\n      normaliseTo,\n      rangeMin,\n      rangeMax,\n      zeroDomain\n    }, normalisePropertyFnBuilder)\n  };\n}\nfunction animationValidation(scope, valueKeyIds = []) {\n  return {\n    type: 'processor',\n    scopes: [scope.id],\n    property: 'animationValidation',\n    calculate(result) {\n      var _a;\n      const {\n        keys,\n        values\n      } = result.defs;\n      const {\n        input,\n        data\n      } = result;\n      let uniqueKeys = true;\n      let orderedKeys = true;\n      const valueKeys = [];\n      for (let k = 0; k < values.length; k++) {\n        if (!((_a = values[k].scopes) === null || _a === void 0 ? void 0 : _a.some(s => s === scope.id))) continue;\n        if (!valueKeyIds.some(v => values[k].id === v)) continue;\n        valueKeys.push([k, values[k]]);\n      }\n      const processKey = (idx, def, type) => {\n        var _a;\n        if (def.valueType === 'category') {\n          const keyValues = result.domain[type][idx];\n          uniqueKeys && (uniqueKeys = keyValues.length === input.count);\n          return;\n        }\n        let lastValue = (_a = data[0]) === null || _a === void 0 ? void 0 : _a[type][idx];\n        for (let d = 1; (uniqueKeys || orderedKeys) && d < data.length; d++) {\n          const keyValue = data[d][type][idx];\n          orderedKeys && (orderedKeys = lastValue <= keyValue);\n          uniqueKeys && (uniqueKeys = lastValue !== keyValue);\n          lastValue = keyValue;\n        }\n      };\n      for (let k = 0; (uniqueKeys || orderedKeys) && k < keys.length; k++) {\n        processKey(k, keys[k], 'keys');\n      }\n      for (let k = 0; (uniqueKeys || orderedKeys) && k < valueKeys.length; k++) {\n        const [idx, key] = valueKeys[k];\n        processKey(idx, key, 'values');\n      }\n      return {\n        uniqueKeys,\n        orderedKeys\n      };\n    }\n  };\n}\nfunction buildGroupAccFn({\n  mode,\n  separateNegative\n}) {\n  return () => () => (values, valueIndexes) => {\n    // Datum scope.\n    const acc = [0, 0];\n    for (const valueIdx of valueIndexes) {\n      const currentVal = values[valueIdx];\n      const accIndex = isNegative(currentVal) && separateNegative ? 0 : 1;\n      if (typeof currentVal !== 'number' || isNaN(currentVal)) continue;\n      if (mode === 'normal') acc[accIndex] += currentVal;\n      values[valueIdx] = acc[accIndex];\n      if (mode === 'trailing') acc[accIndex] += currentVal;\n    }\n  };\n}\nfunction buildGroupWindowAccFn({\n  mode,\n  sum\n}) {\n  return () => {\n    // Entire data-set scope.\n    const lastValues = [];\n    let firstRow = true;\n    return () => {\n      // Group scope.\n      return (values, valueIndexes) => {\n        // Datum scope.\n        let acc = 0;\n        for (const valueIdx of valueIndexes) {\n          const currentVal = values[valueIdx];\n          const lastValue = firstRow && sum === 'current' ? 0 : lastValues[valueIdx];\n          lastValues[valueIdx] = currentVal;\n          const sumValue = sum === 'current' ? currentVal : lastValue;\n          if (typeof currentVal !== 'number' || isNaN(currentVal)) {\n            values[valueIdx] = acc;\n            continue;\n          }\n          if (typeof lastValue !== 'number' || isNaN(lastValue)) {\n            values[valueIdx] = acc;\n            continue;\n          }\n          if (mode === 'normal') acc += sumValue;\n          values[valueIdx] = acc;\n          if (mode === 'trailing') acc += sumValue;\n        }\n        firstRow = false;\n      };\n    };\n  };\n}\nfunction accumulateGroup(scope, matchGroupId, mode, sum, separateNegative = false) {\n  let adjust;\n  if (mode.startsWith('window')) {\n    const modeParam = mode.endsWith('-trailing') ? 'trailing' : 'normal';\n    adjust = memo({\n      mode: modeParam,\n      sum\n    }, buildGroupWindowAccFn);\n  } else {\n    adjust = memo({\n      mode: mode,\n      separateNegative\n    }, buildGroupAccFn);\n  }\n  return {\n    scopes: [scope.id],\n    type: 'group-value-processor',\n    matchGroupIds: [matchGroupId],\n    adjust\n  };\n}\nfunction diff(previousData, updateMovedDatums = true) {\n  return {\n    type: 'processor',\n    property: 'diff',\n    calculate: processedData => {\n      const diff = {\n        changed: false,\n        moved: [],\n        added: [],\n        updated: [],\n        removed: [],\n        addedIndices: [],\n        updatedIndices: [],\n        removedIndices: []\n      };\n      const moved = new Map();\n      const added = new Map();\n      const updated = new Map();\n      const removed = new Map();\n      const addedIndices = new Map();\n      const updatedIndices = new Map();\n      const removedIndices = new Map();\n      for (let i = 0; i < Math.max(previousData.data.length, processedData.data.length); i++) {\n        const prev = previousData.data[i];\n        const datum = processedData.data[i];\n        const prevId = prev ? createDatumId(prev.keys) : '';\n        const datumId = datum ? createDatumId(datum.keys) : '';\n        if (prevId === datumId) {\n          if (!arraysEqual(prev.values, datum.values)) {\n            updated.set(datumId, datum);\n            updatedIndices.set(datumId, i);\n          }\n          continue;\n        }\n        if (removed.has(datumId)) {\n          if (updateMovedDatums || !arraysEqual(removed.get(datumId).values, datum.values)) {\n            updated.set(datumId, datum);\n            updatedIndices.set(datumId, i);\n            moved.set(datumId, datum);\n          }\n          removed.delete(datumId);\n          removedIndices.delete(datumId);\n        } else if (datum) {\n          added.set(datumId, datum);\n          addedIndices.set(datumId, i);\n        }\n        if (added.has(prevId)) {\n          if (updateMovedDatums || !arraysEqual(added.get(prevId).values, prev.values)) {\n            updated.set(prevId, prev);\n            updatedIndices.set(prevId, i);\n            moved.set(prevId, prev);\n          }\n          added.delete(prevId);\n          addedIndices.delete(prevId);\n        } else if (prev) {\n          updated.delete(prevId);\n          updatedIndices.delete(prevId);\n          removed.set(prevId, prev);\n          removedIndices.set(prevId, i);\n        }\n      }\n      diff.added = Array.from(added.keys());\n      diff.updated = Array.from(updated.keys());\n      diff.removed = Array.from(removed.keys());\n      diff.moved = Array.from(moved.keys());\n      diff.addedIndices = Array.from(addedIndices.values());\n      diff.updatedIndices = Array.from(updatedIndices.values());\n      diff.removedIndices = Array.from(removedIndices.values());\n      diff.changed = diff.added.length > 0 || diff.updated.length > 0 || diff.removed.length > 0;\n      return diff;\n    }\n  };\n}\nfunction createDatumId(keys) {\n  return keys.join('___');\n}\nclass Label {\n  constructor() {\n    this.enabled = true;\n    this.color = '#464646';\n    this.fontSize = 12;\n    this.fontFamily = 'Verdana, sans-serif';\n  }\n  getFont() {\n    return getFont(this);\n  }\n}\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Object)], Label.prototype, \"enabled\", void 0);\n__decorate([Validate(COLOR_STRING), __metadata(\"design:type\", Object)], Label.prototype, \"color\", void 0);\n__decorate([Validate(OPT_FONT_STYLE), __metadata(\"design:type\", String)], Label.prototype, \"fontStyle\", void 0);\n__decorate([Validate(OPT_FONT_WEIGHT), __metadata(\"design:type\", String)], Label.prototype, \"fontWeight\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], Label.prototype, \"fontSize\", void 0);\n__decorate([Validate(STRING), __metadata(\"design:type\", Object)], Label.prototype, \"fontFamily\", void 0);\n__decorate([Validate(OPT_FUNCTION), __metadata(\"design:type\", Function)], Label.prototype, \"formatter\", void 0);\nfunction calculateLabelRotation(opts) {\n  const {\n    parallelFlipRotation = 0,\n    regularFlipRotation = 0\n  } = opts;\n  const configuredRotation = opts.rotation ? normalizeAngle360(toRadians(opts.rotation)) : 0;\n  const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\n  // Flip if the axis rotation angle is in the top hemisphere.\n  const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\n  let defaultRotation = 0;\n  if (opts.parallel) {\n    defaultRotation = parallelFlipFlag * Math.PI / 2;\n  } else if (regularFlipFlag === -1) {\n    defaultRotation = Math.PI;\n  }\n  return {\n    configuredRotation,\n    defaultRotation,\n    parallelFlipFlag,\n    regularFlipFlag\n  };\n}\nfunction getLabelSpacing(minSpacing, rotated) {\n  if (!isNaN(minSpacing)) {\n    return minSpacing;\n  }\n  return rotated ? 0 : 10;\n}\nfunction getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag) {\n  if (parallel && !labelRotation) {\n    return sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom';\n  }\n  return 'middle';\n}\nfunction getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {\n  const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;\n  const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;\n  const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;\n  if (parallel) {\n    if (labelRotation || labelAutoRotation) {\n      if (sideFlag * alignFlag === -1) {\n        return 'end';\n      }\n    } else {\n      return 'center';\n    }\n  } else if (sideFlag * regularFlipFlag === -1) {\n    return 'end';\n  }\n  return 'start';\n}\nfunction calculateLabelBBox(text, bbox, labelX, labelY, labelMatrix) {\n  // Text.computeBBox() does not take into account any of the transformations that have been applied to the label nodes, only the width and height are useful.\n  // Rather than taking into account all transformations including those of parent nodes which would be the result of `computeTransformedBBox()`, giving the x and y in the entire axis coordinate space,\n  // take into account only the rotation and translation applied to individual label nodes to get the x y coordinates of the labels relative to each other\n  // this makes label collision detection a lot simpler\n  const {\n    width,\n    height\n  } = bbox;\n  const translatedBBox = new BBox(labelX, labelY, 0, 0);\n  labelMatrix.transformBBox(translatedBBox, bbox);\n  const {\n    x = 0,\n    y = 0\n  } = bbox;\n  bbox.width = width;\n  bbox.height = height;\n  return {\n    point: {\n      x,\n      y,\n      size: 0\n    },\n    label: {\n      width,\n      height,\n      text\n    }\n  };\n}\n\n/**\r\n * Constants to declare the expected nominal zIndex for all types of layer in chart rendering.\r\n */\nvar Layers;\n(function (Layers) {\n  Layers[Layers[\"SERIES_BACKGROUND_ZINDEX\"] = -10] = \"SERIES_BACKGROUND_ZINDEX\";\n  Layers[Layers[\"AXIS_GRID_ZINDEX\"] = 0] = \"AXIS_GRID_ZINDEX\";\n  Layers[Layers[\"AXIS_ZINDEX\"] = 20] = \"AXIS_ZINDEX\";\n  Layers[Layers[\"SERIES_CROSSLINE_RANGE_ZINDEX\"] = 30] = \"SERIES_CROSSLINE_RANGE_ZINDEX\";\n  Layers[Layers[\"SERIES_LAYER_ZINDEX\"] = 500] = \"SERIES_LAYER_ZINDEX\";\n  Layers[Layers[\"AXIS_FOREGROUND_ZINDEX\"] = 750] = \"AXIS_FOREGROUND_ZINDEX\";\n  Layers[Layers[\"SERIES_CROSSHAIR_ZINDEX\"] = 1000] = \"SERIES_CROSSHAIR_ZINDEX\";\n  Layers[Layers[\"SERIES_LABEL_ZINDEX\"] = 1500] = \"SERIES_LABEL_ZINDEX\";\n  Layers[Layers[\"SERIES_CROSSLINE_LINE_ZINDEX\"] = 2500] = \"SERIES_CROSSLINE_LINE_ZINDEX\";\n  Layers[Layers[\"LEGEND_ZINDEX\"] = 3000] = \"LEGEND_ZINDEX\";\n})(Layers || (Layers = {}));\nclass Marker extends Path {\n  constructor() {\n    super(...arguments);\n    this.x = 0;\n    this.y = 0;\n    this.size = 12;\n  }\n  computeBBox() {\n    const {\n      x,\n      y,\n      size\n    } = this;\n    const half = size / 2;\n    return new BBox(x - half, y - half, size, size);\n  }\n  applyPath(s, moves) {\n    const {\n      path\n    } = this;\n    let {\n      x,\n      y\n    } = this;\n    path.clear();\n    for (const {\n      x: mx,\n      y: my,\n      t\n    } of moves) {\n      x += mx * s;\n      y += my * s;\n      if (t === 'move') {\n        path.moveTo(x, y);\n      } else {\n        path.lineTo(x, y);\n      }\n    }\n    path.closePath();\n  }\n}\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Marker.prototype, \"x\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Marker.prototype, \"y\", void 0);\n__decorate([ScenePathChangeDetection({\n  convertor: Math.abs\n}), __metadata(\"design:type\", Number)], Marker.prototype, \"size\", void 0);\nclass Circle extends Marker {\n  updatePath() {\n    const {\n      x,\n      y,\n      path,\n      size\n    } = this;\n    const r = size / 2;\n    path.clear();\n    path.arc(x, y, r, 0, Math.PI * 2);\n    path.closePath();\n  }\n}\nCircle.className = 'Circle';\nconst DEFAULT_FILLS = {\n  BLUE: '#5090dc',\n  ORANGE: '#ffa03a',\n  GREEN: '#459d55',\n  CYAN: '#34bfe1',\n  YELLOW: '#e1cc00',\n  VIOLET: '#9669cb',\n  GRAY: '#b5b5b5',\n  MAGENTA: '#bd5aa7',\n  BROWN: '#8a6224',\n  RED: '#ef5452'\n};\nconst DEFAULT_STROKES = {\n  BLUE: '#2b5c95',\n  ORANGE: '#cc6f10',\n  GREEN: '#1e652e',\n  CYAN: '#18859e',\n  YELLOW: '#a69400',\n  VIOLET: '#603c88',\n  GRAY: '#575757',\n  MAGENTA: '#7d2f6d',\n  BROWN: '#4f3508',\n  RED: '#a82529'\n};\nclass ModuleMap {\n  constructor(parent) {\n    this.modules = {};\n    this.parent = parent;\n  }\n  destroy() {\n    for (const [key, module] of Object.entries(this.modules)) {\n      module.instance.destroy();\n      delete this.modules[key];\n      delete this.parent[key];\n    }\n  }\n  addModule(module) {\n    if (this.modules[module.optionsKey] != null) {\n      throw new Error('AG Charts - module already initialised: ' + module.optionsKey);\n    }\n    if (module.optionsKey in this.parent) {\n      throw new Error(`AG Charts - class already has option key '${module.optionsKey}'`);\n    }\n    if (this.moduleContext == null) {\n      this.moduleContext = this.parent.createModuleContext();\n    }\n    const moduleInstance = new module.instanceConstructor(Object.assign({}, this.moduleContext));\n    this.modules[module.optionsKey] = {\n      instance: moduleInstance\n    };\n    this.parent[module.optionsKey] = moduleInstance;\n  }\n  removeModule(module) {\n    var _a, _b;\n    (_b = (_a = this.modules[module.optionsKey]) === null || _a === void 0 ? void 0 : _a.instance) === null || _b === void 0 ? void 0 : _b.destroy();\n    delete this.modules[module.optionsKey];\n    delete this.parent[module.optionsKey];\n  }\n  isModuleEnabled(module) {\n    return this.modules[module.optionsKey] != null;\n  }\n  *[Symbol.iterator]() {\n    for (const {\n      instance\n    } of Object.values(this.modules)) {\n      yield instance;\n    }\n  }\n}\nclass Listeners {\n  constructor() {\n    this.registeredListeners = new Map();\n  }\n  addListener(eventType, handler, meta) {\n    const record = {\n      symbol: Symbol(eventType),\n      handler,\n      meta\n    };\n    if (this.registeredListeners.has(eventType)) {\n      this.registeredListeners.get(eventType).push(record);\n    } else {\n      this.registeredListeners.set(eventType, [record]);\n    }\n    return () => this.removeListener(record.symbol);\n  }\n  removeListener(eventSymbol) {\n    for (const [type, listeners] of this.registeredListeners.entries()) {\n      const matchIndex = listeners.findIndex(listener => listener.symbol === eventSymbol);\n      if (matchIndex >= 0) {\n        listeners.splice(matchIndex, 1);\n        if (listeners.length === 0) {\n          this.registeredListeners.delete(type);\n        }\n        break;\n      }\n    }\n  }\n  dispatch(eventType, ...params) {\n    // This is a utility class to store all the results of Listeners (or do nothing\n    // if R = void).\n    class ResultArray {\n      constructor() {\n        this.results = undefined;\n      }\n      push(result) {\n        var _a;\n        if (result === undefined) return;\n        (_a = this.results) !== null && _a !== void 0 ? _a : this.results = [];\n        this.results.push(result);\n      }\n    }\n    const results = new ResultArray();\n    for (const listener of this.getListenersByType(eventType)) {\n      try {\n        results.push(listener.handler(...params));\n      } catch (e) {\n        Logger.errorOnce(e);\n      }\n    }\n    return results.results;\n  }\n  dispatchWrapHandlers(eventType, wrapFn, ...params) {\n    for (const listener of this.getListenersByType(eventType)) {\n      try {\n        wrapFn(listener.handler, listener.meta, ...params);\n      } catch (e) {\n        Logger.errorOnce(e);\n      }\n    }\n  }\n  getListenersByType(eventType) {\n    var _a;\n    return (_a = this.registeredListeners.get(eventType)) !== null && _a !== void 0 ? _a : [];\n  }\n}\nclass Observable {\n  constructor() {\n    this.eventListeners = new Map();\n  }\n  addEventListener(eventType, listener) {\n    if (typeof listener !== 'function') {\n      throw new Error('AG Charts - listener must be a Function');\n    }\n    const eventTypeListeners = this.eventListeners.get(eventType);\n    if (eventTypeListeners) {\n      eventTypeListeners.add(listener);\n    } else {\n      this.eventListeners.set(eventType, new Set([listener]));\n    }\n  }\n  removeEventListener(type, listener) {\n    var _a;\n    (_a = this.eventListeners.get(type)) === null || _a === void 0 ? void 0 : _a.delete(listener);\n    if (this.eventListeners.size === 0) {\n      this.eventListeners.delete(type);\n    }\n  }\n  hasEventListener(type) {\n    return this.eventListeners.has(type);\n  }\n  clearEventListeners() {\n    this.eventListeners.clear();\n  }\n  fireEvent(event) {\n    var _a;\n    (_a = this.eventListeners.get(event.type)) === null || _a === void 0 ? void 0 : _a.forEach(listener => listener(event));\n  }\n}\nfunction extendDomain(values, domain = [Infinity, -Infinity]) {\n  for (const value of values) {\n    if (typeof value !== 'number') {\n      continue;\n    }\n    if (value < domain[0]) {\n      domain[0] = value;\n    }\n    if (value > domain[1]) {\n      domain[1] = value;\n    }\n  }\n  return domain;\n}\nfunction sumValues(values, accumulator = [0, 0]) {\n  for (const value of values) {\n    if (typeof value !== 'number') {\n      continue;\n    }\n    if (value < 0) {\n      accumulator[0] += value;\n    }\n    if (value > 0) {\n      accumulator[1] += value;\n    }\n  }\n  return accumulator;\n}\nfunction sum(scope, id, matchGroupId) {\n  const result = {\n    id,\n    scopes: [scope.id],\n    matchGroupIds: [matchGroupId],\n    type: 'aggregate',\n    aggregateFunction: values => sumValues(values)\n  };\n  return result;\n}\nfunction groupSum(scope, id, matchGroupId) {\n  return {\n    id,\n    scopes: [scope.id],\n    type: 'aggregate',\n    matchGroupIds: matchGroupId ? [matchGroupId] : undefined,\n    aggregateFunction: values => sumValues(values),\n    groupAggregateFunction: (next, acc = [0, 0]) => {\n      var _a, _b;\n      acc[0] += (_a = next === null || next === void 0 ? void 0 : next[0]) !== null && _a !== void 0 ? _a : 0;\n      acc[1] += (_b = next === null || next === void 0 ? void 0 : next[1]) !== null && _b !== void 0 ? _b : 0;\n      return acc;\n    }\n  };\n}\nfunction range(scope, id, matchGroupId) {\n  const result = {\n    id,\n    scopes: [scope.id],\n    matchGroupIds: [matchGroupId],\n    type: 'aggregate',\n    aggregateFunction: values => extendDomain(values)\n  };\n  return result;\n}\nfunction count(scope, id) {\n  const result = {\n    id,\n    scopes: [scope.id],\n    type: 'aggregate',\n    aggregateFunction: () => [0, 1]\n  };\n  return result;\n}\nfunction groupCount(scope, id) {\n  return {\n    id,\n    scopes: [scope.id],\n    type: 'aggregate',\n    aggregateFunction: () => [0, 1],\n    groupAggregateFunction: (next, acc = [0, 0]) => {\n      var _a, _b;\n      acc[0] += (_a = next === null || next === void 0 ? void 0 : next[0]) !== null && _a !== void 0 ? _a : 0;\n      acc[1] += (_b = next === null || next === void 0 ? void 0 : next[1]) !== null && _b !== void 0 ? _b : 0;\n      return acc;\n    }\n  };\n}\nfunction average(scope, id, matchGroupId) {\n  const result = {\n    id,\n    scopes: [scope.id],\n    matchGroupIds: [matchGroupId],\n    type: 'aggregate',\n    aggregateFunction: values => sumValues(values).map(v => v / values.length)\n  };\n  return result;\n}\nfunction groupAverage(scope, id, matchGroupId) {\n  const result = {\n    id,\n    scopes: [scope.id],\n    matchGroupIds: matchGroupId ? [matchGroupId] : undefined,\n    type: 'aggregate',\n    aggregateFunction: values => sumValues(values),\n    groupAggregateFunction: (next, acc = [0, 0, -1]) => {\n      var _a, _b;\n      acc[0] += (_a = next === null || next === void 0 ? void 0 : next[0]) !== null && _a !== void 0 ? _a : 0;\n      acc[1] += (_b = next === null || next === void 0 ? void 0 : next[1]) !== null && _b !== void 0 ? _b : 0;\n      acc[2]++;\n      return acc;\n    },\n    finalFunction: (acc = [0, 0, 0]) => {\n      const result = acc[0] + acc[1];\n      if (result >= 0) {\n        return [0, result / acc[2]];\n      }\n      return [result / acc[2], 0];\n    }\n  };\n  return result;\n}\nfunction area(scope, id, aggFn, matchGroupId) {\n  const result = {\n    id,\n    scopes: [scope.id],\n    matchGroupIds: matchGroupId ? [matchGroupId] : undefined,\n    type: 'aggregate',\n    aggregateFunction: (values, keyRange = []) => {\n      const keyWidth = keyRange[1] - keyRange[0];\n      return aggFn.aggregateFunction(values).map(v => v / keyWidth);\n    }\n  };\n  if (aggFn.groupAggregateFunction) {\n    result.groupAggregateFunction = aggFn.groupAggregateFunction;\n  }\n  return result;\n}\nfunction accumulatedValue(onlyPositive) {\n  return () => {\n    let value = 0;\n    return datum => {\n      if (typeof datum !== 'number') return datum;\n      if (isNaN(datum)) return datum;\n      value += onlyPositive ? Math.max(0, datum) : datum;\n      return value;\n    };\n  };\n}\nfunction trailingAccumulatedValue() {\n  return () => {\n    let value = 0;\n    return datum => {\n      if (typeof datum !== 'number') return datum;\n      if (isNaN(datum)) return datum;\n      const trailingValue = value;\n      value += datum;\n      return trailingValue;\n    };\n  };\n}\n\n/** Modes of matching user interactions to rendered nodes (e.g. hover or click) */\nvar SeriesNodePickMode;\n(function (SeriesNodePickMode) {\n  /** Pick matches based upon pick coordinates being inside a matching shape/marker. */\n  SeriesNodePickMode[SeriesNodePickMode[\"EXACT_SHAPE_MATCH\"] = 0] = \"EXACT_SHAPE_MATCH\";\n  /** Pick matches by nearest category/X-axis value, then distance within that category/X-value. */\n  SeriesNodePickMode[SeriesNodePickMode[\"NEAREST_BY_MAIN_AXIS_FIRST\"] = 1] = \"NEAREST_BY_MAIN_AXIS_FIRST\";\n  /** Pick matches by nearest category value, then distance within that category. */\n  SeriesNodePickMode[SeriesNodePickMode[\"NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST\"] = 2] = \"NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST\";\n  /** Pick matches based upon distance to ideal position */\n  SeriesNodePickMode[SeriesNodePickMode[\"NEAREST_NODE\"] = 3] = \"NEAREST_NODE\";\n})(SeriesNodePickMode || (SeriesNodePickMode = {}));\nfunction basicContinuousCheckDatumValidation(v) {\n  return checkDatum(v, true) != null;\n}\nfunction basicDiscreteCheckDatumValidation(v) {\n  return checkDatum(v, false) != null;\n}\nfunction keyProperty(scope, propName, continuous, opts = {}) {\n  const result = Object.assign({\n    scopes: [scope.id],\n    property: propName,\n    type: 'key',\n    valueType: continuous ? 'range' : 'category',\n    validation: continuous ? basicContinuousCheckDatumValidation : basicDiscreteCheckDatumValidation\n  }, opts);\n  return result;\n}\nfunction valueProperty(scope, propName, continuous, opts = {}) {\n  const result = Object.assign({\n    scopes: [scope.id],\n    property: propName,\n    type: 'value',\n    valueType: continuous ? 'range' : 'category',\n    validation: continuous ? basicContinuousCheckDatumValidation : basicDiscreteCheckDatumValidation\n  }, opts);\n  return result;\n}\nfunction rangedValueProperty(scope, propName, opts = {}) {\n  const {\n      min = -Infinity,\n      max = Infinity\n    } = opts,\n    defOpts = __rest(opts, [\"min\", \"max\"]);\n  return Object.assign({\n    scopes: [scope.id],\n    type: 'value',\n    property: propName,\n    valueType: 'range',\n    validation: basicContinuousCheckDatumValidation,\n    processor: () => datum => {\n      if (typeof datum !== 'number') return datum;\n      if (isNaN(datum)) return datum;\n      return Math.min(Math.max(datum, min), max);\n    }\n  }, defOpts);\n}\nfunction trailingValueProperty(scope, propName, continuous, opts = {}) {\n  const result = Object.assign(Object.assign({}, valueProperty(scope, propName, continuous, opts)), {\n    processor: trailingValue()\n  });\n  return result;\n}\nfunction trailingValue() {\n  return () => {\n    let value = 0;\n    return datum => {\n      const trailingValue = value;\n      value = datum;\n      return trailingValue;\n    };\n  };\n}\nfunction accumulativeValueProperty(scope, propName, continuous, opts = {}) {\n  const {\n      onlyPositive\n    } = opts,\n    defOpts = __rest(opts, [\"onlyPositive\"]);\n  const result = Object.assign(Object.assign({}, valueProperty(scope, propName, continuous, defOpts)), {\n    processor: accumulatedValue(onlyPositive)\n  });\n  return result;\n}\nfunction trailingAccumulatedValueProperty(scope, propName, continuous, opts = {}) {\n  const result = Object.assign(Object.assign({}, valueProperty(scope, propName, continuous, opts)), {\n    processor: trailingAccumulatedValue()\n  });\n  return result;\n}\nfunction groupAccumulativeValueProperty(scope, propName, continuous, mode, sum = 'current', opts) {\n  return [valueProperty(scope, propName, continuous, opts), accumulateGroup(scope, opts.groupId, mode, sum, opts.separateNegative)];\n}\nclass SeriesNodeClickEvent {\n  constructor(type, event, {\n    datum\n  }, series) {\n    this.type = type;\n    this.event = event;\n    this.datum = datum;\n    this.seriesId = series.id;\n  }\n}\nclass SeriesItemHighlightStyle {\n  constructor() {\n    this.fill = 'yellow';\n    this.fillOpacity = undefined;\n    this.stroke = undefined;\n    this.strokeWidth = undefined;\n    this.strokeOpacity = undefined;\n    this.lineDash = undefined;\n    this.lineDashOffset = undefined;\n  }\n}\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], SeriesItemHighlightStyle.prototype, \"fill\", void 0);\n__decorate([Validate(OPT_NUMBER(0, 1)), __metadata(\"design:type\", Number)], SeriesItemHighlightStyle.prototype, \"fillOpacity\", void 0);\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], SeriesItemHighlightStyle.prototype, \"stroke\", void 0);\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], SeriesItemHighlightStyle.prototype, \"strokeWidth\", void 0);\n__decorate([Validate(OPT_NUMBER(0, 1)), __metadata(\"design:type\", Number)], SeriesItemHighlightStyle.prototype, \"strokeOpacity\", void 0);\n__decorate([Validate(OPT_LINE_DASH), __metadata(\"design:type\", Array)], SeriesItemHighlightStyle.prototype, \"lineDash\", void 0);\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], SeriesItemHighlightStyle.prototype, \"lineDashOffset\", void 0);\nclass SeriesHighlightStyle {\n  constructor() {\n    this.strokeWidth = undefined;\n    this.dimOpacity = undefined;\n    this.enabled = undefined;\n  }\n}\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], SeriesHighlightStyle.prototype, \"strokeWidth\", void 0);\n__decorate([Validate(OPT_NUMBER(0, 1)), __metadata(\"design:type\", Number)], SeriesHighlightStyle.prototype, \"dimOpacity\", void 0);\n__decorate([Validate(OPT_BOOLEAN), __metadata(\"design:type\", Boolean)], SeriesHighlightStyle.prototype, \"enabled\", void 0);\nclass TextHighlightStyle {\n  constructor() {\n    this.color = 'black';\n  }\n}\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], TextHighlightStyle.prototype, \"color\", void 0);\nclass HighlightStyle {\n  constructor() {\n    this.item = new SeriesItemHighlightStyle();\n    this.series = new SeriesHighlightStyle();\n    this.text = new TextHighlightStyle();\n  }\n}\nvar SeriesHighlight;\n(function (SeriesHighlight) {\n  SeriesHighlight[SeriesHighlight[\"None\"] = 0] = \"None\";\n  SeriesHighlight[SeriesHighlight[\"This\"] = 1] = \"This\";\n  SeriesHighlight[SeriesHighlight[\"Other\"] = 2] = \"Other\";\n})(SeriesHighlight || (SeriesHighlight = {}));\nclass Series extends Observable {\n  get type() {\n    var _a;\n    return (_a = this.constructor.type) !== null && _a !== void 0 ? _a : '';\n  }\n  set data(input) {\n    this._data = input;\n    this.onDataChange();\n  }\n  get data() {\n    var _a;\n    return (_a = this._data) !== null && _a !== void 0 ? _a : this._chartData;\n  }\n  onDataChange() {\n    this.nodeDataRefresh = true;\n  }\n  setChartData(input) {\n    this._chartData = input;\n    if (this.data === input) {\n      this.onDataChange();\n    }\n  }\n  hasData() {\n    const {\n      data\n    } = this;\n    return data && (!Array.isArray(data) || data.length > 0);\n  }\n  set visible(value) {\n    this._visible = value;\n    this.visibleChanged();\n  }\n  get visible() {\n    return this._visible;\n  }\n  onSeriesGroupingChange(prev, next) {\n    const {\n      id,\n      type,\n      visible,\n      rootGroup,\n      highlightGroup,\n      annotationGroup\n    } = this;\n    if (prev) {\n      this.ctx.seriesStateManager.deregisterSeries({\n        id,\n        type\n      });\n    }\n    if (next) {\n      this.ctx.seriesStateManager.registerSeries({\n        id,\n        type,\n        visible,\n        seriesGrouping: next\n      });\n    }\n    // Short-circuit if series isn't already attached to the scene-graph yet.\n    if (this.rootGroup.parent == null) return;\n    this.ctx.seriesLayerManager.changeGroup({\n      id,\n      type,\n      rootGroup,\n      highlightGroup,\n      annotationGroup,\n      getGroupZIndexSubOrder: type => this.getGroupZIndexSubOrder(type),\n      seriesGrouping: next,\n      oldGrouping: prev\n    });\n  }\n  getBandScalePadding() {\n    return {\n      inner: 1,\n      outer: 0\n    };\n  }\n  constructor(seriesOpts) {\n    super();\n    this.NodeClickEvent = SeriesNodeClickEvent;\n    this.id = createId(this);\n    // The group node that contains all the nodes used to render this series.\n    this.rootGroup = new Group({\n      name: 'seriesRoot',\n      isVirtual: true\n    });\n    this.axes = {\n      [ChartAxisDirection.X]: undefined,\n      [ChartAxisDirection.Y]: undefined\n    };\n    this.directions = [ChartAxisDirection.X, ChartAxisDirection.Y];\n    // Flag to determine if we should recalculate node data.\n    this.nodeDataRefresh = true;\n    this._visible = true;\n    this.showInLegend = true;\n    this.cursor = 'default';\n    this.nodeClickRange = 'exact';\n    this.seriesGrouping = undefined;\n    this._declarationOrder = -1;\n    this.seriesListeners = new Listeners();\n    this.highlightStyle = new HighlightStyle();\n    this.moduleMap = new ModuleMap(this);\n    this.nodeDataDependencies = {};\n    this.ctx = seriesOpts.moduleCtx;\n    const {\n      useLabelLayer = false,\n      pickModes = [SeriesNodePickMode.NEAREST_BY_MAIN_AXIS_FIRST],\n      directionKeys = {},\n      directionNames = {},\n      contentGroupVirtual = true,\n      canHaveAxes = false\n    } = seriesOpts;\n    this.directionKeys = directionKeys;\n    this.directionNames = directionNames;\n    this.canHaveAxes = canHaveAxes;\n    this.contentGroup = this.rootGroup.appendChild(new Group({\n      name: `${this.id}-content`,\n      layer: !contentGroupVirtual,\n      isVirtual: contentGroupVirtual,\n      zIndex: Layers.SERIES_LAYER_ZINDEX,\n      zIndexSubOrder: this.getGroupZIndexSubOrder('data')\n    }));\n    this.highlightGroup = new Group({\n      name: `${this.id}-highlight`,\n      layer: !contentGroupVirtual,\n      isVirtual: contentGroupVirtual,\n      zIndex: Layers.SERIES_LAYER_ZINDEX,\n      zIndexSubOrder: this.getGroupZIndexSubOrder('highlight')\n    });\n    this.highlightNode = this.highlightGroup.appendChild(new Group({\n      name: 'highlightNode',\n      zIndex: 0\n    }));\n    this.highlightLabel = this.highlightGroup.appendChild(new Group({\n      name: 'highlightLabel',\n      zIndex: 10\n    }));\n    this.pickModes = pickModes;\n    this.labelGroup = this.rootGroup.appendChild(new Group({\n      name: `${this.id}-series-labels`,\n      layer: useLabelLayer,\n      zIndex: Layers.SERIES_LABEL_ZINDEX\n    }));\n    this.annotationGroup = new Group({\n      name: `${this.id}-annotation`,\n      layer: !contentGroupVirtual,\n      isVirtual: contentGroupVirtual,\n      zIndex: Layers.SERIES_LAYER_ZINDEX,\n      zIndexSubOrder: this.getGroupZIndexSubOrder('annotation')\n    });\n  }\n  getGroupZIndexSubOrder(type, subIndex = 0) {\n    let mainAdjust = 0;\n    switch (type) {\n      case 'data':\n      case 'paths':\n        break;\n      case 'labels':\n        mainAdjust += 20000;\n        break;\n      case 'marker':\n        mainAdjust += 10000;\n        break;\n      // Following cases are in their own layer, so need to be careful to respect declarationOrder.\n      case 'highlight':\n        subIndex += 15000;\n        break;\n      case 'annotation':\n        mainAdjust += 15000;\n        break;\n    }\n    const main = () => this._declarationOrder + mainAdjust;\n    return [main, subIndex];\n  }\n  addListener(type, listener) {\n    return this.seriesListeners.addListener(type, listener);\n  }\n  dispatch(type, event) {\n    return this.seriesListeners.dispatch(type, event);\n  }\n  addChartEventListeners() {\n    return;\n  }\n  destroy() {\n    this.ctx.seriesStateManager.deregisterSeries(this);\n    this.ctx.seriesLayerManager.releaseGroup(this);\n  }\n  getDirectionValues(direction, properties) {\n    const resolvedDirection = this.resolveKeyDirection(direction);\n    const keys = properties === null || properties === void 0 ? void 0 : properties[resolvedDirection];\n    const values = [];\n    if (!keys) return values;\n    const addValues = (...items) => {\n      for (const value of items) {\n        if (Array.isArray(value)) {\n          addValues(...value);\n        } else if (typeof value === 'object') {\n          addValues(...Object.values(value));\n        } else {\n          values.push(value);\n        }\n      }\n    };\n    addValues(...keys.map(key => this[key]));\n    return values;\n  }\n  getKeys(direction) {\n    return this.getDirectionValues(direction, this.directionKeys);\n  }\n  getNames(direction) {\n    return this.getDirectionValues(direction, this.directionNames);\n  }\n  resolveKeyDirection(direction) {\n    return direction;\n  }\n  // The union of the series domain ('community') and series-option domains ('enterprise').\n  getDomain(direction) {\n    var _a;\n    const seriesDomain = this.getSeriesDomain(direction);\n    const moduleDomains = (_a = this.dispatch('data-getDomain', {\n      direction\n    })) !== null && _a !== void 0 ? _a : [];\n    // Flatten the 2D moduleDomains into a 1D array and concatenate it with seriesDomain\n    return moduleDomains.reduce((total, current) => total.concat(current), seriesDomain);\n  }\n  // Indicate that something external changed and we should recalculate nodeData.\n  markNodeDataDirty() {\n    this.nodeDataRefresh = true;\n  }\n  visibleChanged() {\n    this.ctx.seriesStateManager.registerSeries(this);\n  }\n  getOpacity() {\n    const defaultOpacity = 1;\n    const {\n      dimOpacity = 1,\n      enabled = true\n    } = this.highlightStyle.series;\n    if (!enabled || dimOpacity === defaultOpacity) {\n      return defaultOpacity;\n    }\n    switch (this.isItemIdHighlighted()) {\n      case SeriesHighlight.None:\n      case SeriesHighlight.This:\n        return defaultOpacity;\n      case SeriesHighlight.Other:\n      default:\n        return dimOpacity;\n    }\n  }\n  getStrokeWidth(defaultStrokeWidth) {\n    const {\n      strokeWidth,\n      enabled = true\n    } = this.highlightStyle.series;\n    if (!enabled || strokeWidth === undefined) {\n      // No change in styling for highlight cases.\n      return defaultStrokeWidth;\n    }\n    switch (this.isItemIdHighlighted()) {\n      case SeriesHighlight.This:\n        return strokeWidth;\n      case SeriesHighlight.None:\n      case SeriesHighlight.Other:\n        return defaultStrokeWidth;\n    }\n  }\n  isItemIdHighlighted() {\n    var _a, _b;\n    const {\n      series\n    } = (_b = (_a = this.ctx.highlightManager) === null || _a === void 0 ? void 0 : _a.getActiveHighlight()) !== null && _b !== void 0 ? _b : {};\n    // Highlighting not active.\n    if (series == null) {\n      return SeriesHighlight.None;\n    }\n    // Highlighting active, this series not highlighted.\n    if (series !== this) {\n      return SeriesHighlight.Other;\n    }\n    return SeriesHighlight.This;\n  }\n  getModuleTooltipParams(datum) {\n    var _a;\n    const params = (_a = this.dispatch('tooltip-getParams', {\n      datum\n    })) !== null && _a !== void 0 ? _a : [];\n    return params.reduce((total, current) => {\n      return Object.assign(Object.assign({}, current), total);\n    }, {});\n  }\n  pickNode(point, limitPickModes) {\n    const {\n      pickModes,\n      visible,\n      rootGroup\n    } = this;\n    if (!visible || !rootGroup.visible) {\n      return;\n    }\n    for (const pickMode of pickModes) {\n      if (limitPickModes && !limitPickModes.includes(pickMode)) {\n        continue;\n      }\n      let match;\n      switch (pickMode) {\n        case SeriesNodePickMode.EXACT_SHAPE_MATCH:\n          match = this.pickNodeExactShape(point);\n          break;\n        case SeriesNodePickMode.NEAREST_BY_MAIN_AXIS_FIRST:\n        case SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST:\n          match = this.pickNodeMainAxisFirst(point, pickMode === SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST);\n          break;\n        case SeriesNodePickMode.NEAREST_NODE:\n          match = this.pickNodeClosestDatum(point);\n          break;\n      }\n      if (match) {\n        return {\n          pickMode,\n          match: match.datum,\n          distance: match.distance\n        };\n      }\n    }\n  }\n  pickNodeExactShape(point) {\n    const match = this.contentGroup.pickNode(point.x, point.y);\n    return match && {\n      datum: match.datum,\n      distance: 0\n    };\n  }\n  pickNodeClosestDatum(_point) {\n    // Override point for subclasses - but if this is invoked, the subclass specified it wants\n    // to use this feature.\n    throw new Error('AG Charts - Series.pickNodeClosestDatum() not implemented');\n  }\n  pickNodeMainAxisFirst(_point, _requireCategoryAxis) {\n    // Override point for subclasses - but if this is invoked, the subclass specified it wants\n    // to use this feature.\n    throw new Error('AG Charts - Series.pickNodeMainAxisFirst() not implemented');\n  }\n  fireNodeClickEvent(event, datum) {\n    this.fireEvent(new this.NodeClickEvent('nodeClick', event, datum, this));\n  }\n  fireNodeDoubleClickEvent(event, datum) {\n    this.fireEvent(new this.NodeClickEvent('nodeDoubleClick', event, datum, this));\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.visible = enabled;\n    this.nodeDataRefresh = true;\n    this.dispatch('visibility-changed', {\n      itemId,\n      enabled\n    });\n  }\n  isEnabled() {\n    return this.visible;\n  }\n  getModuleMap() {\n    return this.moduleMap;\n  }\n  createModuleContext() {\n    return Object.assign(Object.assign({}, this.ctx), {\n      series: this\n    });\n  }\n  getLabelText(label, params, defaultFormatter = String) {\n    var _a;\n    if (label.formatter) {\n      return (_a = this.ctx.callbackCache.call(label.formatter, Object.assign({\n        seriesId: this.id\n      }, params))) !== null && _a !== void 0 ? _a : defaultFormatter(params.value);\n    }\n    return defaultFormatter(params.value);\n  }\n  getMarkerStyle(marker, params, defaultStyle = marker.getStyle()) {\n    var _a, _b;\n    const defaultSize = {\n      size: (_b = (_a = params.datum.point) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0\n    };\n    const markerStyle = mergeDefaults(defaultSize, defaultStyle);\n    if (marker.formatter) {\n      const style = this.ctx.callbackCache.call(marker.formatter, Object.assign(Object.assign(Object.assign({\n        seriesId: this.id\n      }, markerStyle), params), {\n        datum: params.datum.datum\n      }));\n      return mergeDefaults(style, markerStyle);\n    }\n    return markerStyle;\n  }\n  updateMarkerStyle(markerNode, marker, params, defaultStyle = marker.getStyle(), {\n    applyTranslation = true\n  } = {}) {\n    const {\n      point\n    } = params.datum;\n    const activeStyle = this.getMarkerStyle(marker, params, defaultStyle);\n    const visible = this.visible && activeStyle.size > 0 && point && !isNaN(point.x) && !isNaN(point.y);\n    if (applyTranslation) {\n      markerNode.setProperties(Object.assign(Object.assign({\n        visible\n      }, activeStyle), {\n        translationX: point === null || point === void 0 ? void 0 : point.x,\n        translationY: point === null || point === void 0 ? void 0 : point.y\n      }));\n    } else {\n      markerNode.setProperties(Object.assign({\n        visible\n      }, activeStyle));\n    }\n    // Only for custom marker shapes\n    if (typeof marker.shape === 'function' && !markerNode.dirtyPath) {\n      markerNode.path.clear({\n        trackChanges: true\n      });\n      markerNode.updatePath();\n      markerNode.checkPathDirty();\n    }\n  }\n  getMinRect() {\n    return undefined;\n  }\n  checkResize(newSeriesRect) {\n    const newNodeDataDependencies = {\n      seriesRectWidth: newSeriesRect === null || newSeriesRect === void 0 ? void 0 : newSeriesRect.width,\n      seriesRectHeight: newSeriesRect === null || newSeriesRect === void 0 ? void 0 : newSeriesRect.height\n    };\n    const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n    if (resize) {\n      this.nodeDataDependencies = newNodeDataDependencies;\n      this.markNodeDataDirty();\n    }\n    return resize;\n  }\n}\nSeries.highlightedZIndex = 1000000000000;\n__decorate([Validate(STRING), __metadata(\"design:type\", Object)], Series.prototype, \"id\", void 0);\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Object)], Series.prototype, \"_visible\", void 0);\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Object)], Series.prototype, \"showInLegend\", void 0);\n__decorate([Validate(STRING), __metadata(\"design:type\", Object)], Series.prototype, \"cursor\", void 0);\n__decorate([Validate(INTERACTION_RANGE), __metadata(\"design:type\", Object)], Series.prototype, \"nodeClickRange\", void 0);\n__decorate([ActionOnSet({\n  changeValue: function (newVal, oldVal) {\n    this.onSeriesGroupingChange(oldVal, newVal);\n  }\n}), __metadata(\"design:type\", Object)], Series.prototype, \"seriesGrouping\", void 0);\nfunction seriesLabelFadeInAnimation({\n  id\n}, subId, animationManager, labelSelections) {\n  staticFromToMotion(id, subId, animationManager, labelSelections, {\n    opacity: 0\n  }, {\n    opacity: 1\n  }, LABEL_PHASE);\n}\nfunction seriesLabelFadeOutAnimation({\n  id\n}, subId, animationManager, labelSelections) {\n  staticFromToMotion(id, subId, animationManager, labelSelections, {\n    opacity: 1\n  }, {\n    opacity: 0\n  }, LABEL_PHASE);\n}\nfunction resetLabelFn(_node) {\n  return {\n    opacity: 1\n  };\n}\nconst CONSTANTS = {\n  periods: ['AM', 'PM'],\n  days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\n  shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\n  months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n  shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec']\n};\nfunction dayOfYear(date, startOfYear = new Date(date.getFullYear(), 0, 1)) {\n  const startOffset = date.getTimezoneOffset() - startOfYear.getTimezoneOffset();\n  const timeDiff = date.getTime() - startOfYear.getTime() + startOffset * 60000;\n  const timeOneDay = 3600000 * 24;\n  return Math.floor(timeDiff / timeOneDay);\n}\nfunction weekOfYear(date, startDay) {\n  const startOfYear = new Date(date.getFullYear(), 0, 1);\n  const startOfYearDay = startOfYear.getDay();\n  const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;\n  const startOffset = new Date(date.getFullYear(), 0, firstWeekStartOffset + 1);\n  if (startOffset <= date) {\n    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\n  }\n  // Days before week 1 are in week 0.\n  return 0;\n}\nconst SUNDAY = 0;\nconst MONDAY = 1;\nconst THURSDAY = 4;\nfunction isoWeekOfYear(date, year = date.getFullYear()) {\n  const firstOfYear = new Date(year, 0, 1);\n  const firstOfYearDay = firstOfYear.getDay();\n  const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;\n  const startOffset = new Date(year, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);\n  if (startOffset <= date) {\n    return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\n  }\n  // Days before week 1 are in week 52/53 of previous year.\n  return isoWeekOfYear(date, year - 1);\n}\nfunction timezone(date) {\n  const offset = date.getTimezoneOffset();\n  const unsignedOffset = Math.abs(offset);\n  const sign = offset > 0 ? '-' : '+';\n  return `${sign}${pad(Math.floor(unsignedOffset / 60), 2, '0')}${pad(Math.floor(unsignedOffset % 60), 2, '0')}`;\n}\nconst FORMATTERS = {\n  a: d => CONSTANTS.shortDays[d.getDay()],\n  A: d => CONSTANTS.days[d.getDay()],\n  b: d => CONSTANTS.shortMonths[d.getMonth()],\n  B: d => CONSTANTS.months[d.getMonth()],\n  c: '%x, %X',\n  d: (d, p) => pad(d.getDate(), 2, p !== null && p !== void 0 ? p : '0'),\n  e: '%_d',\n  f: (d, p) => pad(d.getMilliseconds() * 1000, 6, p !== null && p !== void 0 ? p : '0'),\n  H: (d, p) => pad(d.getHours(), 2, p !== null && p !== void 0 ? p : '0'),\n  I: (d, p) => {\n    const hours = d.getHours() % 12;\n    return hours === 0 ? '12' : pad(hours, 2, p !== null && p !== void 0 ? p : '0');\n  },\n  j: (d, p) => pad(dayOfYear(d) + 1, 3, p !== null && p !== void 0 ? p : '0'),\n  m: (d, p) => pad(d.getMonth() + 1, 2, p !== null && p !== void 0 ? p : '0'),\n  M: (d, p) => pad(d.getMinutes(), 2, p !== null && p !== void 0 ? p : '0'),\n  L: (d, p) => pad(d.getMilliseconds(), 3, p !== null && p !== void 0 ? p : '0'),\n  p: d => d.getHours() < 12 ? 'AM' : 'PM',\n  Q: d => String(d.getTime()),\n  s: d => String(Math.floor(d.getTime() / 1000)),\n  S: (d, p) => pad(d.getSeconds(), 2, p !== null && p !== void 0 ? p : '0'),\n  u: d => {\n    let day = d.getDay();\n    if (day < 1) day += 7;\n    return String(day % 7);\n  },\n  U: (d, p) => pad(weekOfYear(d, SUNDAY), 2, p !== null && p !== void 0 ? p : '0'),\n  V: (d, p) => pad(isoWeekOfYear(d), 2, p !== null && p !== void 0 ? p : '0'),\n  w: (d, p) => pad(d.getDay(), 2, p !== null && p !== void 0 ? p : '0'),\n  W: (d, p) => pad(weekOfYear(d, MONDAY), 2, p !== null && p !== void 0 ? p : '0'),\n  x: '%-m/%-d/%Y',\n  X: '%-I:%M:%S %p',\n  y: (d, p) => pad(d.getFullYear() % 100, 2, p !== null && p !== void 0 ? p : '0'),\n  Y: (d, p) => pad(d.getFullYear(), 4, p !== null && p !== void 0 ? p : '0'),\n  Z: d => timezone(d),\n  '%': () => '%'\n};\nconst PADS = {\n  _: ' ',\n  '0': '0',\n  '-': ''\n};\nfunction pad(value, size, padChar) {\n  const output = String(Math.floor(value));\n  if (output.length >= size) {\n    return output;\n  }\n  return `${padChar.repeat(size - output.length)}${output}`;\n}\nfunction buildFormatter(formatString) {\n  const formatParts = [];\n  while (formatString.length > 0) {\n    let nextEscapeIdx = formatString.indexOf('%');\n    if (nextEscapeIdx !== 0) {\n      const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;\n      formatParts.push(literalPart);\n    }\n    if (nextEscapeIdx < 0) break;\n    const maybePadSpecifier = formatString[nextEscapeIdx + 1];\n    const maybePad = PADS[maybePadSpecifier];\n    if (maybePad != null) {\n      nextEscapeIdx++;\n    }\n    const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];\n    const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];\n    if (typeof maybeFormatter === 'function') {\n      formatParts.push([maybeFormatter, maybePad]);\n    } else if (typeof maybeFormatter === 'string') {\n      const formatter = buildFormatter(maybeFormatter);\n      formatParts.push([formatter, maybePad]);\n    } else {\n      formatParts.push(`${maybePad !== null && maybePad !== void 0 ? maybePad : ''}${maybeFormatterSpecifier}`);\n    }\n    formatString = formatString.substring(nextEscapeIdx + 2);\n  }\n  return dateTime => {\n    const dateTimeAsDate = typeof dateTime === 'number' ? new Date(dateTime) : dateTime;\n    return formatParts.map(c => typeof c === 'string' ? c : c[0](dateTimeAsDate, c[1])).join('');\n  };\n}\nconst interpolatePattern = /(#\\{(.*?)\\})/g;\nfunction interpolate(input, values, formats) {\n  return input.replace(interpolatePattern, function (...args) {\n    const name = args[2];\n    const [valueName, formatName] = name.split(':');\n    const value = values[valueName];\n    if (typeof value === 'number') {\n      const format = formatName && formats && formats[formatName];\n      if (format) {\n        const {\n          locales,\n          options\n        } = format;\n        return value.toLocaleString(locales, options);\n      }\n      return String(value);\n    }\n    if (value instanceof Date) {\n      const format = formatName && formats && formats[formatName];\n      if (typeof format === 'string') {\n        const formatter = buildFormatter(format);\n        return formatter(value);\n      }\n      return value.toDateString();\n    }\n    if (typeof value === 'string' || (value === null || value === void 0 ? void 0 : value.toString)) {\n      return String(value);\n    }\n    return '';\n  });\n}\nfunction injectStyle(document, cssStyle) {\n  const styleElement = document.createElement('style');\n  styleElement.innerHTML = cssStyle;\n  // Make sure these styles are injected before other styles, so it can be overridden.\n  document.head.insertBefore(styleElement, document.head.querySelector('style'));\n}\nconst DEFAULT_TOOLTIP_CLASS = 'ag-chart-tooltip';\nconst DEFAULT_TOOLTIP_DARK_CLASS = 'ag-chart-dark-tooltip';\nconst defaultTooltipCss = `\n.${DEFAULT_TOOLTIP_CLASS} {\n    transition: transform 0.1s ease;\n    display: table;\n    position: fixed;\n    left: 0px;\n    top: 0px;\n    white-space: nowrap;\n    z-index: 99999;\n    font: 12px Verdana, sans-serif;\n    color: rgb(70, 70, 70);\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-no-interaction {\n    pointer-events: none;\n    user-select: none;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-no-animation {\n    transition: none !important;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-hidden {\n    visibility: hidden;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-title {\n    position: relative;\n    padding: 8px 14px;\n    border-top-left-radius: 2px;\n    border-top-right-radius: 2px;\n    color: white;\n    background-color: #888888;\n    z-index: 1;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-title:only-child {\n    border-bottom-left-radius: 2px;\n    border-bottom-right-radius: 2px;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-content {\n    padding: 6px 14px;\n    line-height: 1.7em;\n    background: white;\n    border-bottom-left-radius: 2px;\n    border-bottom-right-radius: 2px;\n    border: 1px solid rgba(0, 0, 0, 0.15);\n    overflow: hidden;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-arrow::before {\n    content: \"\";\n\n    position: absolute;\n    top: 100%;\n    left: 50%;\n    transform: translateX(-50%);\n\n    border: 5px solid #d9d9d9;\n\n    border-left-color: transparent;\n    border-right-color: transparent;\n    border-bottom-color: transparent;\n\n    width: 0;\n    height: 0;\n\n    margin: 0 auto;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-arrow::after {\n    content: \"\";\n\n    position: absolute;\n    top: calc(100% - 1px);\n    left: 50%;\n    transform: translateX(-50%);\n\n    border: 5px solid white;\n\n    border-left-color: transparent;\n    border-right-color: transparent;\n    border-bottom-color: transparent;\n\n    width: 0;\n    height: 0;\n\n    margin: 0 auto;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}.${DEFAULT_TOOLTIP_DARK_CLASS} {\n    color: white;\n    background: #15181c;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}.${DEFAULT_TOOLTIP_DARK_CLASS} .${DEFAULT_TOOLTIP_CLASS}-content {\n    border-color: rgba(255, 255, 255, 0.15);\n}\n\n.ag-chart-wrapper {\n    box-sizing: border-box;\n    overflow: hidden;\n}\n`;\nfunction toTooltipHtml(input, defaults) {\n  var _a, _b, _c;\n  if (typeof input === 'string') {\n    return input;\n  }\n  const {\n    content = (_a = defaults === null || defaults === void 0 ? void 0 : defaults.content) !== null && _a !== void 0 ? _a : '',\n    title = defaults === null || defaults === void 0 ? void 0 : defaults.title,\n    color = (_b = defaults === null || defaults === void 0 ? void 0 : defaults.color) !== null && _b !== void 0 ? _b : 'white',\n    backgroundColor = (_c = defaults === null || defaults === void 0 ? void 0 : defaults.backgroundColor) !== null && _c !== void 0 ? _c : '#888'\n  } = input;\n  const titleHtml = title ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-title\"\n        style=\"color: ${color}; background-color: ${backgroundColor}\">${title}</div>` : '';\n  const contentHtml = content ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-content\">${content}</div>` : '';\n  return `${titleHtml}${contentHtml}`;\n}\nconst POSITION_TYPES = ['pointer', 'node'];\nconst POSITION_TYPE = predicateWithMessage(v => POSITION_TYPES.includes(v), `expecting a position type keyword such as 'pointer' or 'node'`);\nclass TooltipPosition {\n  constructor() {\n    /** The type of positioning for the tooltip. By default, the tooltip follows the pointer. */\n    this.type = 'pointer';\n    /** The horizontal offset in pixels for the position of the tooltip. */\n    this.xOffset = 0;\n    /** The vertical offset in pixels for the position of the tooltip. */\n    this.yOffset = 0;\n  }\n}\n__decorate([Validate(POSITION_TYPE)\n/** The type of positioning for the tooltip. By default, the tooltip follows the pointer. */, __metadata(\"design:type\", String)], TooltipPosition.prototype, \"type\", void 0);\n__decorate([Validate(NUMBER$1())\n/** The horizontal offset in pixels for the position of the tooltip. */, __metadata(\"design:type\", Number)], TooltipPosition.prototype, \"xOffset\", void 0);\n__decorate([Validate(NUMBER$1())\n/** The vertical offset in pixels for the position of the tooltip. */, __metadata(\"design:type\", Number)], TooltipPosition.prototype, \"yOffset\", void 0);\nclass Tooltip {\n  constructor(canvasElement, document, window, container) {\n    this.enableInteraction = false;\n    this.enabled = true;\n    this.showArrow = undefined;\n    this.class = undefined;\n    this.lastClass = undefined;\n    this.delay = 0;\n    this.range = 'nearest';\n    this.lastVisibilityChange = Date.now();\n    this.position = new TooltipPosition();\n    this.showTimeout = 0;\n    this._showArrow = true;\n    this.tooltipRoot = container;\n    this.window = window;\n    const element = document.createElement('div');\n    this.element = this.tooltipRoot.appendChild(element);\n    this.element.classList.add(DEFAULT_TOOLTIP_CLASS);\n    this.canvasElement = canvasElement;\n    // Detect when the chart becomes invisible and hide the tooltip as well.\n    if (typeof IntersectionObserver !== 'undefined') {\n      const observer = new IntersectionObserver(entries => {\n        for (const entry of entries) {\n          if (entry.target === this.canvasElement && entry.intersectionRatio === 0) {\n            this.toggle(false);\n          }\n        }\n      }, {\n        root: this.tooltipRoot\n      });\n      observer.observe(this.canvasElement);\n      this.observer = observer;\n    }\n    if (Tooltip.tooltipDocuments.indexOf(document) < 0) {\n      injectStyle(document, defaultTooltipCss);\n      Tooltip.tooltipDocuments.push(document);\n    }\n  }\n  destroy() {\n    const {\n      parentNode\n    } = this.element;\n    if (parentNode) {\n      parentNode.removeChild(this.element);\n    }\n    if (this.observer) {\n      this.observer.unobserve(this.canvasElement);\n    }\n  }\n  isVisible() {\n    const {\n      element\n    } = this;\n    return !element.classList.contains(DEFAULT_TOOLTIP_CLASS + '-hidden');\n  }\n  updateClass(visible, showArrow) {\n    const {\n      element,\n      class: newClass,\n      lastClass,\n      enableInteraction,\n      lastVisibilityChange\n    } = this;\n    const wasVisible = this.isVisible();\n    const nowVisible = !!visible;\n    let timeSinceLastVisibilityChangeMs = Infinity;\n    if (wasVisible !== nowVisible) {\n      const now = Date.now();\n      timeSinceLastVisibilityChangeMs = now - lastVisibilityChange;\n      this.lastVisibilityChange = now;\n    }\n    const toggleClass = (name, include) => {\n      const className = `${DEFAULT_TOOLTIP_CLASS}-${name}`;\n      if (include) {\n        element.classList.add(className);\n      } else {\n        element.classList.remove(className);\n      }\n    };\n    // Time below which an animated move should be used.\n    const animatedMoveThresholdMs = 100;\n    // Time below which we should treat updates as indistinguishable to users, and we shouldn't\n    // adjust the `no-animation` CSS class.\n    const thrashingThresholdMs = 5;\n    // No animation on first show or if tooltip is disabled for a non-trivial amount of time.\n    // Don't change the `no-animation` class on fast update.\n    const noAnimation = !wasVisible && nowVisible && timeSinceLastVisibilityChangeMs > animatedMoveThresholdMs;\n    if (timeSinceLastVisibilityChangeMs > thrashingThresholdMs) {\n      toggleClass('no-animation', noAnimation);\n    }\n    toggleClass('no-interaction', !enableInteraction); // Prevent interaction.\n    toggleClass('hidden', !visible); // Hide if not visible.\n    toggleClass('arrow', !!showArrow); // Add arrow if tooltip is constrained.\n    if (newClass !== lastClass) {\n      if (lastClass) {\n        element.classList.remove(lastClass);\n      }\n      if (newClass) {\n        element.classList.add(newClass);\n      }\n      this.lastClass = newClass;\n    }\n  }\n  /**\r\n   * Shows tooltip at the given event's coordinates.\r\n   * If the `html` parameter is missing, moves the existing tooltip to the new position.\r\n   */\n  show(meta, html, instantly = false) {\n    var _a, _b, _c, _d, _e, _f, _g;\n    const {\n      element,\n      canvasElement\n    } = this;\n    if (html !== undefined) {\n      element.innerHTML = html;\n    } else if (!element.innerHTML) {\n      this.toggle(false);\n      return;\n    }\n    const limit = (low, actual, high) => {\n      return Math.max(Math.min(actual, high), low);\n    };\n    const xOffset = (_b = (_a = meta.position) === null || _a === void 0 ? void 0 : _a.xOffset) !== null && _b !== void 0 ? _b : 0;\n    const yOffset = (_d = (_c = meta.position) === null || _c === void 0 ? void 0 : _c.yOffset) !== null && _d !== void 0 ? _d : 0;\n    const canvasRect = canvasElement.getBoundingClientRect();\n    const naiveLeft = canvasRect.left + meta.offsetX - element.clientWidth / 2 + xOffset;\n    const naiveTop = canvasRect.top + meta.offsetY - element.clientHeight - 8 + yOffset;\n    const windowBounds = this.getWindowBoundingBox();\n    const maxLeft = windowBounds.x + windowBounds.width - element.clientWidth - 1;\n    const maxTop = windowBounds.y + windowBounds.height - element.clientHeight;\n    const left = limit(windowBounds.x, naiveLeft, maxLeft);\n    const top = limit(windowBounds.y, naiveTop, maxTop);\n    const constrained = left !== naiveLeft || top !== naiveTop;\n    const defaultShowArrow = !constrained && !xOffset && !yOffset;\n    const showArrow = (_f = (_e = meta.showArrow) !== null && _e !== void 0 ? _e : this.showArrow) !== null && _f !== void 0 ? _f : defaultShowArrow;\n    this.updateShowArrow(showArrow);\n    element.style.transform = `translate(${Math.round(left)}px, ${Math.round(top)}px)`;\n    this.enableInteraction = (_g = meta.enableInteraction) !== null && _g !== void 0 ? _g : false;\n    if (this.delay > 0 && !instantly) {\n      this.toggle(false);\n      this.showTimeout = this.window.setTimeout(() => {\n        this.toggle(true);\n      }, this.delay);\n      return;\n    }\n    this.toggle(true);\n  }\n  getWindowBoundingBox() {\n    return new BBox(0, 0, this.window.innerWidth, this.window.innerHeight);\n  }\n  toggle(visible) {\n    if (!visible) {\n      this.window.clearTimeout(this.showTimeout);\n    }\n    this.updateClass(visible, this._showArrow);\n  }\n  pointerLeftOntoTooltip(event) {\n    var _a;\n    if (!this.enableInteraction) return false;\n    const classList = (_a = event.sourceEvent.relatedTarget) === null || _a === void 0 ? void 0 : _a.classList;\n    const classes = ['', '-title', '-content'];\n    const classListContains = Boolean(classes.filter(c => classList === null || classList === void 0 ? void 0 : classList.contains(`${DEFAULT_TOOLTIP_CLASS}${c}`)));\n    return classList !== undefined && classListContains;\n  }\n  updateShowArrow(show) {\n    this._showArrow = show;\n  }\n}\nTooltip.tooltipDocuments = [];\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Boolean)], Tooltip.prototype, \"enabled\", void 0);\n__decorate([Validate(OPT_BOOLEAN), __metadata(\"design:type\", Boolean)], Tooltip.prototype, \"showArrow\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], Tooltip.prototype, \"class\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], Tooltip.prototype, \"delay\", void 0);\n__decorate([Validate(INTERACTION_RANGE), __metadata(\"design:type\", Object)], Tooltip.prototype, \"range\", void 0);\nclass SeriesTooltipInteraction {\n  constructor() {\n    this.enabled = false;\n  }\n}\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Object)], SeriesTooltipInteraction.prototype, \"enabled\", void 0);\nclass SeriesTooltip {\n  constructor() {\n    this.enabled = true;\n    this.showArrow = undefined;\n    this.format = undefined;\n    this.renderer = undefined;\n    this.interaction = new SeriesTooltipInteraction();\n    this.position = new TooltipPosition();\n  }\n  toTooltipHtml(defaults, params, overrides) {\n    var _a, _b;\n    const formatFn = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.format) !== null && _a !== void 0 ? _a : this.format;\n    const rendererFn = (_b = overrides === null || overrides === void 0 ? void 0 : overrides.renderer) !== null && _b !== void 0 ? _b : this.renderer;\n    if (formatFn) {\n      return toTooltipHtml({\n        content: interpolate(formatFn, params)\n      }, defaults);\n    }\n    if (rendererFn) {\n      return toTooltipHtml(rendererFn(params), defaults);\n    }\n    return toTooltipHtml(defaults);\n  }\n}\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Object)], SeriesTooltip.prototype, \"enabled\", void 0);\n__decorate([Validate(OPT_BOOLEAN), __metadata(\"design:type\", Boolean)], SeriesTooltip.prototype, \"showArrow\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], SeriesTooltip.prototype, \"format\", void 0);\n__decorate([Validate(OPT_FUNCTION), __metadata(\"design:type\", Function)], SeriesTooltip.prototype, \"renderer\", void 0);\nfunction preparePieSeriesAnimationFunctions(initialLoad, rotationDegrees, scaleFn, oldScaleFn) {\n  const scale = [scaleFn.convert(0), scaleFn.convert(1)];\n  const oldScale = [oldScaleFn.convert(0), oldScaleFn.convert(1)];\n  const rotation = Math.PI / -2 + toRadians(rotationDegrees);\n  const scaleToNewRadius = ({\n    radius\n  }) => {\n    return {\n      innerRadius: scale[0],\n      outerRadius: scale[0] + (scale[1] - scale[0]) * radius\n    };\n  };\n  const scaleToOldRadius = ({\n    radius\n  }) => {\n    return {\n      innerRadius: oldScale[0],\n      outerRadius: oldScale[0] + (oldScale[1] - oldScale[0]) * radius\n    };\n  };\n  const fromFn = (sect, datum, status, {\n    prevFromProps\n  }) => {\n    var _a, _b, _c, _d, _e, _f;\n    // Default to starting from current state.\n    let {\n      startAngle,\n      endAngle,\n      innerRadius,\n      outerRadius\n    } = sect;\n    let {\n      fill,\n      stroke\n    } = datum.sectorFormat;\n    if (status === 'unknown' || status === 'added' && !prevFromProps) {\n      // Start of animation (full new data) - sweep in.\n      startAngle = rotation;\n      endAngle = rotation;\n      innerRadius = datum.innerRadius;\n      outerRadius = datum.outerRadius;\n    } else if (status === 'added' && prevFromProps) {\n      startAngle = (_a = prevFromProps.endAngle) !== null && _a !== void 0 ? _a : rotation;\n      endAngle = (_b = prevFromProps.endAngle) !== null && _b !== void 0 ? _b : rotation;\n      innerRadius = (_c = prevFromProps.innerRadius) !== null && _c !== void 0 ? _c : datum.innerRadius;\n      outerRadius = (_d = prevFromProps.outerRadius) !== null && _d !== void 0 ? _d : datum.outerRadius;\n    }\n    if (status === 'added' && !initialLoad) {\n      const radii = scaleToOldRadius(datum);\n      innerRadius = radii.innerRadius;\n      outerRadius = radii.outerRadius;\n    }\n    if (status === 'updated') {\n      fill = (_e = sect.fill) !== null && _e !== void 0 ? _e : fill;\n      stroke = (_f = sect.stroke) !== null && _f !== void 0 ? _f : stroke;\n    }\n    return {\n      startAngle,\n      endAngle,\n      innerRadius,\n      outerRadius,\n      fill,\n      stroke\n    };\n  };\n  const toFn = (_sect, datum, status, {\n    prevLive\n  }) => {\n    var _a, _b;\n    // Default to moving to target state.\n    let {\n      startAngle,\n      endAngle,\n      innerRadius,\n      outerRadius\n    } = datum;\n    const {\n      stroke,\n      fill\n    } = datum.sectorFormat;\n    if (status === 'removed' && prevLive) {\n      startAngle = (_a = prevLive.datum) === null || _a === void 0 ? void 0 : _a.endAngle;\n      endAngle = (_b = prevLive.datum) === null || _b === void 0 ? void 0 : _b.endAngle;\n    } else if (status === 'removed' && !prevLive) {\n      startAngle = rotation;\n      endAngle = rotation;\n    }\n    if (status === 'removed') {\n      const radii = scaleToNewRadius(datum);\n      innerRadius = radii.innerRadius;\n      outerRadius = radii.outerRadius;\n    }\n    return {\n      startAngle,\n      endAngle,\n      outerRadius,\n      innerRadius,\n      stroke,\n      fill\n    };\n  };\n  const innerCircle = {\n    fromFn: (node, _datum) => {\n      var _a, _b, _c;\n      return {\n        size: (_c = (_b = (_a = node.previousDatum) === null || _a === void 0 ? void 0 : _a.radius) !== null && _b !== void 0 ? _b : node.size) !== null && _c !== void 0 ? _c : 0\n      };\n    },\n    toFn: (_node, datum) => {\n      var _a;\n      return {\n        size: (_a = datum.radius) !== null && _a !== void 0 ? _a : 0\n      };\n    }\n  };\n  return {\n    nodes: {\n      toFn,\n      fromFn\n    },\n    innerCircle\n  };\n}\nfunction resetPieSelectionsFn(_node, datum) {\n  return {\n    startAngle: datum.startAngle,\n    endAngle: datum.endAngle,\n    innerRadius: datum.innerRadius,\n    outerRadius: datum.outerRadius,\n    fill: datum.sectorFormat.fill,\n    stroke: datum.sectorFormat.stroke\n  };\n}\n\n/**\r\n * Implements a per-node reset.\r\n *\r\n * @param selections contains nodes to be reset\r\n * @param propsFn callback to determine per-node properties\r\n */\nfunction resetMotion(selectionsOrNodes, propsFn) {\n  const isNodes = isNodeArray(selectionsOrNodes);\n  const nodes = isNodes ? selectionsOrNodes : [];\n  const selections = !isNodes ? selectionsOrNodes : [];\n  for (const selection of selections) {\n    for (const node of selection.nodes()) {\n      const from = propsFn(node, node.datum);\n      node.setProperties(from);\n    }\n    selection.cleanup();\n  }\n  for (const node of nodes) {\n    const from = propsFn(node, node.datum);\n    node.setProperties(from);\n  }\n}\nvar resetMotion$1 = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  resetMotion: resetMotion\n});\nclass StateMachine {\n  constructor(initialState, states, preTransitionCb) {\n    this.states = states;\n    this.preTransitionCb = preTransitionCb;\n    this.debug = Debug.create(true, 'animation');\n    this.state = initialState;\n    this.debug(`%c${this.constructor.name} | init -> ${initialState}`, 'color: green');\n  }\n  transition(event, data) {\n    var _a, _b;\n    const currentStateConfig = this.states[this.state];\n    const destinationTransition = currentStateConfig === null || currentStateConfig === void 0 ? void 0 : currentStateConfig[event];\n    if (!destinationTransition) {\n      this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.state}`, 'color: grey');\n      return;\n    }\n    let destinationState = this.state;\n    if (typeof destinationTransition === 'string') {\n      destinationState = destinationTransition;\n    } else if (typeof destinationTransition === 'object') {\n      destinationState = destinationTransition.target;\n    }\n    this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${destinationState}`, 'color: green');\n    (_a = this.preTransitionCb) === null || _a === void 0 ? void 0 : _a.call(this, this.state, destinationState);\n    // Change the state before calling the transition action to allow the action to trigger a subsequent transition\n    this.state = destinationState;\n    if (typeof destinationTransition === 'function') {\n      destinationTransition(data);\n    } else if (typeof destinationTransition === 'object') {\n      (_b = destinationTransition.action) === null || _b === void 0 ? void 0 : _b.call(destinationTransition, data);\n    }\n    return this.state;\n  }\n}\nclass DataModelSeries extends Series {\n  isContinuous() {\n    var _a, _b;\n    const isContinuousX = ContinuousScale.is((_a = this.axes[ChartAxisDirection.X]) === null || _a === void 0 ? void 0 : _a.scale);\n    const isContinuousY = ContinuousScale.is((_b = this.axes[ChartAxisDirection.Y]) === null || _b === void 0 ? void 0 : _b.scale);\n    return {\n      isContinuousX,\n      isContinuousY\n    };\n  }\n  // Request data, but with message dispatching to series-options (modules).\n  requestDataModel(dataController, data, opts) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      // Merge properties of this series with properties of all the attached series-options\n      const props = opts.props;\n      const listenerProps = (_a = this.dispatch('data-prerequest', this.isContinuous())) !== null && _a !== void 0 ? _a : [];\n      for (const moreProps of listenerProps) {\n        props.push(...moreProps);\n      }\n      const {\n        dataModel,\n        processedData\n      } = yield dataController.request(this.id, data !== null && data !== void 0 ? data : [], Object.assign(Object.assign({}, opts), {\n        props\n      }));\n      this.dataModel = dataModel;\n      this.processedData = processedData;\n      this.dispatch('data-processed', {\n        dataModel,\n        processedData\n      });\n      return {\n        dataModel,\n        processedData\n      };\n    });\n  }\n  isProcessedDataAnimatable() {\n    var _a, _b;\n    const validationResults = (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.animationValidation;\n    if (!validationResults) return true;\n    const {\n      orderedKeys,\n      uniqueKeys\n    } = validationResults;\n    return !!orderedKeys && !!uniqueKeys;\n  }\n  checkProcessedDataAnimatable() {\n    if (!this.isProcessedDataAnimatable()) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n}\nclass PolarSeries extends DataModelSeries {\n  constructor(_a) {\n    var {\n        useLabelLayer = false,\n        pickModes = [SeriesNodePickMode.EXACT_SHAPE_MATCH],\n        canHaveAxes = false,\n        animationResetFns\n      } = _a,\n      opts = __rest(_a, [\"useLabelLayer\", \"pickModes\", \"canHaveAxes\", \"animationResetFns\"]);\n    super(Object.assign(Object.assign({}, opts), {\n      useLabelLayer,\n      pickModes,\n      contentGroupVirtual: false,\n      directionKeys: {\n        [ChartAxisDirection.X]: ['angleKey'],\n        [ChartAxisDirection.Y]: ['radiusKey']\n      },\n      directionNames: {\n        [ChartAxisDirection.X]: ['angleName'],\n        [ChartAxisDirection.Y]: ['radiusName']\n      },\n      canHaveAxes\n    }));\n    this.sectorGroup = this.contentGroup.appendChild(new Group());\n    this.itemSelection = Selection.select(this.sectorGroup, () => this.nodeFactory(), false);\n    this.labelSelection = Selection.select(this.labelGroup, Text, false);\n    this.highlightSelection = Selection.select(this.highlightGroup, () => this.nodeFactory());\n    /**\r\n     * The center of the polar series (for example, the center of a pie).\r\n     * If the polar chart has multiple series, all of them will have their\r\n     * center set to the same value as a result of the polar chart layout.\r\n     * The center coordinates are not supposed to be set by the user.\r\n     */\n    this.centerX = 0;\n    this.centerY = 0;\n    /**\r\n     * The maximum radius the series can use.\r\n     * This value is set automatically as a result of the polar chart layout\r\n     * and is not supposed to be set by the user.\r\n     */\n    this.radius = 0;\n    this.sectorGroup.zIndexSubOrder = [() => this._declarationOrder, 1];\n    this.animationResetFns = animationResetFns;\n    this.animationState = new StateMachine('empty', {\n      empty: {\n        update: {\n          target: 'ready',\n          action: data => this.animateEmptyUpdateReady(data)\n        }\n      },\n      ready: {\n        updateData: 'waiting',\n        clear: 'clearing',\n        highlight: data => this.animateReadyHighlight(data),\n        highlightMarkers: data => this.animateReadyHighlightMarkers(data),\n        resize: data => this.animateReadyResize(data)\n      },\n      waiting: {\n        update: {\n          target: 'ready',\n          action: data => this.animateWaitingUpdateReady(data)\n        }\n      },\n      clearing: {\n        update: {\n          target: 'empty',\n          action: data => this.animateClearingUpdateEmpty(data)\n        }\n      }\n    }, () => this.checkProcessedDataAnimatable());\n  }\n  getLabelData() {\n    return [];\n  }\n  computeLabelsBBox(_options, _seriesRect) {\n    return null;\n  }\n  resetAllAnimation() {\n    var _a;\n    const {\n      item,\n      label\n    } = (_a = this.animationResetFns) !== null && _a !== void 0 ? _a : {};\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    if (item) {\n      resetMotion([this.itemSelection, this.highlightSelection], item);\n    }\n    if (label) {\n      resetMotion([this.labelSelection], label);\n    }\n    this.itemSelection.cleanup();\n    this.labelSelection.cleanup();\n    this.highlightSelection.cleanup();\n  }\n  animateEmptyUpdateReady(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animateWaitingUpdateReady(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animateReadyHighlight(_data) {\n    var _a;\n    const {\n      item\n    } = (_a = this.animationResetFns) !== null && _a !== void 0 ? _a : {};\n    if (item) {\n      resetMotion([this.highlightSelection], item);\n    }\n  }\n  animateReadyHighlightMarkers(_data) {\n    // Override point for sub-classes.\n  }\n  animateReadyResize(_data) {\n    this.resetAllAnimation();\n  }\n  animateClearingUpdateEmpty(_data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation();\n  }\n  animationTransitionClear() {\n    this.animationState.transition('clear', this.getAnimationData());\n  }\n  getAnimationData(seriesRect) {\n    return {\n      seriesRect\n    };\n  }\n}\nclass PieSeriesNodeClickEvent extends SeriesNodeClickEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.angleKey = series.angleKey;\n    this.radiusKey = series.radiusKey;\n    this.calloutLabelKey = series.calloutLabelKey;\n    this.sectorLabelKey = series.sectorLabelKey;\n  }\n}\nvar PieNodeTag;\n(function (PieNodeTag) {\n  PieNodeTag[PieNodeTag[\"Sector\"] = 0] = \"Sector\";\n  PieNodeTag[PieNodeTag[\"Callout\"] = 1] = \"Callout\";\n  PieNodeTag[PieNodeTag[\"Label\"] = 2] = \"Label\";\n})(PieNodeTag || (PieNodeTag = {}));\nclass PieSeriesCalloutLabel extends Label {\n  constructor() {\n    super(...arguments);\n    this.offset = 3; // from the callout line\n    this.minAngle = 0; // in degrees\n    this.minSpacing = 4;\n    this.maxCollisionOffset = 50;\n    this.avoidCollisions = true;\n  }\n}\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], PieSeriesCalloutLabel.prototype, \"offset\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], PieSeriesCalloutLabel.prototype, \"minAngle\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], PieSeriesCalloutLabel.prototype, \"minSpacing\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], PieSeriesCalloutLabel.prototype, \"maxCollisionOffset\", void 0);\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Object)], PieSeriesCalloutLabel.prototype, \"avoidCollisions\", void 0);\nclass PieSeriesSectorLabel extends Label {\n  constructor() {\n    super(...arguments);\n    this.positionOffset = 0;\n    this.positionRatio = 0.5;\n  }\n}\n__decorate([Validate(NUMBER$1()), __metadata(\"design:type\", Object)], PieSeriesSectorLabel.prototype, \"positionOffset\", void 0);\n__decorate([Validate(NUMBER$1(0, 1)), __metadata(\"design:type\", Object)], PieSeriesSectorLabel.prototype, \"positionRatio\", void 0);\nclass PieSeriesCalloutLine {\n  constructor() {\n    this.length = 10;\n    this.strokeWidth = 1;\n  }\n}\n__decorate([Validate(OPT_COLOR_STRING_ARRAY), __metadata(\"design:type\", Array)], PieSeriesCalloutLine.prototype, \"colors\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], PieSeriesCalloutLine.prototype, \"length\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], PieSeriesCalloutLine.prototype, \"strokeWidth\", void 0);\nclass PieTitle extends Caption {\n  constructor() {\n    super(...arguments);\n    this.showInLegend = false;\n  }\n}\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Object)], PieTitle.prototype, \"showInLegend\", void 0);\nclass DoughnutInnerLabel extends Label {\n  constructor() {\n    super(...arguments);\n    this.text = '';\n    this.margin = 2;\n  }\n}\n__decorate([Validate(STRING), __metadata(\"design:type\", Object)], DoughnutInnerLabel.prototype, \"text\", void 0);\n__decorate([Validate(NUMBER$1()), __metadata(\"design:type\", Object)], DoughnutInnerLabel.prototype, \"margin\", void 0);\nclass DoughnutInnerCircle {\n  constructor() {\n    this.fill = 'transparent';\n    this.fillOpacity = 1;\n  }\n}\n__decorate([Validate(COLOR_STRING), __metadata(\"design:type\", Object)], DoughnutInnerCircle.prototype, \"fill\", void 0);\n__decorate([Validate(OPT_NUMBER(0, 1)), __metadata(\"design:type\", Object)], DoughnutInnerCircle.prototype, \"fillOpacity\", void 0);\nclass PieSeries extends PolarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      useLabelLayer: true,\n      animationResetFns: {\n        item: resetPieSelectionsFn,\n        label: resetLabelFn\n      }\n    });\n    this.previousRadiusScale = new LinearScale();\n    this.radiusScale = new LinearScale();\n    // The group node that contains the background graphics.\n    this.backgroundGroup = this.rootGroup.appendChild(new Group({\n      name: `${this.id}-background`,\n      layer: true,\n      zIndex: Layers.SERIES_BACKGROUND_ZINDEX\n    }));\n    this.innertCircleGroup = this.backgroundGroup.appendChild(new Group({\n      name: `${this.id}-innerCircle`\n    }));\n    this.nodeData = [];\n    // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.\n    this.seriesItemEnabled = [];\n    this.title = undefined;\n    this.calloutLabel = new PieSeriesCalloutLabel();\n    this.sectorLabel = new PieSeriesSectorLabel();\n    this.calloutLine = new PieSeriesCalloutLine();\n    this.tooltip = new SeriesTooltip();\n    /**\r\n     * The key of the numeric field to use to determine the angle (for example,\r\n     * a pie sector angle).\r\n     */\n    this.angleKey = '';\n    this.angleName = '';\n    this.innerLabels = [];\n    this.innerCircle = undefined;\n    /**\r\n     * The key of the numeric field to use to determine the radii of pie sectors.\r\n     * The largest value will correspond to the full radius and smaller values to\r\n     * proportionally smaller radii.\r\n     */\n    this.radiusKey = undefined;\n    this.radiusName = undefined;\n    this.radiusMin = undefined;\n    this.radiusMax = undefined;\n    this.calloutLabelKey = undefined;\n    this.calloutLabelName = undefined;\n    this.sectorLabelKey = undefined;\n    this.sectorLabelName = undefined;\n    this.legendItemKey = undefined;\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.formatter = undefined;\n    /**\r\n     * The series rotation in degrees.\r\n     */\n    this.rotation = 0;\n    this.outerRadiusOffset = 0;\n    this.outerRadiusRatio = 1;\n    this.innerRadiusOffset = 0;\n    this.innerRadiusRatio = 1;\n    this.strokeWidth = 1;\n    this.shadow = undefined;\n    this.highlightStyle = new HighlightStyle();\n    this.surroundingRadius = undefined;\n    this.NodeClickEvent = PieSeriesNodeClickEvent;\n    this.angleScale = new LinearScale();\n    // Each sector is a ratio of the whole, where all ratios add up to 1.\n    this.angleScale.domain = [0, 1];\n    // Add 90 deg to start the first pie at 12 o'clock.\n    this.angleScale.range = [-Math.PI, Math.PI].map(angle => angle + Math.PI / 2);\n    const pieCalloutLabels = new Group({\n      name: 'pieCalloutLabels'\n    });\n    const pieSectorLabels = new Group({\n      name: 'pieSectorLabels'\n    });\n    const innerLabels = new Group({\n      name: 'innerLabels'\n    });\n    this.labelGroup.append(pieCalloutLabels);\n    this.labelGroup.append(pieSectorLabels);\n    this.labelGroup.append(innerLabels);\n    this.calloutLabelSelection = Selection.select(pieCalloutLabels, Group);\n    this.sectorLabelSelection = Selection.select(pieSectorLabels, Text);\n    this.innerLabelsSelection = Selection.select(innerLabels, Text);\n    this.innerCircleSelection = Selection.select(this.innertCircleGroup, Circle);\n  }\n  addChartEventListeners() {\n    var _a;\n    (_a = this.ctx.chartEventManager) === null || _a === void 0 ? void 0 : _a.addListener('legend-item-click', event => this.onLegendItemClick(event));\n  }\n  visibleChanged() {\n    this.processSeriesItemEnabled();\n  }\n  processSeriesItemEnabled() {\n    var _a;\n    const {\n      data,\n      visible\n    } = this;\n    this.seriesItemEnabled = (_a = data === null || data === void 0 ? void 0 : data.map(() => visible)) !== null && _a !== void 0 ? _a : [];\n  }\n  nodeFactory() {\n    return new Sector();\n  }\n  getSeriesDomain(direction) {\n    if (direction === ChartAxisDirection.X) {\n      return this.angleScale.domain;\n    } else {\n      return this.radiusScale.domain;\n    }\n  }\n  processData(dataController) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      let {\n        data\n      } = this;\n      const {\n        angleKey,\n        radiusKey,\n        calloutLabelKey,\n        sectorLabelKey,\n        legendItemKey,\n        seriesItemEnabled\n      } = this;\n      if (angleKey == null || data == null) return;\n      const animationEnabled = !this.ctx.animationManager.isSkipped();\n      const extraKeyProps = [];\n      const extraProps = [];\n      // Order here should match `getDatumIdFromData()`.\n      if (legendItemKey) {\n        extraKeyProps.push(keyProperty(this, legendItemKey, false, {\n          id: `legendItemKey`\n        }));\n      } else if (calloutLabelKey) {\n        extraKeyProps.push(keyProperty(this, calloutLabelKey, false, {\n          id: `calloutLabelKey`\n        }));\n      } else if (sectorLabelKey) {\n        extraKeyProps.push(keyProperty(this, sectorLabelKey, false, {\n          id: `sectorLabelKey`\n        }));\n      }\n      if (radiusKey) {\n        extraProps.push(rangedValueProperty(this, radiusKey, {\n          id: 'radiusValue',\n          min: (_a = this.radiusMin) !== null && _a !== void 0 ? _a : 0,\n          max: this.radiusMax\n        }), valueProperty(this, radiusKey, true, {\n          id: `radiusRaw`\n        }),\n        // Raw value pass-through.\n        normalisePropertyTo(this, {\n          id: 'radiusValue'\n        }, [0, 1], 1, (_b = this.radiusMin) !== null && _b !== void 0 ? _b : 0, this.radiusMax));\n      }\n      if (calloutLabelKey) {\n        extraProps.push(valueProperty(this, calloutLabelKey, false, {\n          id: `calloutLabelValue`\n        }));\n      }\n      if (sectorLabelKey) {\n        extraProps.push(valueProperty(this, sectorLabelKey, false, {\n          id: `sectorLabelValue`\n        }));\n      }\n      if (legendItemKey) {\n        extraProps.push(valueProperty(this, legendItemKey, false, {\n          id: `legendItemValue`\n        }));\n      }\n      if (animationEnabled && this.processedData && extraKeyProps.length > 0) {\n        extraProps.push(diff(this.processedData));\n      }\n      extraProps.push(animationValidation(this));\n      data = data.map((d, idx) => seriesItemEnabled[idx] ? d : Object.assign(Object.assign({}, d), {\n        [angleKey]: 0\n      }));\n      yield this.requestDataModel(dataController, data, {\n        props: [...extraKeyProps, accumulativeValueProperty(this, angleKey, true, {\n          id: `angleValue`,\n          onlyPositive: true\n        }), valueProperty(this, angleKey, true, {\n          id: `angleRaw`\n        }), normalisePropertyTo(this, {\n          id: 'angleValue'\n        }, [0, 1], 0, 0), ...extraProps]\n      });\n      this.animationState.transition('updateData');\n    });\n  }\n  maybeRefreshNodeData() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.nodeDataRefresh) return;\n      const [{\n        nodeData = []\n      } = {}] = yield this.createNodeData();\n      this.nodeData = nodeData;\n      this.nodeDataRefresh = false;\n    });\n  }\n  getProcessedDataIndexes(dataModel) {\n    const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`).index;\n    const radiusIdx = this.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`).index : -1;\n    const calloutLabelIdx = this.calloutLabelKey ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`).index : -1;\n    const sectorLabelIdx = this.sectorLabelKey ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`).index : -1;\n    const legendItemIdx = this.legendItemKey ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`).index : -1;\n    return {\n      angleIdx,\n      radiusIdx,\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    };\n  }\n  createNodeData() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        id: seriesId,\n        processedData,\n        dataModel,\n        rotation,\n        angleScale\n      } = this;\n      if (!processedData || !dataModel || processedData.type !== 'ungrouped') return [];\n      const {\n        angleIdx,\n        radiusIdx,\n        calloutLabelIdx,\n        sectorLabelIdx,\n        legendItemIdx\n      } = this.getProcessedDataIndexes(dataModel);\n      let currentStart = 0;\n      const nodeData = processedData.data.map((group, index) => {\n        var _a;\n        const {\n          datum,\n          values\n        } = group;\n        const currentValue = values[angleIdx];\n        const startAngle = angleScale.convert(currentStart) + toRadians(rotation);\n        currentStart = currentValue;\n        const endAngle = angleScale.convert(currentStart) + toRadians(rotation);\n        const span = Math.abs(endAngle - startAngle);\n        const midAngle = startAngle + span / 2;\n        const angleValue = values[angleIdx + 1];\n        const radius = radiusIdx >= 0 ? (_a = values[radiusIdx]) !== null && _a !== void 0 ? _a : 1 : 1;\n        const radiusValue = radiusIdx >= 0 ? values[radiusIdx + 1] : undefined;\n        const legendItemValue = legendItemIdx >= 0 ? values[legendItemIdx] : undefined;\n        const labels = this.getLabels(datum, midAngle, span, true, values[calloutLabelIdx], values[sectorLabelIdx], legendItemValue);\n        const sectorFormat = this.getSectorFormat(datum, index, false);\n        return Object.assign({\n          itemId: index,\n          series: this,\n          datum,\n          index,\n          angleValue,\n          midAngle,\n          midCos: Math.cos(midAngle),\n          midSin: Math.sin(midAngle),\n          startAngle,\n          endAngle,\n          sectorFormat,\n          radiusValue,\n          radius,\n          innerRadius: Math.max(this.radiusScale.convert(0), 0),\n          outerRadius: Math.max(this.radiusScale.convert(radius), 0),\n          legendItemValue\n        }, labels);\n      });\n      return [{\n        itemId: seriesId,\n        nodeData,\n        labelData: nodeData\n      }];\n    });\n  }\n  getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {\n    const {\n      calloutLabel,\n      sectorLabel,\n      legendItemKey\n    } = this;\n    const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.calloutLabelKey : undefined;\n    const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.sectorLabelKey : undefined;\n    if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {\n      return {};\n    }\n    const labelFormatterParams = {\n      datum,\n      angleKey: this.angleKey,\n      angleName: this.angleName,\n      radiusKey: this.radiusKey,\n      radiusName: this.radiusName,\n      calloutLabelKey: this.calloutLabelKey,\n      calloutLabelName: this.calloutLabelName,\n      sectorLabelKey: this.sectorLabelKey,\n      sectorLabelName: this.sectorLabelName,\n      legendItemKey: this.legendItemKey\n    };\n    const result = {};\n    if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {\n      result.calloutLabel = Object.assign(Object.assign({}, this.getTextAlignment(midAngle)), {\n        text: this.getLabelText(calloutLabel, Object.assign(Object.assign({}, labelFormatterParams), {\n          value: calloutLabelValue\n        })),\n        hidden: false,\n        collisionTextAlign: undefined,\n        collisionOffsetY: 0,\n        box: undefined\n      });\n    }\n    if (sectorLabelKey) {\n      result.sectorLabel = {\n        text: this.getLabelText(sectorLabel, Object.assign(Object.assign({}, labelFormatterParams), {\n          value: sectorLabelValue\n        }))\n      };\n    }\n    if (legendItemKey != null && legendItemValue != null) {\n      result.legendItem = {\n        key: legendItemKey,\n        text: legendItemValue\n      };\n    }\n    return result;\n  }\n  getTextAlignment(midAngle) {\n    const quadrantTextOpts = [{\n      textAlign: 'center',\n      textBaseline: 'bottom'\n    }, {\n      textAlign: 'left',\n      textBaseline: 'middle'\n    }, {\n      textAlign: 'center',\n      textBaseline: 'hanging'\n    }, {\n      textAlign: 'right',\n      textBaseline: 'middle'\n    }];\n    const midAngle180 = normalizeAngle180(midAngle);\n    // Split the circle into quadrants like so: ⊗\n    const quadrantStart = -3 * Math.PI / 4; // same as `normalizeAngle180(toRadians(-135))`\n    const quadrantOffset = midAngle180 - quadrantStart;\n    const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));\n    const quadrantIndex = mod(quadrant, quadrantTextOpts.length);\n    return quadrantTextOpts[quadrantIndex];\n  }\n  getSectorFormat(datum, formatIndex, highlight) {\n    var _a, _b, _c, _d, _e;\n    const {\n      angleKey,\n      radiusKey,\n      fills,\n      strokes,\n      formatter,\n      id: seriesId,\n      ctx: {\n        callbackCache,\n        highlightManager\n      }\n    } = this;\n    const highlightedDatum = highlightManager.getActiveHighlight();\n    const isDatumHighlighted = highlight && (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.series) === this && formatIndex === highlightedDatum.itemId;\n    const {\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity\n    } = mergeDefaults(isDatumHighlighted && this.highlightStyle.item, {\n      fill: fills[formatIndex % fills.length],\n      fillOpacity: this.fillOpacity,\n      stroke: strokes[formatIndex % strokes.length],\n      strokeWidth: this.getStrokeWidth(this.strokeWidth),\n      strokeOpacity: this.getOpacity()\n    });\n    let format;\n    if (formatter) {\n      format = callbackCache.call(formatter, {\n        datum,\n        angleKey,\n        radiusKey,\n        fill,\n        stroke,\n        fills,\n        strokes,\n        strokeWidth,\n        highlighted: isDatumHighlighted,\n        seriesId\n      });\n    }\n    return {\n      fill: (_a = format === null || format === void 0 ? void 0 : format.fill) !== null && _a !== void 0 ? _a : fill,\n      fillOpacity: (_b = format === null || format === void 0 ? void 0 : format.fillOpacity) !== null && _b !== void 0 ? _b : fillOpacity,\n      stroke: (_c = format === null || format === void 0 ? void 0 : format.stroke) !== null && _c !== void 0 ? _c : stroke,\n      strokeWidth: (_d = format === null || format === void 0 ? void 0 : format.strokeWidth) !== null && _d !== void 0 ? _d : strokeWidth,\n      strokeOpacity: (_e = format === null || format === void 0 ? void 0 : format.strokeOpacity) !== null && _e !== void 0 ? _e : strokeOpacity\n    };\n  }\n  getInnerRadius() {\n    const {\n      radius,\n      innerRadiusRatio,\n      innerRadiusOffset\n    } = this;\n    const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;\n    if (innerRadius === radius || innerRadius < 0) {\n      return 0;\n    }\n    return innerRadius;\n  }\n  getOuterRadius() {\n    return Math.max(this.radius * this.outerRadiusRatio + this.outerRadiusOffset, 0);\n  }\n  updateRadiusScale(resize) {\n    const newRange = [this.getInnerRadius(), this.getOuterRadius()];\n    this.radiusScale.range = newRange;\n    if (resize) {\n      this.previousRadiusScale.range = newRange;\n    }\n    this.nodeData = this.nodeData.map(_a => {\n      var {\n          radius\n        } = _a,\n        d = __rest(_a, [\"radius\"]);\n      return Object.assign(Object.assign({}, d), {\n        radius,\n        innerRadius: Math.max(this.radiusScale.convert(0), 0),\n        outerRadius: Math.max(this.radiusScale.convert(radius), 0)\n      });\n    });\n  }\n  getTitleTranslationY() {\n    var _a, _b;\n    const outerRadius = Math.max(0, this.radiusScale.range[1]);\n    if (outerRadius === 0) {\n      return NaN;\n    }\n    const spacing = (_b = (_a = this.title) === null || _a === void 0 ? void 0 : _a.spacing) !== null && _b !== void 0 ? _b : 0;\n    const titleOffset = 2 + spacing;\n    const dy = Math.max(0, -outerRadius);\n    return -outerRadius - titleOffset - dy;\n  }\n  update({\n    seriesRect\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        title\n      } = this;\n      const newNodeDataDependencies = {\n        seriesRectWidth: seriesRect === null || seriesRect === void 0 ? void 0 : seriesRect.width,\n        seriesRectHeight: seriesRect === null || seriesRect === void 0 ? void 0 : seriesRect.height\n      };\n      const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\n      if (resize) {\n        this.nodeDataDependencies = newNodeDataDependencies;\n      }\n      yield this.maybeRefreshNodeData();\n      this.updateTitleNodes();\n      this.updateRadiusScale(resize);\n      this.contentGroup.translationX = this.centerX;\n      this.contentGroup.translationY = this.centerY;\n      this.highlightGroup.translationX = this.centerX;\n      this.highlightGroup.translationY = this.centerY;\n      this.backgroundGroup.translationX = this.centerX;\n      this.backgroundGroup.translationY = this.centerY;\n      if (this.labelGroup) {\n        this.labelGroup.translationX = this.centerX;\n        this.labelGroup.translationY = this.centerY;\n      }\n      if (title) {\n        const dy = this.getTitleTranslationY();\n        const titleBox = title.node.computeBBox();\n        title.node.visible = title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox, 0, dy);\n        title.node.translationY = isFinite(dy) ? dy : 0;\n      }\n      this.updateNodeMidPoint();\n      yield this.updateSelections();\n      yield this.updateNodes(seriesRect);\n    });\n  }\n  updateTitleNodes() {\n    var _a, _b;\n    const {\n      title,\n      oldTitle\n    } = this;\n    if (oldTitle !== title) {\n      if (oldTitle) {\n        (_a = this.labelGroup) === null || _a === void 0 ? void 0 : _a.removeChild(oldTitle.node);\n      }\n      if (title) {\n        title.node.textBaseline = 'bottom';\n        (_b = this.labelGroup) === null || _b === void 0 ? void 0 : _b.appendChild(title.node);\n      }\n      this.oldTitle = title;\n    }\n  }\n  updateNodeMidPoint() {\n    this.nodeData.forEach(d => {\n      const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;\n      d.midPoint = {\n        x: d.midCos * Math.max(0, radius),\n        y: d.midSin * Math.max(0, radius)\n      };\n    });\n  }\n  updateSelections() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.updateGroupSelection();\n      this.updateInnerCircleSelection();\n    });\n  }\n  updateGroupSelection() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        itemSelection,\n        highlightSelection,\n        calloutLabelSelection,\n        sectorLabelSelection,\n        innerLabelsSelection\n      } = this;\n      const update = (selection, clone) => {\n        let nodeData = this.nodeData;\n        if (clone) {\n          // Allow mutable sectorFormat, so formatted sector styles can be updated and varied\n          // between normal and highlighted cases.\n          nodeData = nodeData.map(datum => Object.assign(Object.assign({}, datum), {\n            sectorFormat: Object.assign({}, datum.sectorFormat)\n          }));\n        }\n        selection.update(nodeData);\n        if (this.ctx.animationManager.isSkipped()) {\n          selection.cleanup();\n        }\n      };\n      update(itemSelection, false);\n      update(highlightSelection, true);\n      calloutLabelSelection.update(this.nodeData, group => {\n        const line = new Line();\n        line.tag = PieNodeTag.Callout;\n        line.pointerEvents = PointerEvents.None;\n        group.appendChild(line);\n        const text = new Text();\n        text.tag = PieNodeTag.Label;\n        text.pointerEvents = PointerEvents.None;\n        group.appendChild(text);\n      });\n      sectorLabelSelection.update(this.nodeData, node => {\n        node.pointerEvents = PointerEvents.None;\n      });\n      innerLabelsSelection.update(this.innerLabels, node => {\n        node.pointerEvents = PointerEvents.None;\n      });\n    });\n  }\n  updateInnerCircleSelection() {\n    const {\n      innerCircle\n    } = this;\n    let radius = 0;\n    const innerRadius = this.getInnerRadius();\n    if (innerRadius > 0) {\n      const circleRadius = Math.min(innerRadius, this.getOuterRadius());\n      const antiAliasingPadding = 1;\n      radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);\n    }\n    const datums = innerCircle ? [{\n      radius\n    }] : [];\n    this.innerCircleSelection.update(datums);\n  }\n  updateNodes(seriesRect) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\n      const isVisible = this.seriesItemEnabled.indexOf(true) >= 0;\n      this.rootGroup.visible = isVisible;\n      this.backgroundGroup.visible = isVisible;\n      this.contentGroup.visible = isVisible;\n      this.highlightGroup.visible = isVisible && (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.series) === this;\n      if (this.labelGroup) {\n        this.labelGroup.visible = isVisible;\n      }\n      this.contentGroup.opacity = this.getOpacity();\n      this.innerCircleSelection.each((node, {\n        radius\n      }) => {\n        var _a, _b;\n        node.setProperties({\n          fill: (_a = this.innerCircle) === null || _a === void 0 ? void 0 : _a.fill,\n          opacity: (_b = this.innerCircle) === null || _b === void 0 ? void 0 : _b.fillOpacity,\n          size: radius\n        });\n      });\n      const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {\n        const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);\n        datum.sectorFormat.fill = format.fill;\n        datum.sectorFormat.stroke = format.stroke;\n        const animationDisabled = this.ctx.animationManager.isSkipped();\n        if (animationDisabled) {\n          sector.startAngle = datum.startAngle;\n          sector.endAngle = datum.endAngle;\n          sector.innerRadius = datum.innerRadius;\n          sector.outerRadius = datum.outerRadius;\n        }\n        if (isDatumHighlighted || animationDisabled) {\n          sector.fill = format.fill;\n          sector.stroke = format.stroke;\n        }\n        sector.strokeWidth = format.strokeWidth;\n        sector.fillOpacity = format.fillOpacity;\n        sector.strokeOpacity = this.strokeOpacity;\n        sector.lineDash = this.lineDash;\n        sector.lineDashOffset = this.lineDashOffset;\n        sector.fillShadow = this.shadow;\n        sector.lineJoin = 'round';\n      };\n      this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\n      this.highlightSelection.each((node, datum, index) => {\n        const isDatumHighlighted = (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.series) === this && node.datum.itemId === highlightedDatum.itemId;\n        updateSectorFn(node, datum, index, isDatumHighlighted);\n        node.visible = isDatumHighlighted;\n      });\n      this.updateCalloutLineNodes();\n      this.updateCalloutLabelNodes(seriesRect);\n      this.updateSectorLabelNodes();\n      this.updateInnerLabelNodes();\n      this.animationState.transition('update');\n    });\n  }\n  updateCalloutLineNodes() {\n    var _a;\n    const {\n      calloutLine\n    } = this;\n    const calloutLength = calloutLine.length;\n    const calloutStrokeWidth = calloutLine.strokeWidth;\n    const calloutColors = (_a = calloutLine.colors) !== null && _a !== void 0 ? _a : this.strokes;\n    const {\n      offset\n    } = this.calloutLabel;\n    this.calloutLabelSelection.selectByTag(PieNodeTag.Callout).forEach((line, index) => {\n      const datum = line.datum;\n      const {\n        calloutLabel: label,\n        outerRadius\n      } = datum;\n      if ((label === null || label === void 0 ? void 0 : label.text) && !label.hidden && outerRadius !== 0) {\n        line.visible = true;\n        line.strokeWidth = calloutStrokeWidth;\n        line.stroke = calloutColors[index % calloutColors.length];\n        line.fill = undefined;\n        const x1 = datum.midCos * outerRadius;\n        const y1 = datum.midSin * outerRadius;\n        let x2 = datum.midCos * (outerRadius + calloutLength);\n        let y2 = datum.midSin * (outerRadius + calloutLength);\n        const isMoved = label.collisionTextAlign || label.collisionOffsetY !== 0;\n        if (isMoved && label.box != null) {\n          // Get the closest point to the text bounding box\n          const box = label.box;\n          let cx = x2;\n          let cy = y2;\n          if (x2 < box.x) {\n            cx = box.x;\n          } else if (x2 > box.x + box.width) {\n            cx = box.x + box.width;\n          }\n          if (y2 < box.y) {\n            cy = box.y;\n          } else if (y2 > box.y + box.height) {\n            cy = box.y + box.height;\n          }\n          // Apply label offset\n          const dx = cx - x2;\n          const dy = cy - y2;\n          const length = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          const paddedLength = length - offset;\n          if (paddedLength > 0) {\n            x2 = x2 + dx * paddedLength / length;\n            y2 = y2 + dy * paddedLength / length;\n          }\n        }\n        line.x1 = x1;\n        line.y1 = y1;\n        line.x2 = x2;\n        line.y2 = y2;\n      } else {\n        line.visible = false;\n      }\n    });\n  }\n  getLabelOverflow(text, box, seriesRect) {\n    const seriesLeft = seriesRect.x - this.centerX;\n    const seriesRight = seriesRect.x + seriesRect.width - this.centerX;\n    const seriesTop = seriesRect.y - this.centerY;\n    const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;\n    const errPx = 1; // Prevents errors related to floating point calculations\n    let visibleTextPart = 1;\n    if (box.x + errPx < seriesLeft) {\n      visibleTextPart = (box.x + box.width - seriesLeft) / box.width;\n    } else if (box.x + box.width - errPx > seriesRight) {\n      visibleTextPart = (seriesRight - box.x) / box.width;\n    }\n    const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;\n    const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;\n    const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);\n    return {\n      textLength,\n      hasVerticalOverflow,\n      hasSurroundingSeriesOverflow\n    };\n  }\n  bboxIntersectsSurroundingSeries(box, dx = 0, dy = 0) {\n    const {\n      surroundingRadius\n    } = this;\n    if (surroundingRadius == null) {\n      return false;\n    }\n    const corners = [{\n      x: box.x + dx,\n      y: box.y + dy\n    }, {\n      x: box.x + box.width + dx,\n      y: box.y + dy\n    }, {\n      x: box.x + box.width + dx,\n      y: box.y + box.height + dy\n    }, {\n      x: box.x + dx,\n      y: box.y + box.height + dy\n    }];\n    const sur2 = Math.pow(surroundingRadius, 2);\n    return corners.some(corner => Math.pow(corner.x, 2) + Math.pow(corner.y, 2) > sur2);\n  }\n  computeCalloutLabelCollisionOffsets() {\n    const {\n      radiusScale,\n      calloutLabel,\n      calloutLine\n    } = this;\n    const {\n      offset,\n      minSpacing\n    } = calloutLabel;\n    const innerRadius = radiusScale.convert(0);\n    const shouldSkip = datum => {\n      const label = datum.calloutLabel;\n      return !label || datum.outerRadius === 0;\n    };\n    const fullData = this.nodeData;\n    const data = this.nodeData.filter(t => !shouldSkip(t));\n    data.forEach(datum => {\n      const label = datum.calloutLabel;\n      if (label == null) return;\n      label.hidden = false;\n      label.collisionTextAlign = undefined;\n      label.collisionOffsetY = 0;\n    });\n    if (data.length <= 1) {\n      return;\n    }\n    const leftLabels = data.filter(d => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);\n    const rightLabels = data.filter(d => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);\n    const topLabels = data.filter(d => {\n      var _a;\n      return d.midSin < 0 && ((_a = d.calloutLabel) === null || _a === void 0 ? void 0 : _a.textAlign) === 'center';\n    }).sort((a, b) => a.midCos - b.midCos);\n    const bottomLabels = data.filter(d => {\n      var _a;\n      return d.midSin >= 0 && ((_a = d.calloutLabel) === null || _a === void 0 ? void 0 : _a.textAlign) === 'center';\n    }).sort((a, b) => a.midCos - b.midCos);\n    const tempTextNode = new Text();\n    const getTextBBox = datum => {\n      var _a;\n      const label = datum.calloutLabel;\n      if (label == null) return new BBox(0, 0, 0, 0);\n      const labelRadius = datum.outerRadius + calloutLine.length + offset;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.calloutLabel);\n      tempTextNode.setAlign({\n        textAlign: (_a = label.collisionTextAlign) !== null && _a !== void 0 ? _a : label.textAlign,\n        textBaseline: label.textBaseline\n      });\n      return tempTextNode.computeBBox();\n    };\n    const avoidNeighbourYCollision = (label, next, direction) => {\n      const box = getTextBBox(label).grow(minSpacing / 2);\n      const other = getTextBBox(next).grow(minSpacing / 2);\n      // The full collision is not detected, because sometimes\n      // the next label can appear behind the label with offset\n      const collidesOrBehind = box.x < other.x + other.width && box.x + box.width > other.x && (direction === 'to-top' ? box.y < other.y + other.height : box.y + box.height > other.y);\n      if (collidesOrBehind) {\n        const dy = direction === 'to-top' ? box.y - other.y - other.height : box.y + box.height - other.y;\n        next.calloutLabel.collisionOffsetY = dy;\n      }\n    };\n    const avoidYCollisions = labels => {\n      const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];\n      const midIndex = labels.indexOf(midLabel);\n      for (let i = midIndex - 1; i >= 0; i--) {\n        const prev = labels[i + 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, 'to-top');\n      }\n      for (let i = midIndex + 1; i < labels.length; i++) {\n        const prev = labels[i - 1];\n        const next = labels[i];\n        avoidNeighbourYCollision(prev, next, 'to-bottom');\n      }\n    };\n    const avoidXCollisions = labels => {\n      const labelsCollideLabelsByY = data.some(datum => datum.calloutLabel.collisionOffsetY !== 0);\n      const boxes = labels.map(label => getTextBBox(label));\n      const paddedBoxes = boxes.map(box => box.clone().grow(minSpacing / 2));\n      let labelsCollideLabelsByX = false;\n      for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {\n        const box = paddedBoxes[i];\n        for (let j = i + 1; j < labels.length; j++) {\n          const other = paddedBoxes[j];\n          if (box.collidesBBox(other)) {\n            labelsCollideLabelsByX = true;\n            break;\n          }\n        }\n      }\n      const sectors = fullData.map(datum => {\n        const {\n          startAngle,\n          endAngle,\n          outerRadius\n        } = datum;\n        return {\n          startAngle,\n          endAngle,\n          innerRadius,\n          outerRadius\n        };\n      });\n      const labelsCollideSectors = boxes.some(box => {\n        return sectors.some(sector => boxCollidesSector(box, sector));\n      });\n      if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {\n        return;\n      }\n      labels.filter(d => d.calloutLabel.textAlign === 'center').forEach(d => {\n        const label = d.calloutLabel;\n        if (d.midCos < 0) {\n          label.collisionTextAlign = 'right';\n        } else if (d.midCos > 0) {\n          label.collisionTextAlign = 'left';\n        } else {\n          label.collisionTextAlign = 'center';\n        }\n      });\n    };\n    avoidYCollisions(leftLabels);\n    avoidYCollisions(rightLabels);\n    avoidXCollisions(topLabels);\n    avoidXCollisions(bottomLabels);\n  }\n  updateCalloutLabelNodes(seriesRect) {\n    const {\n      radiusScale,\n      calloutLabel,\n      calloutLine\n    } = this;\n    const calloutLength = calloutLine.length;\n    const {\n      offset,\n      color\n    } = calloutLabel;\n    const tempTextNode = new Text();\n    this.calloutLabelSelection.selectByTag(PieNodeTag.Label).forEach(text => {\n      var _a;\n      const {\n        datum\n      } = text;\n      const label = datum.calloutLabel;\n      const radius = radiusScale.convert(datum.radius);\n      const outerRadius = Math.max(0, radius);\n      if (!(label === null || label === void 0 ? void 0 : label.text) || outerRadius === 0 || label.hidden) {\n        text.visible = false;\n        return;\n      }\n      const labelRadius = outerRadius + calloutLength + offset;\n      const x = datum.midCos * labelRadius;\n      const y = datum.midSin * labelRadius + label.collisionOffsetY;\n      // Detect text overflow\n      const align = {\n        textAlign: (_a = label.collisionTextAlign) !== null && _a !== void 0 ? _a : label.textAlign,\n        textBaseline: label.textBaseline\n      };\n      tempTextNode.text = label.text;\n      tempTextNode.x = x;\n      tempTextNode.y = y;\n      tempTextNode.setFont(this.calloutLabel);\n      tempTextNode.setAlign(align);\n      const box = tempTextNode.computeBBox();\n      let displayText = label.text;\n      let visible = true;\n      if (calloutLabel.avoidCollisions) {\n        const {\n          textLength,\n          hasVerticalOverflow\n        } = this.getLabelOverflow(label.text, box, seriesRect);\n        displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}…`;\n        visible = !hasVerticalOverflow;\n      }\n      text.text = displayText;\n      text.x = x;\n      text.y = y;\n      text.setFont(this.calloutLabel);\n      text.setAlign(align);\n      text.fill = color;\n      text.visible = visible;\n    });\n  }\n  computeLabelsBBox(options, seriesRect) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        calloutLabel,\n        calloutLine\n      } = this;\n      const calloutLength = calloutLine.length;\n      const {\n        offset,\n        maxCollisionOffset,\n        minSpacing\n      } = calloutLabel;\n      if (!calloutLabel.avoidCollisions) {\n        return null;\n      }\n      yield this.maybeRefreshNodeData();\n      this.updateRadiusScale(false);\n      this.computeCalloutLabelCollisionOffsets();\n      const textBoxes = [];\n      const text = new Text();\n      let titleBox;\n      if (((_a = this.title) === null || _a === void 0 ? void 0 : _a.text) && this.title.enabled) {\n        const dy = this.getTitleTranslationY();\n        if (isFinite(dy)) {\n          text.text = this.title.text;\n          text.x = 0;\n          text.y = dy;\n          text.setFont(this.title);\n          text.setAlign({\n            textBaseline: 'bottom',\n            textAlign: 'center'\n          });\n          titleBox = text.computeBBox();\n          textBoxes.push(titleBox);\n        }\n      }\n      this.nodeData.forEach(datum => {\n        var _a;\n        const label = datum.calloutLabel;\n        if (!label || datum.outerRadius === 0) {\n          return null;\n        }\n        const labelRadius = datum.outerRadius + calloutLength + offset;\n        const x = datum.midCos * labelRadius;\n        const y = datum.midSin * labelRadius + label.collisionOffsetY;\n        text.text = label.text;\n        text.x = x;\n        text.y = y;\n        text.setFont(this.calloutLabel);\n        text.setAlign({\n          textAlign: (_a = label.collisionTextAlign) !== null && _a !== void 0 ? _a : label.textAlign,\n          textBaseline: label.textBaseline\n        });\n        const box = text.computeBBox();\n        label.box = box;\n        // Hide labels that where pushed too far by the collision avoidance algorithm\n        if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {\n          label.hidden = true;\n          return;\n        }\n        // Hide labels intersecting or above the title\n        if (titleBox) {\n          const seriesTop = seriesRect.y - this.centerY;\n          const titleCleanArea = new BBox(titleBox.x - minSpacing, seriesTop, titleBox.width + 2 * minSpacing, titleBox.y + titleBox.height + minSpacing - seriesTop);\n          if (box.collidesBBox(titleCleanArea)) {\n            label.hidden = true;\n            return;\n          }\n        }\n        if (options.hideWhenNecessary) {\n          const {\n            textLength,\n            hasVerticalOverflow,\n            hasSurroundingSeriesOverflow\n          } = this.getLabelOverflow(label.text, box, seriesRect);\n          const isTooShort = label.text.length > 2 && textLength < 2;\n          if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {\n            label.hidden = true;\n            return;\n          }\n        }\n        label.hidden = false;\n        textBoxes.push(box);\n      });\n      if (textBoxes.length === 0) {\n        return null;\n      }\n      return BBox.merge(textBoxes);\n    });\n  }\n  updateSectorLabelNodes() {\n    const {\n      radiusScale\n    } = this;\n    const innerRadius = radiusScale.convert(0);\n    const {\n      fontSize,\n      fontStyle,\n      fontWeight,\n      fontFamily,\n      positionOffset,\n      positionRatio,\n      color\n    } = this.sectorLabel;\n    const isDoughnut = innerRadius > 0;\n    const singleVisibleSector = this.seriesItemEnabled.filter(Boolean).length === 1;\n    this.sectorLabelSelection.each((text, datum) => {\n      const {\n        sectorLabel,\n        outerRadius\n      } = datum;\n      let isTextVisible = false;\n      if (sectorLabel && outerRadius !== 0) {\n        const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;\n        text.fill = color;\n        text.fontStyle = fontStyle;\n        text.fontWeight = fontWeight;\n        text.fontSize = fontSize;\n        text.fontFamily = fontFamily;\n        text.text = sectorLabel.text;\n        const shouldPutTextInCenter = !isDoughnut && singleVisibleSector;\n        if (shouldPutTextInCenter) {\n          text.x = 0;\n          text.y = 0;\n        } else {\n          text.x = datum.midCos * labelRadius;\n          text.y = datum.midSin * labelRadius;\n        }\n        text.textAlign = 'center';\n        text.textBaseline = 'middle';\n        const bbox = text.computeBBox();\n        const corners = [[bbox.x, bbox.y], [bbox.x + bbox.width, bbox.y], [bbox.x + bbox.width, bbox.y + bbox.height], [bbox.x, bbox.y + bbox.height]];\n        const {\n          startAngle,\n          endAngle\n        } = datum;\n        const sectorBounds = {\n          startAngle,\n          endAngle,\n          innerRadius,\n          outerRadius\n        };\n        if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {\n          isTextVisible = true;\n        }\n      }\n      text.visible = isTextVisible;\n    });\n  }\n  updateInnerLabelNodes() {\n    const textBBoxes = [];\n    const margins = [];\n    this.innerLabelsSelection.each((text, datum) => {\n      const {\n        fontStyle,\n        fontWeight,\n        fontSize,\n        fontFamily,\n        color\n      } = datum;\n      text.fontStyle = fontStyle;\n      text.fontWeight = fontWeight;\n      text.fontSize = fontSize;\n      text.fontFamily = fontFamily;\n      text.text = datum.text;\n      text.x = 0;\n      text.y = 0;\n      text.fill = color;\n      text.textAlign = 'center';\n      text.textBaseline = 'alphabetic';\n      textBBoxes.push(text.computeBBox());\n      margins.push(datum.margin);\n    });\n    const getMarginTop = index => index === 0 ? 0 : margins[index];\n    const getMarginBottom = index => index === margins.length - 1 ? 0 : margins[index];\n    const totalHeight = textBBoxes.reduce((sum, bbox, i) => {\n      return sum + bbox.height + getMarginTop(i) + getMarginBottom(i);\n    }, 0);\n    const totalWidth = Math.max(...textBBoxes.map(bbox => bbox.width));\n    const innerRadius = this.getInnerRadius();\n    const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));\n    const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());\n    const textBottoms = [];\n    for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {\n      const bbox = textBBoxes[i];\n      const bottom = bbox.height + prev + getMarginTop(i);\n      textBottoms.push(bottom);\n      prev = bottom + getMarginBottom(i);\n    }\n    this.innerLabelsSelection.each((text, _datum, index) => {\n      text.y = textBottoms[index];\n      text.visible = labelsVisible;\n    });\n  }\n  getDatumLegendName(nodeDatum) {\n    const {\n      angleKey,\n      calloutLabelKey,\n      sectorLabelKey,\n      legendItemKey\n    } = this;\n    const {\n      sectorLabel,\n      calloutLabel,\n      legendItem\n    } = nodeDatum;\n    if (legendItemKey && legendItem !== undefined) {\n      return legendItem.text;\n    } else if (calloutLabelKey && calloutLabelKey !== angleKey && (calloutLabel === null || calloutLabel === void 0 ? void 0 : calloutLabel.text) !== undefined) {\n      return calloutLabel.text;\n    } else if (sectorLabelKey && sectorLabelKey !== angleKey && (sectorLabel === null || sectorLabel === void 0 ? void 0 : sectorLabel.text) !== undefined) {\n      return sectorLabel.text;\n    }\n  }\n  getTooltipHtml(nodeDatum) {\n    var _a;\n    if (!this.angleKey) {\n      return '';\n    }\n    const {\n      datum,\n      angleValue,\n      sectorFormat: {\n        fill: color\n      }\n    } = nodeDatum;\n    const title = sanitizeHtml((_a = this.title) === null || _a === void 0 ? void 0 : _a.text);\n    const content = isNumber(angleValue) ? toFixed(angleValue) : String(angleValue);\n    const labelText = this.getDatumLegendName(nodeDatum);\n    return this.tooltip.toTooltipHtml({\n      title: title !== null && title !== void 0 ? title : labelText,\n      content: title && labelText ? `${labelText}: ${content}` : content,\n      backgroundColor: color\n    }, {\n      datum,\n      title,\n      color,\n      seriesId: this.id,\n      angleKey: this.angleKey,\n      angleName: this.angleName,\n      radiusKey: this.radiusKey,\n      radiusName: this.radiusName,\n      calloutLabelKey: this.calloutLabelKey,\n      calloutLabelName: this.calloutLabelName,\n      sectorLabelKey: this.sectorLabelKey,\n      sectorLabelName: this.sectorLabelName\n    });\n  }\n  getLegendData(legendType) {\n    var _a, _b, _c, _d, _e;\n    const {\n      processedData,\n      angleKey,\n      calloutLabelKey,\n      sectorLabelKey,\n      legendItemKey,\n      id,\n      dataModel\n    } = this;\n    if (!dataModel || !processedData || processedData.data.length === 0 || legendType !== 'category') return [];\n    if (!legendItemKey && (!calloutLabelKey || calloutLabelKey === angleKey) && (!sectorLabelKey || sectorLabelKey === angleKey)) return [];\n    const {\n      calloutLabelIdx,\n      sectorLabelIdx,\n      legendItemIdx\n    } = this.getProcessedDataIndexes(dataModel);\n    const titleText = ((_a = this.title) === null || _a === void 0 ? void 0 : _a.showInLegend) && this.title.text;\n    const legendData = [];\n    for (let index = 0; index < processedData.data.length; index++) {\n      const {\n        datum,\n        values\n      } = processedData.data[index];\n      const labelParts = [];\n      if (titleText) {\n        labelParts.push(titleText);\n      }\n      const labels = this.getLabels(datum, 2 * Math.PI, 2 * Math.PI, false, values[calloutLabelIdx], values[sectorLabelIdx], values[legendItemIdx]);\n      if (legendItemKey && labels.legendItem !== undefined) {\n        labelParts.push(labels.legendItem.text);\n      } else if (calloutLabelKey && calloutLabelKey !== angleKey && ((_b = labels.calloutLabel) === null || _b === void 0 ? void 0 : _b.text) !== undefined) {\n        labelParts.push((_c = labels.calloutLabel) === null || _c === void 0 ? void 0 : _c.text);\n      } else if (sectorLabelKey && sectorLabelKey !== angleKey && ((_d = labels.sectorLabel) === null || _d === void 0 ? void 0 : _d.text) !== undefined) {\n        labelParts.push((_e = labels.sectorLabel) === null || _e === void 0 ? void 0 : _e.text);\n      }\n      if (labelParts.length === 0) continue;\n      const sectorFormat = this.getSectorFormat(datum, index, false);\n      legendData.push({\n        legendType: 'category',\n        id,\n        itemId: index,\n        seriesId: id,\n        enabled: this.seriesItemEnabled[index],\n        label: {\n          text: labelParts.join(' - ')\n        },\n        marker: {\n          fill: sectorFormat.fill,\n          stroke: sectorFormat.stroke,\n          fillOpacity: this.fillOpacity,\n          strokeOpacity: this.strokeOpacity,\n          strokeWidth: this.strokeWidth\n        }\n      });\n    }\n    return legendData;\n  }\n  onLegendItemClick(event) {\n    const {\n      enabled,\n      itemId,\n      series\n    } = event;\n    if (series.id === this.id) {\n      this.toggleSeriesItem(itemId, enabled);\n    } else if (series.type === 'pie') {\n      this.toggleOtherSeriesItems(series, itemId, enabled);\n    }\n  }\n  toggleSeriesItem(itemId, enabled) {\n    this.seriesItemEnabled[itemId] = enabled;\n    this.nodeDataRefresh = true;\n  }\n  toggleOtherSeriesItems(series, itemId, enabled) {\n    var _a, _b;\n    const {\n      legendItemKey,\n      dataModel\n    } = this;\n    if (!legendItemKey || !dataModel) return;\n    const datumToggledLegendItemValue = series.legendItemKey && ((_a = series.data) === null || _a === void 0 ? void 0 : _a.find((_, index) => index === itemId)[series.legendItemKey]);\n    if (!datumToggledLegendItemValue) return;\n    const legendItemIdx = dataModel.resolveProcessedDataIndexById(this, `legendItemValue`).index;\n    (_b = this.processedData) === null || _b === void 0 ? void 0 : _b.data.forEach(({\n      values\n    }, datumItemId) => {\n      if (values[legendItemIdx] === datumToggledLegendItemValue) {\n        this.toggleSeriesItem(datumItemId, enabled);\n      }\n    });\n  }\n  animateEmptyUpdateReady(_data) {\n    const {\n      animationManager\n    } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(true, this.rotation, this.radiusScale, this.previousRadiusScale);\n    fromToMotion(this.id, 'nodes', animationManager, [this.itemSelection, this.highlightSelection], fns.nodes);\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeInAnimation(this, 'callout', animationManager, [this.calloutLabelSelection]);\n    seriesLabelFadeInAnimation(this, 'sector', animationManager, [this.sectorLabelSelection]);\n    seriesLabelFadeInAnimation(this, 'inner', animationManager, [this.innerLabelsSelection]);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateWaitingUpdateReady() {\n    var _a, _b, _c, _d, _e, _f;\n    const {\n      itemSelection,\n      highlightSelection,\n      processedData,\n      radiusScale,\n      previousRadiusScale\n    } = this;\n    const {\n      animationManager\n    } = this.ctx;\n    const diff = (_a = processedData === null || processedData === void 0 ? void 0 : processedData.reduced) === null || _a === void 0 ? void 0 : _a.diff;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const supportedDiff = ((_b = diff === null || diff === void 0 ? void 0 : diff.moved.length) !== null && _b !== void 0 ? _b : 0) === 0 && (diff === null || diff === void 0 ? void 0 : diff.addedIndices.every(i => !diff.removedIndices.includes(i)));\n    const hasKeys = ((_c = processedData === null || processedData === void 0 ? void 0 : processedData.defs.keys.length) !== null && _c !== void 0 ? _c : 0) > 0;\n    const hasUniqueKeys = (_f = (_e = (_d = processedData === null || processedData === void 0 ? void 0 : processedData.reduced) === null || _d === void 0 ? void 0 : _d.animationValidation) === null || _e === void 0 ? void 0 : _e.uniqueKeys) !== null && _f !== void 0 ? _f : true;\n    if (!supportedDiff || !hasKeys || !hasUniqueKeys) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n    const fns = preparePieSeriesAnimationFunctions(false, this.rotation, radiusScale, previousRadiusScale);\n    fromToMotion(this.id, 'nodes', animationManager, [itemSelection, highlightSelection], fns.nodes, (_, datum) => this.getDatumId(datum), diff);\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeInAnimation(this, 'callout', this.ctx.animationManager, [this.calloutLabelSelection]);\n    seriesLabelFadeInAnimation(this, 'sector', this.ctx.animationManager, [this.sectorLabelSelection]);\n    seriesLabelFadeInAnimation(this, 'inner', this.ctx.animationManager, [this.innerLabelsSelection]);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  animateClearingUpdateEmpty() {\n    const {\n      itemSelection,\n      highlightSelection,\n      radiusScale,\n      previousRadiusScale\n    } = this;\n    const {\n      animationManager\n    } = this.ctx;\n    const fns = preparePieSeriesAnimationFunctions(false, this.rotation, radiusScale, previousRadiusScale);\n    fromToMotion(this.id, 'nodes', animationManager, [itemSelection, highlightSelection], fns.nodes);\n    fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\n    seriesLabelFadeOutAnimation(this, 'callout', this.ctx.animationManager, [this.calloutLabelSelection]);\n    seriesLabelFadeOutAnimation(this, 'sector', this.ctx.animationManager, [this.sectorLabelSelection]);\n    seriesLabelFadeOutAnimation(this, 'inner', this.ctx.animationManager, [this.innerLabelsSelection]);\n    this.previousRadiusScale.range = this.radiusScale.range;\n  }\n  getDatumIdFromData(datum) {\n    var _a, _b, _c;\n    const {\n      calloutLabelKey,\n      sectorLabelKey,\n      legendItemKey\n    } = this;\n    if (!((_c = (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.animationValidation) === null || _c === void 0 ? void 0 : _c.uniqueKeys)) {\n      return undefined;\n    }\n    if (legendItemKey) {\n      return datum[legendItemKey];\n    } else if (calloutLabelKey) {\n      return datum[calloutLabelKey];\n    } else if (sectorLabelKey) {\n      return datum[sectorLabelKey];\n    }\n  }\n  getDatumId(datum) {\n    var _a;\n    const {\n      index\n    } = datum;\n    return (_a = this.getDatumIdFromData(datum.datum)) !== null && _a !== void 0 ? _a : `${index}`;\n  }\n  onDataChange() {\n    this.processSeriesItemEnabled();\n  }\n}\nPieSeries.className = 'PieSeries';\nPieSeries.type = 'pie';\n__decorate([Validate(STRING), __metadata(\"design:type\", Object)], PieSeries.prototype, \"angleKey\", void 0);\n__decorate([Validate(STRING), __metadata(\"design:type\", Object)], PieSeries.prototype, \"angleName\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], PieSeries.prototype, \"radiusKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], PieSeries.prototype, \"radiusName\", void 0);\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], PieSeries.prototype, \"radiusMin\", void 0);\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], PieSeries.prototype, \"radiusMax\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], PieSeries.prototype, \"calloutLabelKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], PieSeries.prototype, \"calloutLabelName\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], PieSeries.prototype, \"sectorLabelKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], PieSeries.prototype, \"sectorLabelName\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], PieSeries.prototype, \"legendItemKey\", void 0);\n__decorate([Validate(COLOR_STRING_ARRAY), __metadata(\"design:type\", Array)], PieSeries.prototype, \"fills\", void 0);\n__decorate([Validate(COLOR_STRING_ARRAY), __metadata(\"design:type\", Array)], PieSeries.prototype, \"strokes\", void 0);\n__decorate([Validate(NUMBER$1(0, 1)), __metadata(\"design:type\", Object)], PieSeries.prototype, \"fillOpacity\", void 0);\n__decorate([Validate(NUMBER$1(0, 1)), __metadata(\"design:type\", Object)], PieSeries.prototype, \"strokeOpacity\", void 0);\n__decorate([Validate(OPT_LINE_DASH), __metadata(\"design:type\", Array)], PieSeries.prototype, \"lineDash\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], PieSeries.prototype, \"lineDashOffset\", void 0);\n__decorate([Validate(OPT_FUNCTION), __metadata(\"design:type\", Function)], PieSeries.prototype, \"formatter\", void 0);\n__decorate([Validate(NUMBER$1(-360, 360)), __metadata(\"design:type\", Object)], PieSeries.prototype, \"rotation\", void 0);\n__decorate([Validate(NUMBER$1()), __metadata(\"design:type\", Object)], PieSeries.prototype, \"outerRadiusOffset\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], PieSeries.prototype, \"outerRadiusRatio\", void 0);\n__decorate([Validate(NUMBER$1()), __metadata(\"design:type\", Object)], PieSeries.prototype, \"innerRadiusOffset\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], PieSeries.prototype, \"innerRadiusRatio\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], PieSeries.prototype, \"strokeWidth\", void 0);\nconst JSON_APPLY_PLUGINS = {\n  constructors: {},\n  constructedArrays: new WeakMap()\n};\nfunction assignJsonApplyConstructedArray(array, ctor) {\n  var _a;\n  (_a = JSON_APPLY_PLUGINS.constructedArrays) === null || _a === void 0 ? void 0 : _a.set(array, ctor);\n}\nconst JSON_APPLY_OPTIONS = {\n  constructors: {\n    title: Caption,\n    subtitle: Caption,\n    footnote: Caption,\n    shadow: DropShadow,\n    innerCircle: DoughnutInnerCircle,\n    'axes[].title': AxisTitle,\n    'series[].innerLabels[]': DoughnutInnerLabel\n  },\n  allowedTypes: {\n    'legend.pagination.marker.shape': ['primitive', 'function'],\n    'series[].marker.shape': ['primitive', 'function'],\n    'axis[].tick.count': ['primitive', 'class-instance']\n  }\n};\nfunction getJsonApplyOptions() {\n  return {\n    constructors: Object.assign(Object.assign({}, JSON_APPLY_OPTIONS.constructors), JSON_APPLY_PLUGINS.constructors),\n    constructedArrays: JSON_APPLY_PLUGINS.constructedArrays,\n    allowedTypes: Object.assign({}, JSON_APPLY_OPTIONS.allowedTypes)\n  };\n}\nclass Range extends Shape {\n  constructor(opts = {}) {\n    super(opts);\n    this.x1 = 0;\n    this.y1 = 0;\n    this.x2 = 0;\n    this.y2 = 0;\n    this.startLine = false;\n    this.endLine = false;\n    this.isRange = false;\n    this.restoreOwnStyles();\n  }\n  computeBBox() {\n    return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);\n  }\n  isPointInPath(_x, _y) {\n    return false;\n  }\n  render(renderCtx) {\n    var _a;\n    const {\n      ctx,\n      forceRender,\n      stats\n    } = renderCtx;\n    if (this.dirty === RedrawType.NONE && !forceRender) {\n      if (stats) stats.nodesSkipped += this.nodeCount.count;\n      return;\n    }\n    this.computeTransformMatrix();\n    this.matrix.toContext(ctx);\n    let {\n      x1,\n      y1,\n      x2,\n      y2\n    } = this;\n    x1 = this.align(x1);\n    y1 = this.align(y1);\n    x2 = this.align(x2);\n    y2 = this.align(y2);\n    const {\n      fill,\n      opacity,\n      isRange\n    } = this;\n    const fillActive = !!(isRange && fill);\n    if (fillActive) {\n      const {\n        fillOpacity\n      } = this;\n      ctx.fillStyle = fill;\n      ctx.globalAlpha = opacity * fillOpacity;\n      ctx.beginPath();\n      ctx.moveTo(x1, y1);\n      ctx.lineTo(x2, y1);\n      ctx.lineTo(x2, y2);\n      ctx.lineTo(x1, y2);\n      ctx.closePath();\n      ctx.fill();\n    }\n    const {\n      stroke,\n      strokeWidth,\n      startLine,\n      endLine\n    } = this;\n    const strokeActive = !!((startLine || endLine) && stroke && strokeWidth);\n    if (strokeActive) {\n      const {\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        lineCap,\n        lineJoin\n      } = this;\n      ctx.strokeStyle = stroke;\n      ctx.globalAlpha = opacity * strokeOpacity;\n      ctx.lineWidth = strokeWidth;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      ctx.beginPath();\n      if (startLine) {\n        ctx.moveTo(x1, y1);\n        ctx.lineTo(x2, y1);\n      }\n      if (endLine) {\n        ctx.moveTo(x2, y2);\n        ctx.lineTo(x1, y2);\n      }\n      ctx.stroke();\n    }\n    (_a = this.fillShadow) === null || _a === void 0 ? void 0 : _a.markClean();\n    super.render(renderCtx);\n  }\n}\nRange.className = 'Range';\nRange.defaultStyles = Object.assign(Object.assign({}, Shape.defaultStyles), {\n  strokeWidth: 1\n});\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR\n}), __metadata(\"design:type\", Number)], Range.prototype, \"x1\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR\n}), __metadata(\"design:type\", Number)], Range.prototype, \"y1\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR\n}), __metadata(\"design:type\", Number)], Range.prototype, \"x2\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR\n}), __metadata(\"design:type\", Number)], Range.prototype, \"y2\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR\n}), __metadata(\"design:type\", Boolean)], Range.prototype, \"startLine\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR\n}), __metadata(\"design:type\", Boolean)], Range.prototype, \"endLine\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MINOR\n}), __metadata(\"design:type\", Boolean)], Range.prototype, \"isRange\", void 0);\nconst horizontalCrosslineTranslationDirections = {\n  top: {\n    xTranslationDirection: 0,\n    yTranslationDirection: -1\n  },\n  bottom: {\n    xTranslationDirection: 0,\n    yTranslationDirection: 1\n  },\n  left: {\n    xTranslationDirection: -1,\n    yTranslationDirection: 0\n  },\n  right: {\n    xTranslationDirection: 1,\n    yTranslationDirection: 0\n  },\n  topLeft: {\n    xTranslationDirection: 1,\n    yTranslationDirection: -1\n  },\n  topRight: {\n    xTranslationDirection: -1,\n    yTranslationDirection: -1\n  },\n  bottomLeft: {\n    xTranslationDirection: 1,\n    yTranslationDirection: 1\n  },\n  bottomRight: {\n    xTranslationDirection: -1,\n    yTranslationDirection: 1\n  },\n  inside: {\n    xTranslationDirection: 0,\n    yTranslationDirection: 0\n  },\n  insideLeft: {\n    xTranslationDirection: 1,\n    yTranslationDirection: 0\n  },\n  insideRight: {\n    xTranslationDirection: -1,\n    yTranslationDirection: 0\n  },\n  insideTop: {\n    xTranslationDirection: 0,\n    yTranslationDirection: 1\n  },\n  insideBottom: {\n    xTranslationDirection: 0,\n    yTranslationDirection: -1\n  },\n  insideTopLeft: {\n    xTranslationDirection: 1,\n    yTranslationDirection: 1\n  },\n  insideBottomLeft: {\n    xTranslationDirection: 1,\n    yTranslationDirection: -1\n  },\n  insideTopRight: {\n    xTranslationDirection: -1,\n    yTranslationDirection: 1\n  },\n  insideBottomRight: {\n    xTranslationDirection: -1,\n    yTranslationDirection: -1\n  }\n};\nconst verticalCrossLineTranslationDirections = {\n  top: {\n    xTranslationDirection: 1,\n    yTranslationDirection: 0\n  },\n  bottom: {\n    xTranslationDirection: -1,\n    yTranslationDirection: 0\n  },\n  left: {\n    xTranslationDirection: 0,\n    yTranslationDirection: -1\n  },\n  right: {\n    xTranslationDirection: 0,\n    yTranslationDirection: 1\n  },\n  topLeft: {\n    xTranslationDirection: -1,\n    yTranslationDirection: -1\n  },\n  topRight: {\n    xTranslationDirection: -1,\n    yTranslationDirection: 1\n  },\n  bottomLeft: {\n    xTranslationDirection: 1,\n    yTranslationDirection: -1\n  },\n  bottomRight: {\n    xTranslationDirection: 1,\n    yTranslationDirection: 1\n  },\n  inside: {\n    xTranslationDirection: 0,\n    yTranslationDirection: 0\n  },\n  insideLeft: {\n    xTranslationDirection: 0,\n    yTranslationDirection: 1\n  },\n  insideRight: {\n    xTranslationDirection: 0,\n    yTranslationDirection: -1\n  },\n  insideTop: {\n    xTranslationDirection: -1,\n    yTranslationDirection: 0\n  },\n  insideBottom: {\n    xTranslationDirection: 1,\n    yTranslationDirection: 0\n  },\n  insideTopLeft: {\n    xTranslationDirection: -1,\n    yTranslationDirection: 1\n  },\n  insideBottomLeft: {\n    xTranslationDirection: 1,\n    yTranslationDirection: 1\n  },\n  insideTopRight: {\n    xTranslationDirection: -1,\n    yTranslationDirection: -1\n  },\n  insideBottomRight: {\n    xTranslationDirection: 1,\n    yTranslationDirection: -1\n  }\n};\nfunction calculateLabelTranslation({\n  yDirection,\n  padding = 0,\n  position = 'top',\n  bbox\n}) {\n  const crossLineTranslationDirections = yDirection ? horizontalCrosslineTranslationDirections : verticalCrossLineTranslationDirections;\n  const {\n    xTranslationDirection,\n    yTranslationDirection\n  } = crossLineTranslationDirections[position];\n  const w = yDirection ? bbox.width : bbox.height;\n  const h = yDirection ? bbox.height : bbox.width;\n  const xTranslation = xTranslationDirection * (padding + w / 2);\n  const yTranslation = yTranslationDirection * (padding + h / 2);\n  return {\n    xTranslation,\n    yTranslation\n  };\n}\nfunction calculateLabelChartPadding({\n  yDirection,\n  bbox,\n  padding = 0,\n  position = 'top'\n}) {\n  const chartPadding = {};\n  if (position.startsWith('inside')) return chartPadding;\n  if (position === 'top' && !yDirection) {\n    chartPadding.top = padding + bbox.height;\n  } else if (position === 'bottom' && !yDirection) {\n    chartPadding.bottom = padding + bbox.height;\n  } else if (position === 'left' && yDirection) {\n    chartPadding.left = padding + bbox.width;\n  } else if (position === 'right' && yDirection) {\n    chartPadding.right = padding + bbox.width;\n  }\n  return chartPadding;\n}\nconst POSITION_TOP_COORDINATES = ({\n  yDirection,\n  xEnd,\n  yStart,\n  yEnd\n}) => {\n  if (yDirection) {\n    return {\n      x: xEnd / 2,\n      y: yStart\n    };\n  } else {\n    return {\n      x: xEnd,\n      y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart\n    };\n  }\n};\nconst POSITION_LEFT_COORDINATES = ({\n  yDirection,\n  xStart,\n  xEnd,\n  yStart,\n  yEnd\n}) => {\n  if (yDirection) {\n    return {\n      x: xStart,\n      y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart\n    };\n  } else {\n    return {\n      x: xEnd / 2,\n      y: yStart\n    };\n  }\n};\nconst POSITION_RIGHT_COORDINATES = ({\n  yDirection,\n  xEnd,\n  yStart,\n  yEnd\n}) => {\n  if (yDirection) {\n    return {\n      x: xEnd,\n      y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart\n    };\n  } else {\n    return {\n      x: xEnd / 2,\n      y: !isNaN(yEnd) ? yEnd : yStart\n    };\n  }\n};\nconst POSITION_BOTTOM_COORDINATES = ({\n  yDirection,\n  xStart,\n  xEnd,\n  yStart,\n  yEnd\n}) => {\n  if (yDirection) {\n    return {\n      x: xEnd / 2,\n      y: !isNaN(yEnd) ? yEnd : yStart\n    };\n  } else {\n    return {\n      x: xStart,\n      y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart\n    };\n  }\n};\nconst POSITION_INSIDE_COORDINATES = ({\n  xEnd,\n  yStart,\n  yEnd\n}) => {\n  return {\n    x: xEnd / 2,\n    y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart\n  };\n};\nconst POSITION_TOP_LEFT_COORDINATES = ({\n  yDirection,\n  xStart,\n  xEnd,\n  yStart\n}) => {\n  if (yDirection) {\n    return {\n      x: xStart / 2,\n      y: yStart\n    };\n  } else {\n    return {\n      x: xEnd,\n      y: yStart\n    };\n  }\n};\nconst POSITION_BOTTOM_LEFT_COORDINATES = ({\n  yDirection,\n  xStart,\n  yStart,\n  yEnd\n}) => {\n  if (yDirection) {\n    return {\n      x: xStart,\n      y: !isNaN(yEnd) ? yEnd : yStart\n    };\n  } else {\n    return {\n      x: xStart,\n      y: yStart\n    };\n  }\n};\nconst POSITION_TOP_RIGHT_COORDINATES = ({\n  yDirection,\n  xEnd,\n  yStart,\n  yEnd\n}) => {\n  if (yDirection) {\n    return {\n      x: xEnd,\n      y: yStart\n    };\n  } else {\n    return {\n      x: xEnd,\n      y: !isNaN(yEnd) ? yEnd : yStart\n    };\n  }\n};\nconst POSITION_BOTTOM_RIGHT_COORDINATES = ({\n  yDirection,\n  xStart,\n  xEnd,\n  yStart,\n  yEnd\n}) => {\n  if (yDirection) {\n    return {\n      x: xEnd,\n      y: !isNaN(yEnd) ? yEnd : yStart\n    };\n  } else {\n    return {\n      x: xStart,\n      y: !isNaN(yEnd) ? yEnd : yStart\n    };\n  }\n};\nconst labeldDirectionHandling = {\n  top: {\n    c: POSITION_TOP_COORDINATES\n  },\n  bottom: {\n    c: POSITION_BOTTOM_COORDINATES\n  },\n  left: {\n    c: POSITION_LEFT_COORDINATES\n  },\n  right: {\n    c: POSITION_RIGHT_COORDINATES\n  },\n  topLeft: {\n    c: POSITION_TOP_LEFT_COORDINATES\n  },\n  topRight: {\n    c: POSITION_TOP_RIGHT_COORDINATES\n  },\n  bottomLeft: {\n    c: POSITION_BOTTOM_LEFT_COORDINATES\n  },\n  bottomRight: {\n    c: POSITION_BOTTOM_RIGHT_COORDINATES\n  },\n  inside: {\n    c: POSITION_INSIDE_COORDINATES\n  },\n  insideLeft: {\n    c: POSITION_LEFT_COORDINATES\n  },\n  insideRight: {\n    c: POSITION_RIGHT_COORDINATES\n  },\n  insideTop: {\n    c: POSITION_TOP_COORDINATES\n  },\n  insideBottom: {\n    c: POSITION_BOTTOM_COORDINATES\n  },\n  insideTopLeft: {\n    c: POSITION_TOP_LEFT_COORDINATES\n  },\n  insideBottomLeft: {\n    c: POSITION_BOTTOM_LEFT_COORDINATES\n  },\n  insideTopRight: {\n    c: POSITION_TOP_RIGHT_COORDINATES\n  },\n  insideBottomRight: {\n    c: POSITION_BOTTOM_RIGHT_COORDINATES\n  }\n};\nconst CROSSLINE_LABEL_POSITIONS = ['top', 'left', 'right', 'bottom', 'topLeft', 'topRight', 'bottomLeft', 'bottomRight', 'inside', 'insideLeft', 'insideRight', 'insideTop', 'insideBottom', 'insideTopLeft', 'insideBottomLeft', 'insideTopRight', 'insideBottomRight'];\nconst OPT_CROSSLINE_LABEL_POSITION = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, v => CROSSLINE_LABEL_POSITIONS.includes(v)), `expecting an optional crossLine label position keyword such as 'topLeft', 'topRight' or 'inside'`);\nconst OPT_CROSSLINE_TYPE = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, v => v === 'range' || v === 'line'), `expecting a crossLine type keyword such as 'range' or 'line'`);\nclass CartesianCrossLineLabel {\n  constructor() {\n    this.enabled = undefined;\n    this.text = undefined;\n    this.fontStyle = undefined;\n    this.fontWeight = undefined;\n    this.fontSize = 14;\n    this.fontFamily = 'Verdana, sans-serif';\n    /**\r\n     * The padding between the label and the line.\r\n     */\n    this.padding = 5;\n    /**\r\n     * The color of the labels.\r\n     */\n    this.color = 'rgba(87, 87, 87, 1)';\n    this.position = undefined;\n    this.rotation = undefined;\n    this.parallel = undefined;\n  }\n}\n__decorate([Validate(OPT_BOOLEAN), __metadata(\"design:type\", Boolean)], CartesianCrossLineLabel.prototype, \"enabled\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], CartesianCrossLineLabel.prototype, \"text\", void 0);\n__decorate([Validate(OPT_FONT_STYLE), __metadata(\"design:type\", String)], CartesianCrossLineLabel.prototype, \"fontStyle\", void 0);\n__decorate([Validate(OPT_FONT_WEIGHT), __metadata(\"design:type\", String)], CartesianCrossLineLabel.prototype, \"fontWeight\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], CartesianCrossLineLabel.prototype, \"fontSize\", void 0);\n__decorate([Validate(STRING), __metadata(\"design:type\", String)], CartesianCrossLineLabel.prototype, \"fontFamily\", void 0);\n__decorate([Validate(NUMBER$1()), __metadata(\"design:type\", Number)], CartesianCrossLineLabel.prototype, \"padding\", void 0);\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], CartesianCrossLineLabel.prototype, \"color\", void 0);\n__decorate([Validate(OPT_CROSSLINE_LABEL_POSITION), __metadata(\"design:type\", String)], CartesianCrossLineLabel.prototype, \"position\", void 0);\n__decorate([Validate(OPT_NUMBER(-360, 360)), __metadata(\"design:type\", Number)], CartesianCrossLineLabel.prototype, \"rotation\", void 0);\n__decorate([Validate(OPT_BOOLEAN), __metadata(\"design:type\", Boolean)], CartesianCrossLineLabel.prototype, \"parallel\", void 0);\nclass CartesianCrossLine {\n  constructor() {\n    this.id = createId(this);\n    this.enabled = undefined;\n    this.type = undefined;\n    this.range = undefined;\n    this.value = undefined;\n    this.fill = undefined;\n    this.fillOpacity = undefined;\n    this.stroke = undefined;\n    this.strokeWidth = undefined;\n    this.strokeOpacity = undefined;\n    this.lineDash = undefined;\n    this.label = new CartesianCrossLineLabel();\n    this.scale = undefined;\n    this.clippedRange = [-Infinity, Infinity];\n    this.gridLength = 0;\n    this.sideFlag = -1;\n    this.parallelFlipRotation = 0;\n    this.regularFlipRotation = 0;\n    this.direction = ChartAxisDirection.X;\n    this.group = new Group({\n      name: `${this.id}`,\n      layer: true,\n      zIndex: CartesianCrossLine.LINE_LAYER_ZINDEX\n    });\n    this.crossLineRange = new Range();\n    this.crossLineLabel = new Text();\n    this.labelPoint = undefined;\n    this.data = [];\n    this.startLine = false;\n    this.endLine = false;\n    this.isRange = false;\n    const {\n      group,\n      crossLineRange,\n      crossLineLabel\n    } = this;\n    group.append([crossLineRange, crossLineLabel]);\n    crossLineRange.pointerEvents = PointerEvents.None;\n  }\n  update(visible) {\n    if (!this.enabled || !visible || this.data.length === 0) {\n      this.group.visible = false;\n      return;\n    }\n    this.group.visible = true;\n    this.group.zIndex = this.getZIndex(this.isRange);\n    this.updateNodes();\n  }\n  calculateLayout(visible) {\n    if (!visible) {\n      return;\n    }\n    const dataCreated = this.createNodeData();\n    if (!dataCreated) {\n      return;\n    }\n    const {\n      sideFlag,\n      gridLength,\n      data\n    } = this;\n    const boxes = [];\n    const x1 = 0;\n    const x2 = sideFlag * gridLength;\n    const y1 = data[0];\n    const y2 = data[1];\n    const crossLineBox = new BBox(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x1 - x2), Math.abs(y1 - y2));\n    boxes.push(crossLineBox);\n    const labelBox = this.computeLabelBBox();\n    if (labelBox) {\n      boxes.push(labelBox);\n    }\n    return BBox.merge(boxes);\n  }\n  updateNodes() {\n    this.updateRangeNode();\n    if (this.label.enabled) {\n      this.updateLabel();\n      this.positionLabel();\n    }\n  }\n  createNodeData() {\n    var _a, _b;\n    const {\n      scale,\n      gridLength,\n      sideFlag,\n      direction,\n      label: {\n        position = 'top'\n      },\n      clippedRange,\n      strokeWidth = 0\n    } = this;\n    this.data = [];\n    if (!scale) {\n      return false;\n    }\n    const bandwidth = (_a = scale.bandwidth) !== null && _a !== void 0 ? _a : 0;\n    const clippedRangeClamper = x => Math.max(Math.min(...clippedRange), Math.min(Math.max(...clippedRange), x));\n    const [xStart, xEnd] = [0, sideFlag * gridLength];\n    let [yStart, yEnd] = this.getRange();\n    let [clampedYStart, clampedYEnd] = [Number(scale.convert(yStart, {\n      clampMode: 'clamped'\n    })), scale.convert(yEnd, {\n      clampMode: 'clamped'\n    }) + bandwidth];\n    clampedYStart = clippedRangeClamper(clampedYStart);\n    clampedYEnd = clippedRangeClamper(clampedYEnd);\n    [yStart, yEnd] = [Number(scale.convert(yStart)), scale.convert(yEnd) + bandwidth];\n    const validRange = !isNaN(clampedYStart) && !isNaN(clampedYEnd) && (yStart === clampedYStart || yEnd === clampedYEnd || clampedYStart !== clampedYEnd) && Math.abs(clampedYEnd - clampedYStart) > 0;\n    if (validRange) {\n      const reverse = clampedYStart !== Math.min(clampedYStart, clampedYEnd);\n      if (reverse) {\n        [clampedYStart, clampedYEnd] = [Math.min(clampedYStart, clampedYEnd), Math.max(clampedYStart, clampedYEnd)];\n        [yStart, yEnd] = [yEnd, yStart];\n      }\n    }\n    this.isRange = validRange;\n    this.startLine = !isNaN(yStart) && strokeWidth > 0 && yStart === clampedYStart;\n    this.endLine = !isNaN(yEnd) && strokeWidth > 0 && yEnd === clampedYEnd;\n    if (!validRange && !this.startLine && !this.endLine) {\n      return false;\n    }\n    this.data = [clampedYStart, clampedYEnd];\n    if (this.label.enabled) {\n      const yDirection = direction === ChartAxisDirection.Y;\n      const {\n        c = POSITION_TOP_COORDINATES\n      } = (_b = labeldDirectionHandling[position]) !== null && _b !== void 0 ? _b : {};\n      const {\n        x: labelX,\n        y: labelY\n      } = c({\n        yDirection,\n        xStart,\n        xEnd,\n        yStart: clampedYStart,\n        yEnd: clampedYEnd\n      });\n      this.labelPoint = {\n        x: labelX,\n        y: labelY\n      };\n    }\n    return true;\n  }\n  updateRangeNode() {\n    var _a;\n    const {\n      crossLineRange,\n      sideFlag,\n      gridLength,\n      data,\n      startLine,\n      endLine,\n      isRange,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      lineDash\n    } = this;\n    crossLineRange.x1 = 0;\n    crossLineRange.x2 = sideFlag * gridLength;\n    crossLineRange.y1 = data[0];\n    crossLineRange.y2 = data[1];\n    crossLineRange.startLine = startLine;\n    crossLineRange.endLine = endLine;\n    crossLineRange.isRange = isRange;\n    crossLineRange.fill = fill;\n    crossLineRange.fillOpacity = fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1;\n    crossLineRange.stroke = stroke;\n    crossLineRange.strokeWidth = strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 1;\n    crossLineRange.strokeOpacity = (_a = this.strokeOpacity) !== null && _a !== void 0 ? _a : 1;\n    crossLineRange.lineDash = lineDash;\n  }\n  updateLabel() {\n    const {\n      crossLineLabel,\n      label\n    } = this;\n    if (!label.text) {\n      return;\n    }\n    crossLineLabel.fontStyle = label.fontStyle;\n    crossLineLabel.fontWeight = label.fontWeight;\n    crossLineLabel.fontSize = label.fontSize;\n    crossLineLabel.fontFamily = label.fontFamily;\n    crossLineLabel.fill = label.color;\n    crossLineLabel.text = label.text;\n  }\n  positionLabel() {\n    const {\n      crossLineLabel,\n      labelPoint: {\n        x = undefined,\n        y = undefined\n      } = {},\n      label: {\n        parallel,\n        rotation,\n        position = 'top',\n        padding = 0\n      },\n      direction,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this;\n    if (x === undefined || y === undefined) {\n      return;\n    }\n    const {\n      defaultRotation,\n      configuredRotation\n    } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    crossLineLabel.rotation = defaultRotation + configuredRotation;\n    crossLineLabel.textBaseline = 'middle';\n    crossLineLabel.textAlign = 'center';\n    const bbox = crossLineLabel.computeTransformedBBox();\n    if (!bbox) {\n      return;\n    }\n    const yDirection = direction === ChartAxisDirection.Y;\n    const {\n      xTranslation,\n      yTranslation\n    } = calculateLabelTranslation({\n      yDirection,\n      padding,\n      position,\n      bbox\n    });\n    crossLineLabel.translationX = x + xTranslation;\n    crossLineLabel.translationY = y + yTranslation;\n  }\n  getZIndex(isRange = false) {\n    if (isRange) {\n      return CartesianCrossLine.RANGE_LAYER_ZINDEX;\n    }\n    return CartesianCrossLine.LINE_LAYER_ZINDEX;\n  }\n  getRange() {\n    const {\n      value,\n      range,\n      scale\n    } = this;\n    const isContinuous = ContinuousScale.is(scale);\n    let [start, end] = range !== null && range !== void 0 ? range : [value, undefined];\n    if (!isContinuous && end === undefined) {\n      end = start;\n    }\n    start = checkDatum(start, isContinuous) != null ? start : undefined;\n    end = checkDatum(end, isContinuous) != null ? end : undefined;\n    if (isContinuous && start === end) {\n      end = undefined;\n    }\n    if (start === undefined && end !== undefined) {\n      start = end;\n      end = undefined;\n    }\n    return [start, end];\n  }\n  computeLabelBBox() {\n    const {\n      label\n    } = this;\n    if (!label.enabled) {\n      return undefined;\n    }\n    const tempText = new Text();\n    tempText.fontFamily = label.fontFamily;\n    tempText.fontSize = label.fontSize;\n    tempText.fontStyle = label.fontStyle;\n    tempText.fontWeight = label.fontWeight;\n    tempText.text = label.text;\n    const {\n      labelPoint: {\n        x = undefined,\n        y = undefined\n      } = {},\n      label: {\n        parallel,\n        rotation,\n        position = 'top',\n        padding = 0\n      },\n      direction,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this;\n    if (x === undefined || y === undefined) {\n      return undefined;\n    }\n    const {\n      configuredRotation\n    } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    tempText.rotation = configuredRotation;\n    tempText.textBaseline = 'middle';\n    tempText.textAlign = 'center';\n    const bbox = tempText.computeTransformedBBox();\n    if (!bbox) {\n      return undefined;\n    }\n    const yDirection = direction === ChartAxisDirection.Y;\n    const {\n      xTranslation,\n      yTranslation\n    } = calculateLabelTranslation({\n      yDirection,\n      padding,\n      position,\n      bbox\n    });\n    tempText.translationX = x + xTranslation;\n    tempText.translationY = y + yTranslation;\n    return tempText.computeTransformedBBox();\n  }\n  calculatePadding(padding) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const {\n      isRange,\n      startLine,\n      endLine,\n      direction,\n      label: {\n        padding: labelPadding = 0,\n        position = 'top'\n      }\n    } = this;\n    if (!isRange && !startLine && !endLine) {\n      return;\n    }\n    const crossLineLabelBBox = this.computeLabelBBox();\n    const labelX = crossLineLabelBBox === null || crossLineLabelBBox === void 0 ? void 0 : crossLineLabelBBox.x;\n    const labelY = crossLineLabelBBox === null || crossLineLabelBBox === void 0 ? void 0 : crossLineLabelBBox.y;\n    if (!crossLineLabelBBox || labelX == undefined || labelY == undefined) {\n      return;\n    }\n    const chartPadding = calculateLabelChartPadding({\n      yDirection: direction === ChartAxisDirection.Y,\n      padding: labelPadding,\n      position,\n      bbox: crossLineLabelBBox\n    });\n    padding.left = Math.max((_a = padding.left) !== null && _a !== void 0 ? _a : 0, (_b = chartPadding.left) !== null && _b !== void 0 ? _b : 0);\n    padding.right = Math.max((_c = padding.right) !== null && _c !== void 0 ? _c : 0, (_d = chartPadding.right) !== null && _d !== void 0 ? _d : 0);\n    padding.top = Math.max((_e = padding.top) !== null && _e !== void 0 ? _e : 0, (_f = chartPadding.top) !== null && _f !== void 0 ? _f : 0);\n    padding.bottom = Math.max((_g = padding.bottom) !== null && _g !== void 0 ? _g : 0, (_h = chartPadding.bottom) !== null && _h !== void 0 ? _h : 0);\n  }\n}\nCartesianCrossLine.LINE_LAYER_ZINDEX = Layers.SERIES_CROSSLINE_LINE_ZINDEX;\nCartesianCrossLine.RANGE_LAYER_ZINDEX = Layers.SERIES_CROSSLINE_RANGE_ZINDEX;\nCartesianCrossLine.className = 'CrossLine';\n__decorate([Validate(OPT_BOOLEAN), __metadata(\"design:type\", Boolean)], CartesianCrossLine.prototype, \"enabled\", void 0);\n__decorate([Validate(OPT_CROSSLINE_TYPE), __metadata(\"design:type\", String)], CartesianCrossLine.prototype, \"type\", void 0);\n__decorate([Validate(OPT_ARRAY(2)), __metadata(\"design:type\", Array)], CartesianCrossLine.prototype, \"range\", void 0);\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], CartesianCrossLine.prototype, \"fill\", void 0);\n__decorate([Validate(OPT_NUMBER(0, 1)), __metadata(\"design:type\", Number)], CartesianCrossLine.prototype, \"fillOpacity\", void 0);\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], CartesianCrossLine.prototype, \"stroke\", void 0);\n__decorate([Validate(OPT_NUMBER()), __metadata(\"design:type\", Number)], CartesianCrossLine.prototype, \"strokeWidth\", void 0);\n__decorate([Validate(OPT_NUMBER(0, 1)), __metadata(\"design:type\", Number)], CartesianCrossLine.prototype, \"strokeOpacity\", void 0);\n__decorate([Validate(OPT_LINE_DASH), __metadata(\"design:type\", Array)], CartesianCrossLine.prototype, \"lineDash\", void 0);\nconst identity = x => x;\nclass LogScale extends ContinuousScale {\n  constructor() {\n    super([1, 10], [0, 1]);\n    this.type = 'log';\n    this.base = 10;\n    this.cacheProps = ['domain', 'range', 'nice', 'tickCount', 'base'];\n    this.baseLog = identity;\n    this.basePow = identity;\n    this.log = x => {\n      return this.domain[0] >= 0 ? this.baseLog(x) : -this.baseLog(-x);\n    };\n    this.pow = x => {\n      return this.domain[0] >= 0 ? this.basePow(x) : -this.basePow(-x);\n    };\n    // Handling <1 and crossing 0 cases is tricky, easiest solution is to default to clamping.\n    this.defaultClampMode = 'clamped';\n  }\n  toDomain(d) {\n    return d;\n  }\n  transform(x) {\n    return this.domain[0] >= 0 ? Math.log(x) : -Math.log(-x);\n  }\n  transformInvert(x) {\n    return this.domain[0] >= 0 ? Math.exp(x) : -Math.exp(-x);\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    this.updateLogFn();\n    this.updatePowFn();\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  updateLogFn() {\n    const {\n      base\n    } = this;\n    let log;\n    if (base === 10) {\n      log = Math.log10;\n    } else if (base === Math.E) {\n      log = Math.log;\n    } else if (base === 2) {\n      log = Math.log2;\n    } else {\n      const logBase = Math.log(base);\n      log = x => Math.log(x) / logBase;\n    }\n    this.baseLog = log;\n  }\n  updatePowFn() {\n    const {\n      base\n    } = this;\n    let pow;\n    if (base === 10) {\n      pow = LogScale.pow10;\n    } else if (base === Math.E) {\n      pow = Math.exp;\n    } else {\n      pow = x => Math.pow(base, x);\n    }\n    this.basePow = pow;\n  }\n  updateNiceDomain() {\n    const [d0, d1] = this.domain;\n    const n0 = this.pow(Math.floor(this.log(d0)));\n    const n1 = this.pow(Math.ceil(this.log(d1)));\n    this.niceDomain = [n0, n1];\n  }\n  static pow10(x) {\n    return x >= 0 ? Math.pow(10, x) : 1 / Math.pow(10, -x);\n  }\n  ticks() {\n    var _a;\n    const count = (_a = this.tickCount) !== null && _a !== void 0 ? _a : 10;\n    if (!this.domain || this.domain.length < 2 || count < 1) {\n      return [];\n    }\n    this.refresh();\n    const base = this.base;\n    const [d0, d1] = this.getDomain();\n    let p0 = this.log(d0);\n    let p1 = this.log(d1);\n    if (this.interval) {\n      const step = Math.abs(this.interval);\n      const absDiff = Math.abs(p1 - p0);\n      const ticks = range$1(p0, p1, Math.min(absDiff, step)).map(x => this.pow(x)).filter(t => t >= d0 && t <= d1);\n      if (!this.isDenseInterval({\n        start: d0,\n        stop: d1,\n        interval: step,\n        count: ticks.length\n      })) {\n        return ticks;\n      }\n    }\n    const isBaseInteger = base % 1 === 0;\n    const isDiffLarge = p1 - p0 >= count;\n    if (!isBaseInteger || isDiffLarge) {\n      // Returns [10^1, 10^2, 10^3, 10^4, ...]\n      return ticks(p0, p1, Math.min(p1 - p0, count)).map(x => this.pow(x));\n    }\n    const ticks$1 = [];\n    const isPositive = d0 > 0;\n    p0 = Math.floor(p0) - 1;\n    p1 = Math.round(p1) + 1;\n    const min = Math.min(...this.range);\n    const max = Math.max(...this.range);\n    const availableSpacing = (max - min) / count;\n    let lastTickPosition = Infinity;\n    for (let p = p0; p <= p1; p++) {\n      const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));\n      for (let k = 1; k < base; k++) {\n        const q = isPositive ? k : base - k + 1;\n        const t = this.pow(p) * q;\n        const tickPosition = this.convert(t);\n        const prevSpacing = Math.abs(lastTickPosition - tickPosition);\n        const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);\n        const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;\n        if (t >= d0 && t <= d1 && (k === 1 || fits)) {\n          ticks$1.push(t);\n          lastTickPosition = tickPosition;\n        }\n      }\n    }\n    return ticks$1;\n  }\n  tickFormat({\n    count,\n    ticks,\n    specifier\n  }) {\n    const {\n      base\n    } = this;\n    if (specifier == null) {\n      specifier = base === 10 ? '.0e' : ',';\n    }\n    if (typeof specifier === 'string') {\n      specifier = format(specifier);\n    }\n    if (count === Infinity) {\n      return specifier;\n    }\n    if (ticks == null) {\n      this.ticks();\n    }\n    return d => {\n      return specifier(d);\n    };\n  }\n}\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], LogScale.prototype, \"base\", void 0);\nvar DefaultTimeFormats;\n(function (DefaultTimeFormats) {\n  DefaultTimeFormats[DefaultTimeFormats[\"MILLISECOND\"] = 0] = \"MILLISECOND\";\n  DefaultTimeFormats[DefaultTimeFormats[\"SECOND\"] = 1] = \"SECOND\";\n  DefaultTimeFormats[DefaultTimeFormats[\"MINUTE\"] = 2] = \"MINUTE\";\n  DefaultTimeFormats[DefaultTimeFormats[\"HOUR\"] = 3] = \"HOUR\";\n  DefaultTimeFormats[DefaultTimeFormats[\"WEEK_DAY\"] = 4] = \"WEEK_DAY\";\n  DefaultTimeFormats[DefaultTimeFormats[\"SHORT_MONTH\"] = 5] = \"SHORT_MONTH\";\n  DefaultTimeFormats[DefaultTimeFormats[\"MONTH\"] = 6] = \"MONTH\";\n  DefaultTimeFormats[DefaultTimeFormats[\"SHORT_YEAR\"] = 7] = \"SHORT_YEAR\";\n  DefaultTimeFormats[DefaultTimeFormats[\"YEAR\"] = 8] = \"YEAR\";\n})(DefaultTimeFormats || (DefaultTimeFormats = {}));\nconst formatStrings = {\n  [DefaultTimeFormats.MILLISECOND]: '.%L',\n  [DefaultTimeFormats.SECOND]: ':%S',\n  [DefaultTimeFormats.MINUTE]: '%I:%M',\n  [DefaultTimeFormats.HOUR]: '%I %p',\n  [DefaultTimeFormats.WEEK_DAY]: '%a',\n  [DefaultTimeFormats.SHORT_MONTH]: '%b %d',\n  [DefaultTimeFormats.MONTH]: '%B',\n  [DefaultTimeFormats.SHORT_YEAR]: '%y',\n  [DefaultTimeFormats.YEAR]: '%Y'\n};\nfunction toNumber(x) {\n  return x instanceof Date ? x.getTime() : x;\n}\nclass TimeScale extends ContinuousScale {\n  constructor() {\n    super([new Date(2022, 11, 7), new Date(2022, 11, 8)], [0, 1]);\n    this.type = 'time';\n    this.cacheProps = ['domain', 'range', 'nice', 'tickCount', 'interval', 'minTickCount', 'maxTickCount'];\n    this.year = year;\n    this.month = month;\n    this.week = sunday;\n    this.day = day;\n    this.hour = hour;\n    this.minute = minute;\n    this.second = second;\n    this.millisecond = millisecond;\n    /**\r\n     * Array of default tick intervals in the following format:\r\n     *\r\n     *     [\r\n     *         interval (unit of time),\r\n     *         number of units (step),\r\n     *         the length of that number of units in milliseconds\r\n     *     ]\r\n     */\n    this.tickIntervals = [[this.second, 1, durationSecond], [this.second, 5, 5 * durationSecond], [this.second, 15, 15 * durationSecond], [this.second, 30, 30 * durationSecond], [this.minute, 1, durationMinute], [this.minute, 5, 5 * durationMinute], [this.minute, 15, 15 * durationMinute], [this.minute, 30, 30 * durationMinute], [this.hour, 1, durationHour], [this.hour, 3, 3 * durationHour], [this.hour, 6, 6 * durationHour], [this.hour, 12, 12 * durationHour], [this.day, 1, durationDay], [this.day, 2, 2 * durationDay], [this.week, 1, durationWeek], [this.week, 2, 2 * durationWeek], [this.week, 3, 3 * durationWeek], [this.month, 1, durationMonth], [this.month, 2, 2 * durationMonth], [this.month, 3, 3 * durationMonth], [this.month, 4, 4 * durationMonth], [this.month, 6, 6 * durationMonth], [this.year, 1, durationYear]];\n  }\n  toDomain(d) {\n    return new Date(d);\n  }\n  calculateDefaultTickFormat(ticks = []) {\n    let defaultTimeFormat = DefaultTimeFormats.YEAR;\n    const updateFormat = format => {\n      if (format < defaultTimeFormat) {\n        defaultTimeFormat = format;\n      }\n    };\n    for (const value of ticks) {\n      const format = this.getLowestGranularityFormat(value);\n      updateFormat(format);\n    }\n    const firstTick = toNumber(ticks[0]);\n    const lastTick = toNumber(ticks[ticks.length - 1]);\n    const startYear = new Date(firstTick).getFullYear();\n    const stopYear = new Date(lastTick).getFullYear();\n    const yearChange = stopYear - startYear > 0;\n    return this.buildFormatString(defaultTimeFormat, yearChange);\n  }\n  buildFormatString(defaultTimeFormat, yearChange) {\n    let formatStringArray = [formatStrings[defaultTimeFormat]];\n    let timeEndIndex = 0;\n    const domain = this.getDomain();\n    const start = Math.min(...domain.map(toNumber));\n    const stop = Math.max(...domain.map(toNumber));\n    const extent = stop - start;\n    switch (defaultTimeFormat) {\n      case DefaultTimeFormats.SECOND:\n        if (extent / durationMinute > 1) {\n          formatStringArray.push(formatStrings[DefaultTimeFormats.MINUTE]);\n        }\n      // fall through deliberately\n      case DefaultTimeFormats.MINUTE:\n        if (extent / durationHour > 1) {\n          formatStringArray.push(formatStrings[DefaultTimeFormats.HOUR]);\n        }\n      // fall through deliberately\n      case DefaultTimeFormats.HOUR:\n        timeEndIndex = formatStringArray.length;\n        if (extent / durationDay > 1) {\n          formatStringArray.push(formatStrings[DefaultTimeFormats.WEEK_DAY]);\n        }\n      // fall through deliberately\n      case DefaultTimeFormats.WEEK_DAY:\n        if (extent / durationWeek > 1 || yearChange) {\n          // if it's more than a week or there is a year change, don't show week day\n          const weekDayIndex = formatStringArray.indexOf(formatStrings[DefaultTimeFormats.WEEK_DAY]);\n          if (weekDayIndex > -1) {\n            formatStringArray.splice(weekDayIndex, 1, formatStrings[DefaultTimeFormats.SHORT_MONTH]);\n          }\n        }\n      // fall through deliberately\n      case DefaultTimeFormats.SHORT_MONTH:\n      case DefaultTimeFormats.MONTH:\n        if (extent / durationYear > 1 || yearChange) {\n          formatStringArray.push(formatStrings[DefaultTimeFormats.YEAR]);\n        }\n    }\n    if (timeEndIndex < formatStringArray.length) {\n      // Insert a gap between all date components.\n      formatStringArray = [...formatStringArray.slice(0, timeEndIndex), formatStringArray.slice(timeEndIndex).join(' ')];\n    }\n    if (timeEndIndex > 0) {\n      // Reverse order of time components, since they should be displayed in descending\n      // granularity.\n      formatStringArray = [...formatStringArray.slice(0, timeEndIndex).reverse(), ...formatStringArray.slice(timeEndIndex)];\n      if (timeEndIndex < formatStringArray.length) {\n        // Insert a gap between time and date components.\n        formatStringArray.splice(timeEndIndex, 0, ' ');\n      }\n    }\n    return formatStringArray.join('');\n  }\n  getLowestGranularityFormat(value) {\n    if (this.second.floor(value) < value) {\n      return DefaultTimeFormats.MILLISECOND;\n    } else if (this.minute.floor(value) < value) {\n      return DefaultTimeFormats.SECOND;\n    } else if (this.hour.floor(value) < value) {\n      return DefaultTimeFormats.MINUTE;\n    } else if (this.day.floor(value) < value) {\n      return DefaultTimeFormats.HOUR;\n    } else if (this.month.floor(value) < value) {\n      if (this.week.floor(value) < value) {\n        return DefaultTimeFormats.WEEK_DAY;\n      }\n      return DefaultTimeFormats.SHORT_MONTH;\n    } else if (this.year.floor(value) < value) {\n      return DefaultTimeFormats.MONTH;\n    }\n    return DefaultTimeFormats.YEAR;\n  }\n  defaultTickFormat(ticks) {\n    const formatString = this.calculateDefaultTickFormat(ticks);\n    return date => buildFormatter(formatString)(date);\n  }\n  /**\r\n   * @param options Tick interval options.\r\n   * @param options.start The start time (timestamp).\r\n   * @param options.stop The end time (timestamp).\r\n   * @param options.count Number of intervals between ticks.\r\n   */\n  getTickInterval({\n    start,\n    stop,\n    count,\n    minCount,\n    maxCount\n  }) {\n    const {\n      tickIntervals\n    } = this;\n    let countableTimeInterval;\n    let step;\n    const tickCount = count !== null && count !== void 0 ? count : ContinuousScale.defaultTickCount;\n    const target = Math.abs(stop - start) / Math.max(tickCount, 1);\n    let i = 0;\n    while (i < tickIntervals.length && target > tickIntervals[i][2]) {\n      i++;\n    }\n    if (i === 0) {\n      step = Math.max(tickStep(start, stop, tickCount, minCount, maxCount), 1);\n      countableTimeInterval = this.millisecond;\n    } else if (i === tickIntervals.length) {\n      const y0 = start / durationYear;\n      const y1 = stop / durationYear;\n      step = tickStep(y0, y1, tickCount, minCount, maxCount);\n      countableTimeInterval = this.year;\n    } else {\n      const diff0 = target - tickIntervals[i - 1][2];\n      const diff1 = tickIntervals[i][2] - target;\n      const index = diff0 < diff1 ? i - 1 : i;\n      [countableTimeInterval, step] = tickIntervals[index];\n    }\n    return countableTimeInterval.every(step);\n  }\n  invert(y) {\n    return new Date(super.invert(y));\n  }\n  /**\r\n   * Returns uniformly-spaced dates that represent the scale's domain.\r\n   */\n  ticks() {\n    if (!this.domain || this.domain.length < 2) {\n      return [];\n    }\n    this.refresh();\n    const [t0, t1] = this.getDomain().map(toNumber);\n    if (this.interval !== undefined) {\n      return this.getTicksForInterval({\n        start: t0,\n        stop: t1\n      });\n    }\n    if (this.nice) {\n      const {\n        tickCount\n      } = this;\n      if (tickCount === 2) {\n        return this.niceDomain;\n      }\n      if (tickCount === 1) {\n        return this.niceDomain.slice(0, 1);\n      }\n    }\n    return this.getDefaultTicks({\n      start: t0,\n      stop: t1\n    });\n  }\n  getDefaultTicks({\n    start,\n    stop\n  }) {\n    const t = this.getTickInterval({\n      start,\n      stop,\n      count: this.tickCount,\n      minCount: this.minTickCount,\n      maxCount: this.maxTickCount\n    });\n    return t ? t.range(new Date(start), new Date(stop)) : []; // inclusive stop\n  }\n\n  getTicksForInterval({\n    start,\n    stop\n  }) {\n    const {\n      interval,\n      tickIntervals\n    } = this;\n    if (!interval) {\n      return [];\n    }\n    if (interval instanceof TimeInterval) {\n      const ticks = interval.range(new Date(start), new Date(stop));\n      if (this.isDenseInterval({\n        start,\n        stop,\n        interval,\n        count: ticks.length\n      })) {\n        return this.getDefaultTicks({\n          start,\n          stop\n        });\n      }\n      return ticks;\n    }\n    const absInterval = Math.abs(interval);\n    if (this.isDenseInterval({\n      start,\n      stop,\n      interval: absInterval\n    })) {\n      return this.getDefaultTicks({\n        start,\n        stop\n      });\n    }\n    const reversedInterval = [...tickIntervals];\n    reversedInterval.reverse();\n    const timeInterval = reversedInterval.find(tickInterval => absInterval % tickInterval[2] === 0);\n    if (timeInterval) {\n      const i = timeInterval[0].every(absInterval / (timeInterval[2] / timeInterval[1]));\n      return i.range(new Date(start), new Date(stop));\n    }\n    let date = new Date(start);\n    const stopDate = new Date(stop);\n    const ticks = [];\n    while (date <= stopDate) {\n      ticks.push(date);\n      date = new Date(date);\n      date.setMilliseconds(date.getMilliseconds() + absInterval);\n    }\n    return ticks;\n  }\n  /**\r\n   * Returns a time format function suitable for displaying tick values.\r\n   * @param specifier If the specifier string is provided, this method is equivalent to\r\n   * the {@link TimeLocaleObject.format} method.\r\n   * If no specifier is provided, this method returns the default time format function.\r\n   */\n  tickFormat({\n    ticks,\n    specifier\n  }) {\n    return specifier == undefined ? this.defaultTickFormat(ticks) : buildFormatter(specifier);\n  }\n  update() {\n    if (!this.domain || this.domain.length < 2) {\n      return;\n    }\n    if (this.nice) {\n      this.updateNiceDomain();\n    }\n  }\n  /**\r\n   * Extends the domain so that it starts and ends on nice round values.\r\n   * This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value.\r\n   */\n  updateNiceDomain() {\n    const maxAttempts = 4;\n    let [d0, d1] = this.domain;\n    for (let i = 0; i < maxAttempts; i++) {\n      this.updateNiceDomainIteration(d0, d1);\n      const [n0, n1] = this.niceDomain;\n      if (toNumber(d0) === toNumber(n0) && toNumber(d1) === toNumber(n1)) {\n        break;\n      }\n      d0 = n0;\n      d1 = n1;\n    }\n  }\n  updateNiceDomainIteration(d0, d1) {\n    const start = toNumber(d0);\n    const stop = toNumber(d1);\n    const {\n      interval\n    } = this;\n    let i;\n    if (interval instanceof TimeInterval) {\n      i = interval;\n    } else {\n      const tickCount = typeof interval === 'number' ? (stop - start) / Math.max(interval, 1) : this.tickCount;\n      i = this.getTickInterval({\n        start,\n        stop,\n        count: tickCount,\n        minCount: this.minTickCount,\n        maxCount: this.maxTickCount\n      });\n    }\n    if (i) {\n      const intervalRange = i.range(d0, d1, true);\n      const n0 = intervalRange[0];\n      const n1 = intervalRange[intervalRange.length - 1];\n      this.niceDomain = [n0, n1];\n    }\n  }\n}\nclass Padding {\n  constructor(top = 0, right = top, bottom = top, left = right) {\n    this.top = top;\n    this.right = right;\n    this.bottom = bottom;\n    this.left = left;\n  }\n  clear() {\n    this.top = this.right = this.bottom = this.left = 0;\n  }\n}\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], Padding.prototype, \"top\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], Padding.prototype, \"right\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], Padding.prototype, \"bottom\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], Padding.prototype, \"left\", void 0);\nvar sparklinesUtil = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  extent: extent,\n  normalisedExtent: normalisedExtent,\n  normalisedExtentWithMetadata: normalisedExtentWithMetadata,\n  toFixed: toFixed,\n  isNumberEqual: isEqual,\n  tickFormat: tickFormat,\n  interpolateString: interpolate,\n  ticks: ticks,\n  tickStep: tickStep,\n  range: range$1,\n  Color: Color,\n  isString: isString,\n  isStringObject: isStringObject,\n  isDate: isDate,\n  isDiscrete: isDiscrete,\n  isContinuous: isContinuous,\n  checkDatum: checkDatum,\n  isNumber: isNumber,\n  resetIds: resetIds,\n  createId: createId,\n  Padding: Padding,\n  jsonDiff: jsonDiff,\n  DELETE: DELETE,\n  jsonMerge: jsonMerge,\n  jsonApply: jsonApply,\n  jsonWalk: jsonWalk,\n  normalizeAngle360: normalizeAngle360,\n  normalizeAngle360Inclusive: normalizeAngle360Inclusive,\n  normalizeAngle180: normalizeAngle180,\n  toRadians: toRadians,\n  toDegrees: toDegrees,\n  angleBetween: angleBetween,\n  zipObject: zipObject,\n  clamp: clamp,\n  isEqual: isEqual,\n  isNegative: isNegative,\n  round: round$1,\n  mod: mod,\n  sanitizeHtml: sanitizeHtml,\n  Logger: Logger\n});\nfunction areArrayNumbersEqual(arrA, arrB) {\n  return arrA.length === arrB.length && arrA.every((item, i) => Number(item) === Number(arrB[i]));\n}\nfunction circleRectOverlap(c, x, y, w, h) {\n  // Find closest horizontal and vertical edges.\n  let edgeX = c.x;\n  if (c.x < x) {\n    edgeX = x;\n  } else if (c.x > x + w) {\n    edgeX = x + w;\n  }\n  let edgeY = c.y;\n  if (c.y < y) {\n    edgeY = y;\n  } else if (c.y > y + h) {\n    edgeY = y + h;\n  }\n  // Find distance to closest edges.\n  const dx = c.x - edgeX;\n  const dy = c.y - edgeY;\n  const d = Math.sqrt(dx * dx + dy * dy);\n  return d <= c.size * 0.5;\n}\nfunction rectRectOverlap(r1, x2, y2, w2, h2) {\n  const xOverlap = r1.x + r1.width > x2 && r1.x < x2 + w2;\n  const yOverlap = r1.y + r1.height > y2 && r1.y < y2 + h2;\n  return xOverlap && yOverlap;\n}\nfunction rectContainsRect(r1, r2x, r2y, r2w, r2h) {\n  return r2x + r2w < r1.x + r1.width && r2x > r1.x && r2y > r1.y && r2y + r2h < r1.y + r1.height;\n}\nfunction isPointLabelDatum(x) {\n  return x != null && typeof x.point === 'object' && typeof x.label === 'object';\n}\n/**\r\n * @param data Points and labels for one or more series. The order of series determines label placement precedence.\r\n * @param bounds Bounds to fit the labels into. If a label can't be fully contained, it doesn't fit.\r\n * @returns Placed labels for the given series (in the given order).\r\n */\nfunction placeLabels(data, bounds, padding = 5) {\n  const result = [];\n  data = data.map(d => d.slice().sort((a, b) => b.point.size - a.point.size));\n  for (let j = 0; j < data.length; j++) {\n    const labels = result[j] = [];\n    const datum = data[j];\n    if (!((datum === null || datum === void 0 ? void 0 : datum.length) && datum[0].label)) {\n      continue;\n    }\n    for (let i = 0, ln = datum.length; i < ln; i++) {\n      const d = datum[i];\n      const l = d.label;\n      const r = d.point.size * 0.5;\n      const x = d.point.x - l.width * 0.5;\n      const y = d.point.y - r - l.height - padding;\n      const {\n        width,\n        height\n      } = l;\n      const withinBounds = !bounds || rectContainsRect(bounds, x, y, width, height);\n      if (!withinBounds) {\n        continue;\n      }\n      const overlapPoints = data.some(datum => datum.some(d => circleRectOverlap(d.point, x, y, width, height)));\n      if (overlapPoints) {\n        continue;\n      }\n      const overlapLabels = result.some(labels => labels.some(l => rectRectOverlap(l, x, y, width, height)));\n      if (overlapLabels) {\n        continue;\n      }\n      labels.push({\n        index: i,\n        text: l.text,\n        x,\n        y,\n        width,\n        height,\n        datum: d\n      });\n    }\n  }\n  return result;\n}\nfunction axisLabelsOverlap(data, padding) {\n  const result = [];\n  for (let i = 0; i < data.length; i++) {\n    const datum = data[i];\n    const {\n      point: {\n        x,\n        y\n      },\n      label: {\n        text\n      }\n    } = datum;\n    let {\n      label: {\n        width,\n        height\n      }\n    } = datum;\n    width += padding !== null && padding !== void 0 ? padding : 0;\n    height += padding !== null && padding !== void 0 ? padding : 0;\n    const overlapLabels = result.some(l => {\n      return rectRectOverlap(l, x, y, width, height);\n    });\n    if (overlapLabels) {\n      return true;\n    }\n    result.push({\n      index: i,\n      text,\n      x,\n      y,\n      width,\n      height,\n      datum\n    });\n  }\n  return false;\n}\nconst GRID_STYLE_KEYS = ['stroke', 'lineDash'];\nconst GRID_STYLE = predicateWithMessage(ARRAY(undefined, o => {\n  for (const key in o) {\n    if (!GRID_STYLE_KEYS.includes(key)) {\n      return false;\n    }\n  }\n  return true;\n}), `expecting an Array of objects with gridline style properties such as 'stroke' and 'lineDash'`);\nclass AxisGridLine {\n  constructor() {\n    this.enabled = true;\n    this.width = 1;\n    this.style = [{\n      stroke: undefined,\n      lineDash: []\n    }];\n  }\n}\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Object)], AxisGridLine.prototype, \"enabled\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], AxisGridLine.prototype, \"width\", void 0);\n__decorate([Validate(GRID_STYLE), __metadata(\"design:type\", Array)], AxisGridLine.prototype, \"style\", void 0);\nfunction Default(defaultValue, replaces = [undefined]) {\n  return addTransformToInstanceProperty((_, __, v) => {\n    if (replaces.includes(v)) {\n      return defaultValue;\n    }\n    return v;\n  });\n}\nclass AxisLabel {\n  constructor() {\n    this.enabled = true;\n    /** If set to `false`, axis labels will not be wrapped on multiple lines. */\n    this.autoWrap = false;\n    /** Used to constrain the width of the label when `autoWrap` is `true`, if the label text width exceeds the `maxWidth`, it will be wrapped on multiple lines automatically. If `maxWidth` is omitted, a default width constraint will be applied. */\n    this.maxWidth = undefined;\n    /** Used to constrain the height of the multiline label, if the label text height exceeds the `maxHeight`, it will be truncated automatically. If `maxHeight` is omitted, a default height constraint will be applied. */\n    this.maxHeight = undefined;\n    this.fontStyle = undefined;\n    this.fontWeight = undefined;\n    this.fontSize = 12;\n    this.fontFamily = 'Verdana, sans-serif';\n    /**\r\n     * The padding between the labels and the ticks.\r\n     */\n    this.padding = 5;\n    /**\r\n     * Minimum gap in pixels between the axis labels before being removed to avoid collisions.\r\n     */\n    this.minSpacing = NaN;\n    /**\r\n     * The color of the labels.\r\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\r\n     */\n    this.color = 'rgba(87, 87, 87, 1)';\n    /**\r\n     * Custom label rotation in degrees.\r\n     * Labels are rendered perpendicular to the axis line by default.\r\n     * Or parallel to the axis line, if the {@link parallel} is set to `true`.\r\n     * The value of this config is used as the angular offset/deflection\r\n     * from the default rotation.\r\n     */\n    this.rotation = undefined;\n    /**\r\n     * Avoid axis label collision by automatically reducing the number of ticks displayed. If set to `false`, axis labels may collide.\r\n     */\n    this.avoidCollisions = true;\n    /**\r\n     * By default, labels and ticks are positioned to the left of the axis line.\r\n     * `true` positions the labels to the right of the axis line.\r\n     * However, if the axis is rotated, it's easier to think in terms\r\n     * of this side or the opposite side, rather than left and right.\r\n     * We use the term `mirror` for conciseness, although it's not\r\n     * true mirroring - for example, when a label is rotated, so that\r\n     * it is inclined at the 45 degree angle, text flowing from north-west\r\n     * to south-east, ending at the tick to the left of the axis line,\r\n     * and then we set this config to `true`, the text will still be flowing\r\n     * from north-west to south-east, _starting_ at the tick to the right\r\n     * of the axis line.\r\n     */\n    this.mirrored = false;\n    /**\r\n     * Labels are rendered perpendicular to the axis line by default.\r\n     * Setting this config to `true` makes labels render parallel to the axis line\r\n     * and center aligns labels' text at the ticks.\r\n     */\n    this.parallel = false;\n    /**\r\n     * In case {@param value} is a number, the {@param fractionDigits} parameter will\r\n     * be provided as well. The `fractionDigits` corresponds to the number of fraction\r\n     * digits used by the tick step. For example, if the tick step is `0.0005`,\r\n     * the `fractionDigits` is 4.\r\n     */\n    this.formatter = undefined;\n  }\n  /**\r\n   * The side of the axis line to position the labels on.\r\n   * -1 = left (default)\r\n   * 1 = right\r\n   */\n  getSideFlag() {\n    return this.mirrored ? 1 : -1;\n  }\n  getFont() {\n    return getFont(this);\n  }\n}\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Object)], AxisLabel.prototype, \"enabled\", void 0);\n__decorate([Validate(OPT_BOOLEAN), __metadata(\"design:type\", Boolean)], AxisLabel.prototype, \"autoWrap\", void 0);\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], AxisLabel.prototype, \"maxWidth\", void 0);\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], AxisLabel.prototype, \"maxHeight\", void 0);\n__decorate([Validate(OPT_FONT_STYLE), __metadata(\"design:type\", String)], AxisLabel.prototype, \"fontStyle\", void 0);\n__decorate([Validate(OPT_FONT_WEIGHT), __metadata(\"design:type\", String)], AxisLabel.prototype, \"fontWeight\", void 0);\n__decorate([Validate(NUMBER$1(1)), __metadata(\"design:type\", Number)], AxisLabel.prototype, \"fontSize\", void 0);\n__decorate([Validate(STRING), __metadata(\"design:type\", String)], AxisLabel.prototype, \"fontFamily\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], AxisLabel.prototype, \"padding\", void 0);\n__decorate([Validate(NUMBER_OR_NAN()), Default(NaN), __metadata(\"design:type\", Number)], AxisLabel.prototype, \"minSpacing\", void 0);\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], AxisLabel.prototype, \"color\", void 0);\n__decorate([Validate(OPT_NUMBER(-360, 360)), __metadata(\"design:type\", Number)], AxisLabel.prototype, \"rotation\", void 0);\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Boolean)], AxisLabel.prototype, \"avoidCollisions\", void 0);\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Boolean)], AxisLabel.prototype, \"mirrored\", void 0);\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Boolean)], AxisLabel.prototype, \"parallel\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], AxisLabel.prototype, \"format\", void 0);\nclass AxisLine {\n  constructor() {\n    this.enabled = true;\n    this.width = 1;\n    this.color = undefined;\n  }\n}\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Object)], AxisLine.prototype, \"enabled\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], AxisLine.prototype, \"width\", void 0);\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], AxisLine.prototype, \"color\", void 0);\nconst OPT_TICK_INTERVAL = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, (v, ctx) => v !== 0 && NUMBER$1(0)(v, ctx) || v instanceof TimeInterval), `expecting an optional non-zero positive Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'`);\nclass AxisTick {\n  constructor() {\n    this.enabled = true;\n    /**\r\n     * The line width to be used by axis ticks.\r\n     */\n    this.width = 1;\n    /**\r\n     * The line length to be used by axis ticks.\r\n     */\n    this.size = 6;\n    /**\r\n     * The color of the axis ticks.\r\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make the ticks invisible.\r\n     */\n    this.color = undefined;\n    this.interval = undefined;\n    this.values = undefined;\n    this.minSpacing = NaN;\n  }\n}\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Object)], AxisTick.prototype, \"enabled\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], AxisTick.prototype, \"width\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], AxisTick.prototype, \"size\", void 0);\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], AxisTick.prototype, \"color\", void 0);\n__decorate([Validate(OPT_TICK_INTERVAL), __metadata(\"design:type\", Object)], AxisTick.prototype, \"interval\", void 0);\n__decorate([Validate(OPT_ARRAY()), __metadata(\"design:type\", Array)], AxisTick.prototype, \"values\", void 0);\n__decorate([Validate(AND(NUMBER_OR_NAN(1), LESS_THAN('maxSpacing'))), Default(NaN), __metadata(\"design:type\", Number)], AxisTick.prototype, \"minSpacing\", void 0);\nfunction prepareAxisAnimationContext(axis) {\n  const requestedRangeMin = Math.min(...axis.range);\n  const requestedRangeMax = Math.max(...axis.range);\n  const min = Math.floor(requestedRangeMin);\n  const max = Math.ceil(requestedRangeMax);\n  const visible = min !== max;\n  return {\n    min,\n    max,\n    visible\n  };\n}\nconst fullCircle = Math.PI * 2;\nconst halfCircle = fullCircle / 2;\nfunction normaliseEndRotation(start, end) {\n  const directDistance = Math.abs(end - start);\n  if (directDistance < halfCircle) return end;\n  if (start > end) return end + fullCircle;\n  return end - fullCircle;\n}\nfunction prepareAxisAnimationFunctions(ctx) {\n  const outOfBounds = datum => {\n    var _a, _b;\n    const min = Math.min(...((_a = datum.range) !== null && _a !== void 0 ? _a : [ctx.min]));\n    const max = Math.max(...((_b = datum.range) !== null && _b !== void 0 ? _b : [ctx.max]));\n    const translationY = Math.round(datum.translationY);\n    return translationY < min || translationY > max;\n  };\n  const calculateStatus = (datum, nodeDatum, status) => {\n    if (status !== 'removed' && outOfBounds(datum)) {\n      return 'removed';\n    } else if (status !== 'added' && outOfBounds(nodeDatum)) {\n      return 'added';\n    }\n    return status;\n  };\n  const fromBase = (node, datum, status) => {\n    // Default to starting at the same position that the node is currently in.\n    const source = {\n      translationY: Math.round(node.translationY),\n      opacity: node.opacity\n    };\n    status = calculateStatus(datum, node.datum, status);\n    if (status === 'added') {\n      source.translationY = Math.round(datum.translationY);\n      source.opacity = 0;\n    }\n    return Object.assign(Object.assign({}, source), FROM_TO_MIXINS[status]);\n  };\n  const toBase = (_node, datum, status) => {\n    const target = {\n      translationY: Math.round(datum.translationY),\n      opacity: 1\n    };\n    if (status === 'removed') {\n      target.opacity = 0;\n    }\n    return target;\n  };\n  const tick = {\n    fromFn: fromBase,\n    toFn: toBase,\n    intermediateFn: (node, _datum, _status) => {\n      return {\n        visible: !outOfBounds(node)\n      };\n    }\n  };\n  const label = {\n    fromFn: (node, newDatum, status) => {\n      var _a;\n      const datum = (_a = node.previousDatum) !== null && _a !== void 0 ? _a : newDatum;\n      let rotation = datum.rotation;\n      if (status === 'added' || status === 'removed') {\n        rotation = newDatum.rotation;\n      }\n      return Object.assign(Object.assign({}, fromBase(node, newDatum, status)), {\n        x: datum.x,\n        y: datum.y,\n        rotation,\n        rotationCenterX: datum.rotationCenterX\n      });\n    },\n    toFn: (node, datum, status) => {\n      var _a, _b;\n      let rotation;\n      if (status === 'added' || status === 'removed') {\n        rotation = datum.rotation;\n      } else {\n        rotation = normaliseEndRotation((_b = (_a = node.previousDatum) === null || _a === void 0 ? void 0 : _a.rotation) !== null && _b !== void 0 ? _b : datum.rotation, datum.rotation);\n      }\n      return Object.assign(Object.assign({}, toBase(node, datum, status)), {\n        x: datum.x,\n        y: datum.y,\n        rotation,\n        rotationCenterX: datum.rotationCenterX,\n        finish: {\n          rotation: datum.rotation\n        }\n      });\n    }\n  };\n  const line = {\n    fromFn: (node, datum) => {\n      var _a, _b;\n      return Object.assign(Object.assign({}, (_b = (_a = node.previousDatum) !== null && _a !== void 0 ? _a : datum) !== null && _b !== void 0 ? _b : {\n        y: node.y,\n        x1: node.x1,\n        x2: node.x2\n      }), FROM_TO_MIXINS['updated']);\n    },\n    toFn: (_node, datum) => {\n      return Object.assign({}, datum);\n    }\n  };\n  const group = {\n    fromFn: (group, _datum) => {\n      const {\n        rotation,\n        translationX,\n        translationY\n      } = group;\n      return Object.assign({\n        rotation,\n        translationX,\n        translationY\n      }, FROM_TO_MIXINS['updated']);\n    },\n    toFn: (_group, datum) => {\n      const {\n        rotation,\n        translationX,\n        translationY\n      } = datum;\n      return {\n        rotation,\n        translationX,\n        translationY\n      };\n    }\n  };\n  return {\n    tick,\n    line,\n    label,\n    group\n  };\n}\nfunction resetAxisGroupFn() {\n  return (_node, datum) => {\n    return {\n      rotation: datum.rotation,\n      rotationCenterX: datum.rotationCenterX,\n      rotationCenterY: datum.rotationCenterY,\n      translationX: datum.translationX,\n      translationY: datum.translationY\n    };\n  };\n}\nfunction resetAxisSelectionFn(ctx) {\n  const {\n    visible: rangeVisible,\n    min,\n    max\n  } = ctx;\n  return (_node, datum) => {\n    const translationY = Math.round(datum.translationY);\n    const visible = rangeVisible && translationY >= min && translationY <= max;\n    return {\n      translationY,\n      opacity: 1,\n      visible\n    };\n  };\n}\nfunction resetAxisLabelSelectionFn() {\n  return (_node, datum) => {\n    return {\n      x: datum.x,\n      y: datum.y,\n      translationY: datum.translationY,\n      rotation: datum.rotation,\n      rotationCenterX: datum.rotationCenterX\n    };\n  };\n}\nfunction resetAxisLineSelectionFn() {\n  return (_node, datum) => {\n    return Object.assign({}, datum);\n  };\n}\nvar Tags;\n(function (Tags) {\n  Tags[Tags[\"TickLine\"] = 0] = \"TickLine\";\n  Tags[Tags[\"TickLabel\"] = 1] = \"TickLabel\";\n  Tags[Tags[\"GridLine\"] = 2] = \"GridLine\";\n  Tags[Tags[\"GridArc\"] = 3] = \"GridArc\";\n  Tags[Tags[\"AxisLine\"] = 4] = \"AxisLine\";\n})(Tags || (Tags = {}));\nvar TickGenerationType;\n(function (TickGenerationType) {\n  TickGenerationType[TickGenerationType[\"CREATE\"] = 0] = \"CREATE\";\n  TickGenerationType[TickGenerationType[\"CREATE_SECONDARY\"] = 1] = \"CREATE_SECONDARY\";\n  TickGenerationType[TickGenerationType[\"FILTER\"] = 2] = \"FILTER\";\n  TickGenerationType[TickGenerationType[\"VALUES\"] = 3] = \"VALUES\";\n})(TickGenerationType || (TickGenerationType = {}));\n/**\r\n * A general purpose linear axis with no notion of orientation.\r\n * The axis is always rendered vertically, with horizontal labels positioned to the left\r\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\r\n * so that it can be used as a top, right, bottom, left, radial or any other kind\r\n * of linear axis.\r\n * The generic `D` parameter is the type of the domain of the axis' scale.\r\n * The output range of the axis' scale is always numeric (screen coordinates).\r\n */\nclass Axis {\n  get type() {\n    var _a;\n    return (_a = this.constructor.type) !== null && _a !== void 0 ? _a : '';\n  }\n  set crossLines(value) {\n    var _a, _b;\n    (_a = this._crossLines) === null || _a === void 0 ? void 0 : _a.forEach(crossLine => this.detachCrossLine(crossLine));\n    if (value) {\n      this.assignCrossLineArrayConstructor(value);\n    }\n    this._crossLines = value;\n    (_b = this._crossLines) === null || _b === void 0 ? void 0 : _b.forEach(crossLine => {\n      this.attachCrossLine(crossLine);\n      this.initCrossLine(crossLine);\n    });\n  }\n  get crossLines() {\n    return this._crossLines;\n  }\n  constructor(moduleCtx, scale) {\n    this.moduleCtx = moduleCtx;\n    this.scale = scale;\n    this.id = createId(this);\n    this.nice = true;\n    this.dataDomain = {\n      domain: [],\n      clipped: false\n    };\n    this.keys = [];\n    this.boundSeries = [];\n    this.includeInvisibleDomains = false;\n    this.axisGroup = new Group({\n      name: `${this.id}-axis`,\n      zIndex: Layers.AXIS_ZINDEX\n    });\n    this.lineNode = this.axisGroup.appendChild(new Line());\n    this.tickLineGroup = this.axisGroup.appendChild(new Group({\n      name: `${this.id}-Axis-tick-lines`,\n      zIndex: Layers.AXIS_ZINDEX\n    }));\n    this.tickLabelGroup = this.axisGroup.appendChild(new Group({\n      name: `${this.id}-Axis-tick-labels`,\n      zIndex: Layers.AXIS_ZINDEX\n    }));\n    this.crossLineGroup = new Group({\n      name: `${this.id}-CrossLines`\n    });\n    this.gridGroup = new Group({\n      name: `${this.id}-Axis-grid`\n    });\n    this.gridLineGroup = this.gridGroup.appendChild(new Group({\n      name: `${this.id}-gridLines`,\n      zIndex: Layers.AXIS_GRID_ZINDEX\n    }));\n    this.tickLineGroupSelection = Selection.select(this.tickLineGroup, Line, false);\n    this.tickLabelGroupSelection = Selection.select(this.tickLabelGroup, Text, false);\n    this.gridLineGroupSelection = Selection.select(this.gridLineGroup, Line, false);\n    this.line = new AxisLine();\n    this.tick = this.createTick();\n    this.gridLine = new AxisGridLine();\n    this.label = this.createLabel();\n    this.defaultTickMinSpacing = Axis.defaultTickMinSpacing;\n    this.translation = {\n      x: 0,\n      y: 0\n    };\n    this.rotation = 0; // axis rotation angle in degrees\n    this.layout = {\n      label: {\n        fractionDigits: 0,\n        padding: this.label.padding,\n        format: this.label.format\n      }\n    };\n    this.destroyFns = [];\n    this.range = [0, 1];\n    this.visibleRange = [0, 1];\n    this.title = undefined;\n    this._titleCaption = new Caption();\n    /**\r\n     * The length of the grid. The grid is only visible in case of a non-zero value.\r\n     * In case {@link radialGrid} is `true`, the value is interpreted as an angle\r\n     * (in degrees).\r\n     */\n    this._gridLength = 0;\n    this.fractionDigits = 0;\n    /**\r\n     * The distance between the grid ticks and the axis ticks.\r\n     */\n    this.gridPadding = 0;\n    /**\r\n     * Is used to avoid collisions between axis labels and series.\r\n     */\n    this.seriesAreaPadding = 0;\n    this.tickGenerationResult = undefined;\n    this.maxThickness = Infinity;\n    this.moduleMap = new ModuleMap(this);\n    this.refreshScale();\n    this._titleCaption.node.rotation = -Math.PI / 2;\n    this.axisGroup.appendChild(this._titleCaption.node);\n    this.destroyFns.push(moduleCtx.interactionManager.addListener('hover', e => this.checkAxisHover(e)));\n    this.animationManager = moduleCtx.animationManager;\n    this.animationState = new StateMachine('empty', {\n      empty: {\n        update: {\n          target: 'ready',\n          action: () => this.resetSelectionNodes()\n        }\n      },\n      ready: {\n        update: data => this.animateReadyUpdate(data),\n        resize: () => this.resetSelectionNodes()\n      }\n    });\n    this._crossLines = [];\n    this.assignCrossLineArrayConstructor(this._crossLines);\n    let previousSize = undefined;\n    this.destroyFns.push(moduleCtx.layoutService.addListener('layout-complete', e => {\n      // Fire resize animation action if chart canvas size changes.\n      if (previousSize != null && jsonDiff(e.chart, previousSize) != null) {\n        this.animationState.transition('resize');\n      }\n      previousSize = Object.assign({}, e.chart);\n    }));\n    this.destroyFns.push(moduleCtx.updateService.addListener('update-complete', e => {\n      this.minRect = e.minRect;\n    }));\n  }\n  attachCrossLine(crossLine) {\n    this.crossLineGroup.appendChild(crossLine.group);\n  }\n  detachCrossLine(crossLine) {\n    this.crossLineGroup.removeChild(crossLine.group);\n  }\n  destroy() {\n    this.moduleMap.destroy();\n    this.destroyFns.forEach(f => f());\n  }\n  refreshScale() {\n    var _a;\n    this.range = this.scale.range.slice();\n    (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach(crossLine => {\n      this.initCrossLine(crossLine);\n    });\n  }\n  updateRange() {\n    var _a;\n    const {\n      range: rr,\n      visibleRange: vr,\n      scale\n    } = this;\n    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    const shift = span * vr[0];\n    const start = rr[0] - shift;\n    scale.range = [start, start + span];\n    (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach(crossLine => {\n      crossLine.clippedRange = [rr[0], rr[1]];\n    });\n  }\n  setCrossLinesVisible(visible) {\n    this.crossLineGroup.visible = visible;\n  }\n  attachAxis(axisNode, gridNode) {\n    gridNode.appendChild(this.gridGroup);\n    axisNode.appendChild(this.axisGroup);\n    axisNode.appendChild(this.crossLineGroup);\n  }\n  detachAxis(axisNode, gridNode) {\n    gridNode.removeChild(this.gridGroup);\n    axisNode.removeChild(this.axisGroup);\n    axisNode.removeChild(this.crossLineGroup);\n  }\n  /**\r\n   * Checks if a point or an object is in range.\r\n   * @param x A point (or object's starting point).\r\n   * @param width Object's width.\r\n   * @param tolerance Expands the range on both ends by this amount.\r\n   */\n  inRange(x, width = 0, tolerance = 0) {\n    const min = Math.min(...this.range);\n    const max = Math.max(...this.range);\n    return x + width >= min - tolerance && x <= max + tolerance;\n  }\n  onLabelFormatChange(ticks, format) {\n    const {\n      scale,\n      fractionDigits\n    } = this;\n    const logScale = scale instanceof LogScale;\n    const defaultLabelFormatter = !logScale && fractionDigits > 0 ? x => typeof x === 'number' ? x.toFixed(fractionDigits) : String(x) : x => String(x);\n    if (format && scale && scale.tickFormat) {\n      try {\n        this.labelFormatter = scale.tickFormat({\n          ticks,\n          specifier: format\n        });\n      } catch (e) {\n        this.labelFormatter = defaultLabelFormatter;\n        Logger.warnOnce(`the axis label format string ${format} is invalid. No formatting will be applied`);\n      }\n    } else {\n      this.labelFormatter = defaultLabelFormatter;\n    }\n  }\n  setDomain() {\n    var _a;\n    const {\n      scale,\n      dataDomain: {\n        domain\n      },\n      tick: {\n        values: tickValues\n      }\n    } = this;\n    if (tickValues && ContinuousScale.is(scale)) {\n      const [tickMin, tickMax] = (_a = extent(tickValues)) !== null && _a !== void 0 ? _a : [Infinity, -Infinity];\n      const min = Math.min(scale.fromDomain(domain[0]), tickMin);\n      const max = Math.max(scale.fromDomain(domain[1]), tickMax);\n      scale.domain = [scale.toDomain(min), scale.toDomain(max)];\n    } else {\n      scale.domain = domain;\n    }\n  }\n  setTickInterval(interval) {\n    var _a;\n    this.scale.interval = (_a = this.tick.interval) !== null && _a !== void 0 ? _a : interval;\n  }\n  setTickCount(count, minTickCount, maxTickCount) {\n    const {\n      scale\n    } = this;\n    if (!(count && ContinuousScale.is(scale))) {\n      return;\n    }\n    if (typeof count === 'number') {\n      scale.tickCount = count;\n      scale.minTickCount = minTickCount !== null && minTickCount !== void 0 ? minTickCount : 0;\n      scale.maxTickCount = maxTickCount !== null && maxTickCount !== void 0 ? maxTickCount : Infinity;\n      return;\n    }\n    if (scale instanceof TimeScale) {\n      this.setTickInterval(count);\n    }\n  }\n  set gridLength(value) {\n    var _a;\n    // Was visible and now invisible, or was invisible and now visible.\n    if (this._gridLength && !value || !this._gridLength && value) {\n      this.gridLineGroupSelection.clear();\n    }\n    this._gridLength = value;\n    (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach(crossLine => {\n      this.initCrossLine(crossLine);\n    });\n  }\n  get gridLength() {\n    return this._gridLength;\n  }\n  createTick() {\n    return new AxisTick();\n  }\n  createLabel() {\n    return new AxisLabel();\n  }\n  checkAxisHover(event) {\n    const bbox = this.computeBBox();\n    const isInAxis = bbox.containsPoint(event.offsetX, event.offsetY);\n    if (!isInAxis) return;\n    this.moduleCtx.chartEventManager.axisHover(this.id, this.direction);\n  }\n  /**\r\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\r\n   */\n  update(primaryTickCount) {\n    if (!this.tickGenerationResult) {\n      return;\n    }\n    const {\n      rotation,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    this.updatePosition();\n    const lineData = this.getAxisLineCoordinates();\n    const _a = this.tickGenerationResult,\n      {\n        tickData,\n        combinedRotation,\n        textBaseline,\n        textAlign\n      } = _a,\n      ticksResult = __rest(_a, [\"tickData\", \"combinedRotation\", \"textBaseline\", \"textAlign\"]);\n    const previousTicks = this.tickLabelGroupSelection.nodes().map(node => node.datum.tickId);\n    this.updateSelections(lineData, tickData.ticks, {\n      combinedRotation,\n      textAlign,\n      textBaseline,\n      range: this.scale.range\n    });\n    if (this.animationManager.isSkipped()) {\n      this.resetSelectionNodes();\n    } else {\n      const diff = this.calculateUpdateDiff(previousTicks, tickData);\n      this.animationState.transition('update', diff);\n    }\n    this.updateAxisLine();\n    this.updateLabels();\n    this.updateVisibility();\n    this.updateGridLines(sideFlag);\n    this.updateTickLines();\n    this.updateTitle({\n      anyTickVisible: tickData.ticks.length > 0\n    });\n    this.updateCrossLines({\n      rotation,\n      parallelFlipRotation,\n      regularFlipRotation\n    });\n    this.updateLayoutState();\n    primaryTickCount = ticksResult.primaryTickCount;\n    return primaryTickCount;\n  }\n  getAxisLineCoordinates() {\n    const {\n      range: [start, end]\n    } = this;\n    const x = 0;\n    const y1 = Math.min(start, end);\n    const y2 = Math.max(start, end);\n    return {\n      x,\n      y1,\n      y2\n    };\n  }\n  getTickLineCoordinates(datum) {\n    const {\n      tick,\n      label\n    } = this;\n    const sideFlag = label.getSideFlag();\n    const x = sideFlag * tick.size;\n    const x1 = Math.min(0, x);\n    const x2 = x1 + Math.abs(x);\n    const y = Math.round(datum.translationY);\n    return {\n      x1,\n      x2,\n      y\n    };\n  }\n  getTickLabelProps(datum, params) {\n    const {\n      label\n    } = this;\n    const {\n      combinedRotation,\n      textBaseline,\n      textAlign,\n      range\n    } = params;\n    const text = datum.tickLabel;\n    const sideFlag = label.getSideFlag();\n    const tickSize = this.tick.size;\n    const labelX = sideFlag * (tickSize + label.padding + this.seriesAreaPadding);\n    const visible = text !== '' && text != undefined;\n    return {\n      tickId: datum.tickId,\n      translationY: datum.translationY,\n      fill: label.color,\n      fontFamily: label.fontFamily,\n      fontSize: label.fontSize,\n      fontStyle: label.fontStyle,\n      fontWeight: label.fontWeight,\n      rotation: combinedRotation,\n      rotationCenterX: labelX,\n      text,\n      textAlign,\n      textBaseline,\n      visible,\n      x: labelX,\n      y: 0,\n      range\n    };\n  }\n  setTitleProps(caption, params) {\n    var _a;\n    const {\n      title\n    } = this;\n    if (!title) {\n      caption.enabled = false;\n      return;\n    }\n    caption.color = title.color;\n    caption.fontFamily = title.fontFamily;\n    caption.fontSize = title.fontSize;\n    caption.fontStyle = title.fontStyle;\n    caption.fontWeight = title.fontWeight;\n    caption.enabled = title.enabled;\n    caption.wrapping = title.wrapping;\n    if (title.enabled) {\n      const titleNode = caption.node;\n      const {\n        tickSpace\n      } = params;\n      const padding = ((_a = title.spacing) !== null && _a !== void 0 ? _a : 0) + tickSpace;\n      const sideFlag = this.label.getSideFlag();\n      const parallelFlipRotation = normalizeAngle360(this.rotation);\n      const titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\n      const rotation = titleRotationFlag * sideFlag * Math.PI / 2;\n      const textBaseline = titleRotationFlag === 1 ? 'bottom' : 'top';\n      const {\n        range\n      } = this;\n      const x = Math.floor(titleRotationFlag * sideFlag * (range[0] + range[1]) / 2);\n      const y = sideFlag === -1 ? Math.floor(titleRotationFlag * -padding) : Math.floor(-padding);\n      const {\n        callbackCache\n      } = this.moduleCtx;\n      const {\n        formatter = params => params.defaultValue\n      } = title;\n      const text = callbackCache.call(formatter, this.getTitleFormatterParams());\n      titleNode.setProperties({\n        rotation,\n        text,\n        textBaseline,\n        visible: true,\n        x,\n        y\n      });\n    }\n  }\n  calculateLayout(primaryTickCount) {\n    var _a;\n    const {\n      rotation,\n      parallelFlipRotation,\n      regularFlipRotation\n    } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    const labelX = sideFlag * (this.tick.size + this.label.padding + this.seriesAreaPadding);\n    this.updateScale();\n    this.tickGenerationResult = this.generateTicks({\n      primaryTickCount,\n      parallelFlipRotation,\n      regularFlipRotation,\n      labelX,\n      sideFlag\n    });\n    const _b = this.tickGenerationResult,\n      {\n        tickData,\n        combinedRotation,\n        textBaseline,\n        textAlign\n      } = _b,\n      ticksResult = __rest(_b, [\"tickData\", \"combinedRotation\", \"textBaseline\", \"textAlign\"]);\n    const boxes = [];\n    const {\n      x,\n      y1,\n      y2\n    } = this.getAxisLineCoordinates();\n    const lineBox = new BBox(x, y1, 0, y2 - y1);\n    boxes.push(lineBox);\n    const {\n      tick\n    } = this;\n    if (tick.enabled) {\n      tickData.ticks.forEach(datum => {\n        const {\n          x1,\n          x2,\n          y\n        } = this.getTickLineCoordinates(datum);\n        const tickLineBox = new BBox(x1, y, x2 - x1, 0);\n        boxes.push(tickLineBox);\n      });\n    }\n    const {\n      label\n    } = this;\n    if (label.enabled) {\n      const tempText = new Text();\n      tickData.ticks.forEach(datum => {\n        const labelProps = this.getTickLabelProps(datum, {\n          combinedRotation,\n          textAlign,\n          textBaseline,\n          range: this.scale.range\n        });\n        if (!labelProps.visible) {\n          return;\n        }\n        tempText.setProperties(Object.assign(Object.assign({}, labelProps), {\n          translationY: Math.round(datum.translationY)\n        }));\n        const box = tempText.computeTransformedBBox();\n        if (box) {\n          boxes.push(box);\n        }\n      });\n    }\n    const getTransformBox = bbox => {\n      const matrix = new Matrix();\n      const {\n        rotation: axisRotation,\n        translationX,\n        translationY,\n        rotationCenterX,\n        rotationCenterY\n      } = this.getAxisTransform();\n      Matrix.updateTransformMatrix(matrix, 1, 1, axisRotation, translationX, translationY, {\n        scalingCenterX: 0,\n        scalingCenterY: 0,\n        rotationCenterX,\n        rotationCenterY\n      });\n      return matrix.transformBBox(bbox);\n    };\n    const {\n      title\n    } = this;\n    if (title === null || title === void 0 ? void 0 : title.enabled) {\n      const caption = new Caption();\n      let tickSpace = 0;\n      if (tickData.ticks.length > 0) {\n        const contentBox = BBox.merge(boxes);\n        const tickWidth = contentBox.width;\n        if (isFinite(tickWidth)) {\n          tickSpace += tickWidth;\n        }\n      }\n      this.setTitleProps(caption, {\n        tickSpace\n      });\n      const titleNode = caption.node;\n      const titleBox = titleNode.computeTransformedBBox();\n      if (titleBox) {\n        boxes.push(titleBox);\n      }\n    }\n    const bbox = BBox.merge(boxes);\n    const transformedBBox = getTransformBox(bbox);\n    const anySeriesActive = this.isAnySeriesActive();\n    (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach(crossLine => {\n      var _a;\n      crossLine.sideFlag = -sideFlag;\n      crossLine.direction = rotation === -Math.PI / 2 ? ChartAxisDirection.X : ChartAxisDirection.Y;\n      if (crossLine instanceof CartesianCrossLine) {\n        crossLine.label.parallel = (_a = crossLine.label.parallel) !== null && _a !== void 0 ? _a : this.label.parallel;\n      }\n      crossLine.parallelFlipRotation = parallelFlipRotation;\n      crossLine.regularFlipRotation = regularFlipRotation;\n      crossLine.calculateLayout(anySeriesActive);\n    });\n    this.updateLayoutState();\n    primaryTickCount = ticksResult.primaryTickCount;\n    return {\n      primaryTickCount,\n      bbox: transformedBBox\n    };\n  }\n  updateLayoutState() {\n    this.layout.label = {\n      fractionDigits: this.fractionDigits,\n      padding: this.label.padding,\n      format: this.label.format\n    };\n  }\n  updateScale() {\n    this.updateRange();\n    this.calculateDomain();\n    this.setDomain();\n    this.setTickInterval(this.tick.interval);\n    const {\n      scale,\n      nice\n    } = this;\n    if (!ContinuousScale.is(scale)) {\n      return;\n    }\n    scale.nice = nice;\n    scale.update();\n  }\n  calculateRotations() {\n    const rotation = toRadians(this.rotation);\n    // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n    // flip the labels to avoid upside-down text, when the axis is rotated\n    // such that it is in the right hemisphere, i.e. the angle of rotation\n    // is in the [0, π] interval.\n    // The rotation angle is normalized, so that we have an easier time checking\n    // if it's in the said interval. Since the axis is always rendered vertically\n    // and then rotated, zero rotation means 12 (not 3) o-clock.\n    // -1 = flip\n    //  1 = don't flip (default)\n    const parallelFlipRotation = normalizeAngle360(rotation);\n    const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\n    return {\n      rotation,\n      parallelFlipRotation,\n      regularFlipRotation\n    };\n  }\n  generateTicks({\n    primaryTickCount,\n    parallelFlipRotation,\n    regularFlipRotation,\n    labelX,\n    sideFlag\n  }) {\n    var _a;\n    const {\n      scale,\n      tick,\n      label: {\n        parallel,\n        rotation,\n        fontFamily,\n        fontSize,\n        fontStyle,\n        fontWeight\n      }\n    } = this;\n    const secondaryAxis = primaryTickCount !== undefined;\n    const {\n      defaultRotation,\n      configuredRotation,\n      parallelFlipFlag,\n      regularFlipFlag\n    } = calculateLabelRotation({\n      rotation,\n      parallel,\n      regularFlipRotation,\n      parallelFlipRotation\n    });\n    const initialRotation = configuredRotation + defaultRotation;\n    const labelMatrix = new Matrix();\n    const {\n      maxTickCount\n    } = this.estimateTickCount({\n      minSpacing: tick.minSpacing,\n      maxSpacing: (_a = tick.maxSpacing) !== null && _a !== void 0 ? _a : NaN\n    });\n    const continuous = ContinuousScale.is(scale);\n    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\n    let textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\n    const textBaseline = getTextBaseline(parallel, configuredRotation, sideFlag, parallelFlipFlag);\n    const textProps = {\n      fontFamily,\n      fontSize,\n      fontStyle,\n      fontWeight,\n      textBaseline,\n      textAlign\n    };\n    let tickData = {\n      rawTicks: [],\n      ticks: [],\n      labelCount: 0\n    };\n    let index = 0;\n    let autoRotation = 0;\n    let labelOverlap = true;\n    let terminate = false;\n    while (labelOverlap && index <= maxIterations) {\n      if (terminate) {\n        break;\n      }\n      autoRotation = 0;\n      textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\n      const tickStrategies = this.getTickStrategies({\n        secondaryAxis,\n        index\n      });\n      for (const strategy of tickStrategies) {\n        ({\n          tickData,\n          index,\n          autoRotation,\n          terminate\n        } = strategy({\n          index,\n          tickData,\n          textProps,\n          labelOverlap,\n          terminate,\n          primaryTickCount\n        }));\n        const rotated = configuredRotation !== 0 || autoRotation !== 0;\n        const rotation = initialRotation + autoRotation;\n        textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);\n        labelOverlap = this.checkLabelOverlap(rotation, rotated, labelMatrix, tickData.ticks, labelX, Object.assign(Object.assign({}, textProps), {\n          textAlign\n        }));\n      }\n    }\n    const combinedRotation = defaultRotation + configuredRotation + autoRotation;\n    if (!secondaryAxis && tickData.rawTicks.length > 0) {\n      primaryTickCount = tickData.rawTicks.length;\n    }\n    return {\n      tickData,\n      primaryTickCount,\n      combinedRotation,\n      textBaseline,\n      textAlign\n    };\n  }\n  getTickStrategies({\n    index,\n    secondaryAxis\n  }) {\n    const {\n      scale,\n      label,\n      tick\n    } = this;\n    const continuous = ContinuousScale.is(scale);\n    const avoidLabelCollisions = label.enabled && label.avoidCollisions;\n    const filterTicks = !continuous && index !== 0 && avoidLabelCollisions;\n    const autoRotate = label.autoRotate === true && label.rotation === undefined;\n    const strategies = [];\n    let tickGenerationType;\n    if (this.tick.values) {\n      tickGenerationType = TickGenerationType.VALUES;\n    } else if (secondaryAxis) {\n      tickGenerationType = TickGenerationType.CREATE_SECONDARY;\n    } else if (filterTicks) {\n      tickGenerationType = TickGenerationType.FILTER;\n    } else {\n      tickGenerationType = TickGenerationType.CREATE;\n    }\n    const tickGenerationStrategy = ({\n      index,\n      tickData,\n      primaryTickCount,\n      terminate\n    }) => this.createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount);\n    strategies.push(tickGenerationStrategy);\n    if (!continuous && !isNaN(tick.minSpacing)) {\n      const tickFilterStrategy = ({\n        index,\n        tickData,\n        primaryTickCount,\n        terminate\n      }) => this.createTickData(TickGenerationType.FILTER, index, tickData, terminate, primaryTickCount);\n      strategies.push(tickFilterStrategy);\n    }\n    if (!avoidLabelCollisions) {\n      return strategies;\n    }\n    if (label.autoWrap) {\n      const autoWrapStrategy = ({\n        index,\n        tickData,\n        textProps\n      }) => this.wrapLabels(tickData, index, textProps);\n      strategies.push(autoWrapStrategy);\n    } else if (autoRotate) {\n      const autoRotateStrategy = ({\n        index,\n        tickData,\n        labelOverlap,\n        terminate\n      }) => ({\n        index,\n        tickData,\n        autoRotation: this.getAutoRotation(labelOverlap),\n        terminate\n      });\n      strategies.push(autoRotateStrategy);\n    }\n    return strategies;\n  }\n  createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount) {\n    var _a;\n    const {\n      scale,\n      tick\n    } = this;\n    const {\n      maxTickCount,\n      minTickCount,\n      defaultTickCount\n    } = this.estimateTickCount({\n      minSpacing: tick.minSpacing,\n      maxSpacing: (_a = tick.maxSpacing) !== null && _a !== void 0 ? _a : NaN\n    });\n    const continuous = ContinuousScale.is(scale);\n    const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\n    let tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\n    const regenerateTicks = tick.interval === undefined && tick.values === undefined && tickCount > minTickCount && (continuous || tickGenerationType === TickGenerationType.FILTER);\n    let unchanged = true;\n    while (unchanged && index <= maxIterations) {\n      const prevTicks = tickData.rawTicks;\n      tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\n      const {\n        rawTicks,\n        ticks,\n        labelCount\n      } = this.getTicks({\n        tickGenerationType,\n        previousTicks: prevTicks,\n        tickCount,\n        minTickCount,\n        maxTickCount,\n        primaryTickCount\n      });\n      tickData.rawTicks = rawTicks;\n      tickData.ticks = ticks;\n      tickData.labelCount = labelCount;\n      unchanged = regenerateTicks ? areArrayNumbersEqual(rawTicks, prevTicks) : false;\n      index++;\n    }\n    const shouldTerminate = tick.interval !== undefined || tick.values !== undefined;\n    terminate || (terminate = shouldTerminate);\n    return {\n      tickData,\n      index,\n      autoRotation: 0,\n      terminate\n    };\n  }\n  checkLabelOverlap(rotation, rotated, labelMatrix, tickData, labelX, textProps) {\n    Matrix.updateTransformMatrix(labelMatrix, 1, 1, rotation, 0, 0);\n    const labelData = this.createLabelData(tickData, labelX, textProps, labelMatrix);\n    const labelSpacing = getLabelSpacing(this.label.minSpacing, rotated);\n    return axisLabelsOverlap(labelData, labelSpacing);\n  }\n  createLabelData(tickData, labelX, textProps, labelMatrix) {\n    const labelData = [];\n    for (const tickDatum of tickData) {\n      const {\n        tickLabel,\n        translationY\n      } = tickDatum;\n      if (tickLabel === '' || tickLabel == undefined) {\n        // skip user hidden ticks\n        continue;\n      }\n      const lines = splitText(tickLabel);\n      const {\n        width,\n        height\n      } = measureText(lines, labelX, translationY, textProps);\n      const bbox = new BBox(labelX, translationY, width, height);\n      const labelDatum = calculateLabelBBox(tickLabel, bbox, labelX, translationY, labelMatrix);\n      labelData.push(labelDatum);\n    }\n    return labelData;\n  }\n  getAutoRotation(labelOverlap) {\n    var _a;\n    return labelOverlap ? normalizeAngle360(toRadians((_a = this.label.autoRotateAngle) !== null && _a !== void 0 ? _a : 0)) : 0;\n  }\n  getTicks({\n    tickGenerationType,\n    previousTicks,\n    tickCount,\n    minTickCount,\n    maxTickCount,\n    primaryTickCount\n  }) {\n    var _a;\n    const {\n      range,\n      scale,\n      visibleRange\n    } = this;\n    let rawTicks = [];\n    switch (tickGenerationType) {\n      case TickGenerationType.VALUES:\n        rawTicks = this.tick.values;\n        break;\n      case TickGenerationType.CREATE_SECONDARY:\n        // `updateSecondaryAxisTicks` mutates `scale.domain` based on `primaryTickCount`\n        rawTicks = this.updateSecondaryAxisTicks(primaryTickCount);\n        break;\n      case TickGenerationType.FILTER:\n        rawTicks = this.filterTicks(previousTicks, tickCount);\n        break;\n      default:\n        rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);\n        break;\n    }\n    // When the scale domain or the ticks change, the label format may change\n    this.onLabelFormatChange(rawTicks, this.label.format);\n    // `ticks instanceof NumericTicks` doesn't work here, so we feature detect.\n    this.fractionDigits = rawTicks.fractionDigits >= 0 ? rawTicks.fractionDigits : 0;\n    const halfBandwidth = ((_a = scale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;\n    const ticks = [];\n    let labelCount = 0;\n    const tickIdCounts = new Map();\n    // Only get the ticks within a sliding window of the visible range to improve performance\n    const start = Math.max(0, Math.floor(visibleRange[0] * rawTicks.length));\n    const end = Math.min(rawTicks.length, Math.ceil(visibleRange[1] * rawTicks.length));\n    for (let i = start; i < end; i++) {\n      const rawTick = rawTicks[i];\n      const translationY = scale.convert(rawTick) + halfBandwidth;\n      // Do not render ticks outside the range with a small tolerance. A clip rect would trim long labels, so\n      // instead hide ticks based on their translation.\n      if (range.length > 0 && !this.inRange(translationY, 0, 0.001)) continue;\n      const tickLabel = this.formatTick(rawTick, i);\n      // Create a tick id from the label, or as an increment of the last label if this tick label is blank\n      let tickId = tickLabel;\n      if (tickIdCounts.has(tickId)) {\n        const count = tickIdCounts.get(tickId);\n        tickIdCounts.set(tickId, count + 1);\n        tickId = `${tickId}_${count}`;\n      } else {\n        tickIdCounts.set(tickId, 1);\n      }\n      ticks.push({\n        tick: rawTick,\n        tickId,\n        tickLabel,\n        translationY\n      });\n      if (tickLabel === '' || tickLabel == undefined) {\n        continue;\n      }\n      labelCount++;\n    }\n    return {\n      rawTicks,\n      ticks,\n      labelCount\n    };\n  }\n  filterTicks(ticks, tickCount) {\n    var _a;\n    const tickSpacing = !isNaN(this.tick.minSpacing) || !isNaN((_a = this.tick.maxSpacing) !== null && _a !== void 0 ? _a : NaN);\n    const keepEvery = tickSpacing ? Math.ceil(ticks.length / tickCount) : 2;\n    return ticks.filter((_, i) => i % keepEvery === 0);\n  }\n  createTicks(tickCount, minTickCount, maxTickCount) {\n    var _a, _b, _c;\n    this.setTickCount(tickCount, minTickCount, maxTickCount);\n    return (_c = (_b = (_a = this.scale).ticks) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : [];\n  }\n  estimateTickCount({\n    minSpacing,\n    maxSpacing\n  }) {\n    const {\n      minRect\n    } = this;\n    const rangeWithBleed = this.calculateRangeWithBleed();\n    const defaultMinSpacing = Math.max(this.defaultTickMinSpacing, rangeWithBleed / ContinuousScale.defaultMaxTickCount);\n    let clampMaxTickCount = !isNaN(maxSpacing);\n    if (isNaN(minSpacing)) {\n      minSpacing = defaultMinSpacing;\n    }\n    if (isNaN(maxSpacing)) {\n      maxSpacing = rangeWithBleed;\n    }\n    if (minSpacing > maxSpacing) {\n      if (minSpacing === defaultMinSpacing) {\n        minSpacing = maxSpacing;\n      } else {\n        maxSpacing = minSpacing;\n      }\n    }\n    // Clamps the min spacing between ticks to be no more than the min distance between datums\n    const minRectDistance = minRect ? this.direction === ChartAxisDirection.X ? minRect.width : minRect.height : 1;\n    clampMaxTickCount && (clampMaxTickCount = minRectDistance < defaultMinSpacing);\n    const maxTickCount = clamp(1, Math.floor(rangeWithBleed / minSpacing), clampMaxTickCount ? Math.floor(rangeWithBleed / minRectDistance) : Infinity);\n    const minTickCount = Math.min(maxTickCount, Math.ceil(rangeWithBleed / maxSpacing));\n    const defaultTickCount = clamp(minTickCount, ContinuousScale.defaultTickCount, maxTickCount);\n    return {\n      minTickCount,\n      maxTickCount,\n      defaultTickCount\n    };\n  }\n  updateVisibility() {\n    if (this.moduleCtx.animationManager.isSkipped()) {\n      this.resetSelectionNodes();\n    }\n    this.tickLineGroup.visible = this.tick.enabled;\n    this.gridLineGroup.visible = this.gridLine.enabled;\n    this.tickLabelGroup.visible = this.label.enabled;\n  }\n  updateCrossLines({\n    rotation,\n    parallelFlipRotation,\n    regularFlipRotation\n  }) {\n    var _a;\n    const sideFlag = this.label.getSideFlag();\n    const anySeriesActive = this.isAnySeriesActive();\n    (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach(crossLine => {\n      var _a;\n      crossLine.sideFlag = -sideFlag;\n      crossLine.direction = rotation === -Math.PI / 2 ? ChartAxisDirection.X : ChartAxisDirection.Y;\n      if (crossLine instanceof CartesianCrossLine) {\n        crossLine.label.parallel = (_a = crossLine.label.parallel) !== null && _a !== void 0 ? _a : this.label.parallel;\n      }\n      crossLine.parallelFlipRotation = parallelFlipRotation;\n      crossLine.regularFlipRotation = regularFlipRotation;\n      crossLine.update(anySeriesActive);\n    });\n  }\n  updateTickLines() {\n    const {\n      tick,\n      label\n    } = this;\n    const sideFlag = label.getSideFlag();\n    this.tickLineGroupSelection.each(line => {\n      line.strokeWidth = tick.width;\n      line.stroke = tick.color;\n      line.x1 = sideFlag * tick.size;\n      line.x2 = 0;\n      line.y1 = 0;\n      line.y2 = 0;\n    });\n  }\n  calculateAvailableRange() {\n    const {\n      range\n    } = this;\n    const min = Math.min(...range);\n    const max = Math.max(...range);\n    return max - min;\n  }\n  /**\r\n   * Calculates the available range with an additional \"bleed\" beyond the canvas that encompasses the full axis when\r\n   * the visible range is only a portion of the axis.\r\n   */\n  calculateRangeWithBleed() {\n    const {\n      visibleRange\n    } = this;\n    const visibleScale = 1 / (visibleRange[1] - visibleRange[0]);\n    return round$1(this.calculateAvailableRange() * visibleScale, 2);\n  }\n  calculateDomain() {\n    if (this.linkedTo) {\n      this.dataDomain = this.linkedTo.dataDomain;\n    } else {\n      const visibleSeries = this.boundSeries.filter(s => this.includeInvisibleDomains || s.isEnabled());\n      const domains = visibleSeries.flatMap(series => series.getDomain(this.direction));\n      this.dataDomain = this.normaliseDataDomain(domains);\n    }\n  }\n  getAxisTransform() {\n    return {\n      rotation: toRadians(this.rotation),\n      rotationCenterX: 0,\n      rotationCenterY: 0,\n      translationX: this.translation.x,\n      translationY: this.translation.y\n    };\n  }\n  updatePosition() {\n    const {\n      crossLineGroup,\n      axisGroup,\n      gridGroup,\n      translation,\n      gridLineGroupSelection,\n      gridPadding,\n      gridLength\n    } = this;\n    const {\n      rotation\n    } = this.calculateRotations();\n    const sideFlag = this.label.getSideFlag();\n    const translationX = Math.floor(translation.x);\n    const translationY = Math.floor(translation.y);\n    crossLineGroup.setProperties({\n      rotation,\n      translationX,\n      translationY\n    });\n    axisGroup.datum = this.getAxisTransform();\n    gridGroup.setProperties({\n      rotation,\n      translationX,\n      translationY\n    });\n    gridLineGroupSelection.each(line => {\n      line.x1 = gridPadding;\n      line.x2 = -sideFlag * gridLength + gridPadding;\n      line.y = 0;\n    });\n  }\n  updateSecondaryAxisTicks(_primaryTickCount) {\n    throw new Error('AG Charts - unexpected call to updateSecondaryAxisTicks() - check axes configuration.');\n  }\n  updateSelections(lineData, data, params) {\n    this.lineNode.datum = lineData;\n    this.gridLineGroupSelection.update(this.gridLength ? data : [], group => group.append(new Line({\n      tag: Tags.GridLine\n    })), datum => datum.tickId);\n    this.tickLineGroupSelection.update(data, group => group.appendChild(new Line({\n      tag: Tags.TickLine\n    })), datum => datum.tickId);\n    this.tickLabelGroupSelection.update(data.map(d => this.getTickLabelProps(d, params)), group => group.appendChild(new Text({\n      tag: Tags.TickLabel\n    })), datum => datum.tickId);\n  }\n  updateAxisLine() {\n    const {\n      line\n    } = this;\n    // Without this the layout isn't consistent when enabling/disabling the line, padding configurations are not respected.\n    const strokeWidth = line.enabled ? line.width : 0;\n    this.lineNode.setProperties({\n      stroke: line.color,\n      strokeWidth\n    });\n  }\n  updateGridLines(sideFlag) {\n    const {\n      gridLine: {\n        style,\n        width\n      },\n      gridPadding,\n      gridLength\n    } = this;\n    if (gridLength === 0 || style.length === 0) {\n      return;\n    }\n    this.gridLineGroupSelection.each((line, _, index) => {\n      const {\n        stroke,\n        lineDash\n      } = style[index % style.length];\n      line.setProperties({\n        x1: gridPadding,\n        x2: -sideFlag * gridLength + gridPadding,\n        y: 0,\n        fill: undefined,\n        stroke,\n        strokeWidth: width,\n        lineDash\n      });\n    });\n  }\n  updateLabels() {\n    const {\n      label\n    } = this;\n    if (!label.enabled) {\n      return;\n    }\n    // Apply label option values\n    this.tickLabelGroupSelection.each((node, datum) => {\n      node.setProperties(datum, ['fill', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'text', 'textAlign', 'textBaseline']);\n    });\n  }\n  wrapLabels(tickData, index, labelProps) {\n    const {\n      parallel,\n      maxWidth,\n      maxHeight\n    } = this.label;\n    let defaultMaxWidth = this.maxThickness;\n    let defaultMaxHeight = Math.round(this.calculateAvailableRange() / tickData.labelCount);\n    if (parallel) {\n      [defaultMaxWidth, defaultMaxHeight] = [defaultMaxHeight, defaultMaxWidth];\n    }\n    tickData.ticks.forEach(tickDatum => {\n      tickDatum.tickLabel = Text.wrap(tickDatum.tickLabel, maxWidth !== null && maxWidth !== void 0 ? maxWidth : defaultMaxWidth, maxHeight !== null && maxHeight !== void 0 ? maxHeight : defaultMaxHeight, labelProps, 'hyphenate');\n    });\n    return {\n      tickData,\n      index,\n      autoRotation: 0,\n      terminate: true\n    };\n  }\n  updateTitle(params) {\n    const {\n      rotation,\n      title,\n      _titleCaption,\n      lineNode,\n      tickLineGroup,\n      tickLabelGroup\n    } = this;\n    if (!title) {\n      _titleCaption.enabled = false;\n      return;\n    }\n    let tickSpace = 0;\n    const {\n      anyTickVisible\n    } = params;\n    if (title.enabled && anyTickVisible) {\n      const tickBBox = Group.computeBBox([tickLineGroup, tickLabelGroup, lineNode]);\n      const tickWidth = rotation === 0 ? tickBBox.width : tickBBox.height;\n      if (Math.abs(tickWidth) < Infinity) {\n        tickSpace += tickWidth;\n      }\n    }\n    this.setTitleProps(_titleCaption, {\n      tickSpace\n    });\n  }\n  // For formatting (nice rounded) tick values.\n  formatTick(datum, index) {\n    var _a, _b;\n    const {\n      label,\n      labelFormatter,\n      fractionDigits,\n      moduleCtx: {\n        callbackCache\n      }\n    } = this;\n    if (label.formatter) {\n      const value = fractionDigits > 0 ? datum : String(datum);\n      return (_a = callbackCache.call(label.formatter, {\n        value,\n        index,\n        fractionDigits,\n        formatter: labelFormatter\n      })) !== null && _a !== void 0 ? _a : value;\n    } else if (labelFormatter) {\n      return (_b = callbackCache.call(labelFormatter, datum)) !== null && _b !== void 0 ? _b : String(datum);\n    }\n    // The axis is using a logScale or the`datum` is an integer, a string or an object\n    return String(datum);\n  }\n  // For formatting arbitrary values between the ticks.\n  formatDatum(datum) {\n    return String(datum);\n  }\n  computeBBox() {\n    return this.axisGroup.computeBBox();\n  }\n  initCrossLine(crossLine) {\n    crossLine.scale = this.scale;\n    crossLine.gridLength = this.gridLength;\n  }\n  isAnySeriesActive() {\n    return this.boundSeries.some(s => this.includeInvisibleDomains || s.isEnabled());\n  }\n  clipTickLines(x, y, width, height) {\n    this.tickLineGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));\n  }\n  clipGrid(x, y, width, height) {\n    this.gridGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));\n  }\n  calculatePadding(min, _max) {\n    return [Math.abs(min * 0.01), Math.abs(min * 0.01)];\n  }\n  getTitleFormatterParams() {\n    var _a;\n    const boundSeries = this.boundSeries.reduce((acc, next) => {\n      const keys = next.getKeys(this.direction);\n      const names = next.getNames(this.direction);\n      for (let idx = 0; idx < keys.length; idx++) {\n        acc.push({\n          key: keys[idx],\n          name: names[idx]\n        });\n      }\n      return acc;\n    }, []);\n    return {\n      direction: this.direction,\n      boundSeries,\n      defaultValue: (_a = this.title) === null || _a === void 0 ? void 0 : _a.text\n    };\n  }\n  normaliseDataDomain(d) {\n    return {\n      domain: d,\n      clipped: false\n    };\n  }\n  getLayoutState() {\n    return Object.assign({\n      rect: this.computeBBox(),\n      gridPadding: this.gridPadding,\n      seriesAreaPadding: this.seriesAreaPadding,\n      tickSize: this.tick.size\n    }, this.layout);\n  }\n  getModuleMap() {\n    return this.moduleMap;\n  }\n  createModuleContext() {\n    var _a;\n    (_a = this.axisContext) !== null && _a !== void 0 ? _a : this.axisContext = this.createAxisContext();\n    return Object.assign(Object.assign({}, this.moduleCtx), {\n      parent: this.axisContext\n    });\n  }\n  createAxisContext() {\n    return {\n      axisId: this.id,\n      direction: this.direction,\n      continuous: ContinuousScale.is(this.scale),\n      keys: () => this.boundSeries.flatMap(s => s.getKeys(this.direction)),\n      scaleValueFormatter: specifier => {\n        var _a, _b;\n        return (_b = (_a = this.scale).tickFormat) === null || _b === void 0 ? void 0 : _b.call(_a, {\n          specifier\n        });\n      },\n      scaleBandwidth: () => {\n        var _a;\n        return (_a = this.scale.bandwidth) !== null && _a !== void 0 ? _a : 0;\n      },\n      scaleConvert: val => this.scale.convert(val),\n      scaleInvert: val => {\n        var _a, _b;\n        return (_b = (_a = this.scale).invert) === null || _b === void 0 ? void 0 : _b.call(_a, val);\n      }\n    };\n  }\n  animateReadyUpdate(diff) {\n    const {\n      animationManager\n    } = this.moduleCtx;\n    const selectionCtx = prepareAxisAnimationContext(this);\n    const fns = prepareAxisAnimationFunctions(selectionCtx);\n    fromToMotion(this.id, 'axis-group', animationManager, [this.axisGroup], fns.group);\n    fromToMotion(this.id, 'line', animationManager, [this.lineNode], fns.line);\n    fromToMotion(this.id, 'line-paths', animationManager, [this.gridLineGroupSelection, this.tickLineGroupSelection], fns.tick, (_, d) => d.tickId, diff);\n    fromToMotion(this.id, 'tick-labels', animationManager, [this.tickLabelGroupSelection], fns.label, (_, d) => d.tickId, diff);\n  }\n  resetSelectionNodes() {\n    const {\n      gridLineGroupSelection,\n      tickLineGroupSelection,\n      tickLabelGroupSelection,\n      lineNode\n    } = this;\n    const selectionCtx = prepareAxisAnimationContext(this);\n    resetMotion([this.axisGroup], resetAxisGroupFn());\n    resetMotion([gridLineGroupSelection, tickLineGroupSelection], resetAxisSelectionFn(selectionCtx));\n    resetMotion([tickLabelGroupSelection], resetAxisLabelSelectionFn());\n    resetMotion([lineNode], resetAxisLineSelectionFn());\n  }\n  calculateUpdateDiff(previous, tickData) {\n    const added = new Set();\n    const removed = new Set();\n    const tickCount = Math.max(previous.length, tickData.ticks.length);\n    for (let i = 0; i < tickCount; i++) {\n      const tickDatum = tickData.ticks[i];\n      const prev = previous[i];\n      const tick = tickDatum === null || tickDatum === void 0 ? void 0 : tickDatum.tickId;\n      if (prev === tick) {\n        continue;\n      }\n      if (removed.has(tick)) {\n        removed.delete(tick);\n      } else if (tick) {\n        added.add(tick);\n      }\n      if (added.has(prev)) {\n        added.delete(prev);\n      } else if (prev) {\n        removed.add(prev);\n      }\n    }\n    return {\n      changed: added.size > 0 || removed.size > 0,\n      added: [...added.values()],\n      removed: [...removed.values()]\n    };\n  }\n}\nAxis.defaultTickMinSpacing = 50;\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Boolean)], Axis.prototype, \"nice\", void 0);\n__decorate([Validate(STRING_ARRAY), __metadata(\"design:type\", Array)], Axis.prototype, \"keys\", void 0);\nclass CartesianAxisLabel extends AxisLabel {\n  constructor() {\n    super(...arguments);\n    /**\r\n     * Rotation angle to use when autoRotate is applied.\r\n     */\n    this.autoRotateAngle = 335;\n  }\n}\n__decorate([Validate(OPT_BOOLEAN), __metadata(\"design:type\", Boolean)], CartesianAxisLabel.prototype, \"autoRotate\", void 0);\n__decorate([Validate(NUMBER$1(-360, 360)), __metadata(\"design:type\", Number)], CartesianAxisLabel.prototype, \"autoRotateAngle\", void 0);\nclass CartesianAxis extends Axis {\n  constructor() {\n    super(...arguments);\n    this.thickness = 0;\n    this.position = 'left';\n  }\n  get direction() {\n    return ['top', 'bottom'].includes(this.position) ? ChartAxisDirection.X : ChartAxisDirection.Y;\n  }\n  updateDirection() {\n    switch (this.position) {\n      case 'top':\n        this.rotation = -90;\n        this.label.mirrored = true;\n        this.label.parallel = true;\n        break;\n      case 'right':\n        this.rotation = 0;\n        this.label.mirrored = true;\n        this.label.parallel = false;\n        break;\n      case 'bottom':\n        this.rotation = -90;\n        this.label.mirrored = false;\n        this.label.parallel = true;\n        break;\n      case 'left':\n        this.rotation = 0;\n        this.label.mirrored = false;\n        this.label.parallel = false;\n        break;\n    }\n    if (this.axisContext) {\n      this.axisContext.position = this.position;\n      this.axisContext.direction = this.direction;\n    }\n  }\n  update(primaryTickCount) {\n    this.updateDirection();\n    return super.update(primaryTickCount);\n  }\n  calculateLayout(primaryTickCount) {\n    this.updateDirection();\n    return super.calculateLayout(primaryTickCount);\n  }\n  createAxisContext() {\n    return Object.assign(Object.assign({}, super.createAxisContext()), {\n      position: this.position\n    });\n  }\n  assignCrossLineArrayConstructor(crossLines) {\n    assignJsonApplyConstructedArray(crossLines, CartesianCrossLine);\n  }\n  createLabel() {\n    return new CartesianAxisLabel();\n  }\n}\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], CartesianAxis.prototype, \"thickness\", void 0);\n__decorate([Validate(POSITION), __metadata(\"design:type\", String)], CartesianAxis.prototype, \"position\", void 0);\nclass CategoryAxis extends CartesianAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new BandScale());\n    this._paddingOverrideEnabled = false;\n    this.groupPaddingInner = 0.1;\n    this.includeInvisibleDomains = true;\n  }\n  set paddingInner(value) {\n    this._paddingOverrideEnabled = true;\n    this.scale.paddingInner = value;\n  }\n  get paddingInner() {\n    this._paddingOverrideEnabled = true;\n    return this.scale.paddingInner;\n  }\n  set paddingOuter(value) {\n    this.scale.paddingOuter = value;\n  }\n  get paddingOuter() {\n    return this.scale.paddingOuter;\n  }\n  normaliseDataDomain(d) {\n    const domain = [];\n    const uniqueValues = new Set();\n    for (const v of d) {\n      const key = v instanceof Date ? v.getTime() : v;\n      if (!uniqueValues.has(key)) {\n        uniqueValues.add(key);\n        // Only add unique values\n        domain.push(v);\n      }\n    }\n    return {\n      domain,\n      clipped: false\n    };\n  }\n  calculateDomain() {\n    if (!this._paddingOverrideEnabled) {\n      const paddings = this.boundSeries.map(s => {\n        var _a;\n        return (_a = s.getBandScalePadding) === null || _a === void 0 ? void 0 : _a.call(s);\n      }).filter(p => p != null);\n      if (paddings.length > 0) {\n        this.scale.paddingInner = Math.min(...paddings.map(p => p.inner));\n        this.scale.paddingOuter = Math.max(...paddings.map(p => p.outer));\n      }\n    }\n    return super.calculateDomain();\n  }\n}\nCategoryAxis.className = 'CategoryAxis';\nCategoryAxis.type = 'category';\n__decorate([Validate(NUMBER$1(0, 1)), __metadata(\"design:type\", Number)], CategoryAxis.prototype, \"groupPaddingInner\", void 0);\n\n/**\r\n * The tree layout is calculated in abstract x/y coordinates, where the root is at (0, 0)\r\n * and the tree grows downward from the root.\r\n */\nclass TreeNode {\n  constructor(label = '', parent, number = 0) {\n    this.x = 0;\n    this.y = 0;\n    this.subtreeLeft = NaN;\n    this.subtreeRight = NaN;\n    this.screenX = 0;\n    this.screenY = 0;\n    this.children = [];\n    this.leafCount = 0;\n    this.prelim = 0;\n    this.mod = 0;\n    this.ancestor = this;\n    this.change = 0;\n    this.shift = 0;\n    this.label = label;\n    // screenX and screenY are meant to be recomputed from (layout) x and y\n    // when the tree is resized (without performing another layout)\n    this.parent = parent;\n    this.depth = parent ? parent.depth + 1 : 0;\n    this.number = number;\n  }\n  getLeftSibling() {\n    return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : undefined;\n  }\n  getLeftmostSibling() {\n    return this.number > 0 && this.parent ? this.parent.children[0] : undefined;\n  }\n  // traverse the left contour of a subtree, return the successor of v on this contour\n  nextLeft() {\n    return this.children ? this.children[0] : this.thread;\n  }\n  // traverse the right contour of a subtree, return the successor of v on this contour\n  nextRight() {\n    return this.children ? this.children[this.children.length - 1] : this.thread;\n  }\n  getSiblings() {\n    return this.parent ? this.parent.children.filter((_, i) => i !== this.number) : [];\n  }\n}\n/**\r\n * Converts an array of ticks, where each tick has an array of labels, to a label tree.\r\n * If `pad` is `true`, will ensure that every branch matches the depth of the tree by\r\n * creating empty labels.\r\n */\nfunction ticksToTree(ticks, pad = true) {\n  const root = new TreeNode();\n  let depth = 0;\n  if (pad) {\n    ticks.forEach(tick => depth = Math.max(depth, tick.labels.length));\n  }\n  ticks.forEach(tick => {\n    if (pad) {\n      while (tick.labels.length < depth) {\n        tick.labels.unshift('');\n      }\n    }\n    insertTick(root, tick);\n  });\n  return root;\n}\nfunction insertTick(root, tick) {\n  const pathParts = tick.labels.slice().reverse(); // path elements from root to leaf label\n  const lastPartIndex = pathParts.length - 1;\n  pathParts.forEach((pathPart, partIndex) => {\n    const children = root.children;\n    const existingNode = children.find(child => child.label === pathPart);\n    const isNotLeaf = partIndex !== lastPartIndex;\n    if (existingNode && isNotLeaf) {\n      // the isNotLeaf check is to allow duplicate leafs\n      root = existingNode;\n    } else {\n      const node = new TreeNode(pathPart, root);\n      node.number = children.length;\n      children.push(node);\n      if (isNotLeaf) {\n        root = node;\n      }\n    }\n  });\n}\n// Shift the subtree.\nfunction moveSubtree(wm, wp, shift) {\n  const subtrees = wp.number - wm.number;\n  const ratio = shift / subtrees;\n  wp.change -= ratio;\n  wp.shift += shift;\n  wm.change += ratio;\n  wp.prelim += shift;\n  wp.mod += shift;\n}\nfunction ancestor(vim, v, defaultAncestor) {\n  return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;\n}\n// Spaces out the children.\nfunction executeShifts(v) {\n  const children = v.children;\n  if (children) {\n    let shift = 0;\n    let change = 0;\n    for (let i = children.length - 1; i >= 0; i--) {\n      const w = children[i];\n      w.prelim += shift;\n      w.mod += shift;\n      change += w.change;\n      shift += w.shift + change;\n    }\n  }\n}\n// Moves current subtree with v as the root if some nodes are conflicting in space.\nfunction apportion(v, defaultAncestor, distance) {\n  const w = v.getLeftSibling();\n  if (w) {\n    let vop = v;\n    let vip = v;\n    let vim = w;\n    let vom = vip.getLeftmostSibling();\n    let sip = vip.mod;\n    let sop = vop.mod;\n    let sim = vim.mod;\n    let som = vom.mod;\n    while (vim.nextRight() && vip.nextLeft()) {\n      vim = vim.nextRight();\n      vip = vip.nextLeft();\n      vom = vom.nextLeft();\n      vop = vop.nextRight();\n      vop.ancestor = v;\n      const shift = vim.prelim + sim - (vip.prelim + sip) + distance;\n      if (shift > 0) {\n        moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);\n        sip += shift;\n        sop += shift;\n      }\n      sim += vim.mod;\n      sip += vip.mod;\n      som += vom.mod;\n      sop += vop.mod;\n    }\n    if (vim.nextRight() && !vop.nextRight()) {\n      vop.thread = vim.nextRight();\n      vop.mod += sim - sop;\n    } else {\n      if (vip.nextLeft() && !vom.nextLeft()) {\n        vom.thread = vip.nextLeft();\n        vom.mod += sip - som;\n      }\n      defaultAncestor = v;\n    }\n  }\n  return defaultAncestor;\n}\n// Compute the preliminary x-coordinate of node and its children (recursively).\nfunction firstWalk(node, distance) {\n  const children = node.children;\n  if (children.length) {\n    let defaultAncestor = children[0];\n    children.forEach(child => {\n      firstWalk(child, distance);\n      defaultAncestor = apportion(child, defaultAncestor, distance);\n    });\n    executeShifts(node);\n    const midpoint = (children[0].prelim + children[children.length - 1].prelim) / 2;\n    const leftSibling = node.getLeftSibling();\n    if (leftSibling) {\n      node.prelim = leftSibling.prelim + distance;\n      node.mod = node.prelim - midpoint;\n    } else {\n      node.prelim = midpoint;\n    }\n  } else {\n    const leftSibling = node.getLeftSibling();\n    node.prelim = leftSibling ? leftSibling.prelim + distance : 0;\n  }\n}\nclass Dimensions {\n  constructor() {\n    this.top = Infinity;\n    this.right = -Infinity;\n    this.bottom = -Infinity;\n    this.left = Infinity;\n  }\n  update(node, xy) {\n    const {\n      x,\n      y\n    } = xy(node);\n    if (x > this.right) {\n      this.right = x;\n    }\n    if (x < this.left) {\n      this.left = x;\n    }\n    if (y > this.bottom) {\n      this.bottom = y;\n    }\n    if (y < this.top) {\n      this.top = y;\n    }\n  }\n}\nfunction secondWalk(v, m, layout) {\n  v.x = v.prelim + m;\n  v.y = v.depth;\n  layout.update(v);\n  v.children.forEach(w => secondWalk(w, m + v.mod, layout));\n}\n// After the second walk the parent nodes are positioned at the center of their immediate children.\n// If we want the parent nodes to be positioned at the center of the subtree for which they are roots,\n// we need a third walk to adjust the positions.\nfunction thirdWalk(v) {\n  const children = v.children;\n  let leafCount = 0;\n  children.forEach(w => {\n    thirdWalk(w);\n    if (w.children.length) {\n      leafCount += w.leafCount;\n    } else {\n      leafCount++;\n    }\n  });\n  v.leafCount = leafCount;\n  if (children.length) {\n    v.subtreeLeft = children[0].subtreeLeft;\n    v.subtreeRight = children[v.children.length - 1].subtreeRight;\n    v.x = (v.subtreeLeft + v.subtreeRight) / 2;\n  } else {\n    v.subtreeLeft = v.x;\n    v.subtreeRight = v.x;\n  }\n}\nfunction treeLayout(root) {\n  const layout = new TreeLayout();\n  firstWalk(root, 1);\n  secondWalk(root, -root.prelim, layout);\n  thirdWalk(root);\n  return layout;\n}\nclass TreeLayout {\n  constructor() {\n    this.dimensions = new Dimensions();\n    this.leafCount = 0;\n    this.nodes = [];\n    // One might want to process leaf nodes separately from the rest of the tree.\n    // For example, position labels corresponding to leafs vertically, rather than horizontally.\n    this.leafNodes = [];\n    this.nonLeafNodes = [];\n    this.depth = 0;\n  }\n  update(node) {\n    this.dimensions.update(node, node => ({\n      x: node.x,\n      y: node.y\n    }));\n    if (!node.children.length) {\n      this.leafCount++;\n      this.leafNodes.push(node);\n    } else {\n      this.nonLeafNodes.push(node);\n    }\n    if (node.depth > this.depth) {\n      this.depth = node.depth;\n    }\n    this.nodes.push(node);\n  }\n  resize(width, height, shiftX = 0, shiftY = 0, flipX = false) {\n    const xSteps = this.leafCount - 1;\n    const ySteps = this.depth;\n    const dimensions = this.dimensions;\n    let scalingX = 1;\n    let scalingY = 1;\n    if (width > 0 && xSteps) {\n      const existingSpacingX = (dimensions.right - dimensions.left) / xSteps;\n      const desiredSpacingX = width / xSteps;\n      scalingX = desiredSpacingX / existingSpacingX;\n      if (flipX) {\n        scalingX = -scalingX;\n      }\n    }\n    if (height > 0 && ySteps) {\n      const existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;\n      const desiredSpacingY = height / ySteps;\n      scalingY = desiredSpacingY / existingSpacingY;\n    }\n    const screenDimensions = new Dimensions();\n    this.nodes.forEach(node => {\n      node.screenX = node.x * scalingX;\n      node.screenY = node.y * scalingY;\n      screenDimensions.update(node, node => ({\n        x: node.screenX,\n        y: node.screenY\n      }));\n    });\n    // Normalize so that root top and leftmost leaf left start at zero.\n    const offsetX = -screenDimensions.left;\n    const offsetY = -screenDimensions.top;\n    this.nodes.forEach(node => {\n      node.screenX += offsetX + shiftX;\n      node.screenY += offsetY + shiftY;\n    });\n  }\n}\nclass GroupedCategoryAxisLabel extends AxisLabel {\n  constructor() {\n    super(...arguments);\n    this.grid = false;\n  }\n}\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Boolean)], GroupedCategoryAxisLabel.prototype, \"grid\", void 0);\nclass GroupedCategoryAxis extends CartesianAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new BandScale());\n    // Label scale (labels are positioned between ticks, tick count = label count + 1).\n    // We don't call is `labelScale` for consistency with other axes.\n    this.tickScale = new BandScale();\n    this.line = new AxisLine();\n    this.label = new GroupedCategoryAxisLabel();\n    /**\r\n     * The color of the labels.\r\n     * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\r\n     */\n    this.labelColor = 'rgba(87, 87, 87, 1)';\n    this.includeInvisibleDomains = true;\n    const {\n      tickLineGroup,\n      tickLabelGroup,\n      gridLineGroup,\n      tickScale,\n      scale\n    } = this;\n    scale.paddingOuter = 0.1;\n    scale.paddingInner = scale.paddingOuter * 2;\n    this.range = scale.range.slice();\n    this.refreshScale();\n    tickScale.paddingInner = 1;\n    tickScale.paddingOuter = 0;\n    this.gridLineSelection = Selection.select(gridLineGroup, Line);\n    this.axisLineSelection = Selection.select(tickLineGroup, Line);\n    this.separatorSelection = Selection.select(tickLineGroup, Line);\n    this.labelSelection = Selection.select(tickLabelGroup, Text);\n  }\n  updateRange() {\n    const {\n      range: rr,\n      visibleRange: vr,\n      scale\n    } = this;\n    const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\n    const shift = span * vr[0];\n    const start = rr[0] - shift;\n    this.tickScale.range = scale.range = [start, start + span];\n    this.resizeTickTree();\n  }\n  resizeTickTree() {\n    var _a;\n    const s = this.scale;\n    const range = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\n    const layout = this.tickTreeLayout;\n    const lineHeight = this.lineHeight;\n    if (layout) {\n      layout.resize(Math.abs(range[1] - range[0]), layout.depth * lineHeight, (Math.min(range[0], range[1]) || 0) + ((_a = s.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2, -layout.depth * lineHeight, range[1] - range[0] < 0);\n    }\n  }\n  get lineHeight() {\n    return this.label.fontSize * 1.5;\n  }\n  /**\r\n   * The length of the grid. The grid is only visible in case of a non-zero value.\r\n   */\n  set gridLength(value) {\n    // Was visible and now invisible, or was invisible and now visible.\n    if (this._gridLength && !value || !this._gridLength && value) {\n      this.gridLineSelection.clear();\n      this.labelSelection.clear();\n    }\n    this._gridLength = value;\n  }\n  get gridLength() {\n    return this._gridLength;\n  }\n  calculateDomain() {\n    var _a;\n    const {\n      direction\n    } = this;\n    const domains = [];\n    let isNumericX;\n    this.boundSeries.filter(s => s.visible).forEach(series => {\n      if (direction === ChartAxisDirection.X) {\n        if (isNumericX === undefined) {\n          // always add first X domain\n          const domain = series.getDomain(direction);\n          domains.push(domain);\n          isNumericX = typeof domain[0] === 'number';\n        } else if (isNumericX) {\n          // only add further X domains if the axis is numeric\n          domains.push(series.getDomain(direction));\n        }\n      } else {\n        domains.push(series.getDomain(direction));\n      }\n    });\n    const domain = new Array().concat(...domains);\n    const values = (_a = extent(domain)) !== null && _a !== void 0 ? _a : domain;\n    this.dataDomain = this.normaliseDataDomain(values);\n    this.scale.domain = this.dataDomain.domain;\n  }\n  normaliseDataDomain(d) {\n    // Prevent duplicate categories.\n    const values = d.filter((s, i, arr) => arr.indexOf(s) === i);\n    const tickTree = ticksToTree(values);\n    this.tickTreeLayout = treeLayout(tickTree);\n    const tickScaleDomain = values.slice();\n    tickScaleDomain.push('');\n    this.tickScale.domain = tickScaleDomain;\n    this.resizeTickTree();\n    return {\n      domain: values,\n      clipped: false\n    };\n  }\n  /**\r\n   * Creates/removes/updates the scene graph nodes that constitute the axis.\r\n   * Supposed to be called _manually_ after changing _any_ of the axis properties.\r\n   * This allows to bulk set axis properties before updating the nodes.\r\n   * The node changes made by this method are rendered on the next animation frame.\r\n   * We could schedule this method call automatically on the next animation frame\r\n   * when any of the axis properties change (the way we do when properties of scene graph's\r\n   * nodes change), but this will mean that we first wait for the next animation\r\n   * frame to make changes to the nodes of the axis, then wait for another animation\r\n   * frame to render those changes. It's nice to have everything update automatically,\r\n   * but this extra level of async indirection will not just introduce an unwanted delay,\r\n   * it will also make it harder to reason about the program.\r\n   */\n  update() {\n    if (!this.computedLayout) {\n      return;\n    }\n    this.updatePosition();\n    this.updateTitleCaption();\n    this.updateCategoryLabels();\n    this.updateSeparators();\n    this.updateAxisLines();\n    this.updateCategoryGridLines();\n    this.resetSelectionNodes();\n    return undefined;\n  }\n  updateTitleCaption() {\n    // The Text `node` of the Caption is not used to render the title of the grouped category axis.\n    // The phantom root of the tree layout is used instead.\n    const {\n      _titleCaption\n    } = this;\n    _titleCaption.node.visible = false;\n  }\n  updateCategoryLabels() {\n    if (!this.computedLayout) return;\n    const {\n      tickLabelLayout\n    } = this.computedLayout;\n    const labelSelection = this.labelSelection.update(tickLabelLayout);\n    labelSelection.each((node, datum) => {\n      node.setProperties(datum);\n    });\n  }\n  updateSeparators() {\n    if (!this.computedLayout) return;\n    const {\n      separatorLayout\n    } = this.computedLayout;\n    const {\n      range\n    } = this;\n    const epsilon = 0.0000001;\n    const separatorSelection = this.separatorSelection.update(separatorLayout);\n    separatorSelection.each((line, datum) => {\n      line.x1 = datum.x1;\n      line.x2 = datum.x2;\n      line.y1 = datum.y;\n      line.y2 = datum.y;\n      line.visible = datum.y >= range[0] - epsilon && datum.y <= range[1] + epsilon;\n      line.stroke = this.tick.color;\n      line.fill = undefined;\n      line.strokeWidth = 1;\n    });\n  }\n  updateAxisLines() {\n    if (!this.computedLayout) return;\n    const {\n      axisLineLayout\n    } = this.computedLayout;\n    const axisLineSelection = this.axisLineSelection.update(axisLineLayout);\n    axisLineSelection.each((line, datum) => {\n      line.setProperties(Object.assign(Object.assign({}, datum), {\n        stroke: this.line.color,\n        strokeWidth: this.line.width\n      }));\n      line.x1 = datum.x;\n      line.x2 = datum.x;\n      line.y1 = datum.y1;\n      line.y2 = datum.y2;\n      line.strokeWidth = this.line.width;\n      line.stroke = this.line.color;\n    });\n  }\n  updateCategoryGridLines() {\n    const {\n      gridLength,\n      gridLine,\n      label,\n      range,\n      tickScale\n    } = this;\n    const ticks = tickScale.ticks();\n    const sideFlag = label.getSideFlag();\n    const gridSelection = this.gridLineSelection.update(gridLength ? ticks : []);\n    if (gridLength) {\n      const {\n        width,\n        style\n      } = gridLine;\n      const styleCount = style.length;\n      gridSelection.each((line, datum, index) => {\n        const y = Math.round(tickScale.convert(datum));\n        line.x1 = 0;\n        line.x2 = -sideFlag * gridLength;\n        line.y1 = y;\n        line.y2 = y;\n        line.visible = y >= range[0] && y <= range[1];\n        const {\n          stroke,\n          lineDash\n        } = style[index % styleCount];\n        line.stroke = stroke;\n        line.strokeWidth = width;\n        line.lineDash = lineDash;\n        line.fill = undefined;\n      });\n    }\n  }\n  computeLayout() {\n    this.updateDirection();\n    this.calculateDomain();\n    this.updateRange();\n    const {\n      scale,\n      label,\n      label: {\n        parallel\n      },\n      moduleCtx: {\n        callbackCache\n      },\n      range,\n      title,\n      title: {\n        formatter = p => p.defaultValue\n      } = {}\n    } = this;\n    const rangeStart = scale.range[0];\n    const rangeEnd = scale.range[1];\n    const rangeLength = Math.abs(rangeEnd - rangeStart);\n    const bandwidth = rangeLength / scale.domain.length || 0;\n    const rotation = toRadians(this.rotation);\n    const isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\n    const sideFlag = label.getSideFlag();\n    // The Text `node` of the Caption is not used to render the title of the grouped category axis.\n    // The phantom root of the tree layout is used instead.\n    const lineHeight = this.lineHeight;\n    // Render ticks and labels.\n    const tickTreeLayout = this.tickTreeLayout;\n    const labels = scale.ticks();\n    const treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\n    const isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\n    // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\n    // flip the labels to avoid upside-down text, when the axis is rotated\n    // such that it is in the right hemisphere, i.e. the angle of rotation\n    // is in the [0, π] interval.\n    // The rotation angle is normalized, so that we have an easier time checking\n    // if it's in the said interval. Since the axis is always rendered vertically\n    // and then rotated, zero rotation means 12 (not 3) o-clock.\n    // -1 = flip\n    //  1 = don't flip (default)\n    const {\n      defaultRotation,\n      configuredRotation,\n      parallelFlipFlag\n    } = calculateLabelRotation({\n      rotation: label.rotation,\n      parallel,\n      regularFlipRotation: normalizeAngle360(rotation - Math.PI / 2),\n      parallelFlipRotation: normalizeAngle360(rotation)\n    });\n    const tickLabelLayout = [];\n    const copyLabelProps = node => {\n      return {\n        fill: node.fill,\n        fontFamily: node.fontFamily,\n        fontSize: node.fontSize,\n        fontStyle: node.fontStyle,\n        fontWeight: node.fontWeight,\n        rotation: node.rotation,\n        rotationCenterX: node.rotationCenterX,\n        rotationCenterY: node.rotationCenterY,\n        text: node.text,\n        textAlign: node.textAlign,\n        textBaseline: node.textBaseline,\n        translationX: node.translationX,\n        translationY: node.translationY,\n        visible: node.visible,\n        x: node.x,\n        y: node.y\n      };\n    };\n    const labelBBoxes = new Map();\n    let maxLeafLabelWidth = 0;\n    const tempText = new Text();\n    const setLabelProps = (datum, index) => {\n      var _a;\n      tempText.setProperties({\n        fill: label.color,\n        fontFamily: label.fontFamily,\n        fontSize: label.fontSize,\n        fontStyle: label.fontStyle,\n        fontWeight: label.fontWeight,\n        textAlign: 'center',\n        textBaseline: parallelFlipFlag === -1 ? 'bottom' : 'hanging',\n        translationX: datum.screenY - label.fontSize * 0.25,\n        translationY: datum.screenX\n      });\n      if (index === 0) {\n        const isCaptionEnabled = (title === null || title === void 0 ? void 0 : title.enabled) && labels.length > 0;\n        if (!isCaptionEnabled) {\n          return false;\n        }\n        const text = callbackCache.call(formatter, this.getTitleFormatterParams());\n        tempText.setProperties({\n          fill: title.color,\n          fontFamily: title.fontFamily,\n          fontSize: title.fontSize,\n          fontStyle: title.fontStyle,\n          fontWeight: title.fontWeight,\n          text,\n          textBaseline: 'hanging',\n          translationX: datum.screenY - label.fontSize * 0.25,\n          translationY: datum.screenX\n        });\n      } else {\n        const isInRange = datum.screenX >= range[0] && datum.screenX <= range[1];\n        if (!isInRange) {\n          return false;\n        }\n        if (label.formatter) {\n          tempText.text = (_a = callbackCache.call(label.formatter, {\n            value: String(datum.label),\n            index\n          })) !== null && _a !== void 0 ? _a : String(datum.label);\n        } else {\n          tempText.text = String(datum.label);\n        }\n      }\n      return true;\n    };\n    treeLabels.forEach((datum, index) => {\n      const isVisible = setLabelProps(datum, index);\n      if (isVisible) {\n        const bbox = tempText.computeTransformedBBox();\n        if (bbox) {\n          labelBBoxes.set(index, bbox);\n          if (bbox.width > maxLeafLabelWidth) {\n            maxLeafLabelWidth = bbox.width;\n          }\n        }\n      }\n    });\n    const labelX = sideFlag * label.padding;\n    const labelGrid = this.label.grid;\n    const separatorData = [];\n    treeLabels.forEach((datum, index) => {\n      let visible = setLabelProps(datum, index);\n      const id = index;\n      tempText.x = labelX;\n      tempText.rotationCenterX = labelX;\n      const isLeaf = !datum.children.length;\n      if (isLeaf) {\n        tempText.rotation = configuredRotation;\n        tempText.textAlign = 'end';\n        tempText.textBaseline = 'middle';\n        const bbox = labelBBoxes.get(id);\n        if (bbox && bbox.height > bandwidth) {\n          visible = false;\n          labelBBoxes.delete(id);\n        }\n      } else {\n        tempText.translationX -= maxLeafLabelWidth - lineHeight + this.label.padding;\n        const availableRange = datum.leafCount * bandwidth;\n        const bbox = labelBBoxes.get(id);\n        if (bbox && bbox.width > availableRange) {\n          visible = false;\n          labelBBoxes.delete(id);\n        } else if (isHorizontal) {\n          tempText.rotation = defaultRotation;\n        } else {\n          tempText.rotation = -Math.PI / 2;\n        }\n      }\n      // Calculate positions of label separators for all nodes except the root.\n      // Each separator is placed to the top of the current label.\n      if (datum.parent && isLabelTree) {\n        const y = isLeaf ? datum.screenX - bandwidth / 2 : datum.screenX - datum.leafCount * bandwidth / 2;\n        if (isLeaf) {\n          if (datum.number !== datum.children.length - 1 || labelGrid) {\n            separatorData.push({\n              y,\n              x1: 0,\n              x2: -maxLeafLabelWidth - this.label.padding * 2\n            });\n          }\n        } else {\n          const x = -maxLeafLabelWidth - this.label.padding * 2 + datum.screenY;\n          separatorData.push({\n            y,\n            x1: x + lineHeight,\n            x2: x\n          });\n        }\n      }\n      let props;\n      if (visible) {\n        const bbox = tempText.computeTransformedBBox();\n        if (bbox) {\n          labelBBoxes.set(index, bbox);\n        }\n        props = Object.assign(Object.assign({}, copyLabelProps(tempText)), {\n          visible\n        });\n      } else {\n        labelBBoxes.delete(index);\n        props = {\n          visible\n        };\n      }\n      tickLabelLayout.push(props);\n    });\n    // Calculate the position of the long separator on the far bottom of the axis.\n    let minX = 0;\n    separatorData.forEach(d => minX = Math.min(minX, d.x2));\n    separatorData.push({\n      y: Math.max(rangeStart, rangeEnd),\n      x1: 0,\n      x2: minX\n    });\n    const separatorLayout = [];\n    const separatorBoxes = [];\n    const epsilon = 0.0000001;\n    separatorData.forEach(datum => {\n      if (datum.y >= range[0] - epsilon && datum.y <= range[1] + epsilon) {\n        const {\n          x1,\n          x2,\n          y\n        } = datum;\n        const separatorBox = new BBox(Math.min(x1, x2), y, Math.abs(x1 - x2), 0);\n        separatorBoxes.push(separatorBox);\n        separatorLayout.push({\n          x1,\n          x2,\n          y\n        });\n      }\n    });\n    const axisLineLayout = [];\n    const axisLineBoxes = [];\n    const lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\n    for (let i = 0; i < lineCount; i++) {\n      const visible = labels.length > 0 && (i === 0 || labelGrid && isLabelTree);\n      const x = i > 0 ? -maxLeafLabelWidth - this.label.padding * 2 - (i - 1) * lineHeight : 0;\n      const lineBox = new BBox(x, Math.min(...range), 0, Math.abs(range[1] - range[0]));\n      axisLineBoxes.push(lineBox);\n      axisLineLayout.push({\n        x,\n        y1: range[0],\n        y2: range[1],\n        visible\n      });\n    }\n    const getTransformBox = bbox => {\n      const matrix = new Matrix();\n      const {\n        rotation: axisRotation,\n        translationX,\n        translationY,\n        rotationCenterX,\n        rotationCenterY\n      } = this.getAxisTransform();\n      Matrix.updateTransformMatrix(matrix, 1, 1, axisRotation, translationX, translationY, {\n        scalingCenterX: 0,\n        scalingCenterY: 0,\n        rotationCenterX,\n        rotationCenterY\n      });\n      return matrix.transformBBox(bbox);\n    };\n    const bbox = BBox.merge([...labelBBoxes.values(), ...separatorBoxes, ...axisLineBoxes]);\n    const transformedBBox = getTransformBox(bbox);\n    return {\n      bbox: transformedBBox,\n      tickLabelLayout,\n      separatorLayout,\n      axisLineLayout\n    };\n  }\n  calculateLayout() {\n    const {\n      axisLineLayout,\n      separatorLayout,\n      tickLabelLayout,\n      bbox\n    } = this.computeLayout();\n    this.computedLayout = {\n      axisLineLayout,\n      separatorLayout,\n      tickLabelLayout\n    };\n    return {\n      bbox,\n      primaryTickCount: undefined\n    };\n  }\n}\nGroupedCategoryAxis.className = 'GroupedCategoryAxis';\nGroupedCategoryAxis.type = 'grouped-category';\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], GroupedCategoryAxis.prototype, \"labelColor\", void 0);\n\n/**\r\n * Wraps a native OffscreenCanvas and overrides its OffscreenCanvasRenderingContext2D to\r\n * provide resolution independent rendering based on `window.devicePixelRatio`.\r\n */\nclass HdpiOffscreenCanvas {\n  static isSupported() {\n    return typeof OffscreenCanvas !== 'undefined' && OffscreenCanvas.prototype.transferToImageBitmap != null;\n  }\n  // The width/height attributes of the Canvas element default to\n  // 300/150 according to w3.org.\n  constructor({\n    width = 600,\n    height = 300,\n    overrideDevicePixelRatio\n  }) {\n    this.enabled = true;\n    // `NaN` is deliberate here, so that overrides are always applied\n    // and the `resetTransform` inside the `resize` method works in IE11.\n    this._pixelRatio = NaN;\n    this._width = 0;\n    this._height = 0;\n    this.canvas = new OffscreenCanvas(width, height);\n    this.realContext = this.canvas.getContext('2d');\n    this.imageSource = this.canvas.transferToImageBitmap();\n    this.context = this.setPixelRatio(overrideDevicePixelRatio);\n    this.resize(width, height);\n  }\n  snapshot() {\n    this.imageSource.close();\n    this.imageSource = this.canvas.transferToImageBitmap();\n  }\n  destroy() {\n    this.imageSource.close();\n    // Workaround memory allocation quirks in iOS Safari by resizing to 0x0 and clearing.\n    // See https://bugs.webkit.org/show_bug.cgi?id=195325.\n    this.canvas.width = 0;\n    this.canvas.height = 0;\n    this.context.clearRect(0, 0, 0, 0);\n  }\n  clear() {\n    this.context.save();\n    this.context.resetTransform();\n    this.context.clearRect(0, 0, this.width, this.height);\n    this.context.restore();\n  }\n  get pixelRatio() {\n    return this._pixelRatio;\n  }\n  /**\r\n   * Changes the pixel ratio of the Canvas element to the given value,\r\n   * or uses the window.devicePixelRatio (default), then resizes the Canvas\r\n   * element accordingly (default).\r\n   */\n  setPixelRatio(ratio) {\n    let pixelRatio = ratio !== null && ratio !== void 0 ? ratio : window.devicePixelRatio;\n    if (!isDesktop()) {\n      // Mobile browsers have stricter memory limits, we reduce rendering resolution to\n      // improve stability on mobile browsers. iOS Safari 12->16 are pain-points since they\n      // have memory allocation quirks - see https://bugs.webkit.org/show_bug.cgi?id=195325.\n      pixelRatio = 1;\n    }\n    this._pixelRatio = pixelRatio;\n    return HdpiCanvas.overrideScale(this.realContext, pixelRatio);\n  }\n  get width() {\n    return this._width;\n  }\n  get height() {\n    return this._height;\n  }\n  resize(width, height) {\n    if (!(width > 0 && height > 0)) {\n      return;\n    }\n    const {\n      canvas,\n      context,\n      pixelRatio\n    } = this;\n    canvas.width = Math.round(width * pixelRatio);\n    canvas.height = Math.round(height * pixelRatio);\n    context.resetTransform();\n    this._width = width;\n    this._height = height;\n  }\n}\nvar DebugSelectors;\n(function (DebugSelectors) {\n  DebugSelectors[\"SCENE\"] = \"scene\";\n  DebugSelectors[\"SCENE_STATS\"] = \"scene:stats\";\n  DebugSelectors[\"SCENE_STATS_VERBOSE\"] = \"scene:stats:verbose\";\n  DebugSelectors[\"SCENE_DIRTY_TREE\"] = \"scene:dirtyTree\";\n})(DebugSelectors || (DebugSelectors = {}));\nconst advancedCompositeIdentifier = 'adv-composite';\nconst domCompositeIdentifier = 'dom-composite';\nclass Scene {\n  constructor(opts) {\n    var _a;\n    this.id = createId(this);\n    this.layers = [];\n    this._nextZIndex = 0;\n    this._nextLayerId = 0;\n    this._dirty = false;\n    this._root = null;\n    this.debug = Debug.create(true, DebugSelectors.SCENE);\n    const {\n      document,\n      window,\n      mode = (_a = windowValue('agChartsSceneRenderModel')) !== null && _a !== void 0 ? _a : advancedCompositeIdentifier,\n      width,\n      height,\n      overrideDevicePixelRatio = undefined\n    } = opts;\n    this.overrideDevicePixelRatio = overrideDevicePixelRatio;\n    this.opts = {\n      document,\n      window,\n      mode\n    };\n    this.canvas = new HdpiCanvas({\n      document,\n      window,\n      width,\n      height,\n      overrideDevicePixelRatio\n    });\n  }\n  set container(value) {\n    this.canvas.container = value;\n  }\n  get container() {\n    return this.canvas.container;\n  }\n  download(fileName, fileFormat) {\n    this.canvas.download(fileName, fileFormat);\n  }\n  getDataURL(type) {\n    return this.canvas.getDataURL(type);\n  }\n  get width() {\n    return this.pendingSize ? this.pendingSize[0] : this.canvas.width;\n  }\n  get height() {\n    return this.pendingSize ? this.pendingSize[1] : this.canvas.height;\n  }\n  resize(width, height) {\n    width = Math.round(width);\n    height = Math.round(height);\n    // HdpiCanvas doesn't allow width/height <= 0.\n    const lessThanZero = width <= 0 || height <= 0;\n    const nan = isNaN(width) || isNaN(height);\n    const unchanged = width === this.width && height === this.height;\n    if (unchanged || nan || lessThanZero) {\n      return false;\n    }\n    this.pendingSize = [width, height];\n    this.markDirty();\n    return true;\n  }\n  addLayer(opts) {\n    var _a;\n    const {\n      mode\n    } = this.opts;\n    const layeredModes = ['composite', domCompositeIdentifier, advancedCompositeIdentifier];\n    if (!layeredModes.includes(mode)) {\n      return undefined;\n    }\n    const {\n      zIndex = this._nextZIndex++,\n      name,\n      zIndexSubOrder,\n      getComputedOpacity,\n      getVisibility\n    } = opts;\n    const {\n      width,\n      height,\n      overrideDevicePixelRatio\n    } = this;\n    const domLayer = mode === domCompositeIdentifier;\n    const advLayer = mode === advancedCompositeIdentifier;\n    const canvas = !advLayer || !HdpiOffscreenCanvas.isSupported() ? new HdpiCanvas({\n      document: this.opts.document,\n      window: this.opts.window,\n      width,\n      height,\n      domLayer,\n      zIndex,\n      name,\n      overrideDevicePixelRatio\n    }) : new HdpiOffscreenCanvas({\n      width,\n      height,\n      overrideDevicePixelRatio\n    });\n    const newLayer = {\n      id: this._nextLayerId++,\n      name,\n      zIndex,\n      zIndexSubOrder,\n      canvas,\n      getComputedOpacity,\n      getVisibility\n    };\n    if (zIndex >= this._nextZIndex) {\n      this._nextZIndex = zIndex + 1;\n    }\n    this.layers.push(newLayer);\n    this.sortLayers();\n    if (domLayer) {\n      const domCanvases = this.layers.map(v => v.canvas).filter(v => v instanceof HdpiCanvas);\n      const newLayerIndex = domCanvases.findIndex(v => v === canvas);\n      const lastLayer = (_a = domCanvases[newLayerIndex - 1]) !== null && _a !== void 0 ? _a : this.canvas;\n      lastLayer.element.insertAdjacentElement('afterend', canvas.element);\n    }\n    this.debug('Scene.addLayer() - layers', this.layers);\n    return newLayer.canvas;\n  }\n  removeLayer(canvas) {\n    const index = this.layers.findIndex(l => l.canvas === canvas);\n    if (index >= 0) {\n      this.layers.splice(index, 1);\n      canvas.destroy();\n      this.markDirty();\n      this.debug('Scene.removeLayer() -  layers', this.layers);\n    }\n  }\n  moveLayer(canvas, newZIndex, newZIndexSubOrder) {\n    const layer = this.layers.find(l => l.canvas === canvas);\n    if (layer) {\n      layer.zIndex = newZIndex;\n      layer.zIndexSubOrder = newZIndexSubOrder;\n      this.sortLayers();\n      this.markDirty();\n      this.debug('Scene.moveLayer() -  layers', this.layers);\n    }\n  }\n  sortLayers() {\n    this.layers.sort((a, b) => {\n      var _a, _b;\n      return compoundAscending([a.zIndex, ...((_a = a.zIndexSubOrder) !== null && _a !== void 0 ? _a : [undefined, undefined]), a.id], [b.zIndex, ...((_b = b.zIndexSubOrder) !== null && _b !== void 0 ? _b : [undefined, undefined]), b.id], ascendingStringNumberUndefined);\n    });\n  }\n  markDirty() {\n    this._dirty = true;\n  }\n  get dirty() {\n    return this._dirty;\n  }\n  set root(node) {\n    var _a;\n    if (node === this._root) {\n      return;\n    }\n    (_a = this._root) === null || _a === void 0 ? void 0 : _a._setLayerManager();\n    this._root = node;\n    if (node) {\n      node._setLayerManager({\n        addLayer: opts => this.addLayer(opts),\n        moveLayer: (...opts) => this.moveLayer(...opts),\n        removeLayer: (...opts) => this.removeLayer(...opts),\n        markDirty: () => this.markDirty(),\n        canvas: this.canvas,\n        debug: Debug.create(DebugSelectors.SCENE)\n      });\n    }\n    this.markDirty();\n  }\n  get root() {\n    return this._root;\n  }\n  /** Alternative to destroy() that preserves re-usable resources. */\n  strip() {\n    const {\n      layers\n    } = this;\n    for (const layer of layers) {\n      layer.canvas.destroy();\n      delete layer['canvas'];\n    }\n    layers.splice(0, layers.length);\n    this.root = null;\n    this._dirty = false;\n    this.canvas.context.resetTransform();\n  }\n  destroy() {\n    this.container = undefined;\n    this.strip();\n    this.canvas.destroy();\n    Object.assign(this, {\n      canvas: undefined,\n      ctx: undefined\n    });\n  }\n  render(opts) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        debugSplitTimes = {\n          start: performance.now()\n        },\n        extraDebugStats = {}\n      } = opts !== null && opts !== void 0 ? opts : {};\n      const {\n        canvas,\n        canvas: {\n          context: ctx\n        },\n        root,\n        layers,\n        pendingSize,\n        opts: {\n          mode\n        }\n      } = this;\n      if (pendingSize) {\n        this.canvas.resize(...pendingSize);\n        this.layers.forEach(layer => layer.canvas.resize(...pendingSize));\n        this.pendingSize = undefined;\n      }\n      if (root && !root.visible) {\n        this._dirty = false;\n        return;\n      }\n      if (root && !this.dirty) {\n        this.debug('Scene.render() - no-op', {\n          redrawType: RedrawType[root.dirty],\n          tree: this.buildTree(root)\n        });\n        this.debugStats(debugSplitTimes, ctx, undefined, extraDebugStats);\n        return;\n      }\n      const renderCtx = {\n        ctx,\n        devicePixelRatio: (_a = this.canvas.pixelRatio) !== null && _a !== void 0 ? _a : 1,\n        forceRender: true,\n        resized: !!pendingSize,\n        debugNodes: {}\n      };\n      if (Debug.check(DebugSelectors.SCENE_STATS_VERBOSE)) {\n        renderCtx.stats = {\n          layersRendered: 0,\n          layersSkipped: 0,\n          nodesRendered: 0,\n          nodesSkipped: 0\n        };\n      }\n      let canvasCleared = false;\n      if (!root || root.dirty >= RedrawType.TRIVIAL) {\n        // start with a blank canvas, clear previous drawing\n        canvasCleared = true;\n        canvas.clear();\n      }\n      if (root) {\n        const {\n          dirtyTree,\n          paths\n        } = this.buildDirtyTree(root);\n        Debug.create(DebugSelectors.SCENE_DIRTY_TREE)('Scene.render() - dirtyTree', {\n          dirtyTree,\n          paths\n        });\n      }\n      if (root && canvasCleared) {\n        this.debug('Scene.render() - before', {\n          redrawType: RedrawType[root.dirty],\n          canvasCleared,\n          tree: this.buildTree(root)\n        });\n        if (root.visible) {\n          ctx.save();\n          root.render(renderCtx);\n          ctx.restore();\n        }\n      }\n      debugSplitTimes['✍️'] = performance.now();\n      if (mode !== domCompositeIdentifier && layers.length > 0 && canvasCleared) {\n        this.sortLayers();\n        ctx.save();\n        ctx.setTransform(1 / canvas.pixelRatio, 0, 0, 1 / canvas.pixelRatio, 0, 0);\n        layers.forEach(({\n          canvas: {\n            imageSource,\n            enabled\n          },\n          getComputedOpacity,\n          getVisibility\n        }) => {\n          if (!enabled || !getVisibility()) {\n            return;\n          }\n          ctx.globalAlpha = getComputedOpacity();\n          ctx.drawImage(imageSource, 0, 0);\n        });\n        ctx.restore();\n        debugSplitTimes['⛙'] = performance.now();\n      }\n      // Check for save/restore depth of zero!\n      (_b = ctx.verifyDepthZero) === null || _b === void 0 ? void 0 : _b.call(ctx);\n      this._dirty = false;\n      this.debugStats(debugSplitTimes, ctx, renderCtx.stats, extraDebugStats);\n      this.debugSceneNodeHighlight(ctx, renderCtx.debugNodes);\n      if (root) {\n        this.debug('Scene.render() - after', {\n          redrawType: RedrawType[root.dirty],\n          canvasCleared,\n          tree: this.buildTree(root)\n        });\n      }\n    });\n  }\n  debugStats(debugSplitTimes, ctx, renderCtxStats, extraDebugStats = {}) {\n    if (Debug.check(DebugSelectors.SCENE_STATS, DebugSelectors.SCENE_STATS_VERBOSE)) {\n      const end = performance.now();\n      const start = debugSplitTimes['start'];\n      debugSplitTimes['end'] = performance.now();\n      const pct = (rendered, skipped) => {\n        const total = rendered + skipped;\n        return `${rendered} / ${total} (${Math.round(100 * rendered / total)}%)`;\n      };\n      const time = (name, start, end) => {\n        return `${name}: ${Math.round((end - start) * 100) / 100}ms`;\n      };\n      const {\n        layersRendered = 0,\n        layersSkipped = 0,\n        nodesRendered = 0,\n        nodesSkipped = 0\n      } = renderCtxStats !== null && renderCtxStats !== void 0 ? renderCtxStats : {};\n      let lastSplit = 0;\n      const splits = Object.entries(debugSplitTimes).filter(([n]) => n !== 'end').map(([n, t], i) => {\n        const result = i > 0 ? time(n, lastSplit, t) : null;\n        lastSplit = t;\n        return result;\n      }).filter(v => v != null).join(' + ');\n      const extras = Object.entries(extraDebugStats).map(([k, v]) => `${k}: ${v}`).join(' ; ');\n      const detailedStats = Debug.check(DebugSelectors.SCENE_STATS_VERBOSE);\n      const stats = [`${time('⏱️', start, end)} (${splits})`, `${extras}`, `Layers: ${detailedStats ? pct(layersRendered, layersSkipped) : this.layers.length}`, detailedStats ? `Nodes: ${pct(nodesRendered, nodesSkipped)}` : null].filter(v => v != null);\n      const statsSize = stats.map(t => [t, HdpiCanvas.getTextSize(t, ctx.font)]);\n      const width = Math.max(...statsSize.map(([, {\n        width\n      }]) => width));\n      const height = statsSize.reduce((total, [, {\n        height\n      }]) => total + height, 0);\n      ctx.save();\n      ctx.fillStyle = 'white';\n      ctx.fillRect(0, 0, width, height);\n      ctx.fillStyle = 'black';\n      let y = 0;\n      for (const [stat, size] of statsSize) {\n        y += size.height;\n        ctx.fillText(stat, 2, y);\n      }\n      ctx.restore();\n    }\n  }\n  debugSceneNodeHighlight(ctx, debugNodes) {\n    var _a;\n    const regexpPredicate = matcher => n => {\n      if (matcher.test(n.id)) {\n        return true;\n      }\n      return n instanceof Group && n.name != null && matcher.test(n.name);\n    };\n    const stringPredicate = match => n => {\n      if (match === n.id) {\n        return true;\n      }\n      return n instanceof Group && n.name != null && match === n.name;\n    };\n    const sceneNodeHighlight = toArray(windowValue('agChartsSceneDebug')).flatMap(name => name === 'layout' ? ['seriesRoot', 'legend', 'root', /.*Axis-\\d+-axis.*/] : name);\n    for (const next of sceneNodeHighlight) {\n      if (typeof next === 'string' && debugNodes[next] != null) continue;\n      const predicate = typeof next === 'string' ? stringPredicate(next) : regexpPredicate(next);\n      const nodes = (_a = this.root) === null || _a === void 0 ? void 0 : _a.findNodes(predicate);\n      if (!nodes || nodes.length === 0) {\n        Logger.log(`Scene.render() - no debugging node with id [${next}] in scene graph.`);\n        continue;\n      }\n      for (const node of nodes) {\n        if (node instanceof Group && node.name) {\n          debugNodes[node.name] = node;\n        } else {\n          debugNodes[node.id] = node;\n        }\n      }\n    }\n    ctx.save();\n    for (const [name, node] of Object.entries(debugNodes)) {\n      const bbox = node.computeTransformedBBox();\n      if (!bbox) {\n        Logger.log(`Scene.render() - no bbox for debugged node [${name}].`);\n        continue;\n      }\n      ctx.globalAlpha = 0.8;\n      ctx.strokeStyle = 'red';\n      ctx.lineWidth = 1;\n      ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);\n      ctx.fillStyle = 'red';\n      ctx.strokeStyle = 'white';\n      ctx.font = '16px sans-serif';\n      ctx.textBaseline = 'top';\n      ctx.textAlign = 'left';\n      ctx.lineWidth = 2;\n      ctx.strokeText(name, bbox.x, bbox.y, bbox.width);\n      ctx.fillText(name, bbox.x, bbox.y, bbox.width);\n    }\n    ctx.restore();\n  }\n  buildTree(node) {\n    var _a, _b;\n    const name = (_a = node instanceof Group ? node.name : null) !== null && _a !== void 0 ? _a : node.id;\n    return Object.assign(Object.assign({\n      name,\n      node,\n      dirty: RedrawType[node.dirty]\n    }, ((_b = node.parent) === null || _b === void 0 ? void 0 : _b.isVirtual) ? {\n      virtualParentDirty: RedrawType[node.parent.dirty],\n      virtualParent: node.parent\n    } : {}), node.children.map(c => this.buildTree(c)).reduce((result, childTree) => {\n      let {\n        name: treeNodeName\n      } = childTree;\n      const {\n        node: {\n          visible,\n          opacity,\n          zIndex,\n          zIndexSubOrder\n        },\n        node: childNode,\n        virtualParent\n      } = childTree;\n      if (!visible || opacity <= 0) {\n        treeNodeName = `(${treeNodeName})`;\n      }\n      if (childNode instanceof Group && childNode.isLayer()) {\n        treeNodeName = `*${treeNodeName}*`;\n      }\n      const key = [`${treeNodeName !== null && treeNodeName !== void 0 ? treeNodeName : '<unknown>'}`, `z: ${zIndex}`, zIndexSubOrder && `zo: ${zIndexSubOrder.map(v => typeof v === 'function' ? `${v()} (fn)` : v).join(' / ')}`, virtualParent && `(virtual parent)`].filter(v => !!v).join(' ');\n      let selectedKey = key;\n      let index = 1;\n      while (result[selectedKey] != null && index < 100) {\n        selectedKey = `${key} (${index++})`;\n      }\n      result[selectedKey] = childTree;\n      return result;\n    }, {}));\n  }\n  buildDirtyTree(node) {\n    var _a;\n    if (node.dirty === RedrawType.NONE) {\n      return {\n        dirtyTree: {},\n        paths: []\n      };\n    }\n    const childrenDirtyTree = node.children.map(c => this.buildDirtyTree(c)).filter(c => c.paths.length > 0);\n    const name = (_a = node instanceof Group ? node.name : null) !== null && _a !== void 0 ? _a : node.id;\n    const paths = childrenDirtyTree.length === 0 ? [name] : childrenDirtyTree.map(c => c.paths).reduce((r, p) => r.concat(p), []).map(p => `${name}.${p}`);\n    return {\n      dirtyTree: Object.assign({\n        name,\n        node,\n        dirty: RedrawType[node.dirty]\n      }, childrenDirtyTree.map(c => c.dirtyTree).filter(t => t.dirty !== undefined).reduce((result, childTree) => {\n        var _a;\n        result[(_a = childTree.name) !== null && _a !== void 0 ? _a : '<unknown>'] = childTree;\n        return result;\n      }, {})),\n      paths\n    };\n  }\n}\nScene.className = 'Scene';\nfunction sleep(sleepTimeoutMs) {\n  return new Promise(resolve => {\n    setTimeout(() => resolve(undefined), sleepTimeoutMs);\n  });\n}\nclass CallbackCache {\n  constructor() {\n    this.cache = new WeakMap();\n  }\n  call(fn, ...params) {\n    let serialisedParams;\n    let paramCache = this.cache.get(fn);\n    const invoke = () => {\n      try {\n        const result = fn(...params);\n        if (paramCache && serialisedParams != null) {\n          paramCache.set(serialisedParams, result);\n        }\n        return result;\n      } catch (e) {\n        Logger.warnOnce(`User callback errored, ignoring`, e);\n        return undefined;\n      }\n    };\n    try {\n      serialisedParams = JSON.stringify(params);\n    } catch (e) {\n      // Unable to serialise params!\n      // No caching possible.\n      return invoke();\n    }\n    if (paramCache == null) {\n      paramCache = new Map();\n      this.cache.set(fn, paramCache);\n    }\n    if (!paramCache.has(serialisedParams)) {\n      return invoke();\n    }\n    return paramCache.get(serialisedParams);\n  }\n  invalidateCache() {\n    this.cache = new WeakMap();\n  }\n}\nclass Mutex {\n  constructor() {\n    this.available = true;\n    this.acquireQueue = [];\n  }\n  acquire(cb) {\n    return new Promise(resolve => {\n      this.acquireQueue.push([cb, resolve]);\n      if (this.available) {\n        this.dispatchNext();\n      }\n    });\n  }\n  acquireImmediately(cb) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.available) {\n        return false;\n      }\n      yield this.acquire(cb);\n      return true;\n    });\n  }\n  waitForClearAcquireQueue() {\n    return __awaiter(this, void 0, void 0, function* () {\n      return this.acquire(() => __awaiter(this, void 0, void 0, function* () {\n        return undefined;\n      }));\n    });\n  }\n  dispatchNext() {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      this.available = false;\n      let [next, done] = (_a = this.acquireQueue.shift()) !== null && _a !== void 0 ? _a : [];\n      while (next) {\n        try {\n          yield next();\n          done === null || done === void 0 ? void 0 : done();\n        } catch (error) {\n          Logger.error('mutex callback error', error);\n          done === null || done === void 0 ? void 0 : done();\n        }\n        [next, done] = (_b = this.acquireQueue.shift()) !== null && _b !== void 0 ? _b : [];\n      }\n      this.available = true;\n    });\n  }\n}\n\n/**\r\n * Wrap a function in debouncing trigger function. A requestAnimationFrame() is scheduled\r\n * after the first schedule() call, and subsequent schedule() calls will be ignored until the\r\n * animation callback executes.\r\n */\nfunction debouncedAnimationFrame(cb) {\n  return buildScheduler((cb, _delayMs) => requestAnimationFrame(cb), cb);\n}\nfunction debouncedCallback(cb) {\n  return buildScheduler((cb, delayMs = 0) => setTimeout(cb, delayMs), cb);\n}\nfunction buildScheduler(scheduleFn, cb) {\n  let scheduleCount = 0;\n  let promiseRunning = false;\n  let awaitingPromise;\n  let awaitingDone;\n  const busy = () => {\n    return promiseRunning;\n  };\n  const done = () => {\n    promiseRunning = false;\n    awaitingDone === null || awaitingDone === void 0 ? void 0 : awaitingDone();\n    awaitingDone = undefined;\n    awaitingPromise = undefined;\n    if (scheduleCount > 0) {\n      scheduleFn(scheduleCb);\n    }\n  };\n  const scheduleCb = () => {\n    const count = scheduleCount;\n    scheduleCount = 0;\n    promiseRunning = true;\n    const maybePromise = cb({\n      count\n    });\n    if (!maybePromise) {\n      done();\n      return;\n    }\n    maybePromise.then(done).catch(done);\n  };\n  return {\n    schedule(delayMs) {\n      if (scheduleCount === 0 && !busy()) {\n        scheduleFn(scheduleCb, delayMs);\n      }\n      scheduleCount++;\n    },\n    await() {\n      return __awaiter(this, void 0, void 0, function* () {\n        if (!busy()) {\n          return;\n        }\n        if (awaitingPromise == null) {\n          awaitingPromise = new Promise(resolve => {\n            awaitingDone = resolve;\n          });\n        }\n        while (busy()) {\n          yield awaitingPromise;\n        }\n      });\n    }\n  };\n}\nclass SizeMonitor {\n  static init(document) {\n    if (typeof ResizeObserver !== 'undefined') {\n      this.resizeObserver = new ResizeObserver(entries => {\n        for (const entry of entries) {\n          const {\n            width,\n            height\n          } = entry.contentRect;\n          this.checkSize(this.elements.get(entry.target), entry.target, width, height);\n        }\n      });\n    } else {\n      // polyfill (more reliable even in browsers that support ResizeObserver)\n      const step = () => {\n        this.elements.forEach((entry, element) => {\n          this.checkClientSize(element, entry);\n        });\n      };\n      this.pollerHandler = window.setInterval(step, 100);\n    }\n    this.ready = true;\n    this.documentReady = document.readyState !== 'loading';\n    if (this.documentReady) return;\n    // Add DOMContentLoaded listener so we can check if the main document is ready again, and\n    // if it is then attach any queued requests for resize monitoring.\n    //\n    // If we attach before ent.readyState !== 'loading', then additional incorrect resize events\n    // are fired, leading to multiple re-renderings on chart initial load. Waiting for the\n    // document to be loaded irons out this browser quirk.\n    this.readyEventFn = () => {\n      const newState = document.readyState !== 'loading';\n      const oldState = this.documentReady;\n      this.documentReady = newState;\n      if (!newState) return;\n      if (newState === oldState) return;\n      for (const [el, cb] of this.queuedObserveRequests) {\n        this.observe(el, cb);\n      }\n      this.queuedObserveRequests.length = 0;\n    };\n    document.addEventListener('DOMContentLoaded', this.readyEventFn);\n  }\n  static destroy() {\n    var _a;\n    if (this.pollerHandler != null) {\n      clearInterval(this.pollerHandler);\n      this.pollerHandler = undefined;\n    }\n    if (this.readyEventFn) {\n      document.removeEventListener('DOMContentLoaded', this.readyEventFn);\n      this.readyEventFn = undefined;\n    }\n    (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\n    this.resizeObserver = undefined;\n    this.ready = false;\n  }\n  static checkSize(entry, element, width, height) {\n    if (!entry) return;\n    if (!entry.size || width !== entry.size.width || height !== entry.size.height) {\n      entry.size = {\n        width,\n        height\n      };\n      entry.cb(entry.size, element);\n    }\n  }\n  // Only a single callback is supported.\n  static observe(element, cb) {\n    if (!this.ready) {\n      this.init(element.ownerDocument);\n    }\n    if (!this.documentReady) {\n      this.queuedObserveRequests.push([element, cb]);\n      return;\n    }\n    this.unobserve(element, false);\n    if (this.resizeObserver) {\n      this.resizeObserver.observe(element);\n    }\n    this.elements.set(element, {\n      cb\n    });\n  }\n  static unobserve(element, cleanup = true) {\n    if (this.resizeObserver) {\n      this.resizeObserver.unobserve(element);\n    }\n    this.elements.delete(element);\n    this.queuedObserveRequests = this.queuedObserveRequests.filter(([el]) => el === element);\n    if (cleanup && this.elements.size === 0) {\n      this.destroy();\n    }\n  }\n  static checkClientSize(element, entry) {\n    const width = element.clientWidth ? element.clientWidth : 0;\n    const height = element.clientHeight ? element.clientHeight : 0;\n    this.checkSize(entry, element, width, height);\n  }\n}\nSizeMonitor.elements = new Map();\nSizeMonitor.ready = false;\nSizeMonitor.documentReady = false;\nSizeMonitor.queuedObserveRequests = [];\nclass ChartHighlight {\n  constructor() {\n    this.range = 'tooltip';\n  }\n}\n__decorate([Validate(STRING_UNION('tooltip', 'node')), __metadata(\"design:type\", String)], ChartHighlight.prototype, \"range\", void 0);\n\n/** Types of chart-update, in pipeline execution order. */\nvar ChartUpdateType;\n(function (ChartUpdateType) {\n  ChartUpdateType[ChartUpdateType[\"FULL\"] = 0] = \"FULL\";\n  ChartUpdateType[ChartUpdateType[\"PROCESS_DATA\"] = 1] = \"PROCESS_DATA\";\n  ChartUpdateType[ChartUpdateType[\"PERFORM_LAYOUT\"] = 2] = \"PERFORM_LAYOUT\";\n  ChartUpdateType[ChartUpdateType[\"SERIES_UPDATE\"] = 3] = \"SERIES_UPDATE\";\n  ChartUpdateType[ChartUpdateType[\"TOOLTIP_RECALCULATION\"] = 4] = \"TOOLTIP_RECALCULATION\";\n  ChartUpdateType[ChartUpdateType[\"SCENE_RENDER\"] = 5] = \"SCENE_RENDER\";\n  ChartUpdateType[ChartUpdateType[\"NONE\"] = 6] = \"NONE\";\n})(ChartUpdateType || (ChartUpdateType = {}));\nclass DataDomain {\n  constructor(type) {\n    this.type = type;\n    this.continuousDomain = [Infinity, -Infinity];\n    this.discreteDomain = new Set();\n  }\n  extend(val) {\n    if (this.type === 'discrete') {\n      this.discreteDomain.add(val);\n    } else if (this.type === 'continuous') {\n      if (this.continuousDomain[0] > val) {\n        this.continuousDomain[0] = val;\n      }\n      if (this.continuousDomain[1] < val) {\n        this.continuousDomain[1] = val;\n      }\n    }\n  }\n  getDomain() {\n    if (this.type === 'discrete') {\n      return this.discreteDomain;\n    } else if (this.type === 'continuous') {\n      return this.continuousDomain;\n    }\n    throw new Error('AG Charts - Unsupported data domain type: ' + this.type);\n  }\n}\nfunction toKeyString(keys) {\n  return keys.map(v => {\n    if (v == null) {\n      return v;\n    } else if (typeof v === 'number' || typeof v === 'string' || typeof v === 'boolean') {\n      return v;\n    } else if (typeof v === 'object') {\n      return JSON.stringify(v);\n    }\n    return v;\n  }).join('-');\n}\nfunction round(val) {\n  const accuracy = 10000;\n  if (Number.isInteger(val)) {\n    return val;\n  } else if (Math.abs(val) > accuracy) {\n    return Math.trunc(val);\n  }\n  return Math.round(val * accuracy) / accuracy;\n}\nfunction fixNumericExtentInternal(extent) {\n  if (extent === undefined) {\n    // Don't return a range, there is no range.\n    return [];\n  }\n  let [min, max] = extent;\n  min = +min;\n  max = +max;\n  if (min === 0 && max === 0) {\n    // domain has zero length and the single valid value is 0. Use the default of [0, 1].\n    return [0, 1];\n  }\n  if (min === Infinity && max === -Infinity) {\n    // There's no data in the domain.\n    return [];\n  }\n  if (min === Infinity) {\n    min = 0;\n  }\n  if (max === -Infinity) {\n    max = 0;\n  }\n  if (!(isNumber(min) && isNumber(max))) {\n    return [];\n  }\n  return [min, max];\n}\nfunction fixNumericExtent(extent, axis) {\n  var _a;\n  const fixedExtent = fixNumericExtentInternal(extent);\n  if (fixedExtent.length === 0) {\n    return fixedExtent;\n  }\n  let [min, max] = fixedExtent;\n  if (min === max) {\n    // domain has zero length, there is only a single valid value in data\n    const [paddingMin, paddingMax] = (_a = axis === null || axis === void 0 ? void 0 : axis.calculatePadding(min, max)) !== null && _a !== void 0 ? _a : [1, 1];\n    min -= paddingMin;\n    max += paddingMax;\n  }\n  return [min, max];\n}\nconst INVALID_VALUE = Symbol('invalid');\nclass DataModel {\n  constructor(opts) {\n    const {\n      props,\n      mode = 'standalone'\n    } = opts;\n    this.mode = mode;\n    // Validate that keys appear before values in the definitions, as output ordering depends\n    // on configuration ordering, but we process keys before values.\n    let keys = true;\n    for (const next of props) {\n      if (next.type === 'key' && !keys) {\n        throw new Error('AG Charts - internal config error: keys must come before values.');\n      }\n      if (next.type === 'value' && keys) {\n        keys = false;\n      }\n    }\n    this.opts = Object.assign({\n      dataVisible: true\n    }, opts);\n    this.keys = props.filter(def => def.type === 'key').map((def, index) => Object.assign(Object.assign({}, def), {\n      index,\n      missing: 0\n    }));\n    this.values = props.filter(def => def.type === 'value').map((def, index) => Object.assign(Object.assign({}, def), {\n      index,\n      missing: 0\n    }));\n    this.aggregates = props.filter(def => def.type === 'aggregate').map((def, index) => Object.assign(Object.assign({}, def), {\n      index\n    }));\n    this.groupProcessors = props.filter(def => def.type === 'group-value-processor').map((def, index) => Object.assign(Object.assign({}, def), {\n      index\n    }));\n    this.propertyProcessors = props.filter(def => def.type === 'property-value-processor').map((def, index) => Object.assign(Object.assign({}, def), {\n      index\n    }));\n    this.reducers = props.filter(def => def.type === 'reducer').map((def, index) => Object.assign(Object.assign({}, def), {\n      index\n    }));\n    this.processors = props.filter(def => def.type === 'processor').map((def, index) => Object.assign(Object.assign({}, def), {\n      index\n    }));\n    for (const def of this.values) {\n      if (def.property == null) {\n        throw new Error(`AG Charts - internal config error: no properties specified for value definitions: ${JSON.stringify(def)}`);\n      }\n    }\n    const verifyMatchGroupId = ({\n      matchGroupIds\n    }) => {\n      for (const matchGroupId of matchGroupIds !== null && matchGroupIds !== void 0 ? matchGroupIds : []) {\n        if (!this.values.some(def => def.groupId === matchGroupId)) {\n          throw new Error(`AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchGroupId}).`);\n        }\n      }\n    };\n    const verifyMatchIds = ({\n      matchIds\n    }) => {\n      for (const matchId of matchIds !== null && matchIds !== void 0 ? matchIds : []) {\n        if (!this.values.some(def => {\n          var _a;\n          return (_a = def.ids) === null || _a === void 0 ? void 0 : _a.some(([scope, id]) => scope === matchId[0] && id === matchId[1]);\n        })) {\n          throw new Error(`AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchId}).`);\n        }\n      }\n    };\n    for (const def of [...this.groupProcessors, ...this.aggregates]) {\n      verifyMatchIds(def);\n      verifyMatchGroupId(def);\n    }\n  }\n  resolveProcessedDataIndexById(scope, searchId) {\n    var _a;\n    const {\n      index,\n      def\n    } = (_a = this.resolveProcessedDataDefById(scope, searchId)) !== null && _a !== void 0 ? _a : {};\n    return {\n      index,\n      def\n    };\n  }\n  resolveProcessedDataIndicesById(scope, searchId) {\n    return this.resolveProcessedDataDefsById(scope, searchId).map(({\n      index,\n      def\n    }) => ({\n      index,\n      def\n    }));\n  }\n  resolveProcessedDataDefById(scope, searchId) {\n    return this.resolveProcessedDataDefsById(scope, searchId)[0];\n  }\n  resolveProcessedDataDefsByIds(scope, searchIds) {\n    const defs = [];\n    for (const searchId of searchIds) {\n      defs.push([searchId, this.resolveProcessedDataDefsById(scope, searchId)]);\n    }\n    return defs;\n  }\n  resolveProcessedDataDefsValues(defs, {\n    keys,\n    values\n  }) {\n    const result = {};\n    for (const [searchId, [{\n      index,\n      def\n    }]] of defs) {\n      const processedData = def.type === 'key' ? keys : values;\n      result[searchId] = processedData[index];\n    }\n    return result;\n  }\n  resolveProcessedDataDefsById(searchScope, searchId) {\n    const {\n      keys,\n      values,\n      aggregates,\n      groupProcessors,\n      reducers\n    } = this;\n    const match = prop => {\n      const {\n        ids,\n        scopes\n      } = prop;\n      if (ids == null) return false;\n      if (searchScope != null && !(scopes === null || scopes === void 0 ? void 0 : scopes.some(scope => scope === searchScope.id))) return false;\n      return ids.some(([scope, id]) => scope === searchScope.id && (typeof searchId === 'string' ? id === searchId : searchId.test(id)));\n    };\n    const allDefs = [keys, values, aggregates, groupProcessors, reducers];\n    const result = [];\n    for (const defs of allDefs) {\n      result.push(...defs.filter(match).map(def => ({\n        index: def.index,\n        def\n      })));\n    }\n    if (result.length > 0) {\n      return result;\n    }\n    throw new Error(`AG Charts - didn't find property definition for [${searchId}, ${searchScope.id}]`);\n  }\n  getDomain(scope, searchId, type = 'value', processedData) {\n    var _a, _b, _c, _d;\n    let matches;\n    try {\n      matches = this.resolveProcessedDataIndicesById(scope, searchId);\n    } catch (e) {\n      if (typeof searchId !== 'string' && /didn't find property definition/.test(e.message)) return [];\n      throw e;\n    }\n    let domainProp;\n    switch (type) {\n      case 'key':\n        domainProp = 'keys';\n        break;\n      case 'value':\n        domainProp = 'values';\n        break;\n      case 'aggregate':\n        domainProp = 'aggValues';\n        break;\n      case 'group-value-processor':\n        domainProp = 'groups';\n        break;\n      default:\n        return [];\n    }\n    const firstMatch = (_b = (_a = processedData.domain[domainProp]) === null || _a === void 0 ? void 0 : _a[matches[0].index]) !== null && _b !== void 0 ? _b : [];\n    if (matches.length === 1) {\n      return firstMatch;\n    }\n    const result = [...firstMatch];\n    for (const idx of matches.slice(1)) {\n      extendDomain((_d = (_c = processedData.domain[domainProp]) === null || _c === void 0 ? void 0 : _c[idx.index]) !== null && _d !== void 0 ? _d : [], result);\n    }\n    return result;\n  }\n  processData(data) {\n    const {\n      opts: {\n        groupByKeys,\n        groupByFn\n      },\n      aggregates,\n      groupProcessors,\n      reducers,\n      processors,\n      propertyProcessors\n    } = this;\n    const start = performance.now();\n    for (const def of [...this.keys, ...this.values]) {\n      def.missing = 0;\n    }\n    if (groupByKeys && this.keys.length === 0) {\n      return undefined;\n    }\n    let processedData = this.extractData(data);\n    if (groupByKeys) {\n      processedData = this.groupData(processedData);\n    } else if (groupByFn) {\n      processedData = this.groupData(processedData, groupByFn(processedData));\n    }\n    if (groupProcessors.length > 0) {\n      this.postProcessGroups(processedData);\n    }\n    if (aggregates.length > 0) {\n      this.aggregateData(processedData);\n    }\n    if (propertyProcessors.length > 0) {\n      this.postProcessProperties(processedData);\n    }\n    if (reducers.length > 0) {\n      this.reduceData(processedData);\n    }\n    if (processors.length > 0) {\n      this.postProcessData(processedData);\n    }\n    for (const def of [...this.keys, ...this.values]) {\n      if (data.length > 0 && def.missing >= data.length) {\n        Logger.warnOnce(`the key '${def.property}' was not found in any data element.`);\n      }\n    }\n    const end = performance.now();\n    processedData.time = end - start;\n    if (Debug.check(true, 'data-model')) {\n      logProcessedData(processedData);\n    }\n    return processedData;\n  }\n  valueGroupIdxLookup({\n    matchGroupIds,\n    matchIds\n  }) {\n    return this.values.map((def, index) => ({\n      def,\n      index\n    })).filter(({\n      def\n    }) => {\n      if (matchGroupIds && (def.groupId == null || !matchGroupIds.includes(def.groupId))) {\n        return false;\n      }\n      if (!matchIds) return true;\n      if (def.ids == null) return false;\n      return matchIds.some(([matchScope, matchId]) => {\n        var _a;\n        return (_a = def.ids) === null || _a === void 0 ? void 0 : _a.some(([defScope, defId]) => defScope === matchScope && defId === matchId);\n      });\n    }).map(({\n      index\n    }) => index);\n  }\n  valueIdxLookup(scopes, prop) {\n    const noScopesToMatch = scopes == null || scopes.length === 0;\n    const scopeMatch = compareTo => {\n      const anyScope = compareTo == null;\n      if (anyScope) return true;\n      const noScopes = compareTo == null || compareTo.length === 0;\n      if (noScopesToMatch === noScopes) return true;\n      return compareTo === null || compareTo === void 0 ? void 0 : compareTo.some(s => scopes.includes(s));\n    };\n    const propId = typeof prop === 'string' ? prop : prop.id;\n    const idMatch = ([scope, id]) => {\n      return scopeMatch([scope]) && id === propId;\n    };\n    const result = this.values.findIndex(def => {\n      var _a;\n      return scopeMatch(def.scopes) && (((_a = def.ids) === null || _a === void 0 ? void 0 : _a.some(id => idMatch(id))) || def.property === propId || def.id === propId);\n    });\n    if (result >= 0) {\n      return result;\n    }\n    throw new Error(`AG Charts - configuration error, unknown property ${JSON.stringify(prop)} in scope(s) ${JSON.stringify(scopes)}`);\n  }\n  extractData(data) {\n    var _a;\n    const {\n      keys: keyDefs,\n      values: valueDefs,\n      opts: {\n        dataVisible\n      }\n    } = this;\n    const {\n      dataDomain,\n      processValue,\n      scopes,\n      allScopesHaveSameDefs\n    } = this.initDataDomainProcessor();\n    const resultData = new Array(dataVisible ? data.length : 0);\n    let resultDataIdx = 0;\n    let partialValidDataCount = 0;\n    for (const datum of data) {\n      const validScopes = scopes.size > 0 ? new Set(scopes) : undefined;\n      const keys = dataVisible ? new Array(keyDefs.length) : undefined;\n      let keyIdx = 0;\n      let key;\n      for (const def of keyDefs) {\n        key = processValue(def, datum, key);\n        if (key === INVALID_VALUE) break;\n        if (keys) {\n          keys[keyIdx++] = key;\n        }\n      }\n      if (key === INVALID_VALUE) continue;\n      const values = dataVisible && valueDefs.length > 0 ? new Array(valueDefs.length) : undefined;\n      let valueIdx = 0;\n      let value;\n      for (const def of valueDefs) {\n        value = processValue(def, datum, value);\n        if (value === INVALID_VALUE) {\n          if (allScopesHaveSameDefs) break;\n          for (const scope of (_a = def.scopes) !== null && _a !== void 0 ? _a : scopes) {\n            validScopes === null || validScopes === void 0 ? void 0 : validScopes.delete(scope);\n          }\n          valueIdx++;\n          if ((validScopes === null || validScopes === void 0 ? void 0 : validScopes.size) === 0) break;\n        } else if (values) {\n          values[valueIdx++] = value;\n        }\n      }\n      if (value === INVALID_VALUE && allScopesHaveSameDefs) continue;\n      if ((validScopes === null || validScopes === void 0 ? void 0 : validScopes.size) === 0) continue;\n      if (dataVisible) {\n        const result = {\n          datum,\n          keys: keys,\n          values\n        };\n        if (!allScopesHaveSameDefs && validScopes && validScopes.size < scopes.size) {\n          partialValidDataCount++;\n          result.validScopes = [...validScopes];\n        }\n        resultData[resultDataIdx++] = result;\n      }\n    }\n    resultData.length = resultDataIdx;\n    const propertyDomain = def => {\n      const result = dataDomain.get(def).getDomain();\n      if (Array.isArray(result) && result[0] > result[1]) {\n        // Ignore starting values.\n        return [];\n      }\n      return [...result];\n    };\n    return {\n      type: 'ungrouped',\n      input: {\n        count: data.length\n      },\n      data: resultData,\n      domain: {\n        keys: keyDefs.map(def => propertyDomain(def)),\n        values: valueDefs.map(def => propertyDomain(def))\n      },\n      defs: {\n        allScopesHaveSameDefs,\n        keys: keyDefs,\n        values: valueDefs\n      },\n      partialValidDataCount,\n      time: 0\n    };\n  }\n  groupData(data, groupingFn) {\n    var _a, _b, _c, _d;\n    const processedData = new Map();\n    for (const dataEntry of data.data) {\n      const {\n        keys,\n        values,\n        datum,\n        validScopes\n      } = dataEntry;\n      const group = groupingFn ? groupingFn(dataEntry) : keys;\n      const groupStr = toKeyString(group);\n      if (processedData.has(groupStr)) {\n        const existingData = processedData.get(groupStr);\n        existingData.values.push(values);\n        existingData.datum.push(datum);\n        if (validScopes != null) {\n          // Intersection of existing validScopes with new validScopes.\n          for (let index = 0; index < ((_b = (_a = existingData.validScopes) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0); index++) {\n            const scope = (_c = existingData.validScopes) === null || _c === void 0 ? void 0 : _c[index];\n            if (validScopes.some(s => s === scope)) continue;\n            (_d = existingData.validScopes) === null || _d === void 0 ? void 0 : _d.splice(index, 1);\n          }\n        }\n      } else {\n        processedData.set(groupStr, {\n          keys: group,\n          values: [values],\n          datum: [datum],\n          validScopes\n        });\n      }\n    }\n    const resultData = new Array(processedData.size);\n    const resultGroups = new Array(processedData.size);\n    let dataIndex = 0;\n    for (const [, {\n      keys,\n      values,\n      datum,\n      validScopes\n    }] of processedData.entries()) {\n      if ((validScopes === null || validScopes === void 0 ? void 0 : validScopes.length) === 0) continue;\n      resultGroups[dataIndex] = keys;\n      resultData[dataIndex++] = {\n        keys,\n        values,\n        datum,\n        validScopes\n      };\n    }\n    return Object.assign(Object.assign({}, data), {\n      type: 'grouped',\n      data: resultData,\n      domain: Object.assign(Object.assign({}, data.domain), {\n        groups: resultGroups\n      })\n    });\n  }\n  aggregateData(processedData) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const {\n      aggregates: aggDefs\n    } = this;\n    if (!aggDefs) return;\n    const resultAggValues = aggDefs.map(() => [Infinity, -Infinity]);\n    const resultAggValueIndices = aggDefs.map(def => this.valueGroupIdxLookup(def));\n    const resultAggFns = aggDefs.map(def => def.aggregateFunction);\n    const resultGroupAggFns = aggDefs.map(def => def.groupAggregateFunction);\n    const resultFinalFns = aggDefs.map(def => def.finalFunction);\n    for (const group of processedData.data) {\n      let {\n        values\n      } = group;\n      const {\n        validScopes\n      } = group;\n      (_a = group.aggValues) !== null && _a !== void 0 ? _a : group.aggValues = new Array(resultAggValueIndices.length);\n      if (processedData.type === 'ungrouped') {\n        values = [values];\n      }\n      let resultIdx = 0;\n      for (const indices of resultAggValueIndices) {\n        const scopeValid = (_b = validScopes === null || validScopes === void 0 ? void 0 : validScopes.some(s => {\n          var _a;\n          return (_a = aggDefs[resultIdx].matchScopes) === null || _a === void 0 ? void 0 : _a.some(as => s === as);\n        })) !== null && _b !== void 0 ? _b : true;\n        if (!scopeValid) {\n          resultIdx++;\n          continue;\n        }\n        let groupAggValues = (_d = (_c = resultGroupAggFns[resultIdx]) === null || _c === void 0 ? void 0 : _c.call(resultGroupAggFns)) !== null && _d !== void 0 ? _d : extendDomain([]);\n        for (const distinctValues of values) {\n          const valuesToAgg = indices.map(valueIdx => distinctValues[valueIdx]);\n          const valuesAgg = resultAggFns[resultIdx](valuesToAgg, group.keys);\n          if (valuesAgg) {\n            groupAggValues = (_f = (_e = resultGroupAggFns[resultIdx]) === null || _e === void 0 ? void 0 : _e.call(resultGroupAggFns, valuesAgg, groupAggValues)) !== null && _f !== void 0 ? _f : extendDomain(valuesAgg, groupAggValues);\n          }\n        }\n        const finalValues = ((_h = (_g = resultFinalFns[resultIdx]) === null || _g === void 0 ? void 0 : _g.call(resultFinalFns, groupAggValues)) !== null && _h !== void 0 ? _h : groupAggValues).map(v => round(v));\n        extendDomain(finalValues, resultAggValues[resultIdx]);\n        group.aggValues[resultIdx++] = finalValues;\n      }\n    }\n    processedData.domain.aggValues = resultAggValues;\n  }\n  postProcessGroups(processedData) {\n    var _a, _b, _c, _d, _e;\n    const {\n      groupProcessors\n    } = this;\n    if (!groupProcessors) return;\n    const affectedIndices = new Set();\n    const updatedDomains = new Map();\n    const groupProcessorIndices = new Map();\n    const groupProcessorInitFns = new Map();\n    for (const processor of groupProcessors) {\n      const indices = this.valueGroupIdxLookup(processor);\n      groupProcessorIndices.set(processor, indices);\n      groupProcessorInitFns.set(processor, processor.adjust());\n      for (const idx of indices) {\n        const valueDef = this.values[idx];\n        affectedIndices.add(idx);\n        updatedDomains.set(idx, new DataDomain(valueDef.valueType === 'category' ? 'discrete' : 'continuous'));\n      }\n    }\n    const updateDomains = values => {\n      var _a;\n      for (const valueIndex of affectedIndices) {\n        (_a = updatedDomains.get(valueIndex)) === null || _a === void 0 ? void 0 : _a.extend(values[valueIndex]);\n      }\n    };\n    for (const group of processedData.data) {\n      for (const processor of groupProcessors) {\n        const scopeValid = (_b = (_a = group.validScopes) === null || _a === void 0 ? void 0 : _a.some(s => {\n          var _a;\n          return (_a = processor.matchScopes) === null || _a === void 0 ? void 0 : _a.some(as => s === as);\n        })) !== null && _b !== void 0 ? _b : true;\n        if (!scopeValid) {\n          continue;\n        }\n        const valueIndexes = (_c = groupProcessorIndices.get(processor)) !== null && _c !== void 0 ? _c : [];\n        const adjustFn = (_e = (_d = groupProcessorInitFns.get(processor)) === null || _d === void 0 ? void 0 : _d()) !== null && _e !== void 0 ? _e : () => undefined;\n        if (processedData.type === 'grouped') {\n          for (const values of group.values) {\n            if (values) {\n              adjustFn(values, valueIndexes);\n            }\n          }\n          continue;\n        }\n        if (group.values) {\n          adjustFn(group.values, valueIndexes);\n        }\n      }\n      if (processedData.type === 'grouped') {\n        for (const values of group.values) {\n          updateDomains(values);\n        }\n      } else {\n        updateDomains(group.values);\n      }\n    }\n    for (const [idx, dataDomain] of updatedDomains) {\n      processedData.domain.values[idx] = [...dataDomain.getDomain()];\n    }\n  }\n  postProcessProperties(processedData) {\n    const {\n      propertyProcessors\n    } = this;\n    if (!propertyProcessors) return;\n    for (const {\n      adjust,\n      property,\n      scopes\n    } of propertyProcessors) {\n      adjust()(processedData, this.valueIdxLookup(scopes !== null && scopes !== void 0 ? scopes : [], property));\n    }\n  }\n  reduceData(processedData) {\n    var _a, _b, _c;\n    const {\n      reducers: reducerDefs\n    } = this;\n    const scopes = reducerDefs.map(def => def.scopes);\n    const reducers = reducerDefs.map(def => def.reducer());\n    const accValues = reducerDefs.map(def => def.initialValue);\n    for (const group of processedData.data) {\n      let reducerIndex = 0;\n      for (const reducer of reducers) {\n        const scopeValid = (_b = (_a = group.validScopes) === null || _a === void 0 ? void 0 : _a.some(s => {\n          var _a;\n          return (_a = scopes[reducerIndex]) === null || _a === void 0 ? void 0 : _a.some(as => s === as);\n        })) !== null && _b !== void 0 ? _b : true;\n        if (!scopeValid) {\n          reducerIndex++;\n          continue;\n        }\n        accValues[reducerIndex] = reducer(accValues[reducerIndex], group);\n        reducerIndex++;\n      }\n    }\n    for (let accIdx = 0; accIdx < accValues.length; accIdx++) {\n      (_c = processedData.reduced) !== null && _c !== void 0 ? _c : processedData.reduced = {};\n      processedData.reduced[reducerDefs[accIdx].property] = accValues[accIdx];\n    }\n  }\n  postProcessData(processedData) {\n    var _a;\n    const {\n      processors: processorDefs\n    } = this;\n    for (const def of processorDefs) {\n      (_a = processedData.reduced) !== null && _a !== void 0 ? _a : processedData.reduced = {};\n      processedData.reduced[def.property] = def.calculate(processedData);\n    }\n  }\n  initDataDomainProcessor() {\n    var _a;\n    const {\n      keys: keyDefs,\n      values: valueDefs\n    } = this;\n    const scopes = new Set();\n    for (const valueDef of valueDefs) {\n      for (const scope of (_a = valueDef.scopes) !== null && _a !== void 0 ? _a : []) {\n        scopes.add(scope);\n      }\n    }\n    const scopesCount = scopes.size;\n    const dataDomain = new Map();\n    const processorFns = new Map();\n    let allScopesHaveSameDefs = true;\n    const initDataDomainKey = (key, type, updateDataDomain = dataDomain) => {\n      var _a;\n      if (type === 'category') {\n        updateDataDomain.set(key, new DataDomain('discrete'));\n      } else {\n        updateDataDomain.set(key, new DataDomain('continuous'));\n        allScopesHaveSameDefs && (allScopesHaveSameDefs = ((_a = key.scopes) !== null && _a !== void 0 ? _a : []).length === scopesCount);\n      }\n    };\n    const initDataDomain = () => {\n      keyDefs.forEach(def => initDataDomainKey(def, def.valueType));\n      valueDefs.forEach(def => initDataDomainKey(def, def.valueType));\n    };\n    initDataDomain();\n    const accessors = this.buildAccessors(...keyDefs, ...valueDefs);\n    const processValue = (def, datum, previousDatum) => {\n      var _a, _b, _c, _d;\n      const hasAccessor = (def.property in accessors);\n      let valueInDatum = false;\n      let value;\n      if (hasAccessor) {\n        try {\n          value = accessors[def.property](datum);\n        } catch (error) {\n          // Swallow errors - these get reported as missing values to the user later.\n        }\n        valueInDatum = value !== undefined;\n      } else {\n        valueInDatum = def.property in datum;\n        value = valueInDatum ? datum[def.property] : def.missingValue;\n      }\n      if (def.forceValue != null) {\n        // Maintain sign of forceValue from actual value, this maybe significant later when\n        // we account fo the value falling into positive/negative buckets.\n        const valueNegative = valueInDatum && isNegative(value);\n        value = valueNegative ? -1 * def.forceValue : def.forceValue;\n        valueInDatum = true;\n      }\n      const missingValueDef = ('missingValue' in def);\n      if (!valueInDatum && !missingValueDef) {\n        def.missing++;\n      }\n      if (!dataDomain.has(def)) {\n        initDataDomain();\n      }\n      if (valueInDatum) {\n        const valid = (_b = (_a = def.validation) === null || _a === void 0 ? void 0 : _a.call(def, value, datum)) !== null && _b !== void 0 ? _b : true;\n        if (!valid) {\n          if ('invalidValue' in def) {\n            value = def.invalidValue;\n          } else {\n            return INVALID_VALUE;\n          }\n        }\n      }\n      if (def.processor) {\n        if (!processorFns.has(def)) {\n          processorFns.set(def, def.processor());\n        }\n        value = (_c = processorFns.get(def)) === null || _c === void 0 ? void 0 : _c(value, previousDatum !== INVALID_VALUE ? previousDatum : undefined);\n      }\n      (_d = dataDomain.get(def)) === null || _d === void 0 ? void 0 : _d.extend(value);\n      return value;\n    };\n    return {\n      dataDomain,\n      processValue,\n      initDataDomain,\n      scopes,\n      allScopesHaveSameDefs\n    };\n  }\n  buildAccessors(...defs) {\n    const result = {};\n    if (this.mode === 'integrated') return result;\n    for (const def of defs) {\n      const isPath = def.property.indexOf('.') >= 0 || def.property.indexOf('[') >= 0;\n      if (!isPath) continue;\n      let fnBody;\n      if (def.property.startsWith('[')) {\n        fnBody = `return datum${def.property};`;\n      } else {\n        fnBody = `return datum.${def.property};`;\n      }\n      result[def.property] = new Function('datum', fnBody);\n    }\n    return result;\n  }\n}\nfunction logProcessedData(processedData) {\n  var _a, _b;\n  const logValues = (name, data) => {\n    if (data.length > 0) {\n      Logger.log(`DataModel.processData() - ${name}`);\n      Logger.table(data);\n    }\n  };\n  Logger.log('DataModel.processData() - processedData', processedData);\n  logValues('Key Domains', processedData.domain.keys);\n  logValues('Group Domains', (_a = processedData.domain.groups) !== null && _a !== void 0 ? _a : []);\n  logValues('Value Domains', processedData.domain.values);\n  logValues('Aggregate Domains', (_b = processedData.domain.aggValues) !== null && _b !== void 0 ? _b : []);\n  if (processedData.type === 'grouped') {\n    const flattenedValues = processedData.data.reduce((acc, next) => {\n      var _a, _b;\n      const keys = (_a = next.keys) !== null && _a !== void 0 ? _a : [];\n      const aggValues = (_b = next.aggValues) !== null && _b !== void 0 ? _b : [];\n      const skipKeys = next.keys.map(() => undefined);\n      const skipAggValues = aggValues === null || aggValues === void 0 ? void 0 : aggValues.map(() => undefined);\n      acc.push(...next.values.map((v, i) => [...(i === 0 ? keys : skipKeys), ...(v !== null && v !== void 0 ? v : []), ...(i == 0 ? aggValues : skipAggValues)]));\n      return acc;\n    }, []);\n    logValues('Values', flattenedValues);\n  } else {\n    const flattenedValues = processedData.data.reduce((acc, next) => {\n      var _a;\n      const aggValues = (_a = next.aggValues) !== null && _a !== void 0 ? _a : [];\n      acc.push([...next.keys, ...next.values, ...aggValues]);\n      return acc;\n    }, []);\n    logValues('Values', flattenedValues);\n  }\n}\n\n/** Implements cross-series data model coordination. */\nclass DataController {\n  constructor(mode) {\n    this.mode = mode;\n    this.debug = Debug.create(true, 'data-model');\n    this.requested = [];\n    this.status = 'setup';\n  }\n  request(id, data, opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== 'setup') throw new Error(`AG Charts - data request after data setup phase.`);\n      return new Promise((resolve, reject) => {\n        this.requested.push({\n          id,\n          opts,\n          data,\n          resultCb: resolve,\n          reject\n        });\n      });\n    });\n  }\n  execute() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.status !== 'setup') throw new Error(`AG Charts - data request after data setup phase.`);\n      this.status = 'executed';\n      this.debug('DataController.execute() - requested', this.requested);\n      const merged = this.mergeRequested();\n      this.debug('DataController.execute() - merged', merged);\n      const debugMode = Debug.check(true, 'data-model');\n      if (debugMode) {\n        window.processedData = [];\n      }\n      for (const {\n        opts,\n        data,\n        resultCbs,\n        rejects,\n        ids\n      } of merged) {\n        try {\n          const dataModel = new DataModel(Object.assign(Object.assign({}, opts), {\n            mode: this.mode\n          }));\n          const processedData = dataModel.processData(data);\n          if (debugMode) {\n            window.processedData.push(processedData);\n          }\n          if (processedData && processedData.partialValidDataCount === 0) {\n            resultCbs.forEach(cb => cb({\n              dataModel,\n              processedData\n            }));\n          } else if (processedData) {\n            this.splitResult(dataModel, processedData, ids, resultCbs);\n          } else {\n            rejects.forEach(cb => cb(new Error(`AG Charts - no processed data generated`)));\n          }\n        } catch (error) {\n          rejects.forEach(cb => cb(error));\n        }\n      }\n    });\n  }\n  mergeRequested() {\n    const grouped = [];\n    const keys = props => {\n      return props.filter(p => p.type === 'key').map(p => p.property).join(';');\n    };\n    const groupMatch = ({\n      opts,\n      data\n    }) => gr => {\n      return gr[0].data === data && gr[0].opts.groupByKeys === opts.groupByKeys && gr[0].opts.dataVisible === opts.dataVisible && gr[0].opts.groupByFn === opts.groupByFn && keys(gr[0].opts.props) === keys(opts.props);\n    };\n    const propMatch = prop => existing => {\n      var _a;\n      if (existing.type !== prop.type) return false;\n      const diff = (_a = jsonDiff(existing, prop)) !== null && _a !== void 0 ? _a : {};\n      delete diff['scopes'];\n      delete diff['id'];\n      delete diff['ids'];\n      return Object.keys(diff).length === 0;\n    };\n    const mergeOpts = opts => {\n      return Object.assign(Object.assign({}, opts[0]), {\n        props: opts.reduce((result, next) => {\n          var _a, _b, _c, _d, _e, _f;\n          for (const prop of next.props) {\n            if (prop.id != null) {\n              (_a = prop.ids) !== null && _a !== void 0 ? _a : prop.ids = [];\n              (_b = prop.scopes) === null || _b === void 0 ? void 0 : _b.forEach(scope => {\n                var _a;\n                return (_a = prop.ids) === null || _a === void 0 ? void 0 : _a.push([scope, prop.id]);\n              });\n            }\n            const match = result.find(propMatch(prop));\n            if (!match) {\n              result.push(prop);\n              continue;\n            }\n            (_c = match.scopes) !== null && _c !== void 0 ? _c : match.scopes = [];\n            match.scopes.push(...((_d = prop.scopes) !== null && _d !== void 0 ? _d : []));\n            if (match.type !== 'key' && match.type !== 'value') continue;\n            (_e = match.ids) === null || _e === void 0 ? void 0 : _e.push(...((_f = prop.ids) !== null && _f !== void 0 ? _f : []));\n          }\n          return result;\n        }, [])\n      });\n    };\n    const merge = props => {\n      return {\n        ids: props.map(({\n          id\n        }) => id),\n        resultCbs: props.map(({\n          resultCb\n        }) => resultCb),\n        rejects: props.map(({\n          reject\n        }) => reject),\n        data: props[0].data,\n        opts: mergeOpts(props.map(({\n          opts\n        }) => opts))\n      };\n    };\n    for (const request of this.requested) {\n      const match = grouped.find(groupMatch(request));\n      if (match) {\n        match.push(request);\n      } else {\n        grouped.push([request]);\n      }\n    }\n    return grouped.map(merge);\n  }\n  splitResult(dataModel, processedData, scopes, resultCbs) {\n    for (let index = 0; index < scopes.length; index++) {\n      const scope = scopes[index];\n      const resultCb = resultCbs[index];\n      resultCb({\n        dataModel,\n        processedData: Object.assign(Object.assign({}, processedData), {\n          data: processedData.data.filter(({\n            validScopes\n          }) => {\n            return validScopes == null || validScopes.some(s => s === scope);\n          })\n        })\n      });\n    }\n  }\n}\nclass DataService {\n  constructor(getSeries) {\n    this.getSeries = getSeries;\n  }\n}\nclass BaseManager {\n  constructor() {\n    this.listeners = new Listeners();\n  }\n  addListener(type, handler, meta) {\n    return this.listeners.addListener(type, handler, meta);\n  }\n  removeListener(listenerSymbol) {\n    this.listeners.removeListener(listenerSymbol);\n  }\n}\nconst DEBUG_SELECTORS = [true, 'animation'];\n/**\r\n * Manage animations across a chart, running all animations through only one `requestAnimationFrame` callback,\r\n * preventing duplicate animations and handling their lifecycle.\r\n */\nclass AnimationManager extends BaseManager {\n  constructor(interactionManager, chartUpdateMutex) {\n    super();\n    this.interactionManager = interactionManager;\n    this.chartUpdateMutex = chartUpdateMutex;\n    this.defaultDuration = 1000;\n    this.batch = new AnimationBatch();\n    this.debug = Debug.create(...DEBUG_SELECTORS);\n    this.isPlaying = false;\n    this.requestId = null;\n    this.skipAnimations = false;\n  }\n  /**\r\n   * Create an animation to tween a value between the `from` and `to` properties. If an animation already exists\r\n   * with the same `id`, immediately stop it.\r\n   */\n  animate(_a) {\n    var _b, _c;\n    var {\n        disableInteractions = true,\n        immutable = true\n      } = _a,\n      opts = __rest(_a, [\"disableInteractions\", \"immutable\"]);\n    const {\n      batch\n    } = this;\n    try {\n      if (opts.id != null && batch.controllers.has(opts.id)) {\n        if (!immutable) {\n          return batch.controllers.get(opts.id).reset(opts);\n        }\n        batch.controllers.get(opts.id).stop();\n        this.debug(`Skipping animation batch due to update of existing animation: ${opts.id}`);\n        this.batch.skip();\n      }\n    } catch (error) {\n      this.failsafeOnError(error);\n      return;\n    }\n    const id = (_b = opts.id) !== null && _b !== void 0 ? _b : Math.random().toString();\n    const skip = this.isSkipped();\n    if (skip) {\n      this.debug('AnimationManager - skipping animation');\n    }\n    return new Animation(Object.assign(Object.assign({}, opts), {\n      id,\n      skip,\n      autoplay: this.isPlaying ? opts.autoplay : false,\n      duration: (_c = opts.duration) !== null && _c !== void 0 ? _c : this.defaultDuration,\n      onPlay: controller => {\n        var _a;\n        batch.controllers.set(id, controller);\n        this.requestAnimation();\n        if (disableInteractions) {\n          this.interactionManager.pause('animation');\n        }\n        (_a = opts.onPlay) === null || _a === void 0 ? void 0 : _a.call(controller, controller);\n      },\n      onStop: controller => {\n        var _a;\n        batch.controllers.delete(id);\n        if (disableInteractions) {\n          this.interactionManager.resume('animation');\n        }\n        (_a = opts.onStop) === null || _a === void 0 ? void 0 : _a.call(controller, controller);\n      }\n    }));\n  }\n  play() {\n    if (this.isPlaying) {\n      return;\n    }\n    this.isPlaying = true;\n    this.debug('AnimationManager.play()');\n    for (const controller of this.batch.controllers.values()) {\n      try {\n        controller.play();\n      } catch (error) {\n        this.failsafeOnError(error);\n      }\n    }\n    this.requestAnimation();\n  }\n  pause() {\n    if (!this.isPlaying) {\n      return;\n    }\n    this.isPlaying = false;\n    this.cancelAnimation();\n    this.debug('AnimationManager.pause()');\n    for (const controller of this.batch.controllers.values()) {\n      try {\n        controller.pause();\n      } catch (error) {\n        this.failsafeOnError(error);\n      }\n    }\n  }\n  stop() {\n    this.isPlaying = false;\n    this.cancelAnimation();\n    this.debug('AnimationManager.stop()');\n    for (const controller of this.batch.controllers.values()) {\n      try {\n        controller.stop();\n      } catch (error) {\n        this.failsafeOnError(error, false);\n      }\n    }\n  }\n  stopByAnimationId(id) {\n    var _a;\n    try {\n      if (id != null && this.batch.controllers.has(id)) {\n        (_a = this.batch.controllers.get(id)) === null || _a === void 0 ? void 0 : _a.stop();\n      }\n    } catch (error) {\n      this.failsafeOnError(error);\n      return;\n    }\n  }\n  stopByAnimationGroupId(id) {\n    for (const controller of this.batch.controllers.values()) {\n      if (controller.groupId === id) {\n        this.stopByAnimationId(controller.id);\n      }\n    }\n  }\n  reset() {\n    if (this.isPlaying) {\n      this.stop();\n      this.play();\n    } else {\n      this.stop();\n    }\n  }\n  skip(skip = true) {\n    this.skipAnimations = skip;\n  }\n  isSkipped() {\n    return this.skipAnimations || this.batch.isSkipped();\n  }\n  isActive() {\n    return this.isPlaying && this.batch.isActive();\n  }\n  skipCurrentBatch() {\n    if (Debug.check(...DEBUG_SELECTORS)) {\n      this.debug(`AnimationManager - skipCurrentBatch()`, {\n        stack: new Error().stack\n      });\n    }\n    this.batch.skip();\n  }\n  /** Mocking point for tests to guarantee that animation updates happen. */\n  isSkippingFrames() {\n    return true;\n  }\n  /** Mocking point for tests to capture requestAnimationFrame callbacks. */\n  scheduleAnimationFrame(cb) {\n    this.requestId = requestAnimationFrame(cb);\n  }\n  requestAnimation() {\n    if (!this.batch.isActive() || this.requestId !== null) return;\n    let prevTime;\n    const onAnimationFrame = time => __awaiter(this, void 0, void 0, function* () {\n      const executeAnimationFrame = () => __awaiter(this, void 0, void 0, function* () {\n        const deltaTime = time - (prevTime !== null && prevTime !== void 0 ? prevTime : time);\n        prevTime = time;\n        this.debug('AnimationManager - onAnimationFrame()', {\n          controllersCount: this.batch.controllers.size\n        });\n        for (const controller of this.batch.controllers.values()) {\n          try {\n            controller.update(deltaTime);\n          } catch (error) {\n            this.failsafeOnError(error);\n          }\n        }\n        this.listeners.dispatch('animation-frame', {\n          type: 'animation-frame',\n          deltaMs: deltaTime\n        });\n      });\n      if (this.isSkippingFrames()) {\n        // Only run the animation frame if we can acquire the chart update mutex immediately.\n        yield this.chartUpdateMutex.acquireImmediately(executeAnimationFrame);\n      } else {\n        // Wait for the next available point we can execute.\n        yield this.chartUpdateMutex.acquire(executeAnimationFrame);\n      }\n      if (this.batch.isActive()) {\n        this.scheduleAnimationFrame(onAnimationFrame);\n      }\n    });\n    this.scheduleAnimationFrame(onAnimationFrame);\n  }\n  cancelAnimation() {\n    if (this.requestId === null) return;\n    cancelAnimationFrame(this.requestId);\n    this.requestId = null;\n    this.startBatch();\n  }\n  failsafeOnError(error, cancelAnimation = true) {\n    Logger.error('Error during animation, skipping animations', error);\n    if (cancelAnimation) {\n      this.cancelAnimation();\n    }\n  }\n  startBatch(skipAnimations) {\n    this.debug(`AnimationManager - startBatch() with skipAnimations=${skipAnimations}.`);\n    this.reset();\n    this.batch.destroy();\n    this.batch = new AnimationBatch();\n    if (skipAnimations === true) {\n      this.batch.skip();\n    }\n  }\n  endBatch() {\n    this.debug(`AnimationManager - endBatch() with ${this.batch.controllers.size} animations; skipped: ${this.batch.isSkipped()}.`);\n    if (this.batch.isSkipped() && !this.batch.isActive()) {\n      this.batch.skip(false);\n    }\n  }\n}\n/**\r\n * A batch of animations that are synchronised together. Can be skipped independently of other batches and the main\r\n * animation skipping status.\r\n */\nclass AnimationBatch {\n  constructor() {\n    this.controllers = new Map();\n    this.skipAnimations = false;\n  }\n  // private phase?: 'initial-load' | 'remove' | 'update' | 'add';\n  isActive() {\n    return this.controllers.size > 0;\n  }\n  skip(skip = true) {\n    if (this.skipAnimations === false && skip === true) {\n      for (const controller of this.controllers.values()) {\n        controller.stop();\n      }\n      this.controllers.clear();\n    }\n    this.skipAnimations = skip;\n  }\n  isSkipped() {\n    return this.skipAnimations;\n  }\n  destroy() {}\n}\nclass ChartEventManager extends BaseManager {\n  legendItemClick(series, itemId, enabled, legendItemName) {\n    const event = {\n      type: 'legend-item-click',\n      series,\n      itemId,\n      enabled,\n      legendItemName\n    };\n    this.listeners.dispatch('legend-item-click', event);\n  }\n  legendItemDoubleClick(series, itemId, enabled, numVisibleItems, legendItemName) {\n    const event = {\n      type: 'legend-item-double-click',\n      series,\n      itemId,\n      enabled,\n      legendItemName,\n      numVisibleItems\n    };\n    this.listeners.dispatch('legend-item-double-click', event);\n  }\n  axisHover(axisId, direction) {\n    const event = {\n      type: 'axis-hover',\n      axisId,\n      direction\n    };\n    this.listeners.dispatch('axis-hover', event);\n  }\n}\n\n/**\r\n * Manages the cursor styling for an element. Tracks the requested styling from distinct\r\n * dependents and handles conflicting styling requests.\r\n */\nclass CursorManager {\n  constructor(element) {\n    this.states = {};\n    this.element = element;\n  }\n  updateCursor(callerId, style) {\n    delete this.states[callerId];\n    if (style != null) {\n      this.states[callerId] = {\n        style\n      };\n    }\n    this.applyStates();\n  }\n  applyStates() {\n    let styleToApply = 'default';\n    // Last added entry wins.\n    Object.entries(this.states).reverse().slice(0, 1).forEach(([_, {\n      style\n    }]) => styleToApply = style);\n    this.element.style.cursor = styleToApply;\n  }\n  getCursor() {\n    return this.element.style.cursor;\n  }\n}\n\n/**\r\n * Manages the actively highlighted series/datum for a chart. Tracks the requested highlights from\r\n * distinct dependents and handles conflicting highlight requests.\r\n */\nclass HighlightManager extends BaseManager {\n  constructor() {\n    super(...arguments);\n    this.highlightStates = new Map();\n    this.pickedStates = new Map();\n  }\n  updateHighlight(callerId, highlightedDatum) {\n    this.highlightStates.delete(callerId);\n    if (highlightedDatum != null) {\n      this.highlightStates.set(callerId, highlightedDatum);\n    }\n    this.applyHighlightStates();\n  }\n  getActiveHighlight() {\n    return this.activeHighlight;\n  }\n  updatePicked(callerId, clickableDatum) {\n    this.pickedStates.delete(callerId);\n    if (clickableDatum != null) {\n      this.pickedStates.set(callerId, clickableDatum);\n    }\n    this.applyPickedStates();\n  }\n  getActivePicked() {\n    return this.activePicked;\n  }\n  applyHighlightStates() {\n    // Last added entry wins.\n    const {\n      activeHighlight: previousHighlight\n    } = this;\n    this.activeHighlight = Array.from(this.highlightStates.values()).pop();\n    if (!this.isEqual(this.activeHighlight, previousHighlight)) {\n      this.listeners.dispatch('highlight-change', {\n        type: 'highlight-change',\n        currentHighlight: this.activeHighlight,\n        previousHighlight\n      });\n    }\n  }\n  applyPickedStates() {\n    this.activePicked = Array.from(this.pickedStates.values()).pop();\n  }\n  isEqual(a, b) {\n    return a === b || (a === null || a === void 0 ? void 0 : a.series) === (b === null || b === void 0 ? void 0 : b.series) && (a === null || a === void 0 ? void 0 : a.itemId) === (b === null || b === void 0 ? void 0 : b.itemId) && (a === null || a === void 0 ? void 0 : a.datum) === (b === null || b === void 0 ? void 0 : b.datum);\n  }\n}\nconst WINDOW_EVENT_HANDLERS = ['pagehide', 'mousemove', 'mouseup'];\nconst EVENT_HANDLERS = ['click', 'dblclick', 'contextmenu', 'mousedown', 'mouseout', 'mouseenter', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'wheel'];\nconst CSS = `\n.ag-chart-wrapper {\n    touch-action: none;\n}\n`;\n/**\r\n * Manages user interactions with a specific HTMLElement (or interactions that bubble from it's\r\n * children)\r\n */\nclass InteractionManager extends BaseManager {\n  constructor(element, document, window) {\n    super();\n    this.eventHandler = event => this.processEvent(event);\n    this.mouseDown = false;\n    this.touchDown = false;\n    this.pausers = {\n      animation: 0,\n      'context-menu': 0\n    };\n    this.rootElement = document.body;\n    this.element = element;\n    this.window = window;\n    for (const type of EVENT_HANDLERS) {\n      if (type.startsWith('touch')) {\n        element.addEventListener(type, this.eventHandler, {\n          passive: true\n        });\n      } else if (type === 'wheel') {\n        element.addEventListener(type, this.eventHandler, {\n          passive: false\n        });\n      } else {\n        element.addEventListener(type, this.eventHandler);\n      }\n    }\n    for (const type of WINDOW_EVENT_HANDLERS) {\n      this.window.addEventListener(type, this.eventHandler);\n    }\n    if (!InteractionManager.interactionDocuments.includes(document)) {\n      injectStyle(document, CSS);\n      InteractionManager.interactionDocuments.push(document);\n    }\n  }\n  destroy() {\n    for (const type of WINDOW_EVENT_HANDLERS) {\n      this.window.removeEventListener(type, this.eventHandler);\n    }\n    for (const type of EVENT_HANDLERS) {\n      this.element.removeEventListener(type, this.eventHandler);\n    }\n  }\n  resume(pauseType) {\n    this.pausers[pauseType]--;\n  }\n  pause(pauseType) {\n    this.pausers[pauseType]++;\n  }\n  processEvent(event) {\n    const types = this.decideInteractionEventTypes(event);\n    if (types.length > 0) {\n      // Async dispatch to avoid blocking the event-processing thread.\n      this.dispatchEvent(event, types).catch(e => Logger.errorOnce(e));\n    }\n  }\n  dispatchEvent(event, types) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const coords = this.calculateCoordinates(event);\n      if (coords == null) {\n        return;\n      }\n      const pauses = Object.entries(this.pausers).filter(([, count]) => count > 0).map(([pause]) => pause);\n      for (const type of types) {\n        this.listeners.dispatchWrapHandlers(type, (handler, meta, interactionEvent) => {\n          var _a;\n          if (pauses.length > 0 && !((_a = meta === null || meta === void 0 ? void 0 : meta.bypassPause) === null || _a === void 0 ? void 0 : _a.some(p => pauses.includes(p)))) {\n            return;\n          }\n          if (!interactionEvent.consumed) {\n            handler(interactionEvent);\n          }\n        }, this.buildEvent(Object.assign({\n          type,\n          event,\n          pauses\n        }, coords)));\n      }\n    });\n  }\n  decideInteractionEventTypes(event) {\n    const dragStart = 'drag-start';\n    switch (event.type) {\n      case 'click':\n        return ['click'];\n      case 'dblclick':\n        return ['dblclick'];\n      case 'contextmenu':\n        return ['contextmenu'];\n      case 'mousedown':\n        this.mouseDown = true;\n        this.dragStartElement = event.target;\n        return [dragStart];\n      case 'touchstart':\n        this.touchDown = true;\n        this.dragStartElement = event.target;\n        return [dragStart];\n      case 'touchmove':\n      case 'mousemove':\n        if (!this.mouseDown && !this.touchDown && !this.isEventOverElement(event)) {\n          // We only care about these events if the target is the canvas, unless\n          // we're in the middle of a drag/slide.\n          return [];\n        }\n        return this.mouseDown || this.touchDown ? ['drag'] : ['hover'];\n      case 'mouseup':\n        if (!this.mouseDown && !this.isEventOverElement(event)) {\n          // We only care about these events if the target is the canvas, unless\n          // we're in the middle of a drag.\n          return [];\n        }\n        this.mouseDown = false;\n        this.dragStartElement = undefined;\n        return ['drag-end'];\n      case 'touchend':\n        if (!this.touchDown && !this.isEventOverElement(event)) {\n          // We only care about these events if the target is the canvas, unless\n          // we're in the middle of a slide.\n          return [];\n        }\n        this.touchDown = false;\n        this.dragStartElement = undefined;\n        return ['drag-end'];\n      case 'mouseout':\n      case 'touchcancel':\n        return ['leave'];\n      case 'mouseenter':\n        const mouseButtonDown = event instanceof MouseEvent && (event.buttons & 1) === 1;\n        if (this.mouseDown !== mouseButtonDown) {\n          this.mouseDown = mouseButtonDown;\n          return [mouseButtonDown ? dragStart : 'drag-end'];\n        }\n        return [];\n      case 'pagehide':\n        return ['page-left'];\n      case 'wheel':\n        return ['wheel'];\n    }\n    return [];\n  }\n  isEventOverElement(event) {\n    var _a;\n    return event.target === this.element || ((_a = event.target) === null || _a === void 0 ? void 0 : _a.parentElement) === this.element;\n  }\n  calculateCoordinates(event) {\n    var _a;\n    if (event instanceof MouseEvent) {\n      const {\n        clientX,\n        clientY,\n        pageX,\n        pageY,\n        offsetX,\n        offsetY\n      } = event;\n      return this.fixOffsets(event, {\n        clientX,\n        clientY,\n        pageX,\n        pageY,\n        offsetX,\n        offsetY\n      });\n    } else if (typeof TouchEvent !== 'undefined' && event instanceof TouchEvent) {\n      const lastTouch = (_a = event.touches[0]) !== null && _a !== void 0 ? _a : event.changedTouches[0];\n      const {\n        clientX,\n        clientY,\n        pageX,\n        pageY\n      } = lastTouch;\n      return Object.assign(Object.assign({}, InteractionManager.NULL_COORDS), {\n        clientX,\n        clientY,\n        pageX,\n        pageY\n      });\n    } else if (event instanceof PageTransitionEvent) {\n      if (event.persisted) {\n        // Don't fire the page-left event since the page maybe revisited.\n        return;\n      }\n      return InteractionManager.NULL_COORDS;\n    }\n    // Unsupported event - abort.\n  }\n\n  fixOffsets(event, coords) {\n    const offsets = el => {\n      let x = 0;\n      let y = 0;\n      while (el) {\n        x += el.offsetLeft;\n        y += el.offsetTop;\n        el = el.offsetParent;\n      }\n      return {\n        x,\n        y\n      };\n    };\n    if (this.dragStartElement != null && event.target !== this.dragStartElement) {\n      // Offsets need to be relative to the drag-start element to avoid jumps when\n      // the pointer moves between element boundaries.\n      const offsetDragStart = offsets(this.dragStartElement);\n      const offsetEvent = offsets(event.target);\n      coords.offsetX -= offsetDragStart.x - offsetEvent.x;\n      coords.offsetY -= offsetDragStart.y - offsetEvent.y;\n    }\n    return coords;\n  }\n  buildEvent(opts) {\n    const {\n      type,\n      event,\n      clientX,\n      clientY,\n      pauses\n    } = opts;\n    let {\n      offsetX,\n      offsetY,\n      pageX,\n      pageY\n    } = opts;\n    if (!isNumber(offsetX) || !isNumber(offsetY)) {\n      const rect = this.element.getBoundingClientRect();\n      offsetX = clientX - rect.left;\n      offsetY = clientY - rect.top;\n    }\n    if (!isNumber(pageX) || !isNumber(pageY)) {\n      const pageRect = this.rootElement.getBoundingClientRect();\n      pageX = clientX - pageRect.left;\n      pageY = clientY - pageRect.top;\n    }\n    const builtEvent = {\n      type,\n      offsetX: offsetX,\n      offsetY: offsetY,\n      pageX: pageX,\n      pageY: pageY,\n      sourceEvent: event,\n      consumed: false,\n      pauses,\n      consume() {\n        builtEvent.consumed = true;\n      }\n    };\n    return builtEvent;\n  }\n}\nInteractionManager.interactionDocuments = [];\nInteractionManager.NULL_COORDS = {\n  clientX: -Infinity,\n  clientY: -Infinity,\n  pageX: -Infinity,\n  pageY: -Infinity,\n  offsetX: -Infinity,\n  offsetY: -Infinity\n};\n\n/**\r\n * Manages the tooltip HTML an element. Tracks the requested HTML from distinct dependents and\r\n * handles conflicting tooltip requests.\r\n */\nclass TooltipManager {\n  constructor(tooltip, interactionManager) {\n    this.states = {};\n    this.exclusiveAreas = {};\n    this.destroyFns = [];\n    this.tooltip = tooltip;\n    this.destroyFns.push(interactionManager.addListener('hover', e => this.checkExclusiveRects(e)));\n  }\n  getRange() {\n    return this.tooltip.range;\n  }\n  updateTooltip(callerId, meta, content) {\n    var _a;\n    if (content == null) {\n      content = (_a = this.states[callerId]) === null || _a === void 0 ? void 0 : _a.content;\n    }\n    this.states[callerId] = {\n      content,\n      meta\n    };\n    this.applyStates();\n  }\n  updateExclusiveRect(callerId, area) {\n    if (area) {\n      this.exclusiveAreas[callerId] = area;\n    } else {\n      delete this.exclusiveAreas[callerId];\n    }\n  }\n  removeTooltip(callerId) {\n    delete this.states[callerId];\n    this.applyStates();\n  }\n  getTooltipMeta(callerId) {\n    var _a;\n    return (_a = this.states[callerId]) === null || _a === void 0 ? void 0 : _a.meta;\n  }\n  destroy() {\n    for (const destroyFn of this.destroyFns) {\n      destroyFn();\n    }\n  }\n  checkExclusiveRects(e) {\n    let newAppliedExclusiveArea;\n    for (const [entryId, area] of Object.entries(this.exclusiveAreas)) {\n      if (!area.containsPoint(e.offsetX, e.offsetY)) {\n        continue;\n      }\n      newAppliedExclusiveArea = entryId;\n      break;\n    }\n    if (newAppliedExclusiveArea === this.appliedExclusiveArea) {\n      return;\n    }\n    this.appliedExclusiveArea = newAppliedExclusiveArea;\n    this.applyStates();\n  }\n  applyStates() {\n    var _a;\n    const ids = this.appliedExclusiveArea ? [this.appliedExclusiveArea] : Object.keys(this.states);\n    let contentToApply;\n    let metaToApply;\n    // Last added entry wins.\n    ids.reverse();\n    ids.slice(0, 1).forEach(id => {\n      var _a;\n      const {\n        content,\n        meta\n      } = (_a = this.states[id]) !== null && _a !== void 0 ? _a : {};\n      contentToApply = content;\n      metaToApply = meta;\n    });\n    if (metaToApply === undefined || contentToApply === undefined) {\n      this.appliedState = undefined;\n      this.tooltip.toggle(false);\n      return;\n    }\n    if (((_a = this.appliedState) === null || _a === void 0 ? void 0 : _a.content) === contentToApply) {\n      const renderInstantly = this.tooltip.isVisible();\n      this.tooltip.show(metaToApply, undefined, renderInstantly);\n    } else {\n      this.tooltip.show(metaToApply, contentToApply);\n    }\n    this.appliedState = {\n      content: contentToApply,\n      meta: metaToApply\n    };\n  }\n  static makeTooltipMeta(event, canvas, datum, window) {\n    var _a, _b, _c, _d;\n    const {\n      pageX,\n      pageY,\n      offsetX,\n      offsetY\n    } = event;\n    const position = {\n      xOffset: datum.series.tooltip.position.xOffset,\n      yOffset: datum.series.tooltip.position.yOffset\n    };\n    const meta = {\n      pageX,\n      pageY,\n      offsetX,\n      offsetY,\n      event: event,\n      showArrow: datum.series.tooltip.showArrow,\n      position\n    };\n    // On line and scatter series, the tooltip covers the top of errorbars when using\n    // datum.midPoint. Using datum.yBar.upperPoint renders the tooltip higher up.\n    const refPoint = (_b = (_a = datum.yBar) === null || _a === void 0 ? void 0 : _a.upperPoint) !== null && _b !== void 0 ? _b : datum.midPoint;\n    if (datum.series.tooltip.position.type === 'node' && refPoint) {\n      const {\n        x,\n        y\n      } = refPoint;\n      const point = datum.series.contentGroup.inverseTransformPoint(x, y);\n      const canvasRect = canvas.element.getBoundingClientRect();\n      return Object.assign(Object.assign({}, meta), {\n        pageX: Math.round(canvasRect.left + window.scrollX + point.x),\n        pageY: Math.round(canvasRect.top + window.scrollY + point.y),\n        offsetX: Math.round(point.x),\n        offsetY: Math.round(point.y)\n      });\n    }\n    meta.enableInteraction = (_d = (_c = datum.series.tooltip.interaction) === null || _c === void 0 ? void 0 : _c.enabled) !== null && _d !== void 0 ? _d : false;\n    return meta;\n  }\n}\n\n/**\r\n * Manages the current zoom state for a chart. Tracks the requested zoom from distinct dependents\r\n * and handles conflicting zoom requests.\r\n */\nclass ZoomManager extends BaseManager {\n  constructor() {\n    super(...arguments);\n    this.axes = {};\n  }\n  updateAxes(axes) {\n    var _a;\n    const removedAxes = new Set(Object.keys(this.axes));\n    axes.forEach(axis => {\n      var _a;\n      var _b, _c;\n      removedAxes.delete(axis.id);\n      (_a = (_b = this.axes)[_c = axis.id]) !== null && _a !== void 0 ? _a : _b[_c] = new AxisZoomManager(axis);\n    });\n    removedAxes.forEach(axisId => {\n      delete this.axes[axisId];\n    });\n    if ((_a = this.initialZoom) === null || _a === void 0 ? void 0 : _a.newZoom) {\n      this.updateZoom(this.initialZoom.callerId, this.initialZoom.newZoom);\n    }\n    this.initialZoom = undefined;\n  }\n  updateZoom(callerId, newZoom) {\n    if (Object.keys(this.axes).length === 0) {\n      this.initialZoom = {\n        callerId,\n        newZoom\n      };\n      return;\n    }\n    Object.values(this.axes).forEach(axis => {\n      axis.updateZoom(callerId, newZoom === null || newZoom === void 0 ? void 0 : newZoom[axis.getDirection()]);\n    });\n    this.applyStates();\n  }\n  updateAxisZoom(callerId, axisId, newZoom) {\n    var _a;\n    (_a = this.axes[axisId]) === null || _a === void 0 ? void 0 : _a.updateZoom(callerId, newZoom);\n    this.applyStates();\n  }\n  getZoom() {\n    let x;\n    let y;\n    // TODO: this only works when there is a single axis on each direction as it gets the last of each\n    Object.values(this.axes).forEach(axis => {\n      if (axis.getDirection() === ChartAxisDirection.X) {\n        x = axis.getZoom();\n      } else if (axis.getDirection() === ChartAxisDirection.Y) {\n        y = axis.getZoom();\n      }\n    });\n    if (x || y) {\n      return {\n        x,\n        y\n      };\n    }\n  }\n  getAxisZoom(axisId) {\n    var _a;\n    return (_a = this.axes[axisId]) === null || _a === void 0 ? void 0 : _a.getZoom();\n  }\n  getAxisZooms() {\n    const axes = {};\n    for (const [axisId, axis] of Object.entries(this.axes)) {\n      axes[axisId] = {\n        direction: axis.getDirection(),\n        zoom: axis.getZoom()\n      };\n    }\n    return axes;\n  }\n  applyStates() {\n    const changed = Object.values(this.axes).map(axis => axis.applyStates()).some(Boolean);\n    if (!changed) {\n      return;\n    }\n    const currentZoom = this.getZoom();\n    const axes = {};\n    for (const [axisId, axis] of Object.entries(this.axes)) {\n      axes[axisId] = axis.getZoom();\n    }\n    this.listeners.dispatch('zoom-change', Object.assign(Object.assign({\n      type: 'zoom-change'\n    }, currentZoom !== null && currentZoom !== void 0 ? currentZoom : {}), {\n      axes\n    }));\n  }\n}\nclass AxisZoomManager {\n  constructor(axis) {\n    this.states = {};\n    this.axis = axis;\n    const [min = 0, max = 1] = axis.visibleRange;\n    this.currentZoom = {\n      min,\n      max\n    };\n    this.states['__initial__'] = this.currentZoom;\n  }\n  getDirection() {\n    return this.axis.direction;\n  }\n  updateZoom(callerId, newZoom) {\n    delete this.states[callerId];\n    if (newZoom != null) {\n      this.states[callerId] = Object.assign({}, newZoom);\n    }\n  }\n  getZoom() {\n    return this.currentZoom;\n  }\n  applyStates() {\n    var _a, _b;\n    const prevZoom = this.currentZoom;\n    const last = Object.keys(this.states)[Object.keys(this.states).length - 1];\n    this.currentZoom = Object.assign({}, this.states[last]);\n    return (prevZoom === null || prevZoom === void 0 ? void 0 : prevZoom.min) !== ((_a = this.currentZoom) === null || _a === void 0 ? void 0 : _a.min) || (prevZoom === null || prevZoom === void 0 ? void 0 : prevZoom.max) !== ((_b = this.currentZoom) === null || _b === void 0 ? void 0 : _b.max);\n  }\n}\nclass LayoutService extends Listeners {\n  constructor() {\n    super(...arguments);\n    this.layoutComplete = 'layout-complete';\n  }\n  addListener(eventType, handler) {\n    if (this.isLayoutStage(eventType) || this.isLayoutComplete(eventType)) {\n      return super.addListener(eventType, handler);\n    }\n    throw new Error(`AG Charts - unsupported listener type: ${eventType}`);\n  }\n  dispatchPerformLayout(stage, ctx) {\n    if (this.isLayoutStage(stage)) {\n      return this.getListenersByType(stage).reduce((result, listener) => {\n        try {\n          return listener.handler(result);\n        } catch (e) {\n          Logger.errorOnce(e);\n          return result;\n        }\n      }, ctx);\n    }\n    return ctx;\n  }\n  dispatchLayoutComplete(event) {\n    this.dispatch(this.layoutComplete, event);\n  }\n  isLayoutStage(eventType) {\n    return eventType !== this.layoutComplete;\n  }\n  isLayoutComplete(eventType) {\n    return eventType === this.layoutComplete;\n  }\n}\nfunction gridLayout({\n  orientation,\n  bboxes,\n  maxHeight,\n  maxWidth,\n  itemPaddingY = 0,\n  itemPaddingX = 0,\n  forceResult = false\n}) {\n  const horizontal = orientation === 'horizontal';\n  const primary = {\n    max: horizontal ? maxWidth : maxHeight,\n    fn: horizontal ? b => b.width : b => b.height,\n    padding: horizontal ? itemPaddingX : itemPaddingY\n  };\n  const secondary = {\n    max: !horizontal ? maxWidth : maxHeight,\n    fn: !horizontal ? b => b.width : b => b.height,\n    padding: !horizontal ? itemPaddingX : itemPaddingY\n  };\n  let processedBBoxCount = 0;\n  const rawPages = [];\n  while (processedBBoxCount < bboxes.length) {\n    const unprocessedBBoxes = bboxes.slice(processedBBoxCount);\n    const result = processBBoxes(unprocessedBBoxes, processedBBoxCount, primary, secondary, forceResult);\n    if (!result) {\n      return;\n    }\n    processedBBoxCount += result.processedBBoxCount;\n    rawPages.push(result.pageIndices);\n  }\n  return buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX);\n}\nfunction processBBoxes(bboxes, indexOffset, primary, secondary, forceResult) {\n  // If calculatePage() fails on the first guess, we could use the number of items that fit\n  // as a good guess for the next iteration.\n  const minGuess = 1;\n  let startingGuess = estimateStartingGuess(bboxes, primary);\n  if (startingGuess < minGuess) {\n    if (!forceResult) {\n      return undefined;\n    }\n    // Legend constraints too small! Display at least one row/column if forceResult is true\n    startingGuess = minGuess;\n  }\n  for (let guess = startingGuess; guess >= minGuess; guess--) {\n    const pageIndices = calculatePage(bboxes, indexOffset, guess, primary, secondary, forceResult);\n    if (pageIndices == null && guess <= minGuess) {\n      // Can't layout!\n      return undefined;\n    }\n    if (pageIndices == null) {\n      // Guess again!\n      continue;\n    }\n    if (typeof pageIndices === 'number') {\n      // calculatePage() suggested a better guess, use that if it's more than minGuess.\n      if (pageIndices <= minGuess) {\n        // Can't layout!\n        return undefined;\n      }\n      guess = pageIndices < guess && pageIndices > minGuess ? pageIndices : guess;\n      continue;\n    }\n    const processedBBoxCount = pageIndices.length * pageIndices[0].length; // this is an estimate, not all rows/columns will have the same length\n    return {\n      processedBBoxCount,\n      pageIndices\n    };\n  }\n}\nfunction calculatePage(bboxes, indexOffset, primaryCount, primary, secondary, forceResult) {\n  var _a;\n  const result = [];\n  let sumSecondary = 0;\n  let currentMaxSecondary = 0;\n  let currentPrimaryIndices = [];\n  const maxPrimaryValues = [];\n  for (let bboxIndex = 0; bboxIndex < bboxes.length; bboxIndex++) {\n    const primaryValueIdx = (bboxIndex + primaryCount) % primaryCount;\n    if (primaryValueIdx === 0) {\n      sumSecondary += currentMaxSecondary;\n      currentMaxSecondary = 0;\n      if (currentPrimaryIndices.length > 0) {\n        result.push(currentPrimaryIndices);\n      }\n      currentPrimaryIndices = [];\n    }\n    const primaryValue = primary.fn(bboxes[bboxIndex]) + primary.padding;\n    maxPrimaryValues[primaryValueIdx] = Math.max((_a = maxPrimaryValues[primaryValueIdx]) !== null && _a !== void 0 ? _a : 0, primaryValue);\n    currentMaxSecondary = Math.max(currentMaxSecondary, secondary.fn(bboxes[bboxIndex]) + secondary.padding);\n    const currentSecondaryDimension = sumSecondary + currentMaxSecondary;\n    const returnResult = !forceResult || result.length > 0;\n    if (currentSecondaryDimension > secondary.max && returnResult) {\n      // Breached max secondary dimension size, return indices accumlated so far (but not in-progress row/column).\n      currentPrimaryIndices = [];\n      break;\n    }\n    const sumPrimary = maxPrimaryValues.reduce((sum, next) => sum + next, 0);\n    if (sumPrimary > primary.max && !forceResult) {\n      // Breached max main dimension size.\n      if (maxPrimaryValues.length < primaryCount) {\n        // Feedback as guess for next iteration if we're on the first round still.\n        return maxPrimaryValues.length;\n      }\n      return undefined;\n    }\n    currentPrimaryIndices.push(bboxIndex + indexOffset);\n  }\n  if (currentPrimaryIndices.length > 0) {\n    result.push(currentPrimaryIndices);\n  }\n  return result.length > 0 ? result : undefined;\n}\nfunction buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX) {\n  let maxPageWidth = 0;\n  let maxPageHeight = 0;\n  const pages = rawPages.map(indices => {\n    if (orientation === 'horizontal') {\n      indices = transpose(indices);\n    }\n    let endIndex = 0;\n    const columns = indices.map(colIndices => {\n      const colBBoxes = colIndices.map(bboxIndex => {\n        endIndex = Math.max(bboxIndex, endIndex);\n        return bboxes[bboxIndex];\n      });\n      let columnHeight = 0;\n      let columnWidth = 0;\n      colBBoxes.forEach(bbox => {\n        columnHeight += bbox.height + itemPaddingY;\n        columnWidth = Math.max(columnWidth, bbox.width + itemPaddingX);\n      });\n      return {\n        indices: colIndices,\n        bboxes: colBBoxes,\n        columnHeight: Math.ceil(columnHeight),\n        columnWidth: Math.ceil(columnWidth)\n      };\n    });\n    let pageWidth = 0;\n    let pageHeight = 0;\n    columns.forEach(column => {\n      pageWidth += column.columnWidth;\n      pageHeight = Math.max(pageHeight, column.columnHeight);\n    });\n    maxPageWidth = Math.max(pageWidth, maxPageWidth);\n    maxPageHeight = Math.max(pageHeight, maxPageHeight);\n    return {\n      columns,\n      startIndex: indices[0][0],\n      endIndex,\n      pageWidth,\n      pageHeight\n    };\n  });\n  return {\n    pages,\n    maxPageWidth,\n    maxPageHeight\n  };\n}\nfunction transpose(data) {\n  const result = [];\n  for (const _ of data[0]) {\n    result.push([]);\n  }\n  data.forEach((innerData, dataIdx) => {\n    innerData.forEach((item, itemIdx) => {\n      result[itemIdx][dataIdx] = item;\n    });\n  });\n  return result;\n}\nfunction estimateStartingGuess(bboxes, primary) {\n  const n = bboxes.length;\n  let primarySum = 0;\n  for (let bboxIndex = 0; bboxIndex < n; bboxIndex++) {\n    primarySum += primary.fn(bboxes[bboxIndex]) + primary.padding;\n    if (primarySum > primary.max) {\n      const ratio = n / bboxIndex;\n      if (ratio < 2) {\n        return Math.ceil(n / 2);\n      }\n      return bboxIndex;\n    }\n  }\n  return n;\n}\nclass Cross extends Marker {\n  updatePath() {\n    const s = this.size / 4.2;\n    super.applyPath(s, Cross.moves);\n  }\n}\nCross.className = 'Cross';\nCross.moves = [{\n  x: -1,\n  y: 0,\n  t: 'move'\n}, {\n  x: -1,\n  y: -1\n}, {\n  x: +1,\n  y: -1\n}, {\n  x: +1,\n  y: +1\n}, {\n  x: +1,\n  y: -1\n}, {\n  x: +1,\n  y: +1\n}, {\n  x: -1,\n  y: +1\n}, {\n  x: +1,\n  y: +1\n}, {\n  x: -1,\n  y: +1\n}, {\n  x: -1,\n  y: -1\n}, {\n  x: -1,\n  y: +1\n}, {\n  x: -1,\n  y: -1\n}];\nclass Diamond extends Marker {\n  updatePath() {\n    const s = this.size / 2;\n    super.applyPath(s, Diamond.moves);\n  }\n}\nDiamond.className = 'Diamond';\nDiamond.moves = [{\n  x: 0,\n  y: -1,\n  t: 'move'\n}, {\n  x: +1,\n  y: +1\n}, {\n  x: -1,\n  y: +1\n}, {\n  x: -1,\n  y: -1\n}, {\n  x: +1,\n  y: -1\n}];\nclass Heart extends Marker {\n  rad(degree) {\n    return degree / 180 * Math.PI;\n  }\n  updatePath() {\n    const {\n      x,\n      path,\n      size,\n      rad\n    } = this;\n    const r = size / 4;\n    const y = this.y + r / 2;\n    path.clear();\n    path.arc(x - r, y - r, r, rad(130), rad(330));\n    path.arc(x + r, y - r, r, rad(220), rad(50));\n    path.lineTo(x, y + r);\n    path.closePath();\n  }\n}\nHeart.className = 'Heart';\nclass Plus extends Marker {\n  updatePath() {\n    const s = this.size / 3;\n    super.applyPath(s, Plus.moves);\n  }\n}\nPlus.className = 'Plus';\nPlus.moves = [{\n  x: -0.5,\n  y: -0.5,\n  t: 'move'\n}, {\n  x: 0,\n  y: -1\n}, {\n  x: +1,\n  y: 0\n}, {\n  x: 0,\n  y: +1\n}, {\n  x: +1,\n  y: 0\n}, {\n  x: 0,\n  y: +1\n}, {\n  x: -1,\n  y: 0\n}, {\n  x: 0,\n  y: +1\n}, {\n  x: -1,\n  y: 0\n}, {\n  x: 0,\n  y: -1\n}, {\n  x: -1,\n  y: 0\n}, {\n  x: 0,\n  y: -1\n}];\nclass Square extends Marker {\n  updatePath() {\n    const {\n      path,\n      x,\n      y\n    } = this;\n    const hs = this.size / 2;\n    path.clear();\n    path.moveTo(this.align(x - hs), this.align(y - hs));\n    path.lineTo(this.align(x + hs), this.align(y - hs));\n    path.lineTo(this.align(x + hs), this.align(y + hs));\n    path.lineTo(this.align(x - hs), this.align(y + hs));\n    path.closePath();\n  }\n}\nSquare.className = 'Square';\nclass Triangle extends Marker {\n  updatePath() {\n    const s = this.size * 1.1;\n    super.applyPath(s, Triangle.moves);\n  }\n}\nTriangle.className = 'Triangle';\nTriangle.moves = [{\n  x: 0,\n  y: -0.48,\n  t: 'move'\n}, {\n  x: 0.5,\n  y: 0.87\n}, {\n  x: -1,\n  y: 0\n}];\nconst MARKER_SHAPES = {\n  circle: Circle,\n  cross: Cross,\n  diamond: Diamond,\n  heart: Heart,\n  plus: Plus,\n  square: Square,\n  triangle: Triangle\n};\nconst MARKER_SUPPORTED_SHAPES = Object.keys(MARKER_SHAPES);\nfunction isMarkerShape(shape) {\n  return MARKER_SUPPORTED_SHAPES.includes(shape);\n}\n// This function is in its own file because putting it into SeriesMarker makes the Legend\n// suddenly aware of the series (it's an agnostic component), and putting it into Marker\n// introduces circular dependencies.\nfunction getMarker(shape = Square) {\n  if (isMarkerShape(shape)) {\n    return MARKER_SHAPES[shape];\n  }\n  if (typeof shape === 'function') {\n    return shape;\n  }\n  return Square;\n}\nclass MarkerLabel extends Group {\n  constructor() {\n    super({\n      name: 'markerLabelGroup'\n    });\n    this.label = new Text();\n    this._marker = new Square();\n    this._markerSize = 15;\n    this._spacing = 8;\n    const label = this.label;\n    label.textBaseline = 'middle';\n    label.fontSize = 12;\n    label.fontFamily = 'Verdana, sans-serif';\n    label.fill = 'black';\n    // For better looking vertical alignment of labels to markers.\n    label.y = HdpiCanvas.has.textMetrics ? 1 : 0;\n    this.append([this.marker, label]);\n    this.update();\n  }\n  set marker(value) {\n    if (this._marker !== value) {\n      this.removeChild(this._marker);\n      this._marker = value;\n      this.appendChild(value);\n      this.update();\n    }\n  }\n  get marker() {\n    return this._marker;\n  }\n  set markerSize(value) {\n    if (this._markerSize !== value) {\n      this._markerSize = value;\n      this.update();\n    }\n  }\n  get markerSize() {\n    return this._markerSize;\n  }\n  set spacing(value) {\n    if (this._spacing !== value) {\n      this._spacing = value;\n      this.update();\n    }\n  }\n  get spacing() {\n    return this._spacing;\n  }\n  update() {\n    const marker = this.marker;\n    const markerSize = this.markerSize;\n    marker.size = markerSize;\n    this.label.x = markerSize / 2 + this.spacing;\n  }\n  render(renderCtx) {\n    // Cannot override field Group.opacity with get/set pair, so\n    // propagate opacity changes here.\n    this.marker.opacity = this.opacity;\n    this.label.opacity = this.opacity;\n    super.render(renderCtx);\n  }\n}\nMarkerLabel.className = 'MarkerLabel';\n__decorate([ProxyPropertyOnWrite('label'), __metadata(\"design:type\", String)], MarkerLabel.prototype, \"text\", void 0);\n__decorate([ProxyPropertyOnWrite('label'), __metadata(\"design:type\", String)], MarkerLabel.prototype, \"fontStyle\", void 0);\n__decorate([ProxyPropertyOnWrite('label'), __metadata(\"design:type\", String)], MarkerLabel.prototype, \"fontWeight\", void 0);\n__decorate([ProxyPropertyOnWrite('label'), __metadata(\"design:type\", Number)], MarkerLabel.prototype, \"fontSize\", void 0);\n__decorate([ProxyPropertyOnWrite('label'), __metadata(\"design:type\", String)], MarkerLabel.prototype, \"fontFamily\", void 0);\n__decorate([ProxyPropertyOnWrite('label', 'fill'), __metadata(\"design:type\", String)], MarkerLabel.prototype, \"color\", void 0);\n__decorate([ProxyPropertyOnWrite('marker', 'fill'), __metadata(\"design:type\", String)], MarkerLabel.prototype, \"markerFill\", void 0);\n__decorate([ProxyPropertyOnWrite('marker', 'stroke'), __metadata(\"design:type\", String)], MarkerLabel.prototype, \"markerStroke\", void 0);\n__decorate([ProxyPropertyOnWrite('marker', 'strokeWidth'), __metadata(\"design:type\", Number)], MarkerLabel.prototype, \"markerStrokeWidth\", void 0);\n__decorate([ProxyPropertyOnWrite('marker', 'fillOpacity'), __metadata(\"design:type\", Number)], MarkerLabel.prototype, \"markerFillOpacity\", void 0);\n__decorate([ProxyPropertyOnWrite('marker', 'strokeOpacity'), __metadata(\"design:type\", Number)], MarkerLabel.prototype, \"markerStrokeOpacity\", void 0);\nclass PaginationLabel {\n  constructor() {\n    this.color = 'black';\n    this.fontStyle = undefined;\n    this.fontWeight = undefined;\n    this.fontSize = 12;\n    this.fontFamily = 'Verdana, sans-serif';\n  }\n}\n__decorate([Validate(COLOR_STRING), __metadata(\"design:type\", String)], PaginationLabel.prototype, \"color\", void 0);\n__decorate([Validate(OPT_FONT_STYLE), __metadata(\"design:type\", String)], PaginationLabel.prototype, \"fontStyle\", void 0);\n__decorate([Validate(OPT_FONT_WEIGHT), __metadata(\"design:type\", String)], PaginationLabel.prototype, \"fontWeight\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], PaginationLabel.prototype, \"fontSize\", void 0);\n__decorate([Validate(STRING), __metadata(\"design:type\", String)], PaginationLabel.prototype, \"fontFamily\", void 0);\nclass PaginationMarkerStyle {\n  constructor() {\n    this.size = 15;\n    this.fill = undefined;\n    this.fillOpacity = undefined;\n    this.stroke = undefined;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n  }\n}\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], PaginationMarkerStyle.prototype, \"size\", void 0);\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], PaginationMarkerStyle.prototype, \"fill\", void 0);\n__decorate([Validate(OPT_NUMBER(0, 1)), __metadata(\"design:type\", Number)], PaginationMarkerStyle.prototype, \"fillOpacity\", void 0);\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], PaginationMarkerStyle.prototype, \"stroke\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], PaginationMarkerStyle.prototype, \"strokeWidth\", void 0);\n__decorate([Validate(NUMBER$1(0, 1)), __metadata(\"design:type\", Number)], PaginationMarkerStyle.prototype, \"strokeOpacity\", void 0);\nclass PaginationMarker {\n  constructor(parent) {\n    this.parent = parent;\n    this.shape = Triangle;\n    this.size = 15;\n    /**\r\n     * Inner padding between a pagination button and the label.\r\n     */\n    this.padding = 8;\n  }\n}\n__decorate([ActionOnSet({\n  changeValue() {\n    if (this.parent.marker === this) {\n      this.parent.onMarkerShapeChange();\n    }\n  }\n}), __metadata(\"design:type\", Object)], PaginationMarker.prototype, \"shape\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], PaginationMarker.prototype, \"size\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], PaginationMarker.prototype, \"padding\", void 0);\nclass Pagination {\n  constructor(chartUpdateCallback, pageUpdateCallback, interactionManager, cursorManager) {\n    this.chartUpdateCallback = chartUpdateCallback;\n    this.pageUpdateCallback = pageUpdateCallback;\n    this.interactionManager = interactionManager;\n    this.cursorManager = cursorManager;\n    this.id = createId(this);\n    this.group = new Group({\n      name: 'pagination'\n    });\n    this.labelNode = new Text();\n    this.marker = new PaginationMarker(this);\n    this.activeStyle = new PaginationMarkerStyle();\n    this.inactiveStyle = new PaginationMarkerStyle();\n    this.highlightStyle = new PaginationMarkerStyle();\n    this.label = new PaginationLabel();\n    this.totalPages = 0;\n    this.currentPage = 0;\n    this.translationX = 0;\n    this.translationY = 0;\n    this.nextButtonDisabled = false;\n    this.previousButtonDisabled = false;\n    this._visible = true;\n    this._enabled = true;\n    this._orientation = 'vertical';\n    this._nextButton = new Triangle();\n    this._previousButton = new Triangle();\n    const {\n      labelNode\n    } = this;\n    labelNode.textBaseline = 'middle';\n    labelNode.fontSize = 12;\n    labelNode.fontFamily = 'Verdana, sans-serif';\n    labelNode.fill = 'black';\n    labelNode.y = HdpiCanvas.has.textMetrics ? 1 : 0;\n    this.group.append([this.nextButton, this.previousButton, labelNode]);\n    this.interactionManager.addListener('click', event => this.onPaginationClick(event));\n    this.interactionManager.addListener('hover', event => this.onPaginationMouseMove(event));\n    this.update();\n    this.updateMarkers();\n  }\n  set visible(value) {\n    this._visible = value;\n    this.updateGroupVisibility();\n  }\n  get visible() {\n    return this._visible;\n  }\n  set enabled(value) {\n    this._enabled = value;\n    this.updateGroupVisibility();\n  }\n  get enabled() {\n    return this._enabled;\n  }\n  updateGroupVisibility() {\n    this.group.visible = this.enabled && this.visible;\n  }\n  set orientation(value) {\n    this._orientation = value;\n    switch (value) {\n      case 'horizontal':\n        {\n          this.previousButton.rotation = -Math.PI / 2;\n          this.nextButton.rotation = Math.PI / 2;\n          break;\n        }\n      case 'vertical':\n      default:\n        {\n          this.previousButton.rotation = 0;\n          this.nextButton.rotation = Math.PI;\n        }\n    }\n  }\n  get orientation() {\n    return this._orientation;\n  }\n  set nextButton(value) {\n    if (this._nextButton !== value) {\n      this.group.removeChild(this._nextButton);\n      this._nextButton = value;\n      this.group.appendChild(value);\n    }\n  }\n  get nextButton() {\n    return this._nextButton;\n  }\n  set previousButton(value) {\n    if (this._previousButton !== value) {\n      this.group.removeChild(this._previousButton);\n      this._previousButton = value;\n      this.group.appendChild(value);\n    }\n  }\n  get previousButton() {\n    return this._previousButton;\n  }\n  update() {\n    this.updateLabel();\n    this.updatePositions();\n    this.enableOrDisableButtons();\n  }\n  updatePositions() {\n    this.group.translationX = this.translationX;\n    this.group.translationY = this.translationY;\n    this.updateLabelPosition();\n    this.updateNextButtonPosition();\n  }\n  updateLabelPosition() {\n    const {\n      size: markerSize,\n      padding: markerPadding\n    } = this.marker;\n    this.nextButton.size = markerSize;\n    this.previousButton.size = markerSize;\n    this.labelNode.x = markerSize / 2 + markerPadding;\n  }\n  updateNextButtonPosition() {\n    const labelBBox = this.labelNode.computeBBox();\n    this.nextButton.translationX = labelBBox.x + labelBBox.width + this.marker.size / 2 + this.marker.padding;\n  }\n  updateLabel() {\n    const {\n      currentPage,\n      totalPages: pages,\n      labelNode,\n      label: {\n        color,\n        fontStyle,\n        fontWeight,\n        fontSize,\n        fontFamily\n      }\n    } = this;\n    labelNode.text = `${currentPage + 1} / ${pages}`;\n    labelNode.fill = color;\n    labelNode.fontStyle = fontStyle;\n    labelNode.fontWeight = fontWeight;\n    labelNode.fontSize = fontSize;\n    labelNode.fontFamily = fontFamily;\n  }\n  updateMarkers() {\n    const {\n      nextButton,\n      previousButton,\n      nextButtonDisabled,\n      previousButtonDisabled,\n      activeStyle,\n      inactiveStyle,\n      highlightStyle,\n      highlightActive\n    } = this;\n    const buttonStyle = (button, disabled) => {\n      if (disabled) {\n        return inactiveStyle;\n      } else if (button === highlightActive) {\n        return highlightStyle;\n      }\n      return activeStyle;\n    };\n    this.updateMarker(nextButton, buttonStyle('next', nextButtonDisabled));\n    this.updateMarker(previousButton, buttonStyle('previous', previousButtonDisabled));\n  }\n  updateMarker(marker, style) {\n    var _a;\n    const {\n      size\n    } = this.marker;\n    marker.size = size;\n    marker.fill = style.fill;\n    marker.fillOpacity = (_a = style.fillOpacity) !== null && _a !== void 0 ? _a : 1;\n    marker.stroke = style.stroke;\n    marker.strokeWidth = style.strokeWidth;\n    marker.strokeOpacity = style.strokeOpacity;\n  }\n  enableOrDisableButtons() {\n    const {\n      currentPage,\n      totalPages\n    } = this;\n    const zeroPagesToDisplay = totalPages === 0;\n    const onLastPage = currentPage === totalPages - 1;\n    const onFirstPage = currentPage === 0;\n    this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;\n    this.previousButtonDisabled = onFirstPage || zeroPagesToDisplay;\n  }\n  nextButtonContainsPoint(offsetX, offsetY) {\n    return !this.nextButtonDisabled && this.nextButton.containsPoint(offsetX, offsetY);\n  }\n  previousButtonContainsPoint(offsetX, offsetY) {\n    return !this.previousButtonDisabled && this.previousButton.containsPoint(offsetX, offsetY);\n  }\n  onPaginationClick(event) {\n    const {\n      offsetX,\n      offsetY\n    } = event;\n    if (this.nextButtonContainsPoint(offsetX, offsetY)) {\n      this.incrementPage();\n      this.onPaginationChanged();\n      event.consume();\n    } else if (this.previousButtonContainsPoint(offsetX, offsetY)) {\n      this.decrementPage();\n      this.onPaginationChanged();\n      event.consume();\n    }\n  }\n  onPaginationMouseMove(event) {\n    const {\n      offsetX,\n      offsetY\n    } = event;\n    if (this.nextButtonContainsPoint(offsetX, offsetY)) {\n      this.cursorManager.updateCursor(this.id, 'pointer');\n      this.highlightActive = 'next';\n    } else if (this.previousButtonContainsPoint(offsetX, offsetY)) {\n      this.cursorManager.updateCursor(this.id, 'pointer');\n      this.highlightActive = 'previous';\n    } else {\n      this.cursorManager.updateCursor(this.id);\n      this.highlightActive = undefined;\n    }\n    this.updateMarkers();\n    this.chartUpdateCallback(ChartUpdateType.SCENE_RENDER);\n  }\n  onPaginationChanged() {\n    this.pageUpdateCallback(this.currentPage);\n  }\n  incrementPage() {\n    this.currentPage = Math.min(this.currentPage + 1, this.totalPages - 1);\n  }\n  decrementPage() {\n    this.currentPage = Math.max(this.currentPage - 1, 0);\n  }\n  onMarkerShapeChange() {\n    const Marker = getMarker(this.marker.shape || Triangle);\n    this.previousButton = new Marker();\n    this.nextButton = new Marker();\n    this.updatePositions();\n    this.updateMarkers();\n    this.chartUpdateCallback(ChartUpdateType.SCENE_RENDER);\n  }\n  attachPagination(node) {\n    node.append(this.group);\n  }\n  computeBBox() {\n    return this.group.computeBBox();\n  }\n}\nPagination.className = 'Pagination';\nconst ORIENTATIONS = ['horizontal', 'vertical'];\nconst OPT_ORIENTATION = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, v => ORIENTATIONS.includes(v)), `expecting an orientation keyword such as 'horizontal' or 'vertical'`);\nclass LegendLabel {\n  constructor() {\n    this.maxLength = undefined;\n    this.color = 'black';\n    this.fontStyle = undefined;\n    this.fontWeight = undefined;\n    this.fontSize = 12;\n    this.fontFamily = 'Verdana, sans-serif';\n    this.formatter = undefined;\n  }\n}\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], LegendLabel.prototype, \"maxLength\", void 0);\n__decorate([Validate(COLOR_STRING), __metadata(\"design:type\", String)], LegendLabel.prototype, \"color\", void 0);\n__decorate([Validate(OPT_FONT_STYLE), __metadata(\"design:type\", String)], LegendLabel.prototype, \"fontStyle\", void 0);\n__decorate([Validate(OPT_FONT_WEIGHT), __metadata(\"design:type\", String)], LegendLabel.prototype, \"fontWeight\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], LegendLabel.prototype, \"fontSize\", void 0);\n__decorate([Validate(STRING), __metadata(\"design:type\", String)], LegendLabel.prototype, \"fontFamily\", void 0);\n__decorate([Validate(OPT_FUNCTION), __metadata(\"design:type\", Function)], LegendLabel.prototype, \"formatter\", void 0);\nclass LegendMarker {\n  constructor() {\n    this.size = 15;\n    /**\r\n     * If the marker type is set, the legend will always use that marker type for all its items,\r\n     * regardless of the type that comes from the `data`.\r\n     */\n    this._shape = undefined;\n    /**\r\n     * Padding between the marker and the label within each legend item.\r\n     */\n    this.padding = 8;\n    this.strokeWidth = undefined;\n  }\n  set shape(value) {\n    var _a;\n    this._shape = value;\n    (_a = this.parent) === null || _a === void 0 ? void 0 : _a.onMarkerShapeChange();\n  }\n  get shape() {\n    return this._shape;\n  }\n}\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], LegendMarker.prototype, \"size\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], LegendMarker.prototype, \"padding\", void 0);\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Object)], LegendMarker.prototype, \"strokeWidth\", void 0);\nclass LegendItem {\n  constructor() {\n    this.marker = new LegendMarker();\n    this.label = new LegendLabel();\n    /** Used to constrain the width of legend items. */\n    this.maxWidth = undefined;\n    /**\r\n     * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,\r\n     * and as few rows as possible when positioned to top or bottom. This config specifies the amount of horizontal\r\n     * padding between legend items.\r\n     */\n    this.paddingX = 16;\n    /**\r\n     * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,\r\n     * and as few rows as possible when positioned to top or bottom. This config specifies the amount of vertical\r\n     * padding between legend items.\r\n     */\n    this.paddingY = 8;\n    this.toggleSeriesVisible = true;\n  }\n}\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], LegendItem.prototype, \"maxWidth\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], LegendItem.prototype, \"paddingX\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], LegendItem.prototype, \"paddingY\", void 0);\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Boolean)], LegendItem.prototype, \"toggleSeriesVisible\", void 0);\nclass LegendListeners {\n  constructor() {\n    this.legendItemClick = undefined;\n    this.legendItemDoubleClick = undefined;\n  }\n}\n__decorate([Validate(OPT_FUNCTION), __metadata(\"design:type\", Function)], LegendListeners.prototype, \"legendItemClick\", void 0);\nclass Legend {\n  set data(value) {\n    this._data = value;\n    this.updateGroupVisibility();\n  }\n  get data() {\n    return this._data;\n  }\n  set enabled(value) {\n    this._enabled = value;\n    this.updateGroupVisibility();\n  }\n  get enabled() {\n    return this._enabled;\n  }\n  getOrientation() {\n    if (this.orientation !== undefined) {\n      return this.orientation;\n    }\n    switch (this.position) {\n      case 'right':\n      case 'left':\n        return 'vertical';\n      case 'bottom':\n      case 'top':\n        return 'horizontal';\n    }\n  }\n  constructor(ctx) {\n    this.ctx = ctx;\n    this.id = createId(this);\n    this.group = new Group({\n      name: 'legend',\n      layer: true,\n      zIndex: Layers.LEGEND_ZINDEX\n    });\n    this.itemSelection = Selection.select(this.group, MarkerLabel);\n    this.oldSize = [0, 0];\n    this.pages = [];\n    this.maxPageSize = [0, 0];\n    /** Item index to track on re-pagination, so current page updates appropriately. */\n    this.paginationTrackingIndex = 0;\n    this.item = new LegendItem();\n    this.listeners = new LegendListeners();\n    this.truncatedItems = new Set();\n    this._data = [];\n    this._enabled = true;\n    this.position = 'bottom';\n    /** Used to constrain the width of the legend. */\n    this.maxWidth = undefined;\n    /** Used to constrain the height of the legend. */\n    this.maxHeight = undefined;\n    /** Reverse the display order of legend items if `true`. */\n    this.reverseOrder = undefined;\n    this.destroyFns = [];\n    /**\r\n     * Spacing between the legend and the edge of the chart's element.\r\n     */\n    this.spacing = 20;\n    this.characterWidths = new Map();\n    this.size = [0, 0];\n    this._visible = true;\n    this.item.marker.parent = this;\n    this.pagination = new Pagination(type => ctx.updateService.update(type), page => this.updatePageNumber(page), ctx.interactionManager, ctx.cursorManager);\n    this.pagination.attachPagination(this.group);\n    this.item.marker.parent = this;\n    const bypass = {\n      bypassPause: ['animation']\n    };\n    this.destroyFns.push(ctx.interactionManager.addListener('click', e => this.checkLegendClick(e), bypass), ctx.interactionManager.addListener('dblclick', e => this.checkLegendDoubleClick(e), bypass), ctx.interactionManager.addListener('hover', e => this.handleLegendMouseMove(e)), ctx.layoutService.addListener('start-layout', e => this.positionLegend(e.shrinkRect)), () => this.detachLegend());\n  }\n  destroy() {\n    this.destroyFns.forEach(f => f());\n  }\n  onMarkerShapeChange() {\n    this.itemSelection.clear();\n    this.group.markDirty(this.group, RedrawType.MINOR);\n  }\n  getCharacterWidths(font) {\n    const {\n      characterWidths\n    } = this;\n    if (characterWidths.has(font)) {\n      return characterWidths.get(font);\n    }\n    const cw = {\n      '...': HdpiCanvas.getTextSize('...', font).width\n    };\n    characterWidths.set(font, cw);\n    return cw;\n  }\n  set visible(value) {\n    this._visible = value;\n    this.updateGroupVisibility();\n  }\n  get visible() {\n    return this._visible;\n  }\n  updateGroupVisibility() {\n    this.group.visible = this.enabled && this.visible && this.data.length > 0;\n  }\n  attachLegend(node) {\n    node.append(this.group);\n  }\n  detachLegend() {\n    var _a;\n    (_a = this.group.parent) === null || _a === void 0 ? void 0 : _a.removeChild(this.group);\n  }\n  getItemLabel(datum) {\n    const {\n      ctx: {\n        callbackCache\n      }\n    } = this;\n    const {\n      formatter\n    } = this.item.label;\n    if (formatter) {\n      return callbackCache.call(formatter, {\n        itemId: datum.itemId,\n        value: datum.label.text,\n        seriesId: datum.seriesId\n      });\n    }\n    return datum.label.text;\n  }\n  /**\r\n   * The method is given the desired size of the legend, which only serves as a hint.\r\n   * The vertically oriented legend will take as much horizontal space as needed, but will\r\n   * respect the height constraints, and the horizontal legend will take as much vertical\r\n   * space as needed in an attempt not to exceed the given width.\r\n   * After the layout is done, the {@link size} will contain the actual size of the legend.\r\n   * If the actual size is not the same as the previous actual size, the legend will fire\r\n   * the 'layoutChange' event to communicate that another layout is needed, and the above\r\n   * process should be repeated.\r\n   * @param width\r\n   * @param height\r\n   */\n  performLayout(width, height) {\n    const {\n      paddingX,\n      paddingY,\n      label,\n      maxWidth,\n      marker: {\n        size: markerSize,\n        padding: markerPadding,\n        shape: markerShape\n      },\n      label: {\n        maxLength = Infinity,\n        fontStyle,\n        fontWeight,\n        fontSize,\n        fontFamily\n      }\n    } = this.item;\n    const data = [...this.data];\n    if (this.reverseOrder) {\n      data.reverse();\n    }\n    this.itemSelection.update(data);\n    // Update properties that affect the size of the legend items and measure them.\n    const bboxes = [];\n    const font = getFont(label);\n    const itemMaxWidthPercentage = 0.8;\n    const maxItemWidth = maxWidth !== null && maxWidth !== void 0 ? maxWidth : width * itemMaxWidthPercentage;\n    const paddedMarkerWidth = markerSize + markerPadding + paddingX;\n    this.itemSelection.each((markerLabel, datum) => {\n      var _a;\n      const Marker = getMarker(markerShape !== null && markerShape !== void 0 ? markerShape : datum.marker.shape);\n      if (!(markerLabel.marker && markerLabel.marker instanceof Marker)) {\n        markerLabel.marker = new Marker();\n      }\n      markerLabel.markerSize = markerSize;\n      markerLabel.spacing = markerPadding;\n      markerLabel.fontStyle = fontStyle;\n      markerLabel.fontWeight = fontWeight;\n      markerLabel.fontSize = fontSize;\n      markerLabel.fontFamily = fontFamily;\n      const id = (_a = datum.itemId) !== null && _a !== void 0 ? _a : datum.id;\n      const labelText = this.getItemLabel(datum);\n      const text = (labelText !== null && labelText !== void 0 ? labelText : '<unknown>').replace(/\\r?\\n/g, ' ');\n      markerLabel.text = this.truncate(text, maxLength, maxItemWidth, paddedMarkerWidth, font, id);\n      bboxes.push(markerLabel.computeBBox());\n    });\n    width = Math.max(1, width);\n    height = Math.max(1, height);\n    if (!isFinite(width)) {\n      return false;\n    }\n    const size = this.size;\n    const oldSize = this.oldSize;\n    size[0] = width;\n    size[1] = height;\n    if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {\n      oldSize[0] = size[0];\n      oldSize[1] = size[1];\n    }\n    const {\n      pages,\n      maxPageHeight,\n      maxPageWidth\n    } = this.updatePagination(bboxes, width, height);\n    this.pages = pages;\n    this.maxPageSize = [maxPageWidth - paddingX, maxPageHeight - paddingY];\n    const pageNumber = this.pagination.currentPage;\n    const page = this.pages[pageNumber];\n    if (this.pages.length < 1 || !page) {\n      this.visible = false;\n      return;\n    }\n    this.visible = true;\n    // Position legend items\n    this.updatePositions(pageNumber);\n    // Update legend item properties that don't affect the layout.\n    this.update();\n  }\n  truncate(text, maxCharLength, maxItemWidth, paddedMarkerWidth, font, id) {\n    const ellipsis = `...`;\n    const textChars = text.split('');\n    let addEllipsis = false;\n    if (text.length > maxCharLength) {\n      text = `${text.substring(0, maxCharLength)}`;\n      addEllipsis = true;\n    }\n    const labelWidth = Math.floor(paddedMarkerWidth + HdpiCanvas.getTextSize(text, font).width);\n    if (labelWidth > maxItemWidth) {\n      let truncatedText = '';\n      const characterWidths = this.getCharacterWidths(font);\n      let cumulativeWidth = paddedMarkerWidth + characterWidths[ellipsis];\n      for (const char of textChars) {\n        if (!characterWidths[char]) {\n          characterWidths[char] = HdpiCanvas.getTextSize(char, font).width;\n        }\n        cumulativeWidth += characterWidths[char];\n        if (cumulativeWidth > maxItemWidth) {\n          break;\n        }\n        truncatedText += char;\n      }\n      text = truncatedText;\n      addEllipsis = true;\n    }\n    if (addEllipsis) {\n      text += ellipsis;\n      this.truncatedItems.add(id);\n    } else {\n      this.truncatedItems.delete(id);\n    }\n    return text;\n  }\n  updatePagination(bboxes, width, height) {\n    const orientation = this.getOrientation();\n    const trackingIndex = Math.min(this.paginationTrackingIndex, bboxes.length);\n    this.pagination.orientation = orientation;\n    this.pagination.translationX = 0;\n    this.pagination.translationY = 0;\n    const {\n      pages,\n      maxPageHeight,\n      maxPageWidth,\n      paginationBBox,\n      paginationVertical\n    } = this.calculatePagination(bboxes, width, height);\n    const newCurrentPage = pages.findIndex(p => p.endIndex >= trackingIndex);\n    this.pagination.currentPage = Math.min(Math.max(newCurrentPage, 0), pages.length - 1);\n    const {\n      paddingX: itemPaddingX,\n      paddingY: itemPaddingY\n    } = this.item;\n    const paginationComponentPadding = 8;\n    const legendItemsWidth = maxPageWidth - itemPaddingX;\n    const legendItemsHeight = maxPageHeight - itemPaddingY;\n    let paginationX = 0;\n    let paginationY = -paginationBBox.y - this.item.marker.size / 2;\n    if (paginationVertical) {\n      paginationY += legendItemsHeight + paginationComponentPadding;\n    } else {\n      paginationX += -paginationBBox.x + legendItemsWidth + paginationComponentPadding;\n      paginationY += (legendItemsHeight - paginationBBox.height) / 2;\n    }\n    this.pagination.translationX = paginationX;\n    this.pagination.translationY = paginationY;\n    this.pagination.update();\n    this.pagination.updateMarkers();\n    return {\n      maxPageHeight,\n      maxPageWidth,\n      pages\n    };\n  }\n  calculatePagination(bboxes, width, height) {\n    var _a, _b, _c;\n    const {\n      paddingX: itemPaddingX,\n      paddingY: itemPaddingY\n    } = this.item;\n    const orientation = this.getOrientation();\n    const paginationVertical = ['left', 'right'].includes(this.position);\n    let paginationBBox = this.pagination.computeBBox();\n    let lastPassPaginationBBox = new BBox(0, 0, 0, 0);\n    let pages = [];\n    let maxPageWidth = 0;\n    let maxPageHeight = 0;\n    let count = 0;\n    const stableOutput = lastPassPaginationBBox => {\n      const {\n        width,\n        height\n      } = lastPassPaginationBBox;\n      return width === paginationBBox.width && height === paginationBBox.height;\n    };\n    const forceResult = this.maxWidth !== undefined || this.maxHeight !== undefined;\n    do {\n      if (count++ > 10) {\n        Logger.warn('unable to find stable legend layout.');\n        break;\n      }\n      paginationBBox = lastPassPaginationBBox;\n      const maxWidth = width - (paginationVertical ? 0 : paginationBBox.width);\n      const maxHeight = height - (paginationVertical ? paginationBBox.height : 0);\n      const layout = gridLayout({\n        orientation,\n        bboxes,\n        maxHeight,\n        maxWidth,\n        itemPaddingY,\n        itemPaddingX,\n        forceResult\n      });\n      pages = (_a = layout === null || layout === void 0 ? void 0 : layout.pages) !== null && _a !== void 0 ? _a : [];\n      maxPageWidth = (_b = layout === null || layout === void 0 ? void 0 : layout.maxPageWidth) !== null && _b !== void 0 ? _b : 0;\n      maxPageHeight = (_c = layout === null || layout === void 0 ? void 0 : layout.maxPageHeight) !== null && _c !== void 0 ? _c : 0;\n      const totalPages = pages.length;\n      this.pagination.visible = totalPages > 1;\n      this.pagination.totalPages = totalPages;\n      this.pagination.update();\n      lastPassPaginationBBox = this.pagination.computeBBox();\n      if (!this.pagination.visible) {\n        break;\n      }\n    } while (!stableOutput(lastPassPaginationBBox));\n    return {\n      maxPageWidth,\n      maxPageHeight,\n      pages,\n      paginationBBox,\n      paginationVertical\n    };\n  }\n  updatePositions(pageNumber = 0) {\n    const {\n      item: {\n        paddingY\n      },\n      itemSelection,\n      pages\n    } = this;\n    if (pages.length < 1 || !pages[pageNumber]) {\n      return;\n    }\n    const {\n      columns,\n      startIndex: visibleStart,\n      endIndex: visibleEnd\n    } = pages[pageNumber];\n    // Position legend items using the layout computed above.\n    let x = 0;\n    let y = 0;\n    const columnCount = columns.length;\n    const rowCount = columns[0].indices.length;\n    const horizontal = this.getOrientation() === 'horizontal';\n    const itemHeight = columns[0].bboxes[0].height + paddingY;\n    const rowSumColumnWidths = [];\n    itemSelection.each((markerLabel, _, i) => {\n      var _a, _b;\n      if (i < visibleStart || i > visibleEnd) {\n        markerLabel.visible = false;\n        return;\n      }\n      const pageIndex = i - visibleStart;\n      let columnIndex = 0;\n      let rowIndex = 0;\n      if (horizontal) {\n        columnIndex = pageIndex % columnCount;\n        rowIndex = Math.floor(pageIndex / columnCount);\n      } else {\n        columnIndex = Math.floor(pageIndex / rowCount);\n        rowIndex = pageIndex % rowCount;\n      }\n      markerLabel.visible = true;\n      const column = columns[columnIndex];\n      if (!column) {\n        return;\n      }\n      y = itemHeight * rowIndex;\n      x = (_a = rowSumColumnWidths[rowIndex]) !== null && _a !== void 0 ? _a : 0;\n      rowSumColumnWidths[rowIndex] = ((_b = rowSumColumnWidths[rowIndex]) !== null && _b !== void 0 ? _b : 0) + column.columnWidth;\n      // Round off for pixel grid alignment to work properly.\n      markerLabel.translationX = Math.floor(x);\n      markerLabel.translationY = Math.floor(y);\n    });\n  }\n  updatePageNumber(pageNumber) {\n    const {\n      pages\n    } = this;\n    // Track an item on the page in re-pagination cases (e.g. resize).\n    const {\n      startIndex,\n      endIndex\n    } = pages[pageNumber];\n    if (startIndex === 0) {\n      // Stay on first page on pagination update.\n      this.paginationTrackingIndex = 0;\n    } else if (pageNumber === pages.length - 1) {\n      // Stay on last page on pagination update.\n      this.paginationTrackingIndex = endIndex;\n    } else {\n      // Track the middle item on the page).\n      this.paginationTrackingIndex = Math.floor((startIndex + endIndex) / 2);\n    }\n    this.pagination.update();\n    this.pagination.updateMarkers();\n    this.updatePositions(pageNumber);\n    this.ctx.updateService.update(ChartUpdateType.SCENE_RENDER);\n  }\n  update() {\n    const {\n      label: {\n        color\n      },\n      marker: itemMarker\n    } = this.item;\n    this.itemSelection.each((markerLabel, datum) => {\n      var _a;\n      const marker = datum.marker;\n      markerLabel.markerFill = marker.fill;\n      markerLabel.markerStroke = marker.stroke;\n      markerLabel.markerStrokeWidth = (_a = itemMarker.strokeWidth) !== null && _a !== void 0 ? _a : Math.min(2, marker.strokeWidth);\n      markerLabel.markerFillOpacity = marker.fillOpacity;\n      markerLabel.markerStrokeOpacity = marker.strokeOpacity;\n      markerLabel.opacity = datum.enabled ? 1 : 0.5;\n      markerLabel.color = color;\n    });\n  }\n  getDatumForPoint(x, y) {\n    const visibleChildBBoxes = [];\n    const closestLeftTop = {\n      dist: Infinity,\n      datum: undefined\n    };\n    for (const child of this.group.children) {\n      if (!child.visible) continue;\n      if (!(child instanceof MarkerLabel)) continue;\n      const childBBox = child.computeBBox();\n      childBBox.grow(this.item.paddingX / 2, 'horizontal');\n      childBBox.grow(this.item.paddingY / 2, 'vertical');\n      if (childBBox.containsPoint(x, y)) {\n        return child.datum;\n      }\n      const distX = x - childBBox.x - this.item.paddingX / 2;\n      const distY = y - childBBox.y - this.item.paddingY / 2;\n      const dist = Math.pow(distX, 2) + Math.pow(distY, 2);\n      const toTheLeftTop = distX >= 0 && distY >= 0;\n      if (toTheLeftTop && dist < closestLeftTop.dist) {\n        closestLeftTop.dist = dist;\n        closestLeftTop.datum = child.datum;\n      }\n      visibleChildBBoxes.push(childBBox);\n    }\n    const pageBBox = BBox.merge(visibleChildBBoxes);\n    if (!pageBBox.containsPoint(x, y)) {\n      // We're not in-between legend items.\n      return undefined;\n    }\n    // Fallback to returning closest match to the left/up.\n    return closestLeftTop.datum;\n  }\n  computeBBox() {\n    return this.group.computeBBox();\n  }\n  computePagedBBox() {\n    const actualBBox = this.group.computeBBox();\n    if (this.pages.length <= 1) {\n      return actualBBox;\n    }\n    const [maxPageWidth, maxPageHeight] = this.maxPageSize;\n    actualBBox.height = Math.max(maxPageHeight, actualBBox.height);\n    actualBBox.width = Math.max(maxPageWidth, actualBBox.width);\n    return actualBBox;\n  }\n  checkLegendClick(event) {\n    const {\n      listeners: {\n        legendItemClick\n      },\n      ctx: {\n        dataService,\n        highlightManager\n      },\n      item: {\n        toggleSeriesVisible\n      }\n    } = this;\n    const {\n      offsetX,\n      offsetY\n    } = event;\n    const legendBBox = this.computeBBox();\n    const pointerInsideLegend = this.group.visible && legendBBox.containsPoint(offsetX, offsetY);\n    const datum = this.getDatumForPoint(offsetX, offsetY);\n    if (!pointerInsideLegend || !datum) {\n      return;\n    }\n    const {\n      id,\n      itemId,\n      enabled\n    } = datum;\n    const chartSeries = dataService.getSeries();\n    const series = chartSeries.find(s => s.id === id);\n    if (!series) {\n      return;\n    }\n    event.consume();\n    let newEnabled = enabled;\n    if (toggleSeriesVisible) {\n      newEnabled = !enabled;\n      this.ctx.chartEventManager.legendItemClick(series, itemId, newEnabled, datum.legendItemName);\n    }\n    if (!newEnabled) {\n      highlightManager.updateHighlight(this.id);\n    } else {\n      highlightManager.updateHighlight(this.id, {\n        series,\n        itemId,\n        datum: undefined\n      });\n    }\n    this.ctx.updateService.update(ChartUpdateType.PROCESS_DATA, {\n      forceNodeDataRefresh: true\n    });\n    legendItemClick === null || legendItemClick === void 0 ? void 0 : legendItemClick({\n      type: 'click',\n      enabled: newEnabled,\n      itemId,\n      seriesId: series.id\n    });\n  }\n  checkLegendDoubleClick(event) {\n    var _a;\n    const {\n      listeners: {\n        legendItemDoubleClick\n      },\n      ctx: {\n        dataService\n      },\n      item: {\n        toggleSeriesVisible\n      }\n    } = this;\n    const {\n      offsetX,\n      offsetY\n    } = event;\n    // Integrated charts do not handle double click behaviour correctly due to multiple instances of the\n    // chart being created. See https://ag-grid.atlassian.net/browse/RTI-1381\n    if (this.ctx.mode === 'integrated') {\n      return;\n    }\n    const legendBBox = this.computeBBox();\n    const pointerInsideLegend = this.group.visible && legendBBox.containsPoint(offsetX, offsetY);\n    const datum = this.getDatumForPoint(offsetX, offsetY);\n    if (!pointerInsideLegend || !datum) {\n      return;\n    }\n    const {\n      id,\n      itemId,\n      seriesId\n    } = datum;\n    const chartSeries = dataService.getSeries();\n    const series = chartSeries.find(s => s.id === id);\n    if (!series) {\n      return;\n    }\n    event.consume();\n    if (toggleSeriesVisible) {\n      const numVisibleItems = {};\n      const legendData = chartSeries.flatMap(series => series.getLegendData('category'));\n      legendData.forEach(d => {\n        var _a;\n        var _b;\n        (_a = numVisibleItems[_b = d.seriesId]) !== null && _a !== void 0 ? _a : numVisibleItems[_b] = 0;\n        if (d.enabled) {\n          numVisibleItems[d.seriesId]++;\n        }\n      });\n      const clickedItem = legendData.find(d => d.itemId === itemId && d.seriesId === seriesId);\n      this.ctx.chartEventManager.legendItemDoubleClick(series, itemId, (_a = clickedItem === null || clickedItem === void 0 ? void 0 : clickedItem.enabled) !== null && _a !== void 0 ? _a : false, numVisibleItems, clickedItem === null || clickedItem === void 0 ? void 0 : clickedItem.legendItemName);\n    }\n    this.ctx.updateService.update(ChartUpdateType.PROCESS_DATA, {\n      forceNodeDataRefresh: true\n    });\n    legendItemDoubleClick === null || legendItemDoubleClick === void 0 ? void 0 : legendItemDoubleClick({\n      type: 'dblclick',\n      enabled: true,\n      itemId,\n      seriesId: series.id\n    });\n  }\n  handleLegendMouseMove(event) {\n    var _a;\n    const {\n      enabled,\n      item: {\n        toggleSeriesVisible\n      },\n      listeners\n    } = this;\n    if (!enabled) {\n      return;\n    }\n    const legendBBox = this.computeBBox();\n    const {\n      pageX,\n      pageY,\n      offsetX,\n      offsetY\n    } = event;\n    const pointerInsideLegend = this.group.visible && legendBBox.containsPoint(offsetX, offsetY);\n    if (!pointerInsideLegend) {\n      this.ctx.cursorManager.updateCursor(this.id);\n      this.ctx.highlightManager.updateHighlight(this.id);\n      this.ctx.tooltipManager.removeTooltip(this.id);\n      return;\n    }\n    // Prevent other handlers from consuming this event if it's generated inside the legend\n    // boundaries.\n    event.consume();\n    const datum = this.getDatumForPoint(offsetX, offsetY);\n    const pointerOverLegendDatum = pointerInsideLegend && datum !== undefined;\n    if (!pointerOverLegendDatum) {\n      this.ctx.cursorManager.updateCursor(this.id);\n      this.ctx.highlightManager.updateHighlight(this.id);\n      return;\n    }\n    const series = datum ? this.ctx.dataService.getSeries().find(series => series.id === (datum === null || datum === void 0 ? void 0 : datum.id)) : undefined;\n    if (datum && this.truncatedItems.has((_a = datum.itemId) !== null && _a !== void 0 ? _a : datum.id)) {\n      this.ctx.tooltipManager.updateTooltip(this.id, {\n        pageX,\n        pageY,\n        offsetX,\n        offsetY,\n        event,\n        showArrow: false\n      }, toTooltipHtml({\n        content: this.getItemLabel(datum)\n      }));\n    } else {\n      this.ctx.tooltipManager.removeTooltip(this.id);\n    }\n    if (toggleSeriesVisible || listeners.legendItemClick != null || listeners.legendItemDoubleClick != null) {\n      this.ctx.cursorManager.updateCursor(this.id, 'pointer');\n    }\n    if ((datum === null || datum === void 0 ? void 0 : datum.enabled) && series) {\n      this.ctx.highlightManager.updateHighlight(this.id, {\n        series,\n        itemId: datum === null || datum === void 0 ? void 0 : datum.itemId,\n        datum: undefined\n      });\n    } else {\n      this.ctx.highlightManager.updateHighlight(this.id);\n    }\n  }\n  positionLegend(shrinkRect) {\n    const newShrinkRect = shrinkRect.clone();\n    if (!this.enabled || !this.data.length) {\n      return {\n        shrinkRect: newShrinkRect\n      };\n    }\n    const [legendWidth, legendHeight] = this.calculateLegendDimensions(shrinkRect);\n    this.group.translationX = 0;\n    this.group.translationY = 0;\n    this.performLayout(legendWidth, legendHeight);\n    const legendBBox = this.computePagedBBox();\n    const calculateTranslationPerpendicularDimension = () => {\n      switch (this.position) {\n        case 'top':\n        case 'left':\n          return 0;\n        case 'bottom':\n          return shrinkRect.height - legendBBox.height;\n        case 'right':\n        default:\n          return shrinkRect.width - legendBBox.width;\n      }\n    };\n    if (this.visible) {\n      let translationX;\n      let translationY;\n      switch (this.position) {\n        case 'top':\n        case 'bottom':\n          translationX = (shrinkRect.width - legendBBox.width) / 2;\n          translationY = calculateTranslationPerpendicularDimension();\n          newShrinkRect.shrink(legendBBox.height, this.position);\n          break;\n        case 'left':\n        case 'right':\n        default:\n          translationX = calculateTranslationPerpendicularDimension();\n          translationY = (shrinkRect.height - legendBBox.height) / 2;\n          newShrinkRect.shrink(legendBBox.width, this.position);\n      }\n      // Round off for pixel grid alignment to work properly.\n      this.group.translationX = Math.floor(-legendBBox.x + shrinkRect.x + translationX);\n      this.group.translationY = Math.floor(-legendBBox.y + shrinkRect.y + translationY);\n    }\n    if (this.visible && this.enabled && this.data.length) {\n      const legendPadding = this.spacing;\n      newShrinkRect.shrink(legendPadding, this.position);\n      const legendPositionedBBox = legendBBox.clone();\n      legendPositionedBBox.x += this.group.translationX;\n      legendPositionedBBox.y += this.group.translationY;\n      this.ctx.tooltipManager.updateExclusiveRect(this.id, legendPositionedBBox);\n    } else {\n      this.ctx.tooltipManager.updateExclusiveRect(this.id);\n    }\n    return {\n      shrinkRect: newShrinkRect\n    };\n  }\n  calculateLegendDimensions(shrinkRect) {\n    const {\n      width,\n      height\n    } = shrinkRect;\n    const aspectRatio = width / height;\n    const maxCoefficient = 0.5;\n    const minHeightCoefficient = 0.2;\n    const minWidthCoefficient = 0.25;\n    let legendWidth, legendHeight;\n    switch (this.position) {\n      case 'top':\n      case 'bottom':\n        // A horizontal legend should take maximum between 20 to 50 percent of the chart height if height is larger than width\n        // and maximum 20 percent of the chart height if height is smaller than width.\n        const heightCoefficient = aspectRatio < 1 ? Math.min(maxCoefficient, minHeightCoefficient * (1 / aspectRatio)) : minHeightCoefficient;\n        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : width;\n        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : Math.round(height * heightCoefficient);\n        break;\n      case 'left':\n      case 'right':\n      default:\n        // A vertical legend should take maximum between 25 to 50 percent of the chart width if width is larger than height\n        // and maximum 25 percent of the chart width if width is smaller than height.\n        const widthCoefficient = aspectRatio > 1 ? Math.min(maxCoefficient, minWidthCoefficient * aspectRatio) : minWidthCoefficient;\n        legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : Math.round(width * widthCoefficient);\n        legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : height;\n    }\n    return [legendWidth, legendHeight];\n  }\n}\nLegend.className = 'Legend';\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Object)], Legend.prototype, \"_enabled\", void 0);\n__decorate([Validate(POSITION), __metadata(\"design:type\", String)], Legend.prototype, \"position\", void 0);\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], Legend.prototype, \"maxWidth\", void 0);\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], Legend.prototype, \"maxHeight\", void 0);\n__decorate([Validate(OPT_BOOLEAN), __metadata(\"design:type\", Boolean)], Legend.prototype, \"reverseOrder\", void 0);\n__decorate([Validate(OPT_ORIENTATION), __metadata(\"design:type\", String)], Legend.prototype, \"orientation\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], Legend.prototype, \"spacing\", void 0);\nclass Overlay {\n  constructor(className, parent, document) {\n    this.text = undefined;\n    this.className = className;\n    this.parentElement = parent;\n    this.document = document;\n  }\n  show(rect) {\n    var _a, _b;\n    let element = this.element;\n    if (!element) {\n      element = this.document.createElement('div');\n      element.className = this.className;\n      this.element = element;\n    }\n    element.style.position = 'absolute';\n    element.style.left = `${rect.x}px`;\n    element.style.top = `${rect.y}px`;\n    element.style.width = `${rect.width}px`;\n    element.style.height = `${rect.height}px`;\n    if (this.renderer) {\n      element.innerHTML = this.renderer();\n    } else {\n      const content = this.document.createElement('div');\n      content.style.alignItems = 'center';\n      content.style.boxSizing = 'border-box';\n      content.style.display = 'flex';\n      content.style.justifyContent = 'center';\n      content.style.margin = '8px';\n      content.style.height = '100%';\n      content.style.font = '12px Verdana, sans-serif';\n      content.innerText = (_a = this.text) !== null && _a !== void 0 ? _a : 'No data to display';\n      element.append(content);\n    }\n    (_b = this.parentElement) === null || _b === void 0 ? void 0 : _b.append(element);\n  }\n  hide() {\n    var _a;\n    (_a = this.element) === null || _a === void 0 ? void 0 : _a.remove();\n    this.element = undefined;\n  }\n}\n__decorate([Validate(OPT_FUNCTION), __metadata(\"design:type\", Function)], Overlay.prototype, \"renderer\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], Overlay.prototype, \"text\", void 0);\nclass ChartOverlays {\n  constructor(parent) {\n    this.noData = new Overlay('ag-chart-no-data-overlay', parent, parent.ownerDocument);\n  }\n}\nconst SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION = 30;\nclass SeriesLayerManager {\n  constructor(rootGroup) {\n    this.groups = {};\n    this.series = {};\n    this.expectedSeriesCount = 1;\n    this.mode = 'normal';\n    this.rootGroup = rootGroup;\n  }\n  setSeriesCount(count) {\n    this.expectedSeriesCount = count;\n  }\n  requestGroup(seriesConfig) {\n    var _a, _b;\n    var _c, _d;\n    const {\n      id,\n      type,\n      rootGroup: seriesRootGroup,\n      highlightGroup: seriesHighlightGroup,\n      annotationGroup: seriesAnnotationGroup,\n      seriesGrouping\n    } = seriesConfig;\n    const {\n      groupIndex = id\n    } = seriesGrouping !== null && seriesGrouping !== void 0 ? seriesGrouping : {};\n    if (this.series[id] != null) {\n      throw new Error(`AG Charts - series already has an allocated layer: ${this.series[id]}`);\n    }\n    // Re-evaluate mode only on first series addition - we can't swap strategy mid-setup.\n    if (Object.keys(this.series).length === 0) {\n      this.mode = this.expectedSeriesCount >= SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION ? 'aggressive-grouping' : 'normal';\n    }\n    (_a = (_c = this.groups)[type]) !== null && _a !== void 0 ? _a : _c[type] = {};\n    const lookupIndex = this.lookupIdx(groupIndex);\n    let groupInfo = this.groups[type][lookupIndex];\n    if (!groupInfo) {\n      groupInfo = (_b = (_d = this.groups[type])[lookupIndex]) !== null && _b !== void 0 ? _b : _d[lookupIndex] = {\n        seriesIds: [],\n        group: this.rootGroup.appendChild(new Group({\n          name: `${type}-content`,\n          layer: true,\n          zIndex: Layers.SERIES_LAYER_ZINDEX,\n          zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder('data')\n        })),\n        highlight: this.rootGroup.appendChild(new Group({\n          name: `${type}-highlight`,\n          layer: true,\n          zIndex: Layers.SERIES_LAYER_ZINDEX,\n          zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder('highlight')\n        })),\n        annotation: this.rootGroup.appendChild(new Group({\n          name: `${type}-annotation`,\n          layer: true,\n          zIndex: Layers.SERIES_LAYER_ZINDEX,\n          zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder('annotation')\n        }))\n      };\n    }\n    this.series[id] = {\n      layerState: groupInfo,\n      seriesConfig\n    };\n    groupInfo.seriesIds.push(id);\n    groupInfo.group.appendChild(seriesRootGroup);\n    groupInfo.highlight.appendChild(seriesHighlightGroup);\n    groupInfo.annotation.appendChild(seriesAnnotationGroup);\n    return groupInfo.group;\n  }\n  changeGroup(seriesConfig) {\n    var _a, _b;\n    const {\n      id,\n      seriesGrouping,\n      type,\n      rootGroup,\n      highlightGroup,\n      annotationGroup,\n      oldGrouping\n    } = seriesConfig;\n    const {\n      groupIndex = id\n    } = seriesGrouping !== null && seriesGrouping !== void 0 ? seriesGrouping : {};\n    if ((_b = (_a = this.groups[type]) === null || _a === void 0 ? void 0 : _a[groupIndex]) === null || _b === void 0 ? void 0 : _b.seriesIds.includes(id)) {\n      // Already in the right group, nothing to do.\n      return;\n    }\n    if (this.series[id] != null) {\n      this.releaseGroup({\n        id,\n        seriesGrouping: oldGrouping,\n        type,\n        rootGroup,\n        highlightGroup,\n        annotationGroup\n      });\n    }\n    this.requestGroup(seriesConfig);\n  }\n  releaseGroup(seriesConfig) {\n    var _a, _b, _c, _d, _e;\n    const {\n      id,\n      seriesGrouping,\n      rootGroup,\n      highlightGroup,\n      annotationGroup,\n      type\n    } = seriesConfig;\n    const {\n      groupIndex = id\n    } = seriesGrouping !== null && seriesGrouping !== void 0 ? seriesGrouping : {};\n    if (this.series[id] == null) {\n      throw new Error(`AG Charts - series doesn't have an allocated layer: ${id}`);\n    }\n    const lookupIndex = this.lookupIdx(groupIndex);\n    const groupInfo = (_b = (_a = this.groups[type]) === null || _a === void 0 ? void 0 : _a[lookupIndex]) !== null && _b !== void 0 ? _b : (_c = this.series[id]) === null || _c === void 0 ? void 0 : _c.layerState;\n    if (groupInfo) {\n      groupInfo.seriesIds = groupInfo.seriesIds.filter(v => v !== id);\n      groupInfo.group.removeChild(rootGroup);\n      groupInfo.highlight.removeChild(highlightGroup);\n      groupInfo.annotation.removeChild(annotationGroup);\n    }\n    if ((groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.seriesIds.length) === 0) {\n      // Last member of the layer, cleanup.\n      this.rootGroup.removeChild(groupInfo.group);\n      this.rootGroup.removeChild(groupInfo.highlight);\n      this.rootGroup.removeChild(groupInfo.annotation);\n      delete this.groups[type][lookupIndex];\n      delete this.groups[type][id];\n    } else if ((groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.seriesIds.length) > 0) {\n      // Update zIndexSubOrder to avoid it becoming stale as series are removed and re-added\n      // with the same groupIndex, but are otherwise unrelated.\n      const leadSeriesConfig = (_e = this.series[(_d = groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.seriesIds) === null || _d === void 0 ? void 0 : _d[0]]) === null || _e === void 0 ? void 0 : _e.seriesConfig;\n      groupInfo.group.zIndexSubOrder = leadSeriesConfig === null || leadSeriesConfig === void 0 ? void 0 : leadSeriesConfig.getGroupZIndexSubOrder('data');\n      groupInfo.highlight.zIndexSubOrder = leadSeriesConfig === null || leadSeriesConfig === void 0 ? void 0 : leadSeriesConfig.getGroupZIndexSubOrder('highlight');\n      groupInfo.annotation.zIndexSubOrder = leadSeriesConfig === null || leadSeriesConfig === void 0 ? void 0 : leadSeriesConfig.getGroupZIndexSubOrder('annotation');\n    }\n    delete this.series[id];\n  }\n  lookupIdx(groupIndex) {\n    if (this.mode === 'normal') {\n      return groupIndex;\n    }\n    if (typeof groupIndex === 'string') {\n      groupIndex = Number(groupIndex.split('-').slice(-1)[0]);\n      if (!groupIndex) return 0;\n    }\n    return Math.floor(Math.max(Math.min(groupIndex / this.expectedSeriesCount, 1), 0) * SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION);\n  }\n  destroy() {\n    for (const groups of Object.values(this.groups)) {\n      for (const groupInfo of Object.values(groups)) {\n        this.rootGroup.removeChild(groupInfo.group);\n        this.rootGroup.removeChild(groupInfo.highlight);\n        this.rootGroup.removeChild(groupInfo.annotation);\n      }\n    }\n    this.groups = {};\n    this.series = {};\n  }\n}\nclass SeriesStateManager {\n  constructor() {\n    this.groups = {};\n  }\n  registerSeries({\n    id,\n    seriesGrouping,\n    visible,\n    type\n  }) {\n    var _a;\n    var _b;\n    if (!seriesGrouping) return;\n    (_a = (_b = this.groups)[type]) !== null && _a !== void 0 ? _a : _b[type] = {};\n    this.groups[type][id] = {\n      grouping: seriesGrouping,\n      visible\n    };\n  }\n  deregisterSeries({\n    id,\n    type\n  }) {\n    if (this.groups[type]) {\n      delete this.groups[type][id];\n    }\n    if (this.groups[type] && Object.keys(this.groups[type]).length === 0) {\n      delete this.groups[type];\n    }\n  }\n  getVisiblePeerGroupIndex({\n    type,\n    seriesGrouping\n  }) {\n    var _a;\n    if (!seriesGrouping) return {\n      visibleGroupCount: 1,\n      index: 0\n    };\n    const visibleGroups = [...Object.entries((_a = this.groups[type]) !== null && _a !== void 0 ? _a : {}).filter(([_, entry]) => entry.visible).reduce((result, [_, next]) => {\n      if (next.visible) {\n        result.add(next.grouping.groupIndex);\n      }\n      return result;\n    }, new Set()).values()];\n    visibleGroups.sort((a, b) => a - b);\n    return {\n      visibleGroupCount: visibleGroups.length,\n      index: visibleGroups.indexOf(seriesGrouping.groupIndex)\n    };\n  }\n}\nclass BaseLayoutProcessor {\n  constructor(chartLike, layoutService) {\n    this.chartLike = chartLike;\n    this.layoutService = layoutService;\n    this.destroyFns = [];\n    this.destroyFns.push(\n    // eslint-disable-next-line sonarjs/no-duplicate-string\n    this.layoutService.addListener('layout-complete', e => this.layoutComplete(e)), this.layoutService.addListener('start-layout', e => this.positionPadding(e.shrinkRect)), this.layoutService.addListener('start-layout', e => this.positionCaptions(e.shrinkRect)));\n  }\n  destroy() {\n    this.destroyFns.forEach(cb => cb());\n  }\n  layoutComplete({\n    clipSeries,\n    series: {\n      paddedRect\n    }\n  }) {\n    const {\n      seriesArea,\n      seriesRoot\n    } = this.chartLike;\n    if (seriesArea.clip || clipSeries) {\n      seriesRoot.setClipRectInGroupCoordinateSpace(paddedRect);\n    } else {\n      seriesRoot.setClipRectInGroupCoordinateSpace();\n    }\n  }\n  positionPadding(shrinkRect) {\n    const {\n      padding\n    } = this.chartLike;\n    shrinkRect.shrink(padding.left, 'left');\n    shrinkRect.shrink(padding.top, 'top');\n    shrinkRect.shrink(padding.right, 'right');\n    shrinkRect.shrink(padding.bottom, 'bottom');\n    return {\n      shrinkRect\n    };\n  }\n  positionCaptions(shrinkRect) {\n    var _a, _b, _c, _d;\n    const {\n      title,\n      subtitle,\n      footnote\n    } = this.chartLike;\n    const newShrinkRect = shrinkRect.clone();\n    const updateCaption = caption => {\n      var _a;\n      const defaultCaptionHeight = shrinkRect.height / 10;\n      const captionLineHeight = (_a = caption.lineHeight) !== null && _a !== void 0 ? _a : caption.fontSize * Text.defaultLineHeightRatio;\n      const maxWidth = shrinkRect.width;\n      const maxHeight = Math.max(captionLineHeight, defaultCaptionHeight);\n      caption.computeTextWrap(maxWidth, maxHeight);\n    };\n    const positionTopAndShrinkBBox = (caption, spacing) => {\n      const baseY = newShrinkRect.y;\n      caption.node.x = newShrinkRect.x + newShrinkRect.width / 2;\n      caption.node.y = baseY;\n      caption.node.textBaseline = 'top';\n      updateCaption(caption);\n      const bbox = caption.node.computeBBox();\n      // As the bbox (x,y) ends up at a different location than specified above, we need to\n      // take it into consideration when calculating how much space needs to be reserved to\n      // accommodate the caption.\n      const bboxHeight = Math.ceil(bbox.y - baseY + bbox.height + spacing);\n      newShrinkRect.shrink(bboxHeight, 'top');\n    };\n    const positionBottomAndShrinkBBox = (caption, spacing) => {\n      const baseY = newShrinkRect.y + newShrinkRect.height;\n      caption.node.x = newShrinkRect.x + newShrinkRect.width / 2;\n      caption.node.y = baseY;\n      caption.node.textBaseline = 'bottom';\n      updateCaption(caption);\n      const bbox = caption.node.computeBBox();\n      const bboxHeight = Math.ceil(baseY - bbox.y + spacing);\n      newShrinkRect.shrink(bboxHeight, 'bottom');\n    };\n    if (subtitle) {\n      subtitle.node.visible = (_a = subtitle.enabled) !== null && _a !== void 0 ? _a : false;\n    }\n    if (title) {\n      title.node.visible = title.enabled;\n      if (title.node.visible) {\n        const defaultTitleSpacing = (subtitle === null || subtitle === void 0 ? void 0 : subtitle.node.visible) ? Caption.SMALL_PADDING : Caption.LARGE_PADDING;\n        const spacing = (_b = title.spacing) !== null && _b !== void 0 ? _b : defaultTitleSpacing;\n        positionTopAndShrinkBBox(title, spacing);\n      }\n    }\n    if (subtitle && subtitle.node.visible) {\n      positionTopAndShrinkBBox(subtitle, (_c = subtitle.spacing) !== null && _c !== void 0 ? _c : 0);\n    }\n    if (footnote) {\n      footnote.node.visible = footnote.enabled;\n      if (footnote.node.visible) {\n        positionBottomAndShrinkBBox(footnote, (_d = footnote.spacing) !== null && _d !== void 0 ? _d : 0);\n      }\n    }\n    return {\n      shrinkRect: newShrinkRect\n    };\n  }\n}\nclass UpdateService extends Listeners {\n  constructor(updateCallback) {\n    super();\n    this.updateCallback = updateCallback;\n  }\n  update(type = ChartUpdateType.FULL, {\n    forceNodeDataRefresh = false,\n    skipAnimations = false\n  } = {}) {\n    this.updateCallback(type, {\n      forceNodeDataRefresh,\n      skipAnimations\n    });\n  }\n  dispatchUpdateComplete(minRect) {\n    const event = {\n      type: 'update-complete',\n      minRect\n    };\n    this.dispatch('update-complete', event);\n  }\n}\nfunction initialiseSpecialOverrides(opts) {\n  let globalWindow;\n  if (opts.window != null) {\n    globalWindow = opts.window;\n  } else if (typeof window !== 'undefined') {\n    globalWindow = window;\n  } else if (typeof global !== 'undefined') {\n    globalWindow = global.window;\n  } else {\n    throw new Error('AG Charts - unable to resolve global window');\n  }\n  let globalDocument;\n  if (opts.document != null) {\n    globalDocument = opts.document;\n  } else if (typeof document !== 'undefined') {\n    globalDocument = document;\n  } else if (typeof global !== 'undefined') {\n    globalDocument = global.document;\n  } else {\n    throw new Error('AG Charts - unable to resolve global document');\n  }\n  return {\n    document: globalDocument,\n    window: globalWindow,\n    overrideDevicePixelRatio: opts.overrideDevicePixelRatio,\n    sceneMode: opts.sceneMode\n  };\n}\nclass SeriesArea {\n  constructor() {\n    this.clip = undefined;\n    this.padding = new Padding(0);\n  }\n}\n__decorate([Validate(OPT_BOOLEAN), __metadata(\"design:type\", Boolean)], SeriesArea.prototype, \"clip\", void 0);\nclass Chart extends Observable {\n  getOptions() {\n    var _a;\n    const {\n      queuedUserOptions\n    } = this;\n    const lastUpdateOptions = (_a = queuedUserOptions[queuedUserOptions.length - 1]) !== null && _a !== void 0 ? _a : this.userOptions;\n    return jsonMerge([lastUpdateOptions]);\n  }\n  autoSizeChanged(value) {\n    const {\n      style\n    } = this.element;\n    if (value) {\n      style.display = 'block';\n      style.width = '100%';\n      style.height = '100%';\n      if (!this._lastAutoSize) {\n        return;\n      }\n      this.resize(undefined, undefined, 'autoSize option');\n    } else {\n      style.display = 'inline-block';\n      style.width = 'auto';\n      style.height = 'auto';\n    }\n  }\n  download(fileName, fileFormat) {\n    this.scene.download(fileName, fileFormat);\n  }\n  get destroyed() {\n    return this._destroyed;\n  }\n  constructor(specialOverrides, resources) {\n    var _a;\n    super();\n    this.id = createId(this);\n    this.processedOptions = {};\n    this.userOptions = {};\n    this.queuedUserOptions = [];\n    this.seriesRoot = new Group({\n      name: `${this.id}-Series-root`\n    });\n    this.debug = Debug.create();\n    this.extraDebugStats = {};\n    this.container = undefined;\n    this.data = [];\n    this._firstAutoSize = true;\n    this.padding = new Padding(20);\n    this.seriesArea = new SeriesArea();\n    this.title = undefined;\n    this.subtitle = undefined;\n    this.footnote = undefined;\n    this.mode = 'standalone';\n    this._destroyed = false;\n    this._destroyFns = [];\n    this.modules = {};\n    this.legendModules = {};\n    this.processors = [];\n    this.legends = new Map();\n    this._pendingFactoryUpdatesCount = 0;\n    this._performUpdateNoRenderCount = 0;\n    this._performUpdateType = ChartUpdateType.NONE;\n    this._performUpdateSkipAnimations = false;\n    this.updateShortcutCount = 0;\n    this.seriesToUpdate = new Set();\n    this.updateMutex = new Mutex();\n    this.updateRequestors = {};\n    this.performUpdateTrigger = debouncedCallback(({\n      count\n    }) => __awaiter(this, void 0, void 0, function* () {\n      if (this._destroyed) return;\n      this.updateMutex.acquire(() => __awaiter(this, void 0, void 0, function* () {\n        try {\n          yield this.performUpdate(count);\n        } catch (error) {\n          this._lastPerformUpdateError = error;\n          Logger.error('update error', error);\n        }\n      }));\n    }));\n    this._axes = [];\n    this._series = [];\n    this.lastInteractionEvent = undefined;\n    this.pointerScheduler = debouncedAnimationFrame(() => {\n      if (this.lastInteractionEvent) {\n        this.handlePointer(this.lastInteractionEvent);\n      }\n      this.lastInteractionEvent = undefined;\n    });\n    this.onSeriesNodeClick = event => {\n      const seriesNodeClickEvent = Object.assign(Object.assign({}, event), {\n        type: 'seriesNodeClick'\n      });\n      Object.defineProperty(seriesNodeClickEvent, 'series', {\n        enumerable: false,\n        // Should display the deprecation warning\n        get: () => event.series\n      });\n      this.fireEvent(seriesNodeClickEvent);\n    };\n    this.onSeriesNodeDoubleClick = event => {\n      const seriesNodeDoubleClick = Object.assign(Object.assign({}, event), {\n        type: 'seriesNodeDoubleClick'\n      });\n      this.fireEvent(seriesNodeDoubleClick);\n    };\n    this.specialOverrides = initialiseSpecialOverrides(specialOverrides);\n    const {\n      window,\n      document\n    } = this.specialOverrides;\n    const scene = resources === null || resources === void 0 ? void 0 : resources.scene;\n    const element = (_a = resources === null || resources === void 0 ? void 0 : resources.element) !== null && _a !== void 0 ? _a : document.createElement('div');\n    const container = resources === null || resources === void 0 ? void 0 : resources.container;\n    const root = new Group({\n      name: 'root'\n    });\n    // Prevent the scene from rendering chart components in an invalid state\n    // (before first layout is performed).\n    root.visible = false;\n    root.append(this.seriesRoot);\n    this.axisGridGroup = new Group({\n      name: 'Axes-Grids',\n      layer: true,\n      zIndex: Layers.AXIS_GRID_ZINDEX\n    });\n    root.appendChild(this.axisGridGroup);\n    this.axisGroup = new Group({\n      name: 'Axes',\n      layer: true,\n      zIndex: Layers.AXIS_ZINDEX\n    });\n    root.appendChild(this.axisGroup);\n    this.element = element;\n    element.classList.add('ag-chart-wrapper');\n    element.style.position = 'relative';\n    this.scene = scene !== null && scene !== void 0 ? scene : new Scene(this.specialOverrides);\n    this.scene.root = root;\n    this.scene.container = element;\n    this.autoSize = true;\n    this.chartEventManager = new ChartEventManager();\n    this.cursorManager = new CursorManager(element);\n    this.highlightManager = new HighlightManager();\n    this.interactionManager = new InteractionManager(element, document, window);\n    this.zoomManager = new ZoomManager();\n    this.dataService = new DataService(() => this.series);\n    this.layoutService = new LayoutService();\n    this.updateService = new UpdateService((type = ChartUpdateType.FULL, {\n      forceNodeDataRefresh,\n      skipAnimations\n    }) => this.update(type, {\n      forceNodeDataRefresh,\n      skipAnimations\n    }));\n    this.seriesStateManager = new SeriesStateManager();\n    this.seriesLayerManager = new SeriesLayerManager(this.seriesRoot);\n    this.callbackCache = new CallbackCache();\n    this.animationManager = new AnimationManager(this.interactionManager, this.updateMutex);\n    this.animationManager.skip();\n    this.animationManager.play();\n    this.processors = [new BaseLayoutProcessor(this, this.layoutService)];\n    this.tooltip = new Tooltip(this.scene.canvas.element, document, window, document.body);\n    this.tooltipManager = new TooltipManager(this.tooltip, this.interactionManager);\n    this.overlays = new ChartOverlays(this.element);\n    this.highlight = new ChartHighlight();\n    this.container = container;\n    SizeMonitor.observe(this.element, size => this.rawResize(size));\n    this._destroyFns.push(this.interactionManager.addListener('click', event => this.onClick(event)), this.interactionManager.addListener('dblclick', event => this.onDoubleClick(event)), this.interactionManager.addListener('hover', event => this.onMouseMove(event)), this.interactionManager.addListener('leave', event => this.onLeave(event)), this.interactionManager.addListener('page-left', () => this.destroy()), this.interactionManager.addListener('wheel', () => this.disablePointer()),\n    // Block redundant and interfering attempts to update the hovered element during dragging.\n    this.interactionManager.addListener('drag-start', () => this.disablePointer()), this.animationManager.addListener('animation-frame', _ => {\n      this.update(ChartUpdateType.SCENE_RENDER);\n    }), this.highlightManager.addListener('highlight-change', event => this.changeHighlightDatum(event)), this.zoomManager.addListener('zoom-change', _ => this.update(ChartUpdateType.PROCESS_DATA, {\n      forceNodeDataRefresh: true,\n      skipAnimations: true\n    })));\n    this.legend = this.attachLegend('category', Legend);\n  }\n  addModule(module) {\n    if (this.modules[module.optionsKey] != null) {\n      throw new Error('AG Charts - module already initialised: ' + module.optionsKey);\n    }\n    const moduleInstance = new module.instanceConstructor(this.getModuleContext());\n    this.modules[module.optionsKey] = {\n      instance: moduleInstance\n    };\n    this[module.optionsKey] = moduleInstance; // TODO remove\n  }\n\n  removeModule(module) {\n    var _a;\n    (_a = this.modules[module.optionsKey]) === null || _a === void 0 ? void 0 : _a.instance.destroy();\n    delete this.modules[module.optionsKey];\n    delete this[module.optionsKey]; // TODO remove\n  }\n\n  attachLegend(legendType, legendConstructor) {\n    const legend = new legendConstructor(this.getModuleContext());\n    this.legends.set(legendType, legend);\n    legend.attachLegend(this.scene.root);\n    return legend;\n  }\n  addLegendModule(module) {\n    if (this.modules[module.optionsKey] != null) {\n      throw new Error('AG Charts - module already initialised: ' + module.optionsKey);\n    }\n    const legend = this.attachLegend(module.identifier, module.instanceConstructor);\n    this.modules[module.optionsKey] = {\n      instance: legend\n    };\n    this[module.optionsKey] = legend;\n  }\n  removeLegendModule(module) {\n    this.legends.delete(module.identifier);\n    this.removeModule(module);\n  }\n  isModuleEnabled(module) {\n    return this.modules[module.optionsKey] != null;\n  }\n  getModuleContext() {\n    const {\n      scene,\n      animationManager,\n      chartEventManager,\n      cursorManager,\n      highlightManager,\n      interactionManager,\n      tooltipManager,\n      zoomManager,\n      dataService,\n      layoutService,\n      updateService,\n      seriesStateManager,\n      seriesLayerManager,\n      mode,\n      callbackCache,\n      specialOverrides: {\n        window,\n        document\n      }\n    } = this;\n    return {\n      window,\n      document,\n      scene,\n      animationManager,\n      chartEventManager,\n      cursorManager,\n      highlightManager,\n      interactionManager,\n      tooltipManager,\n      zoomManager,\n      dataService,\n      layoutService,\n      updateService,\n      mode,\n      seriesStateManager,\n      seriesLayerManager,\n      callbackCache\n    };\n  }\n  destroy(opts) {\n    if (this._destroyed) {\n      return;\n    }\n    const keepTransferableResources = opts === null || opts === void 0 ? void 0 : opts.keepTransferableResources;\n    let result;\n    this._performUpdateType = ChartUpdateType.NONE;\n    this._destroyFns.forEach(fn => fn());\n    this.processors.forEach(p => p.destroy());\n    this.tooltipManager.destroy();\n    this.tooltip.destroy();\n    Object.values(this.legends).forEach(legend => legend.destroy());\n    this.legends.clear();\n    this.overlays.noData.hide();\n    SizeMonitor.unobserve(this.element);\n    for (const optionsKey of Object.keys(this.modules)) {\n      this.removeModule({\n        optionsKey\n      });\n    }\n    this.interactionManager.destroy();\n    this.animationManager.stop();\n    if (keepTransferableResources) {\n      this.scene.strip();\n      result = {\n        container: this.container,\n        scene: this.scene,\n        element: this.element\n      };\n    } else {\n      this.scene.destroy();\n      this.container = undefined;\n    }\n    this.removeAllSeries();\n    this.seriesLayerManager.destroy();\n    this.axes.forEach(a => a.destroy());\n    this.axes = [];\n    this.callbackCache.invalidateCache();\n    this._destroyed = true;\n    return result;\n  }\n  disablePointer(highlightOnly = false) {\n    if (!highlightOnly) {\n      this.tooltipManager.removeTooltip(this.id);\n    }\n    this.highlightManager.updateHighlight(this.id);\n    if (this.lastInteractionEvent) {\n      this.lastInteractionEvent = undefined;\n    }\n  }\n  requestFactoryUpdate(cb) {\n    this._pendingFactoryUpdatesCount++;\n    this.updateMutex.acquire(() => __awaiter(this, void 0, void 0, function* () {\n      yield cb();\n      this._pendingFactoryUpdatesCount--;\n    }));\n  }\n  get performUpdateType() {\n    return this._performUpdateType;\n  }\n  get lastPerformUpdateError() {\n    return this._lastPerformUpdateError;\n  }\n  update(type = ChartUpdateType.FULL, opts) {\n    var _a, _b;\n    const {\n      forceNodeDataRefresh = false,\n      skipAnimations,\n      seriesToUpdate = this.series,\n      newAnimationBatch\n    } = opts !== null && opts !== void 0 ? opts : {};\n    if (forceNodeDataRefresh) {\n      this.series.forEach(series => series.markNodeDataDirty());\n    }\n    for (const series of seriesToUpdate) {\n      this.seriesToUpdate.add(series);\n    }\n    if (skipAnimations) {\n      this.animationManager.skipCurrentBatch();\n      this._performUpdateSkipAnimations = true;\n    }\n    if (newAnimationBatch) {\n      if (this.animationManager.isActive()) {\n        this._performUpdateSkipAnimations = true;\n      } else {\n        (_a = this._performUpdateSkipAnimations) !== null && _a !== void 0 ? _a : this._performUpdateSkipAnimations = false;\n      }\n    }\n    if (Debug.check(true)) {\n      let stack = (_b = new Error().stack) !== null && _b !== void 0 ? _b : '<unknown>';\n      stack = stack.replace(/\\([^)]*/g, '');\n      this.updateRequestors[stack] = type;\n    }\n    if (type < this._performUpdateType) {\n      this._performUpdateType = type;\n      this.performUpdateTrigger.schedule(opts === null || opts === void 0 ? void 0 : opts.backOffMs);\n    }\n  }\n  performUpdate(count) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        _performUpdateType: performUpdateType,\n        extraDebugStats\n      } = this;\n      const seriesToUpdate = [...this.seriesToUpdate];\n      // Clear state immediately so that side-effects can be detected prior to SCENE_RENDER.\n      this._performUpdateType = ChartUpdateType.NONE;\n      this.seriesToUpdate.clear();\n      if (this.updateShortcutCount === 0 && performUpdateType < ChartUpdateType.SCENE_RENDER) {\n        this.animationManager.startBatch(this._performUpdateSkipAnimations);\n      }\n      this.debug('Chart.performUpdate() - start', ChartUpdateType[performUpdateType]);\n      const splits = {\n        start: performance.now()\n      };\n      switch (performUpdateType) {\n        case ChartUpdateType.FULL:\n        case ChartUpdateType.PROCESS_DATA:\n          yield this.processData();\n          this.disablePointer(true);\n          splits['🏭'] = performance.now();\n        // fallthrough\n        case ChartUpdateType.PERFORM_LAYOUT:\n          if (this.checkUpdateShortcut(ChartUpdateType.PERFORM_LAYOUT)) break;\n          if (!this.checkFirstAutoSize(seriesToUpdate)) break;\n          yield this.processLayout();\n          splits['⌖'] = performance.now();\n        // fallthrough\n        case ChartUpdateType.SERIES_UPDATE:\n          if (this.checkUpdateShortcut(ChartUpdateType.SERIES_UPDATE)) break;\n          const {\n            seriesRect\n          } = this;\n          const seriesUpdates = [...seriesToUpdate].map(series => series.update({\n            seriesRect\n          }));\n          yield Promise.all(seriesUpdates);\n          splits['🤔'] = performance.now();\n        // fallthrough\n        case ChartUpdateType.TOOLTIP_RECALCULATION:\n          if (this.checkUpdateShortcut(ChartUpdateType.TOOLTIP_RECALCULATION)) break;\n          const tooltipMeta = this.tooltipManager.getTooltipMeta(this.id);\n          const isHovered = ((_a = tooltipMeta === null || tooltipMeta === void 0 ? void 0 : tooltipMeta.event) === null || _a === void 0 ? void 0 : _a.type) === 'hover';\n          if (performUpdateType <= ChartUpdateType.SERIES_UPDATE && isHovered) {\n            this.handlePointer(tooltipMeta.event);\n          }\n          splits['↖'] = performance.now();\n        // fallthrough\n        case ChartUpdateType.SCENE_RENDER:\n          if (this.checkUpdateShortcut(ChartUpdateType.SCENE_RENDER)) break;\n          extraDebugStats['updateShortcutCount'] = this.updateShortcutCount;\n          yield this.scene.render({\n            debugSplitTimes: splits,\n            extraDebugStats\n          });\n          this.extraDebugStats = {};\n        // fallthrough\n        case ChartUpdateType.NONE:\n          // Do nothing.\n          this.updateShortcutCount = 0;\n          this.updateRequestors = {};\n          this._performUpdateSkipAnimations = undefined;\n          this.animationManager.endBatch();\n      }\n      this.updateService.dispatchUpdateComplete(this.getMinRect());\n      const end = performance.now();\n      this.debug('Chart.performUpdate() - end', {\n        chart: this,\n        durationMs: Math.round((end - splits['start']) * 100) / 100,\n        count,\n        performUpdateType: ChartUpdateType[performUpdateType]\n      });\n    });\n  }\n  checkUpdateShortcut(checkUpdateType) {\n    const maxShortcuts = 3;\n    if (this.updateShortcutCount > maxShortcuts) {\n      Logger.warn(`exceeded the maximum number of simultaneous updates (${maxShortcuts + 1}), discarding changes and rendering`, this.updateRequestors);\n      return false;\n    }\n    if (this.performUpdateType <= checkUpdateType) {\n      // A previous step modified series state, and we need to re-run this or an earlier step before rendering.\n      this.updateShortcutCount++;\n      return true;\n    }\n    return false;\n  }\n  checkFirstAutoSize(seriesToUpdate) {\n    if (this.autoSize && !this._lastAutoSize) {\n      const count = this._performUpdateNoRenderCount++;\n      const backOffMs = (count ^ 2) * 10;\n      if (count < 8) {\n        // Reschedule if canvas size hasn't been set yet to avoid a race.\n        this.update(ChartUpdateType.PERFORM_LAYOUT, {\n          seriesToUpdate,\n          backOffMs\n        });\n        this.debug('Chart.checkFirstAutoSize() - backing off until first size update', backOffMs);\n        return false;\n      }\n      // After several failed passes, continue and accept there maybe a redundant\n      // render. Sometimes this case happens when we already have the correct\n      // width/height, and we end up never rendering the chart in that scenario.\n      this.debug('Chart.checkFirstAutoSize() - timeout for first size update.');\n    }\n    this._performUpdateNoRenderCount = 0;\n    return true;\n  }\n  set axes(values) {\n    const removedAxes = new Set();\n    this._axes.forEach(axis => {\n      axis.detachAxis(this.axisGroup, this.axisGridGroup);\n      removedAxes.add(axis);\n    });\n    // make linked axes go after the regular ones (simulates stable sort by `linkedTo` property)\n    this._axes = values.filter(a => !a.linkedTo).concat(values.filter(a => a.linkedTo));\n    this._axes.forEach(axis => {\n      axis.attachAxis(this.axisGroup, this.axisGridGroup);\n      removedAxes.delete(axis);\n    });\n    this.zoomManager.updateAxes(this._axes);\n    removedAxes.forEach(axis => axis.destroy());\n  }\n  get axes() {\n    return this._axes;\n  }\n  set series(values) {\n    this.removeAllSeries();\n    this.seriesLayerManager.setSeriesCount(values.length);\n    values.forEach(series => this.addSeries(series));\n  }\n  get series() {\n    return this._series;\n  }\n  addSeries(series) {\n    const {\n      series: allSeries\n    } = this;\n    const canAdd = allSeries.indexOf(series) < 0;\n    if (canAdd) {\n      allSeries.push(series);\n      if (series.rootGroup.parent == null) {\n        this.seriesLayerManager.requestGroup(series);\n      }\n      this.initSeries(series);\n      return true;\n    }\n    return false;\n  }\n  initSeries(series) {\n    const chart = this;\n    series.chart = {\n      get mode() {\n        return chart.mode;\n      },\n      get seriesRect() {\n        return chart.seriesRect;\n      },\n      placeLabels() {\n        return chart.placeLabels();\n      }\n    };\n    series.setChartData(this.data);\n    this.addSeriesListeners(series);\n    series.addChartEventListeners();\n  }\n  removeAllSeries() {\n    this.series.forEach(series => {\n      series.removeEventListener('nodeClick', this.onSeriesNodeClick);\n      series.removeEventListener('nodeDoubleClick', this.onSeriesNodeDoubleClick);\n      series.destroy();\n      series.chart = undefined;\n    });\n    this._series = []; // using `_series` instead of `series` to prevent infinite recursion\n  }\n\n  addSeriesListeners(series) {\n    if (this.hasEventListener('seriesNodeClick')) {\n      series.addEventListener('nodeClick', this.onSeriesNodeClick);\n    }\n    if (this.hasEventListener('seriesNodeDoubleClick')) {\n      series.addEventListener('nodeDoubleClick', this.onSeriesNodeDoubleClick);\n    }\n  }\n  updateAllSeriesListeners() {\n    this.series.forEach(series => {\n      series.removeEventListener('nodeClick', this.onSeriesNodeClick);\n      series.removeEventListener('nodeDoubleClick', this.onSeriesNodeDoubleClick);\n      this.addSeriesListeners(series);\n    });\n  }\n  assignSeriesToAxes() {\n    this.axes.forEach(axis => {\n      axis.boundSeries = this.series.filter(s => {\n        const seriesAxis = s.axes[axis.direction];\n        return seriesAxis === axis;\n      });\n    });\n  }\n  assignAxesToSeries() {\n    // This method has to run before `assignSeriesToAxes`.\n    const directionToAxesMap = {};\n    this.axes.forEach(axis => {\n      var _a;\n      const direction = axis.direction;\n      const directionAxes = (_a = directionToAxesMap[direction]) !== null && _a !== void 0 ? _a : directionToAxesMap[direction] = [];\n      directionAxes.push(axis);\n    });\n    this.series.forEach(series => {\n      series.directions.forEach(direction => {\n        const directionAxes = directionToAxesMap[direction];\n        if (!directionAxes) {\n          Logger.warnOnce(`no available axis for direction [${direction}]; check series and axes configuration.`);\n          return;\n        }\n        const seriesKeys = series.getKeys(direction);\n        const newAxis = this.findMatchingAxis(directionAxes, seriesKeys);\n        if (!newAxis) {\n          Logger.warnOnce(`no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`);\n          return;\n        }\n        series.axes[direction] = newAxis;\n      });\n    });\n  }\n  findMatchingAxis(directionAxes, directionKeys) {\n    for (const axis of directionAxes) {\n      const axisKeys = axis.keys;\n      if (!axisKeys.length) {\n        return axis;\n      }\n      if (!directionKeys) {\n        continue;\n      }\n      for (const directionKey of directionKeys) {\n        if (axisKeys.indexOf(directionKey) >= 0) {\n          return axis;\n        }\n      }\n    }\n  }\n  rawResize(size) {\n    var _a;\n    let {\n      width,\n      height\n    } = size;\n    width = Math.floor(width);\n    height = Math.floor(height);\n    if (!this.autoSize) {\n      return;\n    }\n    if (width === 0 && height === 0) {\n      return;\n    }\n    const [autoWidth = 0, authHeight = 0] = (_a = this._lastAutoSize) !== null && _a !== void 0 ? _a : [];\n    if (autoWidth === width && authHeight === height) {\n      return;\n    }\n    this._lastAutoSize = [width, height];\n    this.resize(undefined, undefined, 'SizeMonitor');\n  }\n  resize(width, height, source) {\n    var _a, _b, _c, _d;\n    width !== null && width !== void 0 ? width : width = (_a = this.width) !== null && _a !== void 0 ? _a : this.autoSize ? (_b = this._lastAutoSize) === null || _b === void 0 ? void 0 : _b[0] : this.scene.canvas.width;\n    height !== null && height !== void 0 ? height : height = (_c = this.height) !== null && _c !== void 0 ? _c : this.autoSize ? (_d = this._lastAutoSize) === null || _d === void 0 ? void 0 : _d[1] : this.scene.canvas.height;\n    this.debug(`Chart.resize() from ${source}`, {\n      width,\n      height,\n      stack: new Error().stack\n    });\n    if (!width || !height || !Number.isFinite(width) || !Number.isFinite(height)) return;\n    if (this.scene.resize(width, height)) {\n      this.disablePointer();\n      this.animationManager.reset();\n      let skipAnimations = true;\n      if (this.autoSize && this._firstAutoSize) {\n        skipAnimations = false;\n        this._firstAutoSize = false;\n      }\n      this.update(ChartUpdateType.PERFORM_LAYOUT, {\n        forceNodeDataRefresh: true,\n        skipAnimations\n      });\n    }\n  }\n  processData() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.series.some(s => s.canHaveAxes)) {\n        this.assignAxesToSeries();\n        this.assignSeriesToAxes();\n      }\n      const dataController = new DataController(this.mode);\n      const seriesPromises = this.series.map(s => s.processData(dataController));\n      yield dataController.execute();\n      yield Promise.all(seriesPromises);\n      yield this.updateLegend();\n    });\n  }\n  placeLabels() {\n    const visibleSeries = [];\n    const data = [];\n    for (const series of this.series) {\n      if (!series.visible) {\n        continue;\n      }\n      const labelData = series.getLabelData();\n      if (!(labelData && isPointLabelDatum(labelData[0]))) {\n        continue;\n      }\n      data.push(labelData);\n      visibleSeries.push(series);\n    }\n    const {\n      seriesRect\n    } = this;\n    const labels = seriesRect && data.length > 0 ? placeLabels(data, {\n      x: 0,\n      y: 0,\n      width: seriesRect.width,\n      height: seriesRect.height\n    }) : [];\n    return new Map(labels.map((l, i) => [visibleSeries[i], l]));\n  }\n  updateLegend() {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.legends.forEach((legend, legendType) => {\n        const isCategoryLegendData = data => data.every(d => d.legendType === 'category');\n        const legendData = this.series.filter(s => s.showInLegend).flatMap(s => s.getLegendData(legendType));\n        if (isCategoryLegendData(legendData)) {\n          this.validateCategoryLegendData(legendData);\n        }\n        legend.data = legendData;\n      });\n    });\n  }\n  validateCategoryLegendData(legendData) {\n    // Validate each series that shares a legend item label uses the same fill colour\n    const labelMarkerFills = {};\n    legendData.forEach(d => {\n      var _a, _b, _c;\n      var _d, _e;\n      const seriesType = (_a = this.series.find(s => s.id === d.seriesId)) === null || _a === void 0 ? void 0 : _a.type;\n      if (!seriesType) return;\n      (_b = labelMarkerFills[seriesType]) !== null && _b !== void 0 ? _b : labelMarkerFills[seriesType] = {};\n      (_c = (_d = labelMarkerFills[seriesType])[_e = d.label.text]) !== null && _c !== void 0 ? _c : _d[_e] = new Set();\n      if (d.marker.fill != null) {\n        labelMarkerFills[seriesType][d.label.text].add(d.marker.fill);\n      }\n    });\n    for (const seriesMarkers of Object.values(labelMarkerFills)) {\n      for (const [name, fills] of Object.entries(seriesMarkers)) {\n        if (fills.size > 1) {\n          Logger.warnOnce(`legend item '${name}' has multiple fill colors, this may cause unexpected behaviour.`);\n        }\n      }\n    }\n  }\n  processLayout() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const oldRect = this.animationRect;\n      yield this.performLayout();\n      if (oldRect && !((_a = this.animationRect) === null || _a === void 0 ? void 0 : _a.equals(oldRect))) {\n        // Skip animations if the layout changed.\n        this.animationManager.skipCurrentBatch();\n      }\n      this.handleNoDataOverlay();\n      this.debug('Chart.performUpdate() - seriesRect', this.seriesRect);\n    });\n  }\n  performLayout() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.scene.root) {\n        this.scene.root.visible = true;\n      }\n      const {\n        width,\n        height\n      } = this.scene;\n      let ctx = {\n        shrinkRect: new BBox(0, 0, width, height)\n      };\n      ctx = this.layoutService.dispatchPerformLayout('start-layout', ctx);\n      ctx = this.layoutService.dispatchPerformLayout('before-series', ctx);\n      return ctx.shrinkRect;\n    });\n  }\n  // x/y are local canvas coordinates in CSS pixels, not actual pixels\n  pickSeriesNode(point, exactMatchOnly, maxDistance) {\n    var _a, _b;\n    const start = performance.now();\n    // Disable 'nearest match' options if looking for exact matches only\n    const pickModes = exactMatchOnly ? [SeriesNodePickMode.EXACT_SHAPE_MATCH] : undefined;\n    // Iterate through series in reverse, as later declared series appears on top of earlier\n    // declared series.\n    const reverseSeries = [...this.series].reverse();\n    let result;\n    for (const series of reverseSeries) {\n      if (!series.visible || !series.rootGroup.visible) {\n        continue;\n      }\n      const {\n        match,\n        distance\n      } = (_a = series.pickNode(point, pickModes)) !== null && _a !== void 0 ? _a : {};\n      if (!match || distance == null) {\n        continue;\n      }\n      if ((!result || result.distance > distance) && distance <= (maxDistance !== null && maxDistance !== void 0 ? maxDistance : Infinity)) {\n        result = {\n          series,\n          distance,\n          datum: match\n        };\n      }\n      if (distance === 0) {\n        break;\n      }\n    }\n    this.extraDebugStats['pickSeriesNode'] = Math.round(((_b = this.extraDebugStats['pickSeriesNode']) !== null && _b !== void 0 ? _b : 0) + (performance.now() - start));\n    return result;\n  }\n  onMouseMove(event) {\n    this.lastInteractionEvent = event;\n    this.pointerScheduler.schedule();\n    this.extraDebugStats['mouseX'] = event.offsetX;\n    this.extraDebugStats['mouseY'] = event.offsetY;\n    this.update(ChartUpdateType.SCENE_RENDER);\n  }\n  onLeave(event) {\n    if (this.tooltip.pointerLeftOntoTooltip(event)) {\n      return;\n    }\n    this.disablePointer();\n  }\n  handlePointer(event) {\n    const {\n      lastPick,\n      hoverRect\n    } = this;\n    const {\n      offsetX,\n      offsetY\n    } = event;\n    const disablePointer = (highlightOnly = false) => {\n      if (lastPick) {\n        // Cursor moved from a non-marker node to empty space.\n        this.disablePointer(highlightOnly);\n      }\n    };\n    if (!(hoverRect === null || hoverRect === void 0 ? void 0 : hoverRect.containsPoint(offsetX, offsetY))) {\n      disablePointer();\n      return;\n    }\n    // Handle node highlighting and tooltip toggling when pointer within `tooltip.range`\n    this.handlePointerTooltip(event, disablePointer);\n    // Handle node highlighting and mouse cursor when pointer withing `series[].nodeClickRange`\n    this.handlePointerNode(event);\n  }\n  handlePointerTooltip(event, disablePointer) {\n    const {\n      lastPick,\n      tooltip\n    } = this;\n    const {\n      range\n    } = tooltip;\n    const {\n      offsetX,\n      offsetY\n    } = event;\n    let pixelRange;\n    if (typeof range === 'number' && Number.isFinite(range)) {\n      pixelRange = range;\n    }\n    const pick = this.pickSeriesNode({\n      x: offsetX,\n      y: offsetY\n    }, range === 'exact', pixelRange);\n    if (!pick) {\n      this.tooltipManager.removeTooltip(this.id);\n      if (this.highlight.range === 'tooltip') disablePointer(true);\n      return;\n    }\n    const isNewDatum = this.highlight.range === 'node' || !lastPick || lastPick.datum !== pick.datum;\n    let html;\n    if (isNewDatum) {\n      html = pick.series.getTooltipHtml(pick.datum);\n      if (this.highlight.range === 'tooltip') {\n        this.highlightManager.updateHighlight(this.id, pick.datum);\n      }\n    } else if (lastPick) {\n      lastPick.event = event.sourceEvent;\n    }\n    const isPixelRange = pixelRange != null;\n    const tooltipEnabled = this.tooltip.enabled && pick.series.tooltip.enabled;\n    const exactlyMatched = range === 'exact' && pick.distance === 0;\n    const rangeMatched = range === 'nearest' || isPixelRange || exactlyMatched;\n    const shouldUpdateTooltip = tooltipEnabled && rangeMatched && (!isNewDatum || html !== undefined);\n    const meta = TooltipManager.makeTooltipMeta(event, this.scene.canvas, pick.datum, this.specialOverrides.window);\n    if (shouldUpdateTooltip) {\n      this.tooltipManager.updateTooltip(this.id, meta, html);\n    }\n  }\n  handlePointerNode(event) {\n    const found = this.checkSeriesNodeRange(event, (series, datum) => {\n      if (series.hasEventListener('nodeClick') || series.hasEventListener('nodeDoubleClick')) {\n        this.cursorManager.updateCursor('chart', 'pointer');\n      }\n      if (this.highlight.range === 'node') {\n        this.highlightManager.updateHighlight(this.id, datum);\n      }\n    });\n    if (!found) {\n      this.cursorManager.updateCursor('chart');\n      if (this.highlight.range === 'node') {\n        this.highlightManager.updateHighlight(this.id);\n      }\n    }\n  }\n  onClick(event) {\n    if (this.checkSeriesNodeClick(event)) {\n      this.update(ChartUpdateType.SERIES_UPDATE);\n      return;\n    }\n    this.fireEvent({\n      type: 'click',\n      event: event.sourceEvent\n    });\n  }\n  onDoubleClick(event) {\n    if (this.checkSeriesNodeDoubleClick(event)) {\n      this.update(ChartUpdateType.SERIES_UPDATE);\n      return;\n    }\n    this.fireEvent({\n      type: 'doubleClick',\n      event: event.sourceEvent\n    });\n  }\n  checkSeriesNodeClick(event) {\n    return this.checkSeriesNodeRange(event, (series, datum) => series.fireNodeClickEvent(event.sourceEvent, datum));\n  }\n  checkSeriesNodeDoubleClick(event) {\n    return this.checkSeriesNodeRange(event, (series, datum) => series.fireNodeDoubleClickEvent(event.sourceEvent, datum));\n  }\n  checkSeriesNodeRange(event, callback) {\n    const nearestNode = this.pickSeriesNode({\n      x: event.offsetX,\n      y: event.offsetY\n    }, false);\n    const datum = nearestNode === null || nearestNode === void 0 ? void 0 : nearestNode.datum;\n    const nodeClickRange = datum === null || datum === void 0 ? void 0 : datum.series.nodeClickRange;\n    let pixelRange;\n    if (typeof nodeClickRange === 'number' && Number.isFinite(nodeClickRange)) {\n      pixelRange = nodeClickRange;\n    }\n    // Find the node if exactly matched and update the highlight picked node\n    let pickedNode = this.pickSeriesNode({\n      x: event.offsetX,\n      y: event.offsetY\n    }, true);\n    if (pickedNode) {\n      this.highlightManager.updatePicked(this.id, pickedNode.datum);\n    } else {\n      this.highlightManager.updatePicked(this.id);\n    }\n    // First check if we should trigger the callback based on nearest node\n    if (datum && nodeClickRange === 'nearest') {\n      callback(datum.series, datum);\n      return true;\n    }\n    if (nodeClickRange !== 'exact') {\n      pickedNode = this.pickSeriesNode({\n        x: event.offsetX,\n        y: event.offsetY\n      }, false, pixelRange);\n    }\n    if (!pickedNode) return false;\n    // Then if we've picked a node within the pixel range, or exactly, trigger the callback\n    const isPixelRange = pixelRange != null;\n    const exactlyMatched = nodeClickRange === 'exact' && pickedNode.distance === 0;\n    if (isPixelRange || exactlyMatched) {\n      callback(pickedNode.series, pickedNode.datum);\n      return true;\n    }\n    return false;\n  }\n  changeHighlightDatum(event) {\n    var _a, _b;\n    const seriesToUpdate = new Set();\n    const {\n      series: newSeries = undefined,\n      datum: newDatum\n    } = (_a = event.currentHighlight) !== null && _a !== void 0 ? _a : {};\n    const {\n      series: lastSeries = undefined,\n      datum: lastDatum\n    } = (_b = event.previousHighlight) !== null && _b !== void 0 ? _b : {};\n    if (lastSeries) {\n      seriesToUpdate.add(lastSeries);\n    }\n    if (newSeries) {\n      seriesToUpdate.add(newSeries);\n    }\n    // Adjust cursor if a specific datum is highlighted, rather than just a series.\n    if ((lastSeries === null || lastSeries === void 0 ? void 0 : lastSeries.cursor) && lastDatum) {\n      this.cursorManager.updateCursor(lastSeries.id);\n    }\n    if ((newSeries === null || newSeries === void 0 ? void 0 : newSeries.cursor) && newDatum) {\n      this.cursorManager.updateCursor(newSeries.id, newSeries.cursor);\n    }\n    this.lastPick = event.currentHighlight ? {\n      datum: event.currentHighlight\n    } : undefined;\n    const updateAll = newSeries == null || lastSeries == null;\n    if (updateAll) {\n      this.update(ChartUpdateType.SERIES_UPDATE);\n    } else {\n      this.update(ChartUpdateType.SERIES_UPDATE, {\n        seriesToUpdate\n      });\n    }\n  }\n  waitForUpdate(timeoutMs = 5000) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const start = performance.now();\n      if (this._pendingFactoryUpdatesCount > 0) {\n        // Await until any pending updates are flushed through.\n        yield this.updateMutex.waitForClearAcquireQueue();\n      }\n      while (this._performUpdateType !== ChartUpdateType.NONE) {\n        if (performance.now() - start > timeoutMs) {\n          throw new Error('waitForUpdate() timeout reached.');\n        }\n        yield sleep(5);\n      }\n      // Await until any remaining updates are flushed through.\n      yield this.updateMutex.waitForClearAcquireQueue();\n    });\n  }\n  handleNoDataOverlay() {\n    const shouldDisplayNoDataOverlay = !this.series.some(s => s.hasData());\n    if (shouldDisplayNoDataOverlay && this.seriesRect) {\n      this.overlays.noData.show(this.seriesRect);\n    } else {\n      this.overlays.noData.hide();\n    }\n  }\n  getMinRect() {\n    const minRects = this.series.map(series => series.getMinRect()).filter(rect => rect !== undefined);\n    if (!minRects.length) return undefined;\n    return new BBox(0, 0, minRects.reduce((max, rect) => Math.max(max, rect.width), 0), minRects.reduce((max, rect) => Math.max(max, rect.height), 0));\n  }\n}\n__decorate([ActionOnSet({\n  newValue(value) {\n    if (this.destroyed) return;\n    value.appendChild(this.element);\n  },\n  oldValue(value) {\n    value.removeChild(this.element);\n  }\n}), __metadata(\"design:type\", Object)], Chart.prototype, \"container\", void 0);\n__decorate([ActionOnSet({\n  newValue(value) {\n    var _a;\n    (_a = this.series) === null || _a === void 0 ? void 0 : _a.forEach(series => {\n      series.setChartData(value);\n    });\n  }\n}), __metadata(\"design:type\", Object)], Chart.prototype, \"data\", void 0);\n__decorate([ActionOnSet({\n  newValue(value) {\n    this.resize(value, undefined, 'width option');\n  }\n}), __metadata(\"design:type\", Number)], Chart.prototype, \"width\", void 0);\n__decorate([ActionOnSet({\n  newValue(value) {\n    this.resize(undefined, value, 'height option');\n  }\n}), __metadata(\"design:type\", Number)], Chart.prototype, \"height\", void 0);\n__decorate([ActionOnSet({\n  changeValue(value) {\n    this.autoSizeChanged(value);\n  }\n}), Validate(BOOLEAN), __metadata(\"design:type\", Object)], Chart.prototype, \"autoSize\", void 0);\n__decorate([ActionOnSet({\n  newValue(value) {\n    var _a;\n    (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(value.node);\n  },\n  oldValue(oldValue) {\n    var _a;\n    (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(oldValue.node);\n  }\n}), __metadata(\"design:type\", Function)], Chart.prototype, \"title\", void 0);\n__decorate([ActionOnSet({\n  newValue(value) {\n    var _a;\n    (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(value.node);\n  },\n  oldValue(oldValue) {\n    var _a;\n    (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(oldValue.node);\n  }\n}), __metadata(\"design:type\", Function)], Chart.prototype, \"subtitle\", void 0);\n__decorate([ActionOnSet({\n  newValue(value) {\n    var _a;\n    (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(value.node);\n  },\n  oldValue(oldValue) {\n    var _a;\n    (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(oldValue.node);\n  }\n}), __metadata(\"design:type\", Function)], Chart.prototype, \"footnote\", void 0);\n__decorate([Validate(STRING_UNION('standalone', 'integrated')), __metadata(\"design:type\", String)], Chart.prototype, \"mode\", void 0);\nvar ArcType;\n(function (ArcType) {\n  ArcType[ArcType[\"Open\"] = 0] = \"Open\";\n  ArcType[ArcType[\"Chord\"] = 1] = \"Chord\";\n  ArcType[ArcType[\"Round\"] = 2] = \"Round\";\n})(ArcType || (ArcType = {}));\n/**\r\n * Elliptical arc node.\r\n */\nclass Arc extends Path {\n  constructor() {\n    super();\n    this.centerX = 0;\n    this.centerY = 0;\n    this.radius = 10;\n    this.startAngle = 0;\n    this.endAngle = Math.PI * 2;\n    this.counterClockwise = false;\n    /**\r\n     * The type of arc to render:\r\n     * - {@link ArcType.Open} - end points of the arc segment are not connected (default)\r\n     * - {@link ArcType.Chord} - end points of the arc segment are connected by a line segment\r\n     * - {@link ArcType.Round} - each of the end points of the arc segment are connected\r\n     *                           to the center of the arc\r\n     * Arcs with {@link ArcType.Open} do not support hit testing, even if they have their\r\n     * {@link Shape.fillStyle} set, because they are not closed paths. Hit testing support\r\n     * would require using two paths - one for rendering, another for hit testing - and there\r\n     * doesn't seem to be a compelling reason to do that, when one can just use {@link ArcType.Chord}\r\n     * to create a closed path.\r\n     */\n    this.type = ArcType.Open;\n    this.restoreOwnStyles();\n  }\n  get fullPie() {\n    return isEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));\n  }\n  updatePath() {\n    const path = this.path;\n    path.clear(); // No need to recreate the Path, can simply clear the existing one.\n    path.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, this.counterClockwise);\n    if (this.type === ArcType.Chord) {\n      path.closePath();\n    } else if (this.type === ArcType.Round && !this.fullPie) {\n      path.lineTo(this.centerX, this.centerY);\n      path.closePath();\n    }\n  }\n  computeBBox() {\n    // Only works with full arcs (circles) and untransformed ellipses.\n    return new BBox(this.centerX - this.radius, this.centerY - this.radius, this.radius * 2, this.radius * 2);\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const bbox = this.computeBBox();\n    return this.type !== ArcType.Open && bbox.containsPoint(point.x, point.y) && this.path.isPointInPath(point.x, point.y);\n  }\n}\nArc.className = 'Arc';\nArc.defaultStyles = Object.assign({}, Shape.defaultStyles, {\n  lineWidth: 1,\n  fillStyle: null\n});\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Arc.prototype, \"centerX\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Arc.prototype, \"centerY\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Arc.prototype, \"radius\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Arc.prototype, \"startAngle\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Arc.prototype, \"endAngle\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Boolean)], Arc.prototype, \"counterClockwise\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Arc.prototype, \"type\", void 0);\nconst convertColorStringToHsla = v => {\n  const color = Color.fromString(v);\n  const [h, s, l] = Color.RGBtoHSL(color.r, color.g, color.b);\n  return {\n    h,\n    s,\n    l,\n    a: color.a\n  };\n};\nconst interpolateHsla = (x, y, d) => {\n  d = Math.min(Math.max(d, 0), 1);\n  let h;\n  let s;\n  if (Number.isNaN(x.h) && Number.isNaN(y.h)) {\n    h = 0;\n    s = 0;\n  } else if (Number.isNaN(x.h)) {\n    h = y.h;\n    s = y.s;\n  } else if (Number.isNaN(y.h)) {\n    h = x.h;\n    s = x.s;\n  } else {\n    const xH = x.h;\n    let yH = y.h;\n    const deltaH = y.h - x.h;\n    if (deltaH > 180) {\n      yH -= 360;\n    } else if (deltaH < -180) {\n      yH += 360;\n    }\n    h = xH * (1 - d) + yH * d;\n    s = x.s * (1 - d) + y.s * d;\n  }\n  const l = x.l * (1 - d) + y.l * d;\n  const a = x.a * (1 - d) + y.a * d;\n  return Color.fromHSL(h, s, l, a);\n};\nclass ColorScale {\n  constructor() {\n    this.domain = [0, 1];\n    this.range = ['red', 'blue'];\n    this.parsedRange = this.range.map(convertColorStringToHsla);\n  }\n  update() {\n    const {\n      domain,\n      range\n    } = this;\n    if (domain.length < 2) {\n      Logger.warnOnce('`colorDomain` should have at least 2 values.');\n      if (domain.length === 0) {\n        domain.push(0, 1);\n      } else if (domain.length === 1) {\n        domain.push(domain[0] + 1);\n      }\n    }\n    for (let i = 1; i < domain.length; i++) {\n      const a = domain[i - 1];\n      const b = domain[i];\n      if (a >= b) {\n        Logger.warnOnce('`colorDomain` values should be supplied in ascending order.');\n        domain.sort((a, b) => a - b);\n        break;\n      }\n    }\n    if (range.length < domain.length) {\n      for (let i = range.length; i < domain.length; i++) {\n        range.push(range.length > 0 ? range[0] : 'black');\n      }\n    }\n    this.parsedRange = this.range.map(convertColorStringToHsla);\n  }\n  convert(x) {\n    const {\n      domain,\n      range,\n      parsedRange\n    } = this;\n    const d0 = domain[0];\n    const d1 = domain[domain.length - 1];\n    const r0 = range[0];\n    const r1 = range[range.length - 1];\n    if (x <= d0) {\n      return r0;\n    }\n    if (x >= d1) {\n      return r1;\n    }\n    let index;\n    let q;\n    if (domain.length === 2) {\n      const t = (x - d0) / (d1 - d0);\n      const step = 1 / (range.length - 1);\n      index = range.length <= 2 ? 0 : Math.min(Math.floor(t * (range.length - 1)), range.length - 2);\n      q = (t - index * step) / step;\n    } else {\n      for (index = 0; index < domain.length - 2; index++) {\n        if (x < domain[index + 1]) {\n          break;\n        }\n      }\n      const a = domain[index];\n      const b = domain[index + 1];\n      q = (x - a) / (b - a);\n    }\n    const c0 = parsedRange[index];\n    const c1 = parsedRange[index + 1];\n    return interpolateHsla(c0, c1, q).toRgbaString();\n  }\n}\nclass LinearGradientFill extends Shape {\n  constructor() {\n    super(...arguments);\n    this.direction = 'to-right';\n    this.stops = undefined;\n    this._mask = undefined;\n  }\n  get mask() {\n    return this._mask;\n  }\n  set mask(newMask) {\n    if (this._mask != null) {\n      this.removeChild(this._mask);\n    }\n    if (newMask != null) {\n      this.appendChild(newMask);\n    }\n    this._mask = newMask;\n  }\n  isPointInPath(x, y) {\n    var _a, _b;\n    return (_b = (_a = this.mask) === null || _a === void 0 ? void 0 : _a.isPointInPath(x, y)) !== null && _b !== void 0 ? _b : false;\n  }\n  computeBBox() {\n    var _a;\n    return (_a = this.mask) === null || _a === void 0 ? void 0 : _a.computeBBox();\n  }\n  render(renderCtx) {\n    const {\n      mask,\n      stops\n    } = this;\n    const {\n      ctx,\n      devicePixelRatio\n    } = renderCtx;\n    const pixelLength = 1 / devicePixelRatio;\n    const maskBbox = mask === null || mask === void 0 ? void 0 : mask.computeTransformedBBox();\n    if (mask == null || stops == null || maskBbox == null) return;\n    if (mask.dirtyPath) {\n      mask.updatePath();\n      mask.dirtyPath = false;\n    }\n    ctx.save();\n    ctx.beginPath();\n    mask.path.draw(ctx);\n    ctx.clip();\n    ctx.resetTransform();\n    const x0 = Math.floor(maskBbox.x);\n    const x1 = Math.ceil(maskBbox.x + maskBbox.width);\n    const y0 = Math.floor(maskBbox.y);\n    const y1 = Math.ceil(maskBbox.y + maskBbox.height);\n    const colorScale = new ColorScale();\n    const [i0, i1] = this.direction === 'to-right' ? [x0, x1] : [y0, y1];\n    colorScale.domain = stops.map((_, index) => {\n      return i0 + (i1 - i0) * index / (stops.length - 1);\n    });\n    colorScale.range = stops;\n    colorScale.update();\n    if (this.direction === 'to-right') {\n      const height = y1 - y0;\n      for (let x = x0; x <= x1; x += pixelLength) {\n        ctx.fillStyle = colorScale.convert(x);\n        ctx.fillRect(x, y0, pixelLength, height);\n      }\n    } else {\n      const width = x1 - x0;\n      for (let y = y0; y <= y1; y += pixelLength) {\n        ctx.fillStyle = colorScale.convert(y);\n        ctx.fillRect(x0, y, width, pixelLength);\n      }\n    }\n    ctx.restore();\n  }\n}\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", String)], LinearGradientFill.prototype, \"direction\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Array)], LinearGradientFill.prototype, \"stops\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Function)], LinearGradientFill.prototype, \"_mask\", void 0);\nclass Rect extends Path {\n  constructor() {\n    super(...arguments);\n    this.borderPath = new Path2D();\n    this.x = 0;\n    this.y = 0;\n    this.width = 10;\n    this.height = 10;\n    this.radius = 0;\n    /**\r\n     * If `true`, the rect is aligned to the pixel grid for crisp looking lines.\r\n     * Animated rects may not look nice with this option enabled, for example\r\n     * when a rect is translated by a sub-pixel value on each frame.\r\n     */\n    this.crisp = false;\n    this.lastUpdatePathStrokeWidth = Shape.defaultStyles.strokeWidth;\n    this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;\n    /**\r\n     * When the rectangle's width or height is less than a pixel\r\n     * and crisp mode is on, the rectangle will still fit into the pixel,\r\n     * but will be less opaque to make an effect of holding less space.\r\n     */\n    this.microPixelEffectOpacity = 1;\n  }\n  isDirtyPath() {\n    var _a;\n    if (this.lastUpdatePathStrokeWidth !== this.strokeWidth) {\n      return true;\n    }\n    return !!(this.path.isDirty() || this.borderPath.isDirty() || ((_a = this.clipPath) === null || _a === void 0 ? void 0 : _a.isDirty()));\n  }\n  updatePath() {\n    var _a, _b, _c;\n    const {\n      path,\n      borderPath,\n      crisp\n    } = this;\n    let {\n      x,\n      y,\n      width: w,\n      height: h,\n      strokeWidth\n    } = this;\n    const pixelRatio = (_b = (_a = this.layerManager) === null || _a === void 0 ? void 0 : _a.canvas.pixelRatio) !== null && _b !== void 0 ? _b : 1;\n    const pixelSize = 1 / pixelRatio;\n    let microPixelEffectOpacity = 1;\n    path.clear({\n      trackChanges: true\n    });\n    borderPath.clear({\n      trackChanges: true\n    });\n    if (crisp) {\n      if (w <= pixelSize) {\n        microPixelEffectOpacity *= w / pixelSize;\n      }\n      if (h <= pixelSize) {\n        microPixelEffectOpacity *= h / pixelSize;\n      }\n      w = this.align(x, w);\n      h = this.align(y, h);\n      x = this.align(x);\n      y = this.align(y);\n    }\n    if (strokeWidth) {\n      if (w < pixelSize) {\n        // Too narrow, draw a vertical stroke\n        const lx = x + pixelSize / 2;\n        borderPath.moveTo(lx, y);\n        borderPath.lineTo(lx, y + h);\n        strokeWidth = pixelSize;\n        this.borderClipPath = undefined;\n      } else if (h < pixelSize) {\n        // Too narrow, draw a horizontal stroke\n        const ly = y + pixelSize / 2;\n        borderPath.moveTo(x, ly);\n        borderPath.lineTo(x + w, ly);\n        strokeWidth = pixelSize;\n        this.borderClipPath = undefined;\n      } else if (strokeWidth < w && strokeWidth < h) {\n        const halfStrokeWidth = strokeWidth / 2;\n        x += halfStrokeWidth;\n        y += halfStrokeWidth;\n        w -= strokeWidth;\n        h -= strokeWidth;\n        // Clipping not needed in this case; fill to center of stroke.\n        this.borderClipPath = undefined;\n        path.rect(x, y, w, h);\n        borderPath.rect(x, y, w, h);\n      } else {\n        // Skip the fill and just render the stroke.\n        this.borderClipPath = (_c = this.borderClipPath) !== null && _c !== void 0 ? _c : new Path2D();\n        this.borderClipPath.clear({\n          trackChanges: true\n        });\n        this.borderClipPath.rect(x, y, w, h);\n        borderPath.rect(x, y, w, h);\n      }\n    } else {\n      // No borderPath needed, and thus no clipPath needed either. Fill to full extent of\n      // Rect.\n      this.borderClipPath = undefined;\n      path.rect(x, y, w, h);\n    }\n    this.effectiveStrokeWidth = strokeWidth;\n    this.lastUpdatePathStrokeWidth = strokeWidth;\n    this.microPixelEffectOpacity = microPixelEffectOpacity;\n  }\n  computeBBox() {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this;\n    return new BBox(x, y, width, height);\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const bbox = this.computeBBox();\n    return bbox.containsPoint(point.x, point.y);\n  }\n  applyFillAlpha(ctx) {\n    const {\n      fillOpacity,\n      microPixelEffectOpacity,\n      opacity\n    } = this;\n    const {\n      globalAlpha\n    } = ctx;\n    ctx.globalAlpha = globalAlpha * opacity * fillOpacity * microPixelEffectOpacity;\n  }\n  renderStroke(ctx) {\n    const {\n      stroke,\n      effectiveStrokeWidth,\n      borderPath,\n      borderClipPath,\n      opacity,\n      microPixelEffectOpacity\n    } = this;\n    const borderActive = !!stroke && !!effectiveStrokeWidth;\n    if (borderActive) {\n      const {\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        lineCap,\n        lineJoin\n      } = this;\n      if (borderClipPath) {\n        // strokeWidth is larger than width or height, so use clipping to render correctly.\n        // This is the simplest way to achieve the correct rendering due to nuances with ~0\n        // width/height lines in Canvas operations.\n        borderClipPath.draw(ctx);\n        ctx.clip();\n      }\n      borderPath.draw(ctx);\n      const {\n        globalAlpha\n      } = ctx;\n      ctx.strokeStyle = stroke;\n      ctx.globalAlpha = globalAlpha * opacity * strokeOpacity * microPixelEffectOpacity;\n      ctx.lineWidth = effectiveStrokeWidth;\n      if (lineDash) {\n        ctx.setLineDash(lineDash);\n      }\n      if (lineDashOffset) {\n        ctx.lineDashOffset = lineDashOffset;\n      }\n      if (lineCap) {\n        ctx.lineCap = lineCap;\n      }\n      if (lineJoin) {\n        ctx.lineJoin = lineJoin;\n      }\n      ctx.stroke();\n      ctx.globalAlpha = globalAlpha;\n    }\n  }\n}\nRect.className = 'Rect';\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Rect.prototype, \"x\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Rect.prototype, \"y\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Rect.prototype, \"width\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Rect.prototype, \"height\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Number)], Rect.prototype, \"radius\", void 0);\n__decorate([ScenePathChangeDetection(), __metadata(\"design:type\", Boolean)], Rect.prototype, \"crisp\", void 0);\nclass Image extends Node {\n  constructor(sourceImage) {\n    super();\n    this.x = 0;\n    this.y = 0;\n    this.width = 0;\n    this.height = 0;\n    this.opacity = 1;\n    this.sourceImage = sourceImage;\n  }\n  render(renderCtx) {\n    const {\n      ctx,\n      forceRender,\n      stats\n    } = renderCtx;\n    if (this.dirty === RedrawType.NONE && !forceRender) {\n      if (stats) stats.nodesSkipped++;\n      return;\n    }\n    this.computeTransformMatrix();\n    this.matrix.toContext(ctx);\n    const image = this.sourceImage;\n    ctx.globalAlpha = this.opacity;\n    ctx.drawImage(image, 0, 0, image.width, image.height, this.x, this.y, this.width, this.height);\n    super.render(renderCtx);\n  }\n}\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Number)], Image.prototype, \"x\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Number)], Image.prototype, \"y\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Number)], Image.prototype, \"width\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Number)], Image.prototype, \"height\", void 0);\n__decorate([SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Number)], Image.prototype, \"opacity\", void 0);\nconst motion = Object.assign(Object.assign({}, fromToMotion$1), resetMotion$1);\nvar integratedChartsScene = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  motion: motion,\n  Caption: Caption,\n  DropShadow: DropShadow,\n  Group: Group,\n  Scene: Scene,\n  Node: Node,\n  get PointerEvents() {\n    return PointerEvents;\n  },\n  get RedrawType() {\n    return RedrawType;\n  },\n  SceneChangeDetection: SceneChangeDetection,\n  Selection: Selection,\n  Arc: Arc,\n  Line: Line,\n  LinearGradientFill: LinearGradientFill,\n  Path: Path,\n  ScenePathChangeDetection: ScenePathChangeDetection,\n  Rect: Rect,\n  Sector: Sector,\n  Shape: Shape,\n  Text: Text,\n  getFont: getFont,\n  ContinuousScale: ContinuousScale,\n  BandScale: BandScale,\n  LinearScale: LinearScale,\n  toRadians: toRadians,\n  Label: Label,\n  Marker: Marker,\n  getMarker: getMarker,\n  Circle: Circle,\n  Diamond: Diamond,\n  Square: Square,\n  Triangle: Triangle,\n  Tooltip: Tooltip,\n  toTooltipHtml: toTooltipHtml,\n  BBox: BBox,\n  nearestSquared: nearestSquared,\n  nearestSquaredInContainer: nearestSquaredInContainer,\n  HdpiCanvas: HdpiCanvas,\n  Image: Image,\n  Path2D: Path2D,\n  easing: easing\n});\nconst DEFAULT_DIRECTION_KEYS = {\n  [ChartAxisDirection.X]: ['xKey'],\n  [ChartAxisDirection.Y]: ['yKey']\n};\nconst DEFAULT_DIRECTION_NAMES = {\n  [ChartAxisDirection.X]: ['xName'],\n  [ChartAxisDirection.Y]: ['yName']\n};\nclass CartesianSeriesNodeClickEvent extends SeriesNodeClickEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.xKey = series.xKey;\n    this.yKey = series.yKey;\n  }\n}\nclass CartesianSeries extends DataModelSeries {\n  get contextNodeData() {\n    return this._contextNodeData.slice();\n  }\n  constructor(_a) {\n    var {\n        pathsPerSeries = 1,\n        hasMarkers = false,\n        hasHighlightedLabels = false,\n        pathsZIndexSubOrderOffset = [],\n        directionKeys = DEFAULT_DIRECTION_KEYS,\n        directionNames = DEFAULT_DIRECTION_NAMES,\n        datumSelectionGarbageCollection = true,\n        markerSelectionGarbageCollection = true,\n        animationResetFns\n      } = _a,\n      otherOpts = __rest(_a, [\"pathsPerSeries\", \"hasMarkers\", \"hasHighlightedLabels\", \"pathsZIndexSubOrderOffset\", \"directionKeys\", \"directionNames\", \"datumSelectionGarbageCollection\", \"markerSelectionGarbageCollection\", \"animationResetFns\"]);\n    super(Object.assign({\n      directionKeys,\n      directionNames,\n      useSeriesGroupLayer: true,\n      canHaveAxes: true\n    }, otherOpts));\n    this.legendItemName = undefined;\n    this._contextNodeData = [];\n    this.NodeClickEvent = CartesianSeriesNodeClickEvent;\n    this.highlightSelection = Selection.select(this.highlightNode, () => this.opts.hasMarkers ? this.markerFactory() : this.nodeFactory());\n    this.highlightLabelSelection = Selection.select(this.highlightLabel, Text);\n    this.annotationSelections = new Set();\n    this.subGroups = [];\n    this.subGroupId = 0;\n    this.debug = Debug.create();\n    this.opts = {\n      pathsPerSeries,\n      hasMarkers,\n      hasHighlightedLabels,\n      pathsZIndexSubOrderOffset,\n      directionKeys,\n      directionNames,\n      animationResetFns,\n      datumSelectionGarbageCollection,\n      markerSelectionGarbageCollection\n    };\n    this.animationState = new StateMachine('empty', {\n      empty: {\n        update: {\n          target: 'ready',\n          action: data => this.animateEmptyUpdateReady(data)\n        }\n      },\n      ready: {\n        updateData: 'waiting',\n        clear: 'clearing',\n        highlight: data => this.animateReadyHighlight(data),\n        highlightMarkers: data => this.animateReadyHighlightMarkers(data),\n        resize: data => this.animateReadyResize(data)\n      },\n      waiting: {\n        update: {\n          target: 'ready',\n          action: data => this.animateWaitingUpdateReady(data)\n        }\n      },\n      clearing: {\n        update: {\n          target: 'empty',\n          action: data => this.animateClearingUpdateEmpty(data)\n        }\n      }\n    }, () => this.checkProcessedDataAnimatable());\n  }\n  addChartEventListeners() {\n    this.ctx.chartEventManager.addListener('legend-item-click', event => this.onLegendItemClick(event));\n    this.ctx.chartEventManager.addListener('legend-item-double-click', event => this.onLegendItemDoubleClick(event));\n  }\n  destroy() {\n    super.destroy();\n    this._contextNodeData.splice(0, this._contextNodeData.length);\n    this.subGroups.splice(0, this.subGroups.length);\n  }\n  update({\n    seriesRect\n  }) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        visible,\n        _contextNodeData: previousContextData\n      } = this;\n      const {\n        series\n      } = (_b = (_a = this.ctx.highlightManager) === null || _a === void 0 ? void 0 : _a.getActiveHighlight()) !== null && _b !== void 0 ? _b : {};\n      const seriesHighlighted = series ? series === this : undefined;\n      const resize = this.checkResize(seriesRect);\n      const highlightItems = yield this.updateHighlightSelection(seriesHighlighted);\n      yield this.updateSelections(visible);\n      yield this.updateNodes(highlightItems, seriesHighlighted, visible);\n      const animationData = this.getAnimationData(seriesRect, previousContextData);\n      if (resize) {\n        this.animationState.transition('resize', animationData);\n      }\n      this.animationState.transition('update', animationData);\n    });\n  }\n  updateSelections(anySeriesItemEnabled) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!anySeriesItemEnabled && this.ctx.animationManager.isSkipped()) {\n        return;\n      }\n      if (!this.nodeDataRefresh && !this.isPathOrSelectionDirty()) {\n        return;\n      }\n      if (this.nodeDataRefresh) {\n        this.nodeDataRefresh = false;\n        this.debug(`CartesianSeries.updateSelections() - calling createNodeData() for`, this.id);\n        this._contextNodeData = yield this.createNodeData();\n        const animationValid = this.isProcessedDataAnimatable();\n        this._contextNodeData.forEach(nodeData => {\n          var _a;\n          (_a = nodeData.animationValid) !== null && _a !== void 0 ? _a : nodeData.animationValid = animationValid;\n        });\n        yield this.updateSeriesGroups();\n        const {\n          dataModel,\n          processedData\n        } = this;\n        if (dataModel !== undefined && processedData !== undefined) {\n          this.dispatch('data-update', {\n            dataModel,\n            processedData\n          });\n        }\n      }\n      yield Promise.all(this.subGroups.map((g, i) => this.updateSeriesGroupSelections(g, i)));\n    });\n  }\n  updateSeriesGroupSelections(subGroup, seriesIdx, seriesHighlighted) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        datumSelection,\n        labelSelection,\n        markerSelection,\n        paths\n      } = subGroup;\n      const contextData = this._contextNodeData[seriesIdx];\n      const {\n        nodeData,\n        labelData,\n        itemId\n      } = contextData;\n      yield this.updatePaths({\n        seriesHighlighted,\n        itemId,\n        contextData,\n        paths,\n        seriesIdx\n      });\n      subGroup.datumSelection = yield this.updateDatumSelection({\n        nodeData,\n        datumSelection,\n        seriesIdx\n      });\n      subGroup.labelSelection = yield this.updateLabelSelection({\n        labelData,\n        labelSelection,\n        seriesIdx\n      });\n      if (markerSelection) {\n        subGroup.markerSelection = yield this.updateMarkerSelection({\n          nodeData,\n          markerSelection,\n          seriesIdx\n        });\n      }\n    });\n  }\n  markerFactory() {\n    const MarkerShape = getMarker();\n    return new MarkerShape();\n  }\n  updateSeriesGroups() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        _contextNodeData: contextNodeData,\n        contentGroup,\n        subGroups,\n        opts: {\n          pathsPerSeries,\n          hasMarkers,\n          datumSelectionGarbageCollection,\n          markerSelectionGarbageCollection\n        }\n      } = this;\n      if (contextNodeData.length === subGroups.length) {\n        return;\n      }\n      if (contextNodeData.length < subGroups.length) {\n        subGroups.splice(contextNodeData.length).forEach(({\n          dataNodeGroup,\n          markerGroup,\n          labelGroup,\n          paths\n        }) => {\n          contentGroup.removeChild(dataNodeGroup);\n          if (markerGroup) {\n            contentGroup.removeChild(markerGroup);\n          }\n          if (labelGroup) {\n            contentGroup.removeChild(labelGroup);\n          }\n          for (const path of paths) {\n            contentGroup.removeChild(path);\n          }\n        });\n      }\n      const totalGroups = contextNodeData.length;\n      while (totalGroups > subGroups.length) {\n        const layer = false;\n        const subGroupId = this.subGroupId++;\n        const dataNodeGroup = new Group({\n          name: `${this.id}-series-sub${subGroupId}-dataNodes`,\n          layer,\n          zIndex: Layers.SERIES_LAYER_ZINDEX,\n          zIndexSubOrder: this.getGroupZIndexSubOrder('data', subGroupId)\n        });\n        const markerGroup = hasMarkers ? new Group({\n          name: `${this.id}-series-sub${this.subGroupId++}-markers`,\n          layer,\n          zIndex: Layers.SERIES_LAYER_ZINDEX,\n          zIndexSubOrder: this.getGroupZIndexSubOrder('marker', subGroupId)\n        }) : undefined;\n        const labelGroup = new Group({\n          name: `${this.id}-series-sub${this.subGroupId++}-labels`,\n          layer,\n          zIndex: Layers.SERIES_LABEL_ZINDEX,\n          zIndexSubOrder: this.getGroupZIndexSubOrder('labels', subGroupId)\n        });\n        contentGroup.appendChild(dataNodeGroup);\n        contentGroup.appendChild(labelGroup);\n        if (markerGroup) {\n          contentGroup.appendChild(markerGroup);\n        }\n        const paths = [];\n        for (let index = 0; index < pathsPerSeries; index++) {\n          paths[index] = new Path();\n          paths[index].zIndex = Layers.SERIES_LAYER_ZINDEX;\n          paths[index].zIndexSubOrder = this.getGroupZIndexSubOrder('paths', index);\n          contentGroup.appendChild(paths[index]);\n        }\n        subGroups.push({\n          paths,\n          dataNodeGroup,\n          markerGroup,\n          labelGroup,\n          labelSelection: Selection.select(labelGroup, Text),\n          datumSelection: Selection.select(dataNodeGroup, () => this.nodeFactory(), datumSelectionGarbageCollection),\n          markerSelection: markerGroup ? Selection.select(markerGroup, () => this.markerFactory(), markerSelectionGarbageCollection) : undefined\n        });\n      }\n    });\n  }\n  getGroupZIndexSubOrder(type, subIndex = 0) {\n    var _a;\n    const result = super.getGroupZIndexSubOrder(type, subIndex);\n    if (type === 'paths') {\n      const pathOffset = (_a = this.opts.pathsZIndexSubOrderOffset[subIndex]) !== null && _a !== void 0 ? _a : 0;\n      const superFn = result[0];\n      if (typeof superFn === 'function') {\n        result[0] = () => +superFn() + pathOffset;\n      } else {\n        result[0] = +superFn + pathOffset;\n      }\n    }\n    return result;\n  }\n  updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        highlightSelection,\n        highlightLabelSelection,\n        opts: {\n          hasMarkers,\n          hasHighlightedLabels\n        }\n      } = this;\n      const animationEnabled = !this.ctx.animationManager.isSkipped();\n      const visible = this.visible && ((_a = this._contextNodeData) === null || _a === void 0 ? void 0 : _a.length) > 0 && anySeriesItemEnabled;\n      this.rootGroup.visible = animationEnabled || visible;\n      this.contentGroup.visible = animationEnabled || visible;\n      this.highlightGroup.visible = (animationEnabled || visible) && !!seriesHighlighted;\n      const subGroupOpacity = this.getOpacity();\n      if (hasMarkers) {\n        yield this.updateMarkerNodes({\n          markerSelection: highlightSelection,\n          isHighlight: true,\n          seriesIdx: -1\n        });\n        this.animationState.transition('highlightMarkers', highlightSelection);\n      } else {\n        yield this.updateDatumNodes({\n          datumSelection: highlightSelection,\n          isHighlight: true,\n          seriesIdx: -1\n        });\n        this.animationState.transition('highlight', highlightSelection);\n      }\n      if (hasHighlightedLabels) {\n        yield this.updateLabelNodes({\n          labelSelection: highlightLabelSelection,\n          seriesIdx: -1\n        });\n      }\n      yield Promise.all(this.subGroups.map((subGroup, seriesIdx) => __awaiter(this, void 0, void 0, function* () {\n        const {\n          dataNodeGroup,\n          markerGroup,\n          datumSelection,\n          labelSelection,\n          markerSelection,\n          paths,\n          labelGroup\n        } = subGroup;\n        const {\n          itemId\n        } = this.contextNodeData[seriesIdx];\n        const subGroupVisible = visible;\n        dataNodeGroup.opacity = subGroupOpacity;\n        dataNodeGroup.visible = animationEnabled || subGroupVisible;\n        labelGroup.visible = subGroupVisible;\n        if (markerGroup) {\n          markerGroup.opacity = subGroupOpacity;\n          markerGroup.zIndex = dataNodeGroup.zIndex >= Layers.SERIES_LAYER_ZINDEX ? dataNodeGroup.zIndex : dataNodeGroup.zIndex + 1;\n          markerGroup.visible = subGroupVisible;\n        }\n        if (labelGroup) {\n          labelGroup.opacity = subGroupOpacity;\n        }\n        yield this.updatePathNodes({\n          seriesHighlighted,\n          itemId,\n          paths,\n          seriesIdx,\n          opacity: subGroupOpacity,\n          visible: subGroupVisible,\n          animationEnabled\n        });\n        if (!dataNodeGroup.visible) {\n          return;\n        }\n        yield this.updateDatumNodes({\n          datumSelection,\n          highlightedItems,\n          isHighlight: false,\n          seriesIdx\n        });\n        yield this.updateLabelNodes({\n          labelSelection,\n          seriesIdx\n        });\n        if (hasMarkers && markerSelection) {\n          yield this.updateMarkerNodes({\n            markerSelection,\n            isHighlight: false,\n            seriesIdx\n          });\n        }\n      })));\n    });\n  }\n  getHighlightLabelData(labelData, highlightedItem) {\n    const labelItem = labelData.find(ld => ld.datum === highlightedItem.datum && ld.itemId === highlightedItem.itemId);\n    return labelItem ? [labelItem] : undefined;\n  }\n  getHighlightData(_nodeData, highlightedItem) {\n    return highlightedItem ? [highlightedItem] : undefined;\n  }\n  updateHighlightSelection(seriesHighlighted) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        highlightSelection,\n        highlightLabelSelection,\n        _contextNodeData: contextNodeData\n      } = this;\n      const highlightedDatum = (_a = this.ctx.highlightManager) === null || _a === void 0 ? void 0 : _a.getActiveHighlight();\n      const item = seriesHighlighted && (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.datum) ? highlightedDatum : undefined;\n      let labelItems;\n      let highlightItems;\n      if (item != null) {\n        const labelsEnabled = this.isLabelEnabled();\n        for (const {\n          labelData,\n          nodeData\n        } of contextNodeData) {\n          highlightItems = this.getHighlightData(nodeData, item);\n          labelItems = labelsEnabled ? this.getHighlightLabelData(labelData, item) : undefined;\n          if ((!labelsEnabled || labelItems != null) && highlightItems != null) {\n            break;\n          }\n        }\n      }\n      this.highlightSelection = yield this.updateHighlightSelectionItem({\n        items: highlightItems,\n        highlightSelection\n      });\n      this.highlightLabelSelection = yield this.updateHighlightSelectionLabel({\n        items: labelItems,\n        highlightLabelSelection\n      });\n      return highlightItems;\n    });\n  }\n  pickNodeExactShape(point) {\n    var _a;\n    const result = super.pickNodeExactShape(point);\n    if (result) {\n      return result;\n    }\n    const {\n      x,\n      y\n    } = point;\n    const {\n      opts: {\n        hasMarkers\n      }\n    } = this;\n    for (const {\n      dataNodeGroup,\n      markerGroup\n    } of this.subGroups) {\n      let match = dataNodeGroup.pickNode(x, y);\n      if (!match && hasMarkers) {\n        match = markerGroup === null || markerGroup === void 0 ? void 0 : markerGroup.pickNode(x, y);\n      }\n      if (match) {\n        break;\n      }\n    }\n    {\n      for (const mod of this.moduleMap) {\n        const {\n          datum\n        } = (_a = mod.pickNodeExact(point)) !== null && _a !== void 0 ? _a : {};\n        if (datum !== undefined) {\n          return {\n            datum,\n            distance: 0\n          };\n        }\n      }\n    }\n  }\n  pickNodeClosestDatum(point) {\n    var _a, _b;\n    const {\n      x,\n      y\n    } = point;\n    const {\n      axes,\n      rootGroup,\n      _contextNodeData: contextNodeData\n    } = this;\n    const xAxis = axes[ChartAxisDirection.X];\n    const yAxis = axes[ChartAxisDirection.Y];\n    const hitPoint = rootGroup.transformPoint(x, y);\n    let minDistance = Infinity;\n    let closestDatum;\n    for (const context of contextNodeData) {\n      for (const datum of context.nodeData) {\n        const {\n          point: {\n            x: datumX = NaN,\n            y: datumY = NaN\n          } = {}\n        } = datum;\n        if (isNaN(datumX) || isNaN(datumY)) {\n          continue;\n        }\n        const isInRange = (xAxis === null || xAxis === void 0 ? void 0 : xAxis.inRange(datumX)) && (yAxis === null || yAxis === void 0 ? void 0 : yAxis.inRange(datumY));\n        if (!isInRange) {\n          continue;\n        }\n        // No need to use Math.sqrt() since x < y implies Math.sqrt(x) < Math.sqrt(y) for\n        // values > 1\n        const distance = Math.max(Math.pow(hitPoint.x - datumX, 2) + Math.pow(hitPoint.y - datumY, 2), 0);\n        if (distance < minDistance) {\n          minDistance = distance;\n          closestDatum = datum;\n        }\n      }\n    }\n    for (const mod of this.moduleMap) {\n      const modPick = mod.pickNodeNearest(point);\n      if (modPick !== undefined && modPick.distanceSquared < minDistance) {\n        minDistance = modPick.distanceSquared;\n        closestDatum = modPick.datum;\n        break;\n      }\n    }\n    if (closestDatum) {\n      const distance = Math.max(Math.sqrt(minDistance) - ((_b = (_a = closestDatum.point) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0), 0);\n      return {\n        datum: closestDatum,\n        distance\n      };\n    }\n  }\n  pickNodeMainAxisFirst(point, requireCategoryAxis) {\n    var _a, _b;\n    const {\n      x,\n      y\n    } = point;\n    const {\n      axes,\n      rootGroup,\n      _contextNodeData: contextNodeData\n    } = this;\n    const xAxis = axes[ChartAxisDirection.X];\n    const yAxis = axes[ChartAxisDirection.Y];\n    // Prefer to start search with any available category axis.\n    const directions = [xAxis, yAxis].filter(a => a instanceof CategoryAxis).map(a => a.direction);\n    if (requireCategoryAxis && directions.length === 0) {\n      return;\n    }\n    // Default to X-axis unless we found a suitable category axis.\n    const [primaryDirection = ChartAxisDirection.X] = directions;\n    const hitPoint = rootGroup.transformPoint(x, y);\n    const hitPointCoords = primaryDirection === ChartAxisDirection.X ? [hitPoint.x, hitPoint.y] : [hitPoint.y, hitPoint.x];\n    const minDistance = [Infinity, Infinity];\n    let closestDatum;\n    for (const context of contextNodeData) {\n      for (const datum of context.nodeData) {\n        const {\n          point: {\n            x: datumX = NaN,\n            y: datumY = NaN\n          } = {}\n        } = datum;\n        if (isNaN(datumX) || isNaN(datumY)) {\n          continue;\n        }\n        const isInRange = (xAxis === null || xAxis === void 0 ? void 0 : xAxis.inRange(datumX)) && (yAxis === null || yAxis === void 0 ? void 0 : yAxis.inRange(datumY));\n        if (!isInRange) {\n          continue;\n        }\n        const point = primaryDirection === ChartAxisDirection.X ? [datumX, datumY] : [datumY, datumX];\n        // Compare distances from most significant dimension to least.\n        let newMinDistance = true;\n        for (let i = 0; i < point.length; i++) {\n          const dist = Math.abs(point[i] - hitPointCoords[i]);\n          if (dist > minDistance[i]) {\n            newMinDistance = false;\n            break;\n          }\n          if (dist < minDistance[i]) {\n            minDistance[i] = dist;\n            minDistance.fill(Infinity, i + 1, minDistance.length);\n          }\n        }\n        if (newMinDistance) {\n          closestDatum = datum;\n        }\n      }\n    }\n    if (closestDatum) {\n      let closestDistanceSquared = Math.max(Math.pow(minDistance[0], 2) + Math.pow(minDistance[1], 2) - ((_b = (_a = closestDatum.point) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0), 0);\n      for (const mod of this.moduleMap) {\n        const modPick = mod.pickNodeMainAxisFirst(point);\n        if (modPick !== undefined && modPick.distanceSquared < closestDistanceSquared) {\n          closestDatum = modPick.datum;\n          closestDistanceSquared = modPick.distanceSquared;\n          break;\n        }\n      }\n      return {\n        datum: closestDatum,\n        distance: Math.sqrt(closestDistanceSquared)\n      };\n    }\n  }\n  onLegendItemClick(event) {\n    const {\n      enabled,\n      itemId,\n      series,\n      legendItemName\n    } = event;\n    const matchedLegendItemName = this.legendItemName != null && this.legendItemName === legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      this.toggleSeriesItem(itemId, enabled);\n    }\n  }\n  onLegendItemDoubleClick(event) {\n    const {\n      enabled,\n      itemId,\n      series,\n      numVisibleItems,\n      legendItemName\n    } = event;\n    const totalVisibleItems = Object.values(numVisibleItems).reduce((p, v) => p + v, 0);\n    const matchedLegendItemName = this.legendItemName != null && this.legendItemName === legendItemName;\n    if (series.id === this.id || matchedLegendItemName) {\n      // Double-clicked item should always become visible.\n      this.toggleSeriesItem(itemId, true);\n    } else if (enabled && totalVisibleItems === 1) {\n      // Other items should become visible if there is only one existing visible item.\n      this.toggleSeriesItem(itemId, true);\n    } else {\n      // Disable other items if not exactly one enabled.\n      this.toggleSeriesItem(itemId, false);\n    }\n  }\n  isPathOrSelectionDirty() {\n    // Override point to allow more sophisticated dirty selection detection.\n    return false;\n  }\n  getLabelData() {\n    return [];\n  }\n  shouldFlipXY() {\n    return false;\n  }\n  /**\r\n   * Get the minimum bounding box that contains any adjacent two nodes. The axes are treated independently, so this\r\n   * may not represent the same two points for both directions. The dimensions represent the greatest distance\r\n   * between any two adjacent nodes.\r\n   */\n  getMinRect() {\n    const [context] = this._contextNodeData;\n    if (!context || context.nodeData.length == 0) return;\n    const width = context.nodeData.map(({\n      midPoint\n    }) => {\n      var _a;\n      return (_a = midPoint === null || midPoint === void 0 ? void 0 : midPoint.x) !== null && _a !== void 0 ? _a : 0;\n    }).sort((a, b) => a - b).reduce((max, x, i, array) => i > 0 ? Math.max(max, x - array[i - 1]) : max, 0);\n    const height = context.nodeData.map(({\n      midPoint\n    }) => {\n      var _a;\n      return (_a = midPoint === null || midPoint === void 0 ? void 0 : midPoint.y) !== null && _a !== void 0 ? _a : 0;\n    }).sort((a, b) => a - b).reduce((max, y, i, array) => i > 0 ? Math.max(max, y - array[i - 1]) : max, 0);\n    return new BBox(0, 0, width, height);\n  }\n  updateHighlightSelectionItem(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        opts: {\n          hasMarkers\n        }\n      } = this;\n      const {\n        items,\n        highlightSelection\n      } = opts;\n      const nodeData = items !== null && items !== void 0 ? items : [];\n      if (hasMarkers) {\n        const markerSelection = highlightSelection;\n        return this.updateMarkerSelection({\n          nodeData,\n          markerSelection,\n          seriesIdx: -1\n        });\n      } else {\n        return this.updateDatumSelection({\n          nodeData,\n          datumSelection: highlightSelection,\n          seriesIdx: -1\n        });\n      }\n    });\n  }\n  updateHighlightSelectionLabel(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        items,\n        highlightLabelSelection\n      } = opts;\n      const labelData = items !== null && items !== void 0 ? items : [];\n      return this.updateLabelSelection({\n        labelData,\n        labelSelection: highlightLabelSelection,\n        seriesIdx: -1\n      });\n    });\n  }\n  updateDatumSelection(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Override point for sub-classes.\n      return opts.datumSelection;\n    });\n  }\n  updateDatumNodes(_opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Override point for sub-classes.\n    });\n  }\n  updateMarkerSelection(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Override point for sub-classes.\n      return opts.markerSelection;\n    });\n  }\n  updateMarkerNodes(_opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Override point for sub-classes.\n    });\n  }\n  updatePaths(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // Override point for sub-classes.\n      opts.paths.forEach(p => p.visible = false);\n    });\n  }\n  updatePathNodes(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        paths,\n        opacity,\n        visible\n      } = opts;\n      for (const path of paths) {\n        path.opacity = opacity;\n        path.visible = visible;\n      }\n    });\n  }\n  resetAllAnimation(data) {\n    var _a, _b;\n    const {\n      path,\n      datum,\n      label,\n      marker\n    } = (_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.animationResetFns) !== null && _b !== void 0 ? _b : {};\n    // Stop any running animations by prefix convention.\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    if (path) {\n      data.paths.forEach(paths => {\n        resetMotion(paths, path);\n      });\n    }\n    if (datum) {\n      resetMotion(data.datumSelections, datum);\n    }\n    if (label) {\n      resetMotion(data.labelSelections, label);\n    }\n    if (marker) {\n      resetMotion(data.markerSelections, marker);\n    }\n    if (data.contextData.some(d => d.animationValid === false)) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  animateEmptyUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateWaitingUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateReadyHighlight(data) {\n    var _a, _b;\n    const {\n      datum\n    } = (_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.animationResetFns) !== null && _b !== void 0 ? _b : {};\n    if (datum) {\n      resetMotion([data], datum);\n    }\n  }\n  animateReadyHighlightMarkers(data) {\n    var _a, _b;\n    const {\n      marker\n    } = (_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.animationResetFns) !== null && _b !== void 0 ? _b : {};\n    if (marker) {\n      resetMotion([data], marker);\n    }\n  }\n  animateReadyResize(data) {\n    this.resetAllAnimation(data);\n  }\n  animateClearingUpdateEmpty(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animationTransitionClear() {\n    this.animationState.transition('clear', this.getAnimationData());\n  }\n  getAnimationData(seriesRect, previousContextData) {\n    const animationData = {\n      datumSelections: this.subGroups.map(({\n        datumSelection\n      }) => datumSelection),\n      markerSelections: this.subGroups.filter(({\n        markerSelection\n      }) => markerSelection !== undefined).map(({\n        markerSelection\n      }) => markerSelection),\n      labelSelections: this.subGroups.map(({\n        labelSelection\n      }) => labelSelection),\n      annotationSelections: [...this.annotationSelections],\n      contextData: this._contextNodeData,\n      previousContextData,\n      paths: this.subGroups.map(({\n        paths\n      }) => paths),\n      seriesRect\n    };\n    return animationData;\n  }\n  calculateScaling() {\n    const result = {};\n    const addScale = direction => {\n      const axis = this.axes[direction];\n      if (!axis) return;\n      if (axis.scale instanceof LogScale) {\n        const {\n          range,\n          domain\n        } = axis.scale;\n        result[direction] = {\n          type: 'log',\n          convert: domain => axis.scale.convert(domain),\n          domain: [domain[0], domain[1]],\n          range: [range[0], range[1]]\n        };\n      } else if (axis.scale instanceof ContinuousScale) {\n        const {\n          range\n        } = axis.scale;\n        const domain = axis.scale.getDomain();\n        result[direction] = {\n          type: 'continuous',\n          domain: [domain[0], domain[1]],\n          range: [range[0], range[1]]\n        };\n      } else if (axis.scale) {\n        const {\n          domain\n        } = axis.scale;\n        result[direction] = {\n          type: 'category',\n          domain,\n          range: domain.map(d => axis.scale.convert(d))\n        };\n      }\n    };\n    addScale(ChartAxisDirection.X);\n    addScale(ChartAxisDirection.Y);\n    return result;\n  }\n}\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], CartesianSeries.prototype, \"legendItemName\", void 0);\nconst directions = ['top', 'right', 'bottom', 'left'];\nclass CartesianChart extends Chart {\n  constructor(specialOverrides, resources) {\n    super(specialOverrides, resources);\n    /** Integrated Charts feature state - not used in Standalone Charts. */\n    this.paired = true;\n    this._lastAxisWidths = {\n      top: 0,\n      bottom: 0,\n      left: 0,\n      right: 0\n    };\n    this._lastVisibility = {\n      crossLines: true,\n      series: true\n    };\n  }\n  performLayout() {\n    const _super = Object.create(null, {\n      performLayout: {\n        get: () => super.performLayout\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const shrinkRect = yield _super.performLayout.call(this);\n      const {\n        animationRect,\n        seriesRect,\n        visibility,\n        clipSeries\n      } = this.updateAxes(shrinkRect);\n      this.seriesRoot.visible = visibility.series;\n      this.seriesRect = seriesRect;\n      this.animationRect = animationRect;\n      this.seriesRoot.translationX = Math.floor(seriesRect.x);\n      this.seriesRoot.translationY = Math.floor(seriesRect.y);\n      const {\n        seriesArea: {\n          padding\n        }\n      } = this;\n      // Recreate padding object to prevent issues with getters in `BBox.shrink()`\n      const seriesPaddedRect = seriesRect.clone().grow({\n        top: padding.top,\n        right: padding.right,\n        bottom: padding.bottom,\n        left: padding.left\n      });\n      this.hoverRect = seriesPaddedRect;\n      this.layoutService.dispatchLayoutComplete({\n        type: 'layout-complete',\n        chart: {\n          width: this.scene.width,\n          height: this.scene.height\n        },\n        clipSeries,\n        series: {\n          rect: seriesRect,\n          paddedRect: seriesPaddedRect,\n          visible: visibility.series,\n          shouldFlipXY: this.shouldFlipXY()\n        },\n        axes: this.axes.map(axis => Object.assign({\n          id: axis.id\n        }, axis.getLayoutState()))\n      });\n      return shrinkRect;\n    });\n  }\n  updateAxes(inputShrinkRect) {\n    var _a;\n    // Start with a good approximation from the last update - this should mean that in many resize\n    // cases that only a single pass is needed \\o/.\n    const axisWidths = Object.assign({}, this._lastAxisWidths);\n    const visibility = Object.assign({}, this._lastVisibility);\n    // Clean any positions which aren't valid with the current axis status (otherwise we end up\n    // never being able to find a stable result).\n    const liveAxisWidths = new Set(this._axes.map(a => a.position));\n    for (const position of Object.keys(axisWidths)) {\n      if (!liveAxisWidths.has(position)) {\n        delete axisWidths[position];\n      }\n    }\n    const stableOutputs = (otherAxisWidths, otherVisibility) => {\n      // Check for new axis positions.\n      if (Object.keys(otherAxisWidths).some(k => axisWidths[k] == null)) {\n        return false;\n      }\n      return visibility.crossLines === otherVisibility.crossLines && visibility.series === otherVisibility.series &&\n      // Check for existing axis positions and equality.\n      Object.entries(axisWidths).every(([p, w]) => {\n        const otherW = otherAxisWidths[p];\n        if (w != null || otherW != null) {\n          return w === otherW;\n        }\n        return true;\n      });\n    };\n    const ceilValues = records => {\n      return Object.entries(records).reduce((out, [key, value]) => {\n        if (value && Math.abs(value) === Infinity) {\n          value = 0;\n        }\n        out[key] = value != null ? Math.ceil(value) : value;\n        return out;\n      }, {});\n    };\n    // Iteratively try to resolve axis widths - since X axis width affects Y axis range,\n    // and vice-versa, we need to iteratively try and find a fit for the axes and their\n    // ticks/labels.\n    let lastPassAxisWidths = {};\n    let lastPassVisibility = {};\n    let clipSeries = false;\n    let seriesRect = (_a = this.seriesRect) === null || _a === void 0 ? void 0 : _a.clone();\n    let count = 0;\n    let primaryTickCounts = {};\n    do {\n      Object.assign(axisWidths, lastPassAxisWidths);\n      Object.assign(visibility, lastPassVisibility);\n      const result = this.updateAxesPass(axisWidths, inputShrinkRect.clone(), seriesRect);\n      lastPassAxisWidths = ceilValues(result.axisWidths);\n      lastPassVisibility = result.visibility;\n      clipSeries = result.clipSeries;\n      seriesRect = result.seriesRect;\n      primaryTickCounts = result.primaryTickCounts;\n      if (count++ > 10) {\n        Logger.warn('unable to find stable axis layout.');\n        break;\n      }\n    } while (!stableOutputs(lastPassAxisWidths, lastPassVisibility));\n    this.axes.forEach(axis => {\n      const {\n        direction\n      } = axis;\n      const primaryTickCount = primaryTickCounts[direction];\n      axis.update(primaryTickCount);\n    });\n    const clipRectPadding = 5;\n    this.axes.forEach(axis => {\n      // update visibility of crosslines\n      axis.setCrossLinesVisible(visibility.crossLines);\n      if (!seriesRect) {\n        return;\n      }\n      axis.clipGrid(seriesRect.x, seriesRect.y, seriesRect.width + clipRectPadding, seriesRect.height + clipRectPadding);\n      switch (axis.position) {\n        case 'left':\n        case 'right':\n          axis.clipTickLines(inputShrinkRect.x, seriesRect.y, inputShrinkRect.width + clipRectPadding, seriesRect.height + clipRectPadding);\n          break;\n        case 'top':\n        case 'bottom':\n          axis.clipTickLines(seriesRect.x, inputShrinkRect.y, seriesRect.width + clipRectPadding, inputShrinkRect.height + clipRectPadding);\n          break;\n      }\n    });\n    this._lastAxisWidths = axisWidths;\n    this._lastVisibility = visibility;\n    return {\n      seriesRect,\n      animationRect: inputShrinkRect,\n      visibility,\n      clipSeries\n    };\n  }\n  updateAxesPass(axisWidths, bounds, lastPassSeriesRect) {\n    const {\n      axes\n    } = this;\n    const visited = {};\n    const newAxisWidths = {};\n    const visibility = {\n      series: true,\n      crossLines: true\n    };\n    let clipSeries = false;\n    const primaryTickCounts = {};\n    const paddedBounds = this.applySeriesPadding(bounds);\n    const crossLinePadding = lastPassSeriesRect ? this.buildCrossLinePadding(axisWidths) : {};\n    const axisBound = this.buildAxisBound(paddedBounds, axisWidths, crossLinePadding, visibility);\n    const seriesRect = this.buildSeriesRect(axisBound, axisWidths);\n    // Set the number of ticks for continuous axes based on the available range\n    // before updating the axis domain via `this.updateAxes()` as the tick count has an effect on the calculated `nice` domain extent\n    axes.forEach(axis => {\n      var _a, _b;\n      const {\n        position = 'left'\n      } = axis;\n      const {\n        clipSeries: newClipSeries,\n        axisThickness,\n        axisOffset\n      } = this.calculateAxisDimensions({\n        axis,\n        seriesRect,\n        paddedBounds,\n        axisWidths,\n        newAxisWidths,\n        primaryTickCounts,\n        clipSeries,\n        addInterAxisPadding: ((_a = visited[position]) !== null && _a !== void 0 ? _a : 0) > 0\n      });\n      visited[position] = ((_b = visited[position]) !== null && _b !== void 0 ? _b : 0) + 1;\n      clipSeries = clipSeries || newClipSeries;\n      this.positionAxis({\n        axis,\n        axisBound,\n        axisOffset,\n        axisThickness,\n        axisWidths,\n        primaryTickCounts,\n        seriesRect\n      });\n    });\n    return {\n      clipSeries,\n      seriesRect,\n      axisWidths: newAxisWidths,\n      visibility,\n      primaryTickCounts\n    };\n  }\n  buildCrossLinePadding(axisWidths) {\n    var _a;\n    const crossLinePadding = {};\n    this.axes.forEach(axis => {\n      if (axis.crossLines) {\n        axis.crossLines.forEach(crossLine => {\n          crossLine.calculatePadding(crossLinePadding);\n        });\n      }\n    });\n    // Reduce cross-line padding to account for overlap with axes.\n    for (const [side, padding = 0] of Object.entries(crossLinePadding)) {\n      crossLinePadding[side] = Math.max(padding - ((_a = axisWidths[side]) !== null && _a !== void 0 ? _a : 0), 0);\n    }\n    return crossLinePadding;\n  }\n  applySeriesPadding(bounds) {\n    const paddedRect = bounds.clone();\n    const reversedAxes = this.axes.slice().reverse();\n    directions.forEach(dir => {\n      const padding = this.seriesArea.padding[dir];\n      const axis = reversedAxes.find(axis => axis.position === dir);\n      if (axis) {\n        axis.seriesAreaPadding = padding;\n      } else {\n        paddedRect.shrink(padding, dir);\n      }\n    });\n    return paddedRect;\n  }\n  buildAxisBound(bounds, axisWidths, crossLinePadding, visibility) {\n    var _a, _b, _c, _d;\n    const result = bounds.clone();\n    const {\n      top = 0,\n      right = 0,\n      bottom = 0,\n      left = 0\n    } = crossLinePadding;\n    const horizontalPadding = left + right;\n    const verticalPadding = top + bottom;\n    const totalWidth = ((_a = axisWidths.left) !== null && _a !== void 0 ? _a : 0) + ((_b = axisWidths.right) !== null && _b !== void 0 ? _b : 0) + horizontalPadding;\n    const totalHeight = ((_c = axisWidths.top) !== null && _c !== void 0 ? _c : 0) + ((_d = axisWidths.bottom) !== null && _d !== void 0 ? _d : 0) + verticalPadding;\n    if (result.width <= totalWidth || result.height <= totalHeight) {\n      // Not enough space for crossLines and series\n      visibility.crossLines = false;\n      visibility.series = false;\n      return result;\n    }\n    result.x += left;\n    result.y += top;\n    result.width -= horizontalPadding;\n    result.height -= verticalPadding;\n    return result;\n  }\n  buildSeriesRect(axisBound, axisWidths) {\n    const result = axisBound.clone();\n    const {\n      top,\n      bottom,\n      left,\n      right\n    } = axisWidths;\n    result.x += left !== null && left !== void 0 ? left : 0;\n    result.y += top !== null && top !== void 0 ? top : 0;\n    result.width -= (left !== null && left !== void 0 ? left : 0) + (right !== null && right !== void 0 ? right : 0);\n    result.height -= (top !== null && top !== void 0 ? top : 0) + (bottom !== null && bottom !== void 0 ? bottom : 0);\n    // Width and height should not be negative.\n    result.width = Math.max(0, result.width);\n    result.height = Math.max(0, result.height);\n    return result;\n  }\n  clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = seriesRect;\n    const clampBounds = [x, y, x + width, y + height];\n    const fn = direction === 1 ? Math.min : Math.max;\n    const compareTo = clampBounds[(dimension === 'x' ? 0 : 1) + (direction === 1 ? 0 : 2)];\n    return fn(value, compareTo);\n  }\n  calculateAxisDimensions(opts) {\n    var _a, _b, _c, _d, _e;\n    const {\n      axis,\n      seriesRect,\n      paddedBounds,\n      axisWidths,\n      newAxisWidths,\n      primaryTickCounts,\n      addInterAxisPadding\n    } = opts;\n    let {\n      clipSeries\n    } = opts;\n    const {\n      position = 'left',\n      direction\n    } = axis;\n    const axisLeftRightRange = axis => {\n      if (axis instanceof CategoryAxis || axis instanceof GroupedCategoryAxis) {\n        return [0, seriesRect.height];\n      }\n      return [seriesRect.height, 0];\n    };\n    const axisOffset = (_a = newAxisWidths[position]) !== null && _a !== void 0 ? _a : 0;\n    switch (position) {\n      case 'top':\n      case 'bottom':\n        axis.range = [0, seriesRect.width];\n        axis.gridLength = seriesRect.height;\n        break;\n      case 'right':\n      case 'left':\n        axis.range = axisLeftRightRange(axis);\n        axis.gridLength = seriesRect.width;\n        break;\n    }\n    const zoom = this.zoomManager.getAxisZoom(axis.id);\n    const {\n      min = 0,\n      max = 1\n    } = zoom !== null && zoom !== void 0 ? zoom : {};\n    axis.visibleRange = [min, max];\n    const rangeClipped = axis.dataDomain.clipped || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1;\n    clipSeries || (clipSeries = rangeClipped);\n    let primaryTickCount = axis.nice ? primaryTickCounts[direction] : undefined;\n    const paddedBoundsCoefficient = 0.3;\n    if (axis.thickness != null && axis.thickness > 0) {\n      axis.maxThickness = axis.thickness;\n    } else if (direction === ChartAxisDirection.Y) {\n      axis.maxThickness = paddedBounds.width * paddedBoundsCoefficient;\n    } else {\n      axis.maxThickness = paddedBounds.height * paddedBoundsCoefficient;\n    }\n    const layout = axis.calculateLayout(primaryTickCount);\n    primaryTickCount = layout.primaryTickCount;\n    primaryTickCounts[direction] = (_b = primaryTickCounts[direction]) !== null && _b !== void 0 ? _b : primaryTickCount;\n    let axisThickness = 0;\n    if (axis.thickness != null && axis.thickness > 0) {\n      axisThickness = axis.thickness;\n    } else {\n      const {\n        bbox\n      } = layout;\n      axisThickness = direction === ChartAxisDirection.X ? bbox.height : bbox.width;\n    }\n    // for multiple axes in the same direction and position, apply padding at the top of each inner axis (i.e. between axes).\n    const axisPadding = 15;\n    if (addInterAxisPadding) {\n      axisThickness += axisPadding;\n    }\n    axisThickness = Math.ceil(axisThickness);\n    newAxisWidths[position] = ((_c = newAxisWidths[position]) !== null && _c !== void 0 ? _c : 0) + axisThickness;\n    axis.gridPadding = ((_d = axisWidths[position]) !== null && _d !== void 0 ? _d : 0) - ((_e = newAxisWidths[position]) !== null && _e !== void 0 ? _e : 0);\n    return {\n      clipSeries,\n      axisThickness,\n      axisOffset,\n      primaryTickCount\n    };\n  }\n  positionAxis(opts) {\n    var _a, _b, _c, _d;\n    const {\n      axis,\n      axisBound,\n      axisWidths,\n      seriesRect,\n      axisOffset,\n      axisThickness\n    } = opts;\n    const {\n      position\n    } = axis;\n    switch (position) {\n      case 'top':\n        axis.translation.x = axisBound.x + ((_a = axisWidths.left) !== null && _a !== void 0 ? _a : 0);\n        axis.translation.y = this.clampToOutsideSeriesRect(seriesRect, axisBound.y + 1 + axisOffset + axisThickness, 'y', 1);\n        break;\n      case 'bottom':\n        axis.translation.x = axisBound.x + ((_b = axisWidths.left) !== null && _b !== void 0 ? _b : 0);\n        axis.translation.y = this.clampToOutsideSeriesRect(seriesRect, axisBound.y + axisBound.height + 1 - axisThickness - axisOffset, 'y', -1);\n        break;\n      case 'left':\n        axis.translation.y = axisBound.y + ((_c = axisWidths.top) !== null && _c !== void 0 ? _c : 0);\n        axis.translation.x = this.clampToOutsideSeriesRect(seriesRect, axisBound.x + axisOffset + axisThickness, 'x', 1);\n        break;\n      case 'right':\n        axis.translation.y = axisBound.y + ((_d = axisWidths.top) !== null && _d !== void 0 ? _d : 0);\n        axis.translation.x = this.clampToOutsideSeriesRect(seriesRect, axisBound.x + axisBound.width - axisThickness - axisOffset, 'x', -1);\n        break;\n    }\n    axis.updatePosition({\n      rotation: toRadians(axis.rotation),\n      sideFlag: axis.label.getSideFlag()\n    });\n  }\n  shouldFlipXY() {\n    // Only flip the xy axes if all the series agree on flipping\n    return !this.series.some(series => !(series instanceof CartesianSeries && series.shouldFlipXY()));\n  }\n}\nCartesianChart.className = 'CartesianChart';\nCartesianChart.type = 'cartesian';\n\n/**\r\n * Proxy class, to allow library users to keep a stable reference to their chart, even if we need\r\n * to switch concrete class (e.g. when switching between CartesianChart vs. PolarChart).\r\n */\nclass AgChartInstanceProxy {\n  static isInstance(x) {\n    var _a;\n    if (x instanceof AgChartInstanceProxy) {\n      // Simple case.\n      return true;\n    }\n    if (((_a = x.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'AgChartInstanceProxy' && x.chart != null) {\n      // instanceof can fail if mixing bundles (e.g. grid all-modules vs. standalone).\n      return true;\n    }\n    return x.chart != null && this.validateImplementation(x);\n  }\n  static validateImplementation(x) {\n    var _a, _b;\n    const chartProps = ['getOptions', 'destroy'];\n    const signatureProps = Object.keys((_b = (_a = x.constructor) === null || _a === void 0 ? void 0 : _a.prototype) !== null && _b !== void 0 ? _b : {});\n    return chartProps.every(prop => signatureProps.includes(prop));\n  }\n  constructor(chart) {\n    this.chart = chart;\n  }\n  getOptions() {\n    return this.chart.getOptions();\n  }\n  destroy() {\n    this.chart.destroy();\n  }\n}\nfunction calculateNiceSecondaryAxis(domain, primaryTickCount) {\n  // Make secondary axis domain nice using strict tick count, matching the tick count from the primary axis.\n  // This is to make the secondary axis grid lines/ tick positions align with the ones from the primary axis.\n  let start = Math.floor(domain[0]);\n  let stop = domain[1];\n  start = calculateNiceStart(start, stop, primaryTickCount);\n  const step = getTickStep(start, stop, primaryTickCount);\n  const segments = primaryTickCount - 1;\n  stop = start + segments * step;\n  const d = [start, stop];\n  const ticks = getTicks(start, step, primaryTickCount);\n  return [d, ticks];\n}\nfunction calculateNiceStart(a, b, count) {\n  const rawStep = Math.abs(b - a) / (count - 1);\n  const order = Math.floor(Math.log10(rawStep));\n  const magnitude = Math.pow(10, order);\n  return Math.floor(a / magnitude) * magnitude;\n}\nfunction getTicks(start, step, count) {\n  // power of the step will be negative if the step is a fraction (between 0 and 1)\n  const stepPower = Math.floor(Math.log10(step));\n  const fractionDigits = step > 0 && step < 1 ? Math.abs(stepPower) : 0;\n  const f = Math.pow(10, fractionDigits);\n  const ticks = new NumericTicks(fractionDigits);\n  for (let i = 0; i < count; i++) {\n    const tick = start + step * i;\n    ticks[i] = Math.round(tick * f) / f;\n  }\n  return ticks;\n}\nfunction getTickStep(start, stop, count) {\n  const segments = count - 1;\n  const rawStep = (stop - start) / segments;\n  return calculateNextNiceStep(rawStep);\n}\nfunction calculateNextNiceStep(rawStep) {\n  const order = Math.floor(Math.log10(rawStep));\n  const magnitude = Math.pow(10, order);\n  // Make order 1\n  const step = rawStep / magnitude * 10;\n  if (step > 0 && step <= 1) {\n    return magnitude / 10;\n  }\n  if (step > 1 && step <= 2) {\n    return 2 * magnitude / 10;\n  }\n  if (step > 1 && step <= 5) {\n    return 5 * magnitude / 10;\n  }\n  if (step > 5 && step <= 10) {\n    return 10 * magnitude / 10;\n  }\n  if (step > 10 && step <= 20) {\n    return 20 * magnitude / 10;\n  }\n  if (step > 20 && step <= 40) {\n    return 40 * magnitude / 10;\n  }\n  if (step > 40 && step <= 50) {\n    return 50 * magnitude / 10;\n  }\n  if (step > 50 && step <= 100) {\n    return 100 * magnitude / 10;\n  }\n  return step;\n}\nclass NumberAxisTick extends AxisTick {\n  constructor() {\n    super(...arguments);\n    this.maxSpacing = NaN;\n  }\n}\n__decorate([Validate(AND(NUMBER_OR_NAN(1), GREATER_THAN('minSpacing'))), Default(NaN), __metadata(\"design:type\", Number)], NumberAxisTick.prototype, \"maxSpacing\", void 0);\nclass NumberAxis extends CartesianAxis {\n  constructor(moduleCtx, scale = new LinearScale()) {\n    super(moduleCtx, scale);\n    this.min = NaN;\n    this.max = NaN;\n  }\n  normaliseDataDomain(d) {\n    const {\n      min,\n      max\n    } = this;\n    const {\n      extent,\n      clipped\n    } = normalisedExtentWithMetadata(d, min, max);\n    return {\n      domain: extent,\n      clipped\n    };\n  }\n  formatDatum(datum) {\n    if (typeof datum === 'number') {\n      return datum.toFixed(2);\n    } else {\n      Logger.warnOnce('data contains Date objects which are being plotted against a number axis, please only use a number axis for numbers.');\n      return String(datum);\n    }\n  }\n  createTick() {\n    return new NumberAxisTick();\n  }\n  updateSecondaryAxisTicks(primaryTickCount) {\n    if (this.dataDomain == null) {\n      throw new Error('AG Charts - dataDomain not calculated, cannot perform tick calculation.');\n    }\n    if (this.dataDomain.domain.length === 0) return [];\n    const [d, ticks] = calculateNiceSecondaryAxis(this.dataDomain.domain, primaryTickCount !== null && primaryTickCount !== void 0 ? primaryTickCount : 0);\n    this.scale.nice = false;\n    this.scale.domain = d;\n    this.scale.update();\n    return ticks;\n  }\n}\nNumberAxis.className = 'NumberAxis';\nNumberAxis.type = 'number';\n__decorate([Validate(AND(NUMBER_OR_NAN(), LESS_THAN('max'))), Default(NaN), __metadata(\"design:type\", Number)], NumberAxis.prototype, \"min\", void 0);\n__decorate([Validate(AND(NUMBER_OR_NAN(), GREATER_THAN('min'))), Default(NaN), __metadata(\"design:type\", Number)], NumberAxis.prototype, \"max\", void 0);\nfunction NON_ZERO_NUMBER() {\n  // Cannot be 0\n  const message = `expecting a non-zero Number`;\n  return predicateWithMessage(v => typeof v === 'number' && v !== 0, message);\n}\nclass LogAxis extends NumberAxis {\n  normaliseDataDomain(d) {\n    const {\n      min,\n      max\n    } = this;\n    const {\n      extent,\n      clipped\n    } = normalisedExtentWithMetadata(d, min, max);\n    const isInverted = extent[0] > extent[1];\n    const crossesZero = extent[0] < 0 && extent[1] > 0;\n    const hasZeroExtent = extent[0] === 0 && extent[1] === 0;\n    const invalidDomain = isInverted || crossesZero || hasZeroExtent;\n    if (invalidDomain) {\n      d = [];\n      if (crossesZero) {\n        Logger.warn(`the data domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.`);\n      } else if (hasZeroExtent) {\n        Logger.warn(`the data domain has 0 extent, no data is rendered.`);\n      }\n    }\n    if (extent[0] === 0) {\n      extent[0] = 1;\n    }\n    if (extent[1] === 0) {\n      extent[1] = -1;\n    }\n    return {\n      domain: extent,\n      clipped\n    };\n  }\n  set base(value) {\n    this.scale.base = value;\n  }\n  get base() {\n    return this.scale.base;\n  }\n  constructor(moduleCtx) {\n    super(moduleCtx, new LogScale());\n    this.min = NaN;\n    this.max = NaN;\n  }\n}\nLogAxis.className = 'LogAxis';\nLogAxis.type = 'log';\n__decorate([Validate(AND(NUMBER_OR_NAN(), LESS_THAN('max'), NON_ZERO_NUMBER())), Default(NaN), __metadata(\"design:type\", Number)], LogAxis.prototype, \"min\", void 0);\n__decorate([Validate(AND(NUMBER_OR_NAN(), GREATER_THAN('min'), NON_ZERO_NUMBER())), Default(NaN), __metadata(\"design:type\", Number)], LogAxis.prototype, \"max\", void 0);\nclass TimeAxisTick extends AxisTick {\n  constructor() {\n    super(...arguments);\n    this.maxSpacing = NaN;\n  }\n}\n__decorate([Validate(AND(NUMBER_OR_NAN(1), GREATER_THAN('minSpacing'))), Default(NaN), __metadata(\"design:type\", Number)], TimeAxisTick.prototype, \"maxSpacing\", void 0);\nclass TimeAxis extends CartesianAxis {\n  constructor(moduleCtx) {\n    super(moduleCtx, new TimeScale());\n    this.datumFormat = '%m/%d/%y, %H:%M:%S';\n    this.min = undefined;\n    this.max = undefined;\n    const {\n      scale\n    } = this;\n    this.refreshScale();\n    this.datumFormatter = scale.tickFormat({\n      specifier: this.datumFormat\n    });\n  }\n  normaliseDataDomain(d) {\n    var _a;\n    let {\n      min,\n      max\n    } = this;\n    let clipped = false;\n    if (typeof min === 'number') {\n      min = new Date(min);\n    }\n    if (typeof max === 'number') {\n      max = new Date(max);\n    }\n    if (d.length > 2) {\n      d = ((_a = extent(d)) !== null && _a !== void 0 ? _a : [0, 1000]).map(x => new Date(x));\n    }\n    if (min instanceof Date) {\n      clipped || (clipped = min > d[0]);\n      d = [min, d[1]];\n    }\n    if (max instanceof Date) {\n      clipped || (clipped = max < d[1]);\n      d = [d[0], max];\n    }\n    if (d[0] > d[1]) {\n      d = [];\n    }\n    return {\n      domain: d,\n      clipped\n    };\n  }\n  createTick() {\n    return new TimeAxisTick();\n  }\n  onLabelFormatChange(ticks, format) {\n    if (format) {\n      super.onLabelFormatChange(ticks, format);\n    } else {\n      // For time axis labels to look nice, even if date format wasn't set.\n      this.labelFormatter = this.scale.tickFormat({\n        ticks\n      });\n    }\n  }\n  formatDatum(datum) {\n    var _a;\n    return (_a = this.moduleCtx.callbackCache.call(this.datumFormatter, datum)) !== null && _a !== void 0 ? _a : String(datum);\n  }\n  calculatePadding(_min, _max) {\n    // numbers in domain correspond to Unix timestamps\n    // automatically expand domain by 1 in forward direction\n    return [0, 1];\n  }\n}\nTimeAxis.className = 'TimeAxis';\nTimeAxis.type = 'time';\n__decorate([Validate(AND(OPT_DATE_OR_DATETIME_MS, LESS_THAN('max'))), __metadata(\"design:type\", Object)], TimeAxis.prototype, \"min\", void 0);\n__decorate([Validate(AND(OPT_DATE_OR_DATETIME_MS, GREATER_THAN('min'))), __metadata(\"design:type\", Object)], TimeAxis.prototype, \"max\", void 0);\nconst AXIS_CONSTRUCTORS = {\n  [NumberAxis.type]: NumberAxis,\n  [CategoryAxis.type]: CategoryAxis,\n  [TimeAxis.type]: TimeAxis,\n  [GroupedCategoryAxis.type]: GroupedCategoryAxis,\n  [LogAxis.type]: LogAxis\n};\nfunction registerAxis(axisType, ctor) {\n  AXIS_CONSTRUCTORS[axisType] = ctor;\n}\nfunction getAxis(axisType, moduleCtx) {\n  const axisConstructor = AXIS_CONSTRUCTORS[axisType];\n  if (axisConstructor) {\n    return new axisConstructor(moduleCtx);\n  }\n  throw new Error(`AG Charts - unknown axis type: ${axisType}`);\n}\nconst AXIS_TYPES = {\n  has(axisType) {\n    return Object.prototype.hasOwnProperty.call(AXIS_CONSTRUCTORS, axisType);\n  },\n  get axesTypes() {\n    return Object.keys(AXIS_CONSTRUCTORS);\n  }\n};\nconst AXIS_THEME_TEMPLATES = {};\nfunction registerAxisThemeTemplate(axisType, theme) {\n  AXIS_THEME_TEMPLATES[axisType] = theme;\n}\nfunction getAxisThemeTemplate(axisType) {\n  var _a;\n  return (_a = AXIS_THEME_TEMPLATES[axisType]) !== null && _a !== void 0 ? _a : {};\n}\nconst EXPECTED_ENTERPRISE_MODULES = [{\n  type: 'root',\n  optionsKey: 'animation',\n  chartTypes: ['cartesian', 'polar', 'hierarchy']\n}, {\n  type: 'root',\n  optionsKey: 'background',\n  chartTypes: ['cartesian', 'polar', 'hierarchy'],\n  optionsInnerKey: 'image'\n}, {\n  type: 'root',\n  optionsKey: 'contextMenu',\n  chartTypes: ['cartesian', 'polar', 'hierarchy']\n}, {\n  type: 'root',\n  optionsKey: 'zoom',\n  chartTypes: ['cartesian']\n}, {\n  type: 'legend',\n  optionsKey: 'gradientLegend',\n  chartTypes: ['cartesian', 'polar', 'hierarchy'],\n  identifier: 'gradient'\n}, {\n  type: 'axis',\n  optionsKey: 'axes[]',\n  chartTypes: ['polar'],\n  identifier: 'angle-category'\n}, {\n  type: 'axis',\n  optionsKey: 'axes[]',\n  chartTypes: ['polar'],\n  identifier: 'angle-number'\n}, {\n  type: 'axis',\n  optionsKey: 'axes[]',\n  chartTypes: ['polar'],\n  identifier: 'radius-category'\n}, {\n  type: 'axis',\n  optionsKey: 'axes[]',\n  chartTypes: ['polar'],\n  identifier: 'radius-number'\n}, {\n  type: 'axis-option',\n  optionsKey: 'crosshair',\n  chartTypes: ['cartesian']\n}, {\n  type: 'series',\n  optionsKey: 'series[]',\n  chartTypes: ['cartesian'],\n  identifier: 'box-plot'\n}, {\n  type: 'series',\n  optionsKey: 'series[]',\n  chartTypes: ['cartesian'],\n  identifier: 'bullet'\n}, {\n  type: 'series',\n  optionsKey: 'series[]',\n  chartTypes: ['cartesian'],\n  identifier: 'heatmap'\n}, {\n  type: 'series',\n  optionsKey: 'series[]',\n  chartTypes: ['polar'],\n  identifier: 'nightingale'\n}, {\n  type: 'series',\n  optionsKey: 'series[]',\n  chartTypes: ['polar'],\n  identifier: 'radar-area'\n}, {\n  type: 'series',\n  optionsKey: 'series[]',\n  chartTypes: ['polar'],\n  identifier: 'radar-line'\n}, {\n  type: 'series',\n  optionsKey: 'series[]',\n  chartTypes: ['polar'],\n  identifier: 'radial-bar'\n}, {\n  type: 'series',\n  optionsKey: 'series[]',\n  chartTypes: ['polar'],\n  identifier: 'radial-column'\n}, {\n  type: 'series',\n  optionsKey: 'series[]',\n  chartTypes: ['cartesian'],\n  identifier: 'range-area'\n}, {\n  type: 'series',\n  optionsKey: 'series[]',\n  chartTypes: ['cartesian'],\n  identifier: 'range-bar'\n}, {\n  type: 'series',\n  optionsKey: 'series[]',\n  chartTypes: ['hierarchy'],\n  identifier: 'sunburst'\n}, {\n  type: 'series',\n  optionsKey: 'series[]',\n  chartTypes: ['hierarchy'],\n  identifier: 'treemap'\n}, {\n  type: 'series',\n  optionsKey: 'series[]',\n  chartTypes: ['cartesian'],\n  identifier: 'waterfall'\n}, {\n  type: 'series-option',\n  optionsKey: 'errorBar',\n  chartTypes: ['cartesian'],\n  identifier: 'error-bars'\n}];\nfunction isEnterpriseSeriesType(type) {\n  return EXPECTED_ENTERPRISE_MODULES.some(s => s.type === 'series' && s.identifier === type);\n}\nfunction getEnterpriseSeriesChartTypes(type) {\n  var _a;\n  return (_a = EXPECTED_ENTERPRISE_MODULES.find(s => s.type === 'series' && s.identifier === type)) === null || _a === void 0 ? void 0 : _a.chartTypes;\n}\nfunction isEnterpriseSeriesTypeLoaded(type) {\n  var _a, _b;\n  return ((_b = (_a = EXPECTED_ENTERPRISE_MODULES.find(s => s.type === 'series' && s.identifier === type)) === null || _a === void 0 ? void 0 : _a.useCount) !== null && _b !== void 0 ? _b : 0) > 0;\n}\nfunction isEnterpriseCartesian(seriesType) {\n  var _a;\n  const type = (_a = getEnterpriseSeriesChartTypes(seriesType)) === null || _a === void 0 ? void 0 : _a.find(v => v === 'cartesian');\n  return type === 'cartesian';\n}\nfunction isEnterprisePolar(seriesType) {\n  var _a;\n  const type = (_a = getEnterpriseSeriesChartTypes(seriesType)) === null || _a === void 0 ? void 0 : _a.find(v => v === 'polar');\n  return type === 'polar';\n}\nfunction isEnterpriseHierarchy(seriesType) {\n  var _a;\n  const type = (_a = getEnterpriseSeriesChartTypes(seriesType)) === null || _a === void 0 ? void 0 : _a.find(v => v === 'hierarchy');\n  return type === 'hierarchy';\n}\nfunction verifyIfModuleExpected(module) {\n  var _a;\n  if (module.packageType !== 'enterprise') {\n    throw new Error('AG Charts - internal configuration error, only enterprise modules need verification.');\n  }\n  const stub = EXPECTED_ENTERPRISE_MODULES.find(s => {\n    return s.type === module.type && s.optionsKey === module.optionsKey && s.identifier === module.identifier && module.chartTypes.every(t => s.chartTypes.includes(t));\n  });\n  if (stub) {\n    (_a = stub.useCount) !== null && _a !== void 0 ? _a : stub.useCount = 0;\n    stub.useCount++;\n  }\n  return stub != null;\n}\nfunction getUnusedExpectedModules() {\n  return EXPECTED_ENTERPRISE_MODULES.filter(({\n    useCount\n  }) => useCount == null || useCount === 0);\n}\nconst LEGEND_KEYS = {\n  category: 'legend'\n};\nfunction registerLegend(type, key, ctr, theme) {\n  LEGEND_KEYS[type] = key;\n  LEGEND_THEME_TEMPLATES[key] = theme;\n}\nconst LEGEND_THEME_TEMPLATES = {};\nfunction getLegendThemeTemplates() {\n  return LEGEND_THEME_TEMPLATES;\n}\nfunction getLegendKeys() {\n  return LEGEND_KEYS;\n}\nclass Background extends BaseModuleInstance {\n  constructor(ctx) {\n    var _a;\n    super();\n    this.node = new Group({\n      name: 'background',\n      zIndex: Layers.SERIES_BACKGROUND_ZINDEX\n    });\n    this.rectNode = new Rect();\n    this.visible = true;\n    this.fill = 'white';\n    // placeholder for enterprise module\n    this.image = undefined;\n    this.node.appendChild(this.rectNode);\n    (_a = ctx.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(this.node);\n    this.destroyFns.push(() => {\n      var _a;\n      return (_a = ctx.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(this.node);\n    }, ctx.layoutService.addListener('layout-complete', e => this.onLayoutComplete(e)));\n  }\n  onLayoutComplete(e) {\n    const {\n      width,\n      height\n    } = e.chart;\n    this.rectNode.width = width;\n    this.rectNode.height = height;\n  }\n}\n__decorate([Validate(BOOLEAN), ProxyPropertyOnWrite('node', 'visible'), __metadata(\"design:type\", Boolean)], Background.prototype, \"visible\", void 0);\n__decorate([Validate(OPT_COLOR_STRING), ProxyPropertyOnWrite('rectNode', 'fill'), __metadata(\"design:type\", String)], Background.prototype, \"fill\", void 0);\nconst BackgroundModule = {\n  type: 'root',\n  optionsKey: 'background',\n  packageType: 'community',\n  chartTypes: ['cartesian', 'polar', 'hierarchy'],\n  instanceConstructor: Background\n};\nclass NavigatorHandle {\n  set fill(value) {\n    this.rh.fill = value;\n  }\n  get fill() {\n    return this.rh.fill;\n  }\n  set stroke(value) {\n    this.rh.stroke = value;\n  }\n  get stroke() {\n    return this.rh.stroke;\n  }\n  set strokeWidth(value) {\n    this.rh.strokeWidth = value;\n  }\n  get strokeWidth() {\n    return this.rh.strokeWidth;\n  }\n  set width(value) {\n    this.rh.width = value;\n  }\n  get width() {\n    return this.rh.width;\n  }\n  set height(value) {\n    this.rh.height = value;\n  }\n  get height() {\n    return this.rh.height;\n  }\n  set gripLineGap(value) {\n    this.rh.gripLineGap = value;\n  }\n  get gripLineGap() {\n    return this.rh.gripLineGap;\n  }\n  set gripLineLength(value) {\n    this.rh.gripLineLength = value;\n  }\n  get gripLineLength() {\n    return this.rh.gripLineLength;\n  }\n  constructor(rangeHandle) {\n    this.rh = rangeHandle;\n  }\n}\nclass NavigatorMask {\n  set fill(value) {\n    this.rm.fill = value;\n  }\n  get fill() {\n    return this.rm.fill;\n  }\n  set stroke(value) {\n    this.rm.stroke = value;\n  }\n  get stroke() {\n    return this.rm.stroke;\n  }\n  set strokeWidth(value) {\n    this.rm.strokeWidth = value;\n  }\n  get strokeWidth() {\n    return this.rm.strokeWidth;\n  }\n  set fillOpacity(value) {\n    this.rm.fillOpacity = value;\n  }\n  get fillOpacity() {\n    return this.rm.fillOpacity;\n  }\n  constructor(rangeMask) {\n    this.rm = rangeMask;\n  }\n}\nclass RangeHandle extends Path {\n  constructor() {\n    super(...arguments);\n    this._fill = '#f2f2f2';\n    this._stroke = '#999999';\n    this._strokeWidth = 1;\n    this._lineCap = 'square';\n    this._centerX = 0;\n    this._centerY = 0;\n    // Use an even number for better looking results.\n    this._width = 8;\n    // Use an even number for better looking results.\n    this._gripLineGap = 2;\n    // Use an even number for better looking results.\n    this._gripLineLength = 8;\n    this._height = 16;\n  }\n  set centerX(value) {\n    if (this._centerX !== value) {\n      this._centerX = value;\n      this.dirtyPath = true;\n    }\n  }\n  get centerX() {\n    return this._centerX;\n  }\n  set centerY(value) {\n    if (this._centerY !== value) {\n      this._centerY = value;\n      this.dirtyPath = true;\n    }\n  }\n  get centerY() {\n    return this._centerY;\n  }\n  set width(value) {\n    if (this._width !== value) {\n      this._width = value;\n      this.dirtyPath = true;\n    }\n  }\n  get width() {\n    return this._width;\n  }\n  set gripLineGap(value) {\n    if (this._gripLineGap !== value) {\n      this._gripLineGap = value;\n      this.dirtyPath = true;\n    }\n  }\n  get gripLineGap() {\n    return this._gripLineGap;\n  }\n  set gripLineLength(value) {\n    if (this._gripLineLength !== value) {\n      this._gripLineLength = value;\n      this.dirtyPath = true;\n    }\n  }\n  get gripLineLength() {\n    return this._gripLineLength;\n  }\n  set height(value) {\n    if (this._height !== value) {\n      this._height = value;\n      this.dirtyPath = true;\n    }\n  }\n  get height() {\n    return this._height;\n  }\n  computeBBox() {\n    const {\n      centerX,\n      centerY,\n      width,\n      height\n    } = this;\n    const x = centerX - width / 2;\n    const y = centerY - height / 2;\n    return new BBox(x, y, width, height);\n  }\n  isPointInPath(x, y) {\n    const point = this.transformPoint(x, y);\n    const bbox = this.computeBBox();\n    return bbox.containsPoint(point.x, point.y);\n  }\n  updatePath() {\n    const {\n      path,\n      centerX,\n      centerY,\n      width,\n      height\n    } = this;\n    path.clear();\n    const x = centerX - width / 2;\n    const y = centerY - height / 2;\n    const ax = this.align(x);\n    const ay = this.align(y);\n    const axw = ax + this.align(x, width);\n    const ayh = ay + this.align(y, height);\n    // Handle.\n    path.moveTo(ax, ay);\n    path.lineTo(axw, ay);\n    path.lineTo(axw, ayh);\n    path.lineTo(ax, ayh);\n    path.lineTo(ax, ay);\n    // Grip lines.\n    const dx = this.gripLineGap / 2;\n    const dy = this.gripLineLength / 2;\n    path.moveTo(this.align(centerX - dx), this.align(centerY - dy));\n    path.lineTo(this.align(centerX - dx), this.align(centerY + dy));\n    path.moveTo(this.align(centerX + dx), this.align(centerY - dy));\n    path.lineTo(this.align(centerX + dx), this.align(centerY + dy));\n  }\n}\nRangeHandle.className = 'RangeHandle';\n__decorate([Validate(COLOR_STRING), __metadata(\"design:type\", Object)], RangeHandle.prototype, \"_fill\", void 0);\n__decorate([Validate(COLOR_STRING), __metadata(\"design:type\", Object)], RangeHandle.prototype, \"_stroke\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], RangeHandle.prototype, \"_strokeWidth\", void 0);\n__decorate([Validate(LINE_CAP), __metadata(\"design:type\", Object)], RangeHandle.prototype, \"_lineCap\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], RangeHandle.prototype, \"_width\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], RangeHandle.prototype, \"_gripLineGap\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], RangeHandle.prototype, \"_gripLineLength\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], RangeHandle.prototype, \"_height\", void 0);\nfunction markDirtyOnChange(newValue, oldValue) {\n  if (newValue !== oldValue) {\n    this.dirtyPath = true;\n  }\n}\nclass RangeMask extends Path {\n  constructor() {\n    super(...arguments);\n    this.x = 0;\n    this.y = 0;\n    this.width = 200;\n    this.height = 30;\n    this.minRange = 0.05;\n    this._min = 0;\n    this._max = 1;\n  }\n  set min(value) {\n    var _a;\n    value = clamp(0, value, this.max - this.minRange);\n    if (this._min !== value && !isNaN(value)) {\n      this._min = value;\n      this.dirtyPath = true;\n      (_a = this.onRangeChange) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n  }\n  get min() {\n    return this._min;\n  }\n  set max(value) {\n    var _a;\n    value = clamp(this.min + this.minRange, value, 1);\n    if (this._max !== value && !isNaN(value)) {\n      this._max = value;\n      this.dirtyPath = true;\n      (_a = this.onRangeChange) === null || _a === void 0 ? void 0 : _a.call(this);\n    }\n  }\n  get max() {\n    return this._max;\n  }\n  computeBBox() {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this;\n    return new BBox(x, y, width, height);\n  }\n  computeVisibleRangeBBox() {\n    const {\n      x,\n      y,\n      width,\n      height,\n      min,\n      max\n    } = this;\n    const minX = x + width * min;\n    const maxX = x + width * max;\n    return new BBox(minX, y, maxX - minX, height);\n  }\n  updatePath() {\n    const {\n      path,\n      x,\n      y,\n      width,\n      height,\n      min,\n      max\n    } = this;\n    path.clear();\n    const ax = this.align(x);\n    const ay = this.align(y);\n    const axw = ax + this.align(x, width);\n    const ayh = ay + this.align(y, height);\n    // Whole range.\n    path.moveTo(ax, ay);\n    path.lineTo(axw, ay);\n    path.lineTo(axw, ayh);\n    path.lineTo(ax, ayh);\n    path.lineTo(ax, ay);\n    const minX = this.align(x + width * min);\n    const maxX = this.align(x + width * max);\n    // Visible range.\n    path.moveTo(minX, ay);\n    path.lineTo(minX, ayh);\n    path.lineTo(maxX, ayh);\n    path.lineTo(maxX, ay);\n    path.lineTo(minX, ay);\n  }\n}\nRangeMask.className = 'RangeMask';\n__decorate([ActionOnSet({\n  changeValue: markDirtyOnChange\n}), Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], RangeMask.prototype, \"x\", void 0);\n__decorate([ActionOnSet({\n  changeValue: markDirtyOnChange\n}), Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], RangeMask.prototype, \"y\", void 0);\n__decorate([ActionOnSet({\n  changeValue: markDirtyOnChange\n}), Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], RangeMask.prototype, \"width\", void 0);\n__decorate([ActionOnSet({\n  changeValue: markDirtyOnChange\n}), Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], RangeMask.prototype, \"height\", void 0);\n__decorate([Validate(NUMBER$1()), __metadata(\"design:type\", Number)], RangeMask.prototype, \"_min\", void 0);\n__decorate([Validate(NUMBER$1()), __metadata(\"design:type\", Number)], RangeMask.prototype, \"_max\", void 0);\nclass RangeSelector extends Group {\n  set x(value) {\n    this.mask.x = value;\n    this.updateHandles();\n  }\n  get x() {\n    return this.mask.x;\n  }\n  set y(value) {\n    this.mask.y = value;\n    this.updateHandles();\n  }\n  get y() {\n    return this.mask.y;\n  }\n  set width(value) {\n    this.mask.width = value;\n    this.updateHandles();\n  }\n  get width() {\n    return this.mask.width;\n  }\n  set height(value) {\n    this.mask.height = value;\n    this.updateHandles();\n  }\n  get height() {\n    return this.mask.height;\n  }\n  set min(value) {\n    this.mask.min = value;\n  }\n  get min() {\n    return this.mask.min;\n  }\n  set max(value) {\n    this.mask.max = value;\n  }\n  get max() {\n    return this.mask.max;\n  }\n  constructor() {\n    super({\n      name: 'rangeSelectorGroup'\n    });\n    this.minHandle = new RangeHandle();\n    this.maxHandle = new RangeHandle();\n    this.mask = (() => {\n      const {\n        x,\n        y,\n        width,\n        height,\n        min,\n        max\n      } = RangeSelector.defaults;\n      const mask = new RangeMask();\n      mask.x = x;\n      mask.y = y;\n      mask.width = width;\n      mask.height = height;\n      mask.min = min;\n      mask.max = max;\n      const {\n        minHandle,\n        maxHandle\n      } = this;\n      minHandle.centerX = x;\n      maxHandle.centerX = x + width;\n      minHandle.centerY = maxHandle.centerY = y + height / 2;\n      this.append([mask, minHandle, maxHandle]);\n      mask.onRangeChange = () => {\n        var _a;\n        this.updateHandles();\n        (_a = this.onRangeChange) === null || _a === void 0 ? void 0 : _a.call(this);\n      };\n      return mask;\n    })();\n    this._x = RangeSelector.defaults.x;\n    this._y = RangeSelector.defaults.y;\n    this._width = RangeSelector.defaults.width;\n    this._height = RangeSelector.defaults.height;\n    this._min = RangeSelector.defaults.min;\n    this._max = RangeSelector.defaults.max;\n    this.isContainerNode = true;\n  }\n  updateHandles() {\n    const {\n      minHandle,\n      maxHandle,\n      x,\n      y,\n      width,\n      height,\n      mask\n    } = this;\n    minHandle.centerX = x + width * mask.min;\n    maxHandle.centerX = x + width * mask.max;\n    minHandle.centerY = maxHandle.centerY = y + height / 2;\n  }\n  computeBBox() {\n    return this.mask.computeBBox();\n  }\n  computeVisibleRangeBBox() {\n    return this.mask.computeVisibleRangeBBox();\n  }\n  render(renderCtx) {\n    const {\n      ctx,\n      forceRender,\n      stats\n    } = renderCtx;\n    if (this.dirty === RedrawType.NONE && !forceRender) {\n      if (stats) stats.nodesSkipped++;\n      return;\n    }\n    this.computeTransformMatrix();\n    this.matrix.toContext(ctx);\n    const {\n      mask,\n      minHandle,\n      maxHandle\n    } = this;\n    [mask, minHandle, maxHandle].forEach(child => {\n      if (child.visible && (forceRender || child.dirty > RedrawType.NONE)) {\n        ctx.save();\n        child.render(Object.assign(Object.assign({}, renderCtx), {\n          ctx,\n          forceRender\n        }));\n        ctx.restore();\n      }\n    });\n    this.markClean({\n      force: true\n    });\n    if (stats) stats.nodesRendered++;\n  }\n}\nRangeSelector.className = 'Range';\nRangeSelector.defaults = {\n  x: 0,\n  y: 0,\n  width: 200,\n  height: 30,\n  min: 0,\n  max: 1\n};\nclass Navigator extends BaseModuleInstance {\n  set width(value) {\n    this.rs.width = value;\n  }\n  get width() {\n    return this.rs.width;\n  }\n  set height(value) {\n    this.rs.height = value;\n  }\n  get height() {\n    return this.rs.height;\n  }\n  set min(value) {\n    this.rs.min = value;\n  }\n  get min() {\n    return this.rs.min;\n  }\n  set max(value) {\n    this.rs.max = value;\n  }\n  get max() {\n    return this.rs.max;\n  }\n  set visible(value) {\n    this._visible = value;\n    this.updateGroupVisibility();\n  }\n  get visible() {\n    return this._visible;\n  }\n  updateGroupVisibility() {\n    const visible = this.enabled && this.visible;\n    this.rs.visible = visible;\n    if (visible) {\n      this.ctx.zoomManager.updateZoom('navigator', {\n        x: {\n          min: this.rs.min,\n          max: this.rs.max\n        },\n        y: {\n          min: 0,\n          max: 1\n        }\n      });\n    } else {\n      this.ctx.zoomManager.updateZoom('navigator');\n    }\n  }\n  constructor(ctx) {\n    var _a;\n    super();\n    this.ctx = ctx;\n    this.rs = new RangeSelector();\n    // Wrappers to allow option application to the scene graph nodes.\n    this.mask = new NavigatorMask(this.rs.mask);\n    this.minHandle = new NavigatorHandle(this.rs.minHandle);\n    this.maxHandle = new NavigatorHandle(this.rs.maxHandle);\n    this.minHandleDragging = false;\n    this.maxHandleDragging = false;\n    this.panHandleOffset = NaN;\n    this.enabled = false;\n    this.margin = 10;\n    this._visible = true;\n    this.rs.onRangeChange = () => ctx.zoomManager.updateZoom('navigator', {\n      x: {\n        min: this.rs.min,\n        max: this.rs.max\n      },\n      y: {\n        min: 0,\n        max: 1\n      }\n    });\n    (_a = ctx.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(this.rs);\n    const interactionOpts = {\n      bypassPause: ['animation']\n    };\n    this.destroyFns.push(ctx.interactionManager.addListener('drag-start', event => this.onDragStart(event), interactionOpts), ctx.interactionManager.addListener('drag', event => this.onDrag(event), interactionOpts), ctx.interactionManager.addListener('hover', event => this.onDrag(event), interactionOpts), ctx.interactionManager.addListener('drag-end', () => this.onDragStop(), interactionOpts), ctx.layoutService.addListener('before-series', event => this.layout(event)), ctx.layoutService.addListener('layout-complete', event => this.layoutComplete(event)), () => {\n      var _a;\n      return (_a = ctx.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(this.rs);\n    }, () => this.ctx.zoomManager.updateZoom('navigator'));\n    this.updateGroupVisibility();\n  }\n  layout({\n    shrinkRect\n  }) {\n    if (this.enabled) {\n      const navigatorTotalHeight = this.rs.height + this.margin;\n      shrinkRect.shrink(navigatorTotalHeight, 'bottom');\n      this.rs.y = shrinkRect.y + shrinkRect.height + this.margin;\n    }\n    return {\n      shrinkRect\n    };\n  }\n  layoutComplete({\n    series: {\n      rect,\n      visible\n    }\n  }) {\n    if (this.enabled && visible) {\n      this.rs.x = rect.x;\n      this.rs.width = rect.width;\n    }\n    this.visible = visible;\n  }\n  onDragStart(offset) {\n    if (!this.enabled) {\n      return;\n    }\n    const {\n      offsetX,\n      offsetY\n    } = offset;\n    const {\n      rs\n    } = this;\n    const {\n      minHandle,\n      maxHandle,\n      x,\n      width,\n      min\n    } = rs;\n    const visibleRange = rs.computeVisibleRangeBBox();\n    if (!(this.minHandleDragging || this.maxHandleDragging)) {\n      if (minHandle.containsPoint(offsetX, offsetY)) {\n        this.minHandleDragging = true;\n      } else if (maxHandle.containsPoint(offsetX, offsetY)) {\n        this.maxHandleDragging = true;\n      } else if (visibleRange.containsPoint(offsetX, offsetY)) {\n        this.panHandleOffset = (offsetX - x) / width - min;\n      }\n    }\n  }\n  onDrag(offset) {\n    if (!this.enabled) {\n      return;\n    }\n    const {\n      rs,\n      panHandleOffset\n    } = this;\n    const {\n      x,\n      y,\n      width,\n      height,\n      minHandle,\n      maxHandle\n    } = rs;\n    const {\n      offsetX,\n      offsetY\n    } = offset;\n    const minX = x + width * rs.min;\n    const maxX = x + width * rs.max;\n    const visibleRange = new BBox(minX, y, maxX - minX, height);\n    const getRatio = () => Math.min(Math.max((offsetX - x) / width, 0), 1);\n    if (minHandle.containsPoint(offsetX, offsetY) || maxHandle.containsPoint(offsetX, offsetY)) {\n      this.ctx.cursorManager.updateCursor('navigator', 'ew-resize');\n    } else if (visibleRange.containsPoint(offsetX, offsetY)) {\n      this.ctx.cursorManager.updateCursor('navigator', 'grab');\n    } else {\n      this.ctx.cursorManager.updateCursor('navigator');\n    }\n    if (this.minHandleDragging) {\n      rs.min = getRatio();\n    } else if (this.maxHandleDragging) {\n      rs.max = getRatio();\n    } else if (!isNaN(panHandleOffset)) {\n      const span = rs.max - rs.min;\n      const min = Math.min(getRatio() - panHandleOffset, 1 - span);\n      if (min <= rs.min) {\n        // pan left\n        rs.min = min;\n        rs.max = rs.min + span;\n      } else {\n        // pan right\n        rs.max = min + span;\n        rs.min = rs.max - span;\n      }\n    }\n  }\n  onDragStop() {\n    this.stopHandleDragging();\n  }\n  stopHandleDragging() {\n    this.minHandleDragging = this.maxHandleDragging = false;\n    this.panHandleOffset = NaN;\n  }\n}\n__decorate([ActionOnSet({\n  changeValue(newValue) {\n    if (newValue) {\n      this.min = 0;\n      this.max = 1;\n    }\n    this.updateGroupVisibility();\n  }\n}), Validate(BOOLEAN), __metadata(\"design:type\", Object)], Navigator.prototype, \"enabled\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], Navigator.prototype, \"margin\", void 0);\nconst NavigatorModule = {\n  type: 'root',\n  optionsKey: 'navigator',\n  packageType: 'community',\n  chartTypes: ['cartesian'],\n  instanceConstructor: Navigator,\n  themeTemplate: {\n    navigator: {\n      enabled: false,\n      height: 30,\n      mask: {\n        fill: '#999999',\n        stroke: '#999999',\n        strokeWidth: 1,\n        fillOpacity: 0.2\n      },\n      minHandle: {\n        fill: '#f2f2f2',\n        stroke: '#999999',\n        strokeWidth: 1,\n        width: 8,\n        height: 16,\n        gripLineGap: 2,\n        gripLineLength: 8\n      },\n      maxHandle: {\n        fill: '#f2f2f2',\n        stroke: '#999999',\n        strokeWidth: 1,\n        width: 8,\n        height: 16,\n        gripLineGap: 2,\n        gripLineLength: 8\n      }\n    }\n  }\n};\nconst singleSeriesPaletteFactory = ({\n  takeColors\n}) => {\n  const {\n    fills: [fill],\n    strokes: [stroke]\n  } = takeColors(1);\n  return {\n    fill,\n    stroke\n  };\n};\nconst markerPaletteFactory = params => {\n  const {\n    fill,\n    stroke\n  } = singleSeriesPaletteFactory(params);\n  return {\n    marker: {\n      fill,\n      stroke\n    }\n  };\n};\nconst FONT_SIZE = {\n  SMALL: 12,\n  MEDIUM: 13,\n  LARGE: 17\n};\nconst BOLD = 'bold';\nconst NORMAL = 'normal';\nconst BOTTOM = 'bottom';\nconst LEFT = 'left';\nconst TOP = 'top';\nconst CARTESIAN_AXIS_POSITIONS = {\n  BOTTOM,\n  LEFT,\n  TOP\n};\nconst CATEGORY = 'category';\nconst NUMBER = 'number';\nconst TIME = 'time';\nconst LOG = 'log';\nconst CARTESIAN_AXIS_TYPES = {\n  CATEGORY,\n  NUMBER,\n  TIME,\n  LOG\n};\nconst ANGLE_CATEGORY = 'angle-category';\nconst ANGLE_NUMBER = 'angle-number';\nconst RADIUS_CATEGORY = 'radius-category';\nconst RADIUS_NUMBER = 'radius-number';\nconst POLAR_AXIS_TYPES = {\n  ANGLE_CATEGORY,\n  ANGLE_NUMBER,\n  RADIUS_CATEGORY,\n  RADIUS_NUMBER\n};\nconst CIRCLE = 'circle';\nconst TYPES = {};\nconst DEFAULTS = {};\nconst CHART_TYPES = {\n  has(seriesType) {\n    return Object.prototype.hasOwnProperty.call(TYPES, seriesType);\n  },\n  isCartesian(seriesType) {\n    return TYPES[seriesType] === 'cartesian';\n  },\n  isPolar(seriesType) {\n    return TYPES[seriesType] === 'polar';\n  },\n  isHierarchy(seriesType) {\n    return TYPES[seriesType] === 'hierarchy';\n  },\n  get seriesTypes() {\n    return Object.keys(TYPES);\n  },\n  get cartesianTypes() {\n    return this.seriesTypes.filter(t => this.isCartesian(t));\n  },\n  get polarTypes() {\n    return this.seriesTypes.filter(t => this.isPolar(t));\n  },\n  get hierarchyTypes() {\n    return this.seriesTypes.filter(t => this.isHierarchy(t));\n  }\n};\nfunction registerChartSeriesType(seriesType, chartType) {\n  TYPES[seriesType] = chartType;\n}\nfunction registerChartDefaults(chartType, defaults) {\n  var _a;\n  DEFAULTS[chartType] = jsonMerge([(_a = DEFAULTS[chartType]) !== null && _a !== void 0 ? _a : {}, defaults]);\n}\nfunction getChartDefaults(chartType) {\n  var _a;\n  return (_a = DEFAULTS[chartType]) !== null && _a !== void 0 ? _a : {};\n}\nfunction getChartType(seriesType) {\n  var _a;\n  return (_a = TYPES[seriesType]) !== null && _a !== void 0 ? _a : 'unknown';\n}\nfunction optionsType(input) {\n  var _a, _b, _c, _d;\n  return (_d = (_a = input.type) !== null && _a !== void 0 ? _a : (_c = (_b = input.series) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.type) !== null && _d !== void 0 ? _d : 'line';\n}\nfunction isAgCartesianChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return true;\n  }\n  if (specifiedType === 'cartesian') {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return CHART_TYPES.isCartesian(specifiedType) || isEnterpriseCartesian(specifiedType);\n}\nfunction isAgHierarchyChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === 'hierarchy') {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return CHART_TYPES.isHierarchy(specifiedType) || isEnterpriseHierarchy(specifiedType);\n}\nfunction isAgPolarChartOptions(input) {\n  const specifiedType = optionsType(input);\n  if (specifiedType == null) {\n    return false;\n  }\n  if (specifiedType === 'polar') {\n    Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\n    return true;\n  }\n  return CHART_TYPES.isPolar(specifiedType) || isEnterprisePolar(specifiedType);\n}\nfunction isSeriesOptionType(input) {\n  if (input == null) {\n    return false;\n  }\n  return CHART_TYPES.has(input);\n}\nfunction isAxisOptionType(input) {\n  if (input == null) {\n    return false;\n  }\n  return AXIS_TYPES.has(input);\n}\nconst DEFAULT_CARTESIAN_CHART_OVERRIDES = {\n  axes: [{\n    type: CARTESIAN_AXIS_TYPES.NUMBER,\n    position: CARTESIAN_AXIS_POSITIONS.LEFT\n  }, {\n    type: CARTESIAN_AXIS_TYPES.CATEGORY,\n    position: CARTESIAN_AXIS_POSITIONS.BOTTOM\n  }]\n};\nfunction swapAxes(opts) {\n  var _a;\n  if (!isAgCartesianChartOptions(opts)) {\n    return opts;\n  }\n  const [axis0, axis1] = (_a = opts.axes) !== null && _a !== void 0 ? _a : [];\n  return Object.assign(Object.assign({}, opts), {\n    axes: [Object.assign(Object.assign({}, axis0), {\n      position: axis1.position\n    }), Object.assign(Object.assign({}, axis1), {\n      position: axis0.position\n    })]\n  });\n}\nfunction resolveModuleConflicts(opts) {\n  var _a, _b, _c, _d;\n  const conflictOverrides = {};\n  for (const [source, conflicts] of MODULE_CONFLICTS.entries()) {\n    if (opts[source] == null || !conflicts.length) {\n      continue;\n    }\n    (_a = conflictOverrides[source]) !== null && _a !== void 0 ? _a : conflictOverrides[source] = {};\n    for (const conflict of conflicts) {\n      if (((_b = opts[source]) === null || _b === void 0 ? void 0 : _b.enabled) && ((_c = opts[conflict]) === null || _c === void 0 ? void 0 : _c.enabled)) {\n        Logger.warnOnce(`the [${source}] module can not be used at the same time as [${conflict}], it will be disabled.`);\n        conflictOverrides[source].enabled = false;\n      } else {\n        conflictOverrides[source].enabled = (_d = opts[source]) === null || _d === void 0 ? void 0 : _d.enabled;\n      }\n    }\n  }\n  return conflictOverrides;\n}\nconst EXTENDS_CHART_DEFAULTS = Symbol('extends-chart-defaults');\nconst EXTENDS_LEGEND_DEFAULTS = Symbol('extends-legend-defaults');\nconst EXTENDS_LEGEND_ITEM_DEFAULTS = Symbol('extends-legend-item-defaults');\nconst EXTENDS_LEGEND_ITEM_MARKER_DEFAULTS = Symbol('extends-legend-item-marker-defaults');\nconst EXTENDS_AXES_DEFAULTS = Symbol('extends-axes-defaults');\nconst EXTENDS_AXES_LABEL_DEFAULTS = Symbol('extends-axes-label-defaults');\nconst EXTENDS_AXES_LINE_DEFAULTS = Symbol('extends-axes-line-defaults');\nconst EXTENDS_AXES_TICK_DEFAULTS = Symbol('extends-axes-tick-defaults');\nconst EXTENDS_AXES_GRID_LINE_DEFAULTS = Symbol('extends-axes-grid-line-defaults');\nconst EXTENDS_SERIES_DEFAULTS = Symbol('extends-series-defaults');\nconst EXTENDS_CARTESIAN_MARKER_DEFAULTS = Symbol('extends-cartesian-marker-defaults');\nconst OVERRIDE_SERIES_LABEL_DEFAULTS = Symbol('override-series-label-defaults');\nconst DEFAULT_FONT_FAMILY = Symbol('default-font');\nconst DEFAULT_LABEL_COLOUR = Symbol('default-label-colour');\nconst DEFAULT_INVERTED_LABEL_COLOUR = Symbol('default-inverted-label-colour');\nconst DEFAULT_INSIDE_SERIES_LABEL_COLOUR = Symbol('default-inside-series-label-colour');\nconst DEFAULT_MUTED_LABEL_COLOUR = Symbol('default-muted-label-colour');\nconst DEFAULT_AXIS_GRID_COLOUR = Symbol('default-axis-grid-colour');\nconst DEFAULT_AXIS_LINE_COLOUR = Symbol('default-axis-line-colour');\nconst DEFAULT_CROSS_LINES_COLOUR = Symbol('default-cross-lines-colour');\nconst DEFAULT_BACKGROUND_COLOUR = Symbol('default-background-colour');\nconst DEFAULT_SHADOW_COLOUR = Symbol('default-shadow-colour');\nconst DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS = Symbol('default-waterfall-series-positive-colors');\nconst DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS = Symbol('default-waterfall-series-negative-colors');\nconst DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS = Symbol('default-waterfall-series-total-colors');\nconst DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE = Symbol('default-waterfall-series-connector-line-stroke');\nconst DEFAULT_POLAR_SERIES_STROKE = Symbol('default-polar-series-stroke');\nconst DEFAULT_DIVERGING_SERIES_COLOUR_RANGE = Symbol('default-diverging-series-colour-range');\nconst DEFAULT_HIERARCHY_FILLS = Symbol('default-hierarchy-fills');\nconst DEFAULT_HIERARCHY_STROKES = Symbol('default-hierarchy-strokes');\n\n/**\r\n * Implements a per-path \"to/from\" animation.\r\n *\r\n * @param id prefix for all animation ids generated by this call\r\n * @param animationManager used to schedule generated animations\r\n * @param paths contains paths to be animated\r\n * @param intermediateFn callback to update path\r\n * @param extraOpts optional additional animation properties to pass to AnimationManager#animate.\r\n */\nfunction pathMotion(groupId, subId, animationManager, paths, fns) {\n  const {\n    defaultDuration\n  } = animationManager;\n  const {\n    addPhaseFn,\n    updatePhaseFn,\n    removePhaseFn\n  } = fns;\n  const animate = (phase, path, updateFn) => {\n    animationManager.animate({\n      id: `${groupId}_${subId}_${path.id}_${phase}`,\n      groupId,\n      from: 0,\n      to: 1,\n      ease: easeOut,\n      onUpdate(ratio, preInit) {\n        if (preInit && phase !== 'removed') return;\n        path.path.clear({\n          trackChanges: true\n        });\n        updateFn(ratio, path);\n        path.checkPathDirty();\n      },\n      onStop() {\n        if (phase !== 'added') return;\n        path.path.clear({\n          trackChanges: true\n        });\n        updateFn(1, path);\n        path.checkPathDirty();\n      },\n      duration: FROM_TO_MIXINS[phase].animationDuration * defaultDuration,\n      delay: FROM_TO_MIXINS[phase].animationDelay * defaultDuration\n    });\n  };\n  for (const path of paths) {\n    if (!animationManager.isSkipped()) {\n      animate('removed', path, removePhaseFn);\n      animate('updated', path, updatePhaseFn);\n    }\n    animate('added', path, addPhaseFn);\n  }\n}\nconst MARKER_SHAPE = predicateWithMessage(v => isMarkerShape(v) || Object.getPrototypeOf(v) === Marker, `expecting a marker shape keyword such as 'circle', 'diamond' or 'square' or an object extending the Marker class`);\nclass SeriesMarker extends ChangeDetectable {\n  constructor() {\n    super(...arguments);\n    this.enabled = true;\n    /** One of the predefined marker names, or a marker constructor function (for user-defined markers). */\n    this.shape = Circle;\n    this.size = 6;\n    this.fillOpacity = 1;\n    this.strokeWidth = 1;\n    this.strokeOpacity = 1;\n  }\n  getStyle() {\n    const {\n      size,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity\n    } = this;\n    return {\n      size,\n      fill,\n      fillOpacity,\n      stroke,\n      strokeWidth,\n      strokeOpacity\n    };\n  }\n  getDiameter() {\n    return this.size + this.strokeWidth;\n  }\n}\n__decorate([Validate(BOOLEAN), SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Object)], SeriesMarker.prototype, \"enabled\", void 0);\n__decorate([Validate(MARKER_SHAPE), SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Object)], SeriesMarker.prototype, \"shape\", void 0);\n__decorate([Validate(NUMBER$1(0)), SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Number)], SeriesMarker.prototype, \"size\", void 0);\n__decorate([Validate(OPT_COLOR_STRING), SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", String)], SeriesMarker.prototype, \"fill\", void 0);\n__decorate([Validate(OPT_NUMBER(0, 1)), SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Number)], SeriesMarker.prototype, \"fillOpacity\", void 0);\n__decorate([Validate(OPT_COLOR_STRING), SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", String)], SeriesMarker.prototype, \"stroke\", void 0);\n__decorate([Validate(OPT_NUMBER(0)), SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Number)], SeriesMarker.prototype, \"strokeWidth\", void 0);\n__decorate([Validate(OPT_NUMBER(0, 1)), SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Number)], SeriesMarker.prototype, \"strokeOpacity\", void 0);\n__decorate([Validate(OPT_FUNCTION), SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Function)], SeriesMarker.prototype, \"formatter\", void 0);\nfunction markerFadeInAnimation({\n  id\n}, animationManager, markerSelections, status = 'unknown') {\n  const params = Object.assign({}, FROM_TO_MIXINS[status]);\n  staticFromToMotion(id, 'markers', animationManager, markerSelections, {\n    opacity: 0\n  }, {\n    opacity: 1\n  }, params);\n  markerSelections.forEach(s => s.cleanup());\n}\nfunction markerScaleInAnimation({\n  id\n}, animationManager, markerSelections) {\n  staticFromToMotion(id, 'markers', animationManager, markerSelections, {\n    scalingX: 0,\n    scalingY: 0\n  }, {\n    scalingX: 1,\n    scalingY: 1\n  });\n  markerSelections.forEach(s => s.cleanup());\n}\nfunction markerSwipeScaleInAnimation({\n  id\n}, animationManager, markerSelections, seriesWidth) {\n  // Improves consistency with matching parallel animations.\n  const tweakFactor = 0.1;\n  const fromFn = (_, datum) => {\n    var _a, _b;\n    const x = (_b = (_a = datum.midPoint) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : seriesWidth;\n    // Calculate a delay that depends on the X position of the datum, so that nodes appear\n    // gradually from left to right. Use easeInOut to match any parallel swipe animations.\n    const delayRatio = easeInOut(x / seriesWidth) - tweakFactor;\n    const delay = Math.max(Math.min(delayRatio, 1), 0);\n    return {\n      scalingX: 0,\n      scalingY: 0,\n      animationDelay: delay,\n      animationDuration: QUICK_TRANSITION\n    };\n  };\n  const toFn = () => {\n    return {\n      scalingX: 1,\n      scalingY: 1\n    };\n  };\n  fromToMotion(id, 'markers', animationManager, markerSelections, {\n    fromFn,\n    toFn\n  });\n}\nfunction resetMarkerFn(_node) {\n  return {\n    opacity: 1,\n    scalingX: 1,\n    scalingY: 1\n  };\n}\nfunction resetMarkerPositionFn(_node, datum) {\n  var _a, _b, _c, _d;\n  return {\n    translationX: (_b = (_a = datum.point) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : NaN,\n    translationY: (_d = (_c = datum.point) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : NaN\n  };\n}\nfunction prepareMarkerAnimation(pairMap, parentStatus) {\n  const readFirstPair = (xValue, type) => {\n    const val = pairMap[type][xValue];\n    return Array.isArray(val) ? val[0] : val;\n  };\n  const markerStatus = datum => {\n    const {\n      xValue\n    } = datum;\n    if (pairMap.moved[xValue]) {\n      return {\n        point: readFirstPair(xValue, 'moved'),\n        status: 'updated'\n      };\n    } else if (pairMap.removed[xValue]) {\n      return {\n        point: readFirstPair(xValue, 'removed'),\n        status: 'removed'\n      };\n    } else if (pairMap.added[xValue]) {\n      return {\n        point: readFirstPair(xValue, 'added'),\n        status: 'added'\n      };\n    }\n    return {\n      status: 'unknown'\n    };\n  };\n  const fromFn = (marker, datum) => {\n    var _a, _b, _c, _d, _e, _f;\n    const {\n      status,\n      point\n    } = markerStatus(datum);\n    if (status === 'unknown') return {\n      opacity: 0\n    };\n    const defaults = Object.assign({\n      translationX: (_b = (_a = point === null || point === void 0 ? void 0 : point.from) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : marker.translationX,\n      translationY: (_d = (_c = point === null || point === void 0 ? void 0 : point.from) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : marker.translationY,\n      opacity: marker.opacity\n    }, FROM_TO_MIXINS[status]);\n    if (parentStatus === 'added') {\n      return Object.assign(Object.assign(Object.assign({}, defaults), {\n        opacity: 0,\n        translationX: (_e = point === null || point === void 0 ? void 0 : point.to) === null || _e === void 0 ? void 0 : _e.x,\n        translationY: (_f = point === null || point === void 0 ? void 0 : point.to) === null || _f === void 0 ? void 0 : _f.y\n      }), FROM_TO_MIXINS['added']);\n    }\n    if (status === 'added') {\n      defaults.opacity = 0;\n    }\n    return defaults;\n  };\n  const toFn = (_marker, datum) => {\n    var _a, _b;\n    const {\n      status,\n      point\n    } = markerStatus(datum);\n    if (status === 'unknown') return {\n      opacity: 0\n    };\n    const defaults = Object.assign({\n      translationX: datum.point.x,\n      translationY: datum.point.y,\n      opacity: 1\n    }, FROM_TO_MIXINS[status]);\n    if (status === 'removed' || parentStatus === 'removed') {\n      return Object.assign(Object.assign(Object.assign({}, defaults), {\n        translationX: (_a = point === null || point === void 0 ? void 0 : point.to) === null || _a === void 0 ? void 0 : _a.x,\n        translationY: (_b = point === null || point === void 0 ? void 0 : point.to) === null || _b === void 0 ? void 0 : _b.y,\n        opacity: 0\n      }), FROM_TO_MIXINS['removed']);\n    }\n    return defaults;\n  };\n  return {\n    fromFn,\n    toFn\n  };\n}\nfunction minMax(nodeData) {\n  return nodeData.reduce(({\n    min,\n    max\n  }, node) => {\n    if (min == null || min.point.x > node.point.x) {\n      min = node;\n    }\n    if (max == null || max.point.x < node.point.x) {\n      max = node;\n    }\n    return {\n      min,\n      max\n    };\n  }, {});\n}\nfunction intersectionOnLine(a, b, targetX) {\n  const m = (b.y - a.y) / (b.x - a.x);\n  // Find a point a distance along the line from `a` and `b`\n  const y = (targetX - a.x) * m + a.y;\n  return {\n    x: targetX,\n    y\n  };\n}\nfunction backfillPathPoint(results, process, skip, processFn) {\n  let prevMarkerIdx = -1,\n    nextMarkerIdx = 0;\n  const toProcess = [];\n  while (nextMarkerIdx < results.length) {\n    if (results[nextMarkerIdx].change === process) {\n      toProcess.push(results[nextMarkerIdx]);\n      nextMarkerIdx++;\n      continue;\n    }\n    if (results[nextMarkerIdx].change === skip) {\n      nextMarkerIdx++;\n      continue;\n    }\n    if (toProcess.length > 0) {\n      processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\n      toProcess.length = 0;\n    }\n    prevMarkerIdx = nextMarkerIdx;\n    nextMarkerIdx++;\n  }\n  if (toProcess.length > 0) {\n    processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\n  }\n}\nfunction backfillPathPointData(result, splitMode) {\n  backfillPathPoint(result, 'out', 'in', (toProcess, sIdx, eIdx) => {\n    var _a, _b;\n    if (sIdx === -1 && result[eIdx]) {\n      toProcess.forEach(d => d.to = result[eIdx].from);\n    } else if (eIdx === result.length && result[sIdx]) {\n      toProcess.forEach(d => d.to = result[sIdx].from);\n    } else if (splitMode === 'intersect' && ((_a = result[sIdx]) === null || _a === void 0 ? void 0 : _a.from) && ((_b = result[eIdx]) === null || _b === void 0 ? void 0 : _b.from)) {\n      toProcess.forEach(d => d.to = intersectionOnLine(result[sIdx].from, result[eIdx].from, d.from.x));\n    } else {\n      toProcess.forEach(d => d.to = d.from);\n    }\n  });\n  backfillPathPoint(result, 'in', 'out', (toProcess, sIdx, eIdx) => {\n    var _a, _b;\n    if (sIdx === -1 && result[eIdx]) {\n      toProcess.forEach(d => d.from = result[eIdx].to);\n    } else if (eIdx === result.length && result[sIdx]) {\n      toProcess.forEach(d => d.from = result[sIdx].to);\n    } else if (splitMode === 'intersect' && ((_a = result[sIdx]) === null || _a === void 0 ? void 0 : _a.to) && ((_b = result[eIdx]) === null || _b === void 0 ? void 0 : _b.to)) {\n      toProcess.forEach(d => d.from = intersectionOnLine(result[sIdx].to, result[eIdx].to, d.to.x));\n    } else {\n      toProcess.forEach(d => d.from = d.to);\n    }\n  });\n}\nfunction calculatePoint(from, to, ratio) {\n  const x1 = isNaN(from.x) ? to.x : from.x;\n  const y1 = isNaN(from.y) ? to.y : from.y;\n  const xd = to.x - from.x;\n  const yd = to.y - from.y;\n  const xr = isNaN(xd) ? 0 : xd * ratio;\n  const yr = isNaN(yd) ? 0 : yd * ratio;\n  return {\n    x: x1 + xr,\n    y: y1 + yr\n  };\n}\nfunction renderPartialPath(pairData, ratios, path) {\n  const {\n    path: linePath\n  } = path;\n  let previousTo;\n  for (const data of pairData) {\n    const ratio = ratios[data.change];\n    if (ratio == null) continue;\n    const {\n      from,\n      to\n    } = data;\n    if (from == null || to == null) continue;\n    const {\n      x,\n      y\n    } = calculatePoint(from, to, ratio);\n    if (data.moveTo === false) {\n      linePath.lineTo(x, y);\n    } else if (data.moveTo === true || !previousTo) {\n      linePath.moveTo(x, y);\n    } else if (previousTo) {\n      const moveToRatio = data.moveTo === 'in' ? ratio : 1 - ratio;\n      const {\n        x: midPointX,\n        y: midPointY\n      } = calculatePoint(previousTo, {\n        x,\n        y\n      }, moveToRatio);\n      linePath.lineTo(midPointX, midPointY);\n      linePath.moveTo(x, y);\n    }\n    previousTo = {\n      x,\n      y\n    };\n  }\n}\nfunction pathSwipeInAnimation({\n  id\n}, animationManager, paths) {\n  staticFromToMotion(id, 'path_properties', animationManager, paths, {\n    clipScalingX: 0\n  }, {\n    clipScalingX: 1\n  }, {\n    start: {\n      clipMode: 'normal'\n    },\n    finish: {\n      clipMode: undefined\n    }\n  });\n}\nfunction pathFadeInAnimation({\n  id\n}, subId, animationManager, selection) {\n  staticFromToMotion(id, subId, animationManager, selection, {\n    opacity: 0\n  }, {\n    opacity: 1\n  }, LABEL_PHASE);\n}\nfunction pathFadeOutAnimation({\n  id\n}, subId, animationManager, selection) {\n  staticFromToMotion(id, subId, animationManager, selection, {\n    opacity: 1\n  }, {\n    opacity: 0\n  }, LABEL_PHASE);\n}\nfunction buildResetPathFn(opts) {\n  return _node => {\n    return {\n      opacity: opts.getOpacity(),\n      clipScalingX: 1,\n      clipMode: undefined\n    };\n  };\n}\nfunction scale(val, scaling) {\n  if (!scaling) return NaN;\n  if (val instanceof Date) {\n    val = val.getTime();\n  }\n  if (scaling.type === 'continuous' && typeof val === 'number') {\n    const domainRatio = (val - scaling.domain[0]) / (scaling.domain[1] - scaling.domain[0]);\n    return domainRatio * (scaling.range[1] - scaling.range[0]) + scaling.range[0];\n  }\n  if (scaling.type === 'log' && typeof val === 'number') {\n    return scaling.convert(val);\n  }\n  // Category axis case.\n  const matchingIndex = scaling.domain.findIndex(d => d === val);\n  if (matchingIndex >= 0) {\n    return scaling.range[matchingIndex];\n  }\n  // We failed to convert using the scale.\n  return NaN;\n}\nfunction closeMatch(a, b) {\n  const an = Number(a);\n  const bn = Number(b);\n  if (!isNaN(an) && !isNaN(bn)) {\n    return Math.abs(bn - an) < 0.25;\n  }\n  return a === b;\n}\nfunction calculateMoveTo(from = false, to = false) {\n  if (from === to) {\n    return !!from;\n  }\n  return from ? 'in' : 'out';\n}\nfunction pairContinuousData(newData, oldData, opts = {}) {\n  var _a, _b, _c, _d;\n  const {\n    backfillSplitMode = 'intersect'\n  } = opts;\n  const toNewScale = oldDatum => {\n    var _a, _b;\n    return {\n      x: scale((_a = oldDatum.xValue) !== null && _a !== void 0 ? _a : NaN, newData.scales.x),\n      y: scale((_b = oldDatum.yValue) !== null && _b !== void 0 ? _b : NaN, newData.scales.y)\n    };\n  };\n  const toOldScale = newDatum => {\n    var _a, _b;\n    return {\n      x: scale((_a = newDatum.xValue) !== null && _a !== void 0 ? _a : NaN, oldData.scales.x),\n      y: scale((_b = newDatum.yValue) !== null && _b !== void 0 ? _b : NaN, oldData.scales.y)\n    };\n  };\n  const result = [];\n  const resultMap = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const pairUp = (from, to, xValue, change = 'move') => {\n    if (from && (isNaN(from.point.x) || isNaN(from.point.y))) {\n      // Default to 'to' position if 'from' is invalid.\n      from = to;\n    }\n    const resultPoint = {\n      from: from === null || from === void 0 ? void 0 : from.point,\n      to: to === null || to === void 0 ? void 0 : to.point,\n      moveTo: calculateMoveTo(from === null || from === void 0 ? void 0 : from.point.moveTo, to === null || to === void 0 ? void 0 : to.point.moveTo),\n      change\n    };\n    if (change === 'move') {\n      resultMap.moved[xValue] = resultPoint;\n      oldIdx++;\n      newIdx++;\n    } else if (change === 'in') {\n      resultMap.added[xValue] = resultPoint;\n      newIdx++;\n    } else if (change === 'out') {\n      resultMap.removed[xValue] = resultPoint;\n      oldIdx++;\n    }\n    result.push(resultPoint);\n  };\n  const {\n    min: minFromNode,\n    max: maxFromNode\n  } = minMax(oldData.nodeData);\n  const {\n    min: minToNode,\n    max: maxToNode\n  } = minMax(newData.nodeData);\n  let oldIdx = 0;\n  let newIdx = 0;\n  while (oldIdx < oldData.nodeData.length || newIdx < newData.nodeData.length) {\n    const from = oldData.nodeData[oldIdx];\n    const to = newData.nodeData[newIdx];\n    const fromShifted = from ? toNewScale(from) : undefined;\n    const toUnshifted = to ? toOldScale(to) : undefined;\n    const NA = undefined;\n    if (fromShifted && closeMatch(fromShifted.x, to === null || to === void 0 ? void 0 : to.point.x)) {\n      pairUp(from, to, to.xValue, 'move');\n    } else if (fromShifted && fromShifted.x < ((_a = minToNode === null || minToNode === void 0 ? void 0 : minToNode.point.x) !== null && _a !== void 0 ? _a : -Infinity)) {\n      pairUp(from, NA, from.xValue, 'out');\n    } else if (fromShifted && fromShifted.x > ((_b = maxToNode === null || maxToNode === void 0 ? void 0 : maxToNode.point.x) !== null && _b !== void 0 ? _b : Infinity)) {\n      pairUp(from, NA, from.xValue, 'out');\n    } else if (toUnshifted && toUnshifted.x < ((_c = minFromNode === null || minFromNode === void 0 ? void 0 : minFromNode.point.x) !== null && _c !== void 0 ? _c : -Infinity)) {\n      pairUp(NA, to, to.xValue, 'in');\n    } else if (toUnshifted && toUnshifted.x > ((_d = maxFromNode === null || maxFromNode === void 0 ? void 0 : maxFromNode.point.x) !== null && _d !== void 0 ? _d : Infinity)) {\n      pairUp(NA, to, to.xValue, 'in');\n    } else if (fromShifted && fromShifted.x < (to === null || to === void 0 ? void 0 : to.point.x)) {\n      pairUp(from, NA, from.xValue, 'out');\n    } else if (toUnshifted && toUnshifted.x < (from === null || from === void 0 ? void 0 : from.point.x)) {\n      pairUp(NA, to, to.xValue, 'in');\n    } else if (from) {\n      pairUp(from, NA, from.xValue, 'out');\n    } else if (to) {\n      pairUp(NA, to, to.xValue, 'in');\n    } else {\n      throw new Error('Unable to process points');\n    }\n  }\n  backfillPathPointData(result, backfillSplitMode);\n  return {\n    result,\n    resultMap\n  };\n}\nfunction pairCategoryData(newData, oldData, diff, opts = {}) {\n  var _a, _b, _c;\n  const {\n    backfillSplitMode = 'intersect',\n    multiDatum = false\n  } = opts;\n  const result = [];\n  const resultMapSingle = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  const resultMapMulti = {\n    added: {},\n    moved: {},\n    removed: {}\n  };\n  let previousResultPoint = undefined;\n  let previousXValue = undefined;\n  const addToResultMap = (xValue, result) => {\n    var _a;\n    var _b;\n    const type = result.change === 'move' ? 'moved' : result.change === 'in' ? 'added' : 'removed';\n    if (multiDatum) {\n      (_a = (_b = resultMapMulti[type])[xValue]) !== null && _a !== void 0 ? _a : _b[xValue] = [];\n      resultMapMulti[type][xValue].push(result);\n    } else {\n      resultMapSingle[type][xValue] = result;\n    }\n    previousResultPoint = result;\n    previousXValue = xValue;\n  };\n  let oldIndex = 0;\n  let newIndex = 0;\n  let isXUnordered = false;\n  while (oldIndex < oldData.nodeData.length || newIndex < newData.nodeData.length) {\n    const before = oldData.nodeData[oldIndex];\n    const after = newData.nodeData[newIndex];\n    let resultPoint;\n    if ((before === null || before === void 0 ? void 0 : before.xValue) === (after === null || after === void 0 ? void 0 : after.xValue)) {\n      resultPoint = {\n        change: 'move',\n        moveTo: calculateMoveTo((_a = before.point.moveTo) !== null && _a !== void 0 ? _a : false, after.point.moveTo),\n        from: before.point,\n        to: after.point\n      };\n      addToResultMap(before.xValue, resultPoint);\n      oldIndex++;\n      newIndex++;\n    } else if (diff.removed.indexOf(before === null || before === void 0 ? void 0 : before.xValue) >= 0) {\n      resultPoint = {\n        change: 'out',\n        moveTo: (_b = before.point.moveTo) !== null && _b !== void 0 ? _b : false,\n        from: before.point\n      };\n      addToResultMap(before.xValue, resultPoint);\n      oldIndex++;\n    } else if (diff.added.indexOf(after === null || after === void 0 ? void 0 : after.xValue) >= 0) {\n      resultPoint = {\n        change: 'in',\n        moveTo: (_c = after.point.moveTo) !== null && _c !== void 0 ? _c : false,\n        to: after.point\n      };\n      addToResultMap(after.xValue, resultPoint);\n      newIndex++;\n    } else if (multiDatum && previousResultPoint && previousXValue === (before === null || before === void 0 ? void 0 : before.xValue)) {\n      resultPoint = Object.assign({}, previousResultPoint);\n      addToResultMap(before.xValue, resultPoint);\n      oldIndex++;\n    } else if (multiDatum && previousResultPoint && previousXValue === (after === null || after === void 0 ? void 0 : after.xValue)) {\n      resultPoint = Object.assign({}, previousResultPoint);\n      addToResultMap(after.xValue, resultPoint);\n      newIndex++;\n    } else {\n      isXUnordered = true;\n      break;\n    }\n    result.push(resultPoint);\n  }\n  let previousX = -Infinity;\n  isXUnordered || (isXUnordered = result.some(pathPoint => {\n    const {\n      change: marker,\n      to: {\n        x = -Infinity\n      } = {}\n    } = pathPoint;\n    if (marker === 'out') return;\n    const result = x < previousX;\n    previousX = x;\n    return result;\n  }));\n  if (isXUnordered) {\n    return {\n      result: undefined,\n      resultMap: undefined\n    };\n  }\n  backfillPathPointData(result, backfillSplitMode);\n  if (multiDatum) {\n    return {\n      result,\n      resultMap: resultMapMulti\n    };\n  }\n  return {\n    result,\n    resultMap: resultMapSingle\n  };\n}\nfunction determinePathStatus(newData, oldData) {\n  let status = 'updated';\n  const visible = data => {\n    return data.visible;\n  };\n  if (!visible(oldData) && visible(newData)) {\n    status = 'added';\n  } else if (visible(oldData) && !visible(newData)) {\n    status = 'removed';\n  }\n  return status;\n}\nfunction prepareLinePathPropertyAnimation(status, visibleToggleMode) {\n  const phase = visibleToggleMode === 'none' ? 'updated' : status;\n  const result = {\n    fromFn: _path => {\n      let mixin;\n      if (status === 'removed') {\n        mixin = {\n          finish: {\n            visible: false\n          }\n        };\n      } else if (status === 'added') {\n        mixin = {\n          start: {\n            visible: true\n          }\n        };\n      } else {\n        mixin = {};\n      }\n      return Object.assign(Object.assign({}, FROM_TO_MIXINS[phase]), mixin);\n    },\n    toFn: _path => {\n      return Object.assign({}, FROM_TO_MIXINS[phase]);\n    }\n  };\n  if (visibleToggleMode === 'fade') {\n    return {\n      fromFn: path => {\n        const opacity = status === 'added' ? 0 : path.opacity;\n        return Object.assign({\n          opacity\n        }, result.fromFn(path));\n      },\n      toFn: path => {\n        const opacity = status === 'removed' ? 0 : 1;\n        return Object.assign({\n          opacity\n        }, result.toFn(path));\n      }\n    };\n  }\n  return result;\n}\nfunction prepareLinePathAnimationFns(newData, oldData, pairData, visibleToggleMode, render) {\n  const status = determinePathStatus(newData, oldData);\n  const removePhaseFn = (ratio, path) => {\n    render(pairData, {\n      move: 0,\n      out: ratio\n    }, path);\n  };\n  const updatePhaseFn = (ratio, path) => {\n    render(pairData, {\n      move: ratio\n    }, path);\n  };\n  const addPhaseFn = (ratio, path) => {\n    render(pairData, {\n      move: 1,\n      in: ratio\n    }, path);\n  };\n  const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\n  return {\n    status,\n    path: {\n      addPhaseFn,\n      updatePhaseFn,\n      removePhaseFn\n    },\n    pathProperties\n  };\n}\nfunction prepareLinePathAnimation(newData, oldData, diff) {\n  var _a;\n  const isCategoryBased = ((_a = newData.scales.x) === null || _a === void 0 ? void 0 : _a.type) === 'category';\n  const {\n    result: pairData,\n    resultMap: pairMap\n  } = isCategoryBased && diff ? pairCategoryData(newData, oldData, diff) : pairContinuousData(newData, oldData);\n  let status = 'updated';\n  if (oldData.visible && !newData.visible) {\n    status = 'removed';\n  } else if (!oldData.visible && newData.visible) {\n    status = 'added';\n  }\n  if (pairData === undefined || pairMap === undefined) {\n    return;\n  }\n  const pathFns = prepareLinePathAnimationFns(newData, oldData, pairData, 'fade', renderPartialPath);\n  const marker = prepareMarkerAnimation(pairMap, status);\n  return Object.assign(Object.assign({}, pathFns), {\n    marker\n  });\n}\nvar AreaSeriesTag;\n(function (AreaSeriesTag) {\n  AreaSeriesTag[AreaSeriesTag[\"Fill\"] = 0] = \"Fill\";\n  AreaSeriesTag[AreaSeriesTag[\"Stroke\"] = 1] = \"Stroke\";\n  AreaSeriesTag[AreaSeriesTag[\"Marker\"] = 2] = \"Marker\";\n  AreaSeriesTag[AreaSeriesTag[\"Label\"] = 3] = \"Label\";\n})(AreaSeriesTag || (AreaSeriesTag = {}));\nfunction splitFillPoints(context) {\n  const {\n    points\n  } = context.fillData;\n  return {\n    top: points.slice(0, points.length / 2),\n    bottom: points.slice(points.length / 2).reverse()\n  };\n}\nfunction prepPoints(key, ctx, points) {\n  return {\n    scales: ctx.scales,\n    nodeData: points[key],\n    visible: ctx.visible\n  };\n}\nfunction pairFillCategoryData(newData, oldData, diff) {\n  const oldPoints = splitFillPoints(oldData);\n  const newPoints = splitFillPoints(newData);\n  const pairOpts = {\n    multiDatum: true\n  };\n  return {\n    top: pairCategoryData(prepPoints('top', newData, newPoints), prepPoints('top', oldData, oldPoints), diff, pairOpts),\n    bottom: pairCategoryData(prepPoints('bottom', newData, newPoints), prepPoints('bottom', oldData, oldPoints), diff, pairOpts)\n  };\n}\nfunction pairFillContinuousData(newData, oldData) {\n  const oldPoints = splitFillPoints(oldData);\n  const newPoints = splitFillPoints(newData);\n  return {\n    top: pairContinuousData(prepPoints('top', newData, newPoints), prepPoints('top', oldData, oldPoints)),\n    bottom: pairContinuousData(prepPoints('bottom', newData, newPoints), prepPoints('bottom', oldData, oldPoints))\n  };\n}\nfunction prepareAreaPathAnimation(newData, oldData, diff) {\n  var _a;\n  const isCategoryBased = ((_a = newData.scales.x) === null || _a === void 0 ? void 0 : _a.type) === 'category';\n  let status = 'updated';\n  if (oldData.visible && !newData.visible) {\n    status = 'removed';\n  } else if (!oldData.visible && newData.visible) {\n    status = 'added';\n  }\n  const prepareMarkerPairs = () => {\n    if (isCategoryBased && diff) {\n      return pairCategoryData(newData, oldData, diff, {\n        backfillSplitMode: 'static',\n        multiDatum: true\n      });\n    }\n    return pairContinuousData(newData, oldData, {\n      backfillSplitMode: 'static'\n    });\n  };\n  const prepareFillPairs = () => {\n    if (isCategoryBased && diff) {\n      return pairFillCategoryData(newData, oldData, diff);\n    }\n    return pairFillContinuousData(newData, oldData);\n  };\n  const {\n    resultMap: markerPairMap\n  } = prepareMarkerPairs();\n  const {\n    top,\n    bottom\n  } = prepareFillPairs();\n  if (markerPairMap === undefined || top.result === undefined || bottom.result === undefined) {\n    return;\n  }\n  const pairData = [...top.result, ...bottom.result.reverse()];\n  const fill = prepareLinePathAnimationFns(newData, oldData, pairData, 'none', renderPartialPath);\n  const marker = prepareMarkerAnimation(markerPairMap, status);\n  return {\n    fill,\n    marker\n  };\n}\nclass AreaSeries extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pathsPerSeries: 2,\n      pathsZIndexSubOrderOffset: [0, 1000],\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      pickModes: [SeriesNodePickMode.NEAREST_BY_MAIN_AXIS_FIRST, SeriesNodePickMode.EXACT_SHAPE_MATCH],\n      animationResetFns: {\n        path: buildResetPathFn({\n          getOpacity: () => this.getOpacity()\n        }),\n        label: resetLabelFn,\n        marker: (node, datum) => Object.assign(Object.assign({}, resetMarkerFn()), resetMarkerPositionFn(node, datum))\n      }\n    });\n    this.tooltip = new SeriesTooltip();\n    this.marker = new SeriesMarker();\n    this.label = new Label();\n    this.fill = '#c16068';\n    this.stroke = '#874349';\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.xKey = undefined;\n    this.xName = undefined;\n    this.strokeWidth = 2;\n    this.shadow = undefined;\n  }\n  processData(dataController) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        xKey,\n        yKey,\n        normalizedTo,\n        data,\n        visible,\n        seriesGrouping: {\n          groupIndex = this.id\n        } = {}\n      } = this;\n      if (xKey == null || yKey == null || data == null) return;\n      const animationEnabled = !this.ctx.animationManager.isSkipped();\n      const {\n        isContinuousX,\n        isContinuousY\n      } = this.isContinuous();\n      const ids = [`area-stack-${groupIndex}-yValues`, `area-stack-${groupIndex}-yValues-trailing`, `area-stack-${groupIndex}-yValues-prev`, `area-stack-${groupIndex}-yValues-trailing-prev`, `area-stack-${groupIndex}-yValues-marker`];\n      const extraProps = [];\n      const normaliseTo = normalizedTo && isFinite(normalizedTo) ? normalizedTo : undefined;\n      if (normaliseTo) {\n        extraProps.push(normaliseGroupTo(this, [ids[0], ids[1], ids[4]], normaliseTo, 'range'));\n        extraProps.push(normaliseGroupTo(this, [ids[2], ids[3]], normaliseTo, 'range'));\n      }\n      // If two or more datums share an x-value, i.e. lined up vertically, they will have the same datum id.\n      // They must be identified this way when animated to ensure they can be tracked when their y-value\n      // is updated. If this is a static chart, we can instead not bother with identifying datums and\n      // automatically garbage collect the marker selection.\n      if (!isContinuousX && animationEnabled && this.processedData) {\n        extraProps.push(diff(this.processedData));\n      }\n      if (animationEnabled) {\n        extraProps.push(animationValidation(this));\n      }\n      const common = {\n        invalidValue: null\n      };\n      if (!visible) {\n        common.forceValue = 0;\n      }\n      yield this.requestDataModel(dataController, data, {\n        props: [keyProperty(this, xKey, isContinuousX, {\n          id: 'xValue'\n        }), valueProperty(this, yKey, isContinuousY, Object.assign({\n          id: `yValueRaw`\n        }, common)), ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'window', 'current', Object.assign(Object.assign({\n          id: `yValueEnd`\n        }, common), {\n          groupId: ids[0]\n        })), ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'window-trailing', 'current', Object.assign(Object.assign({\n          id: `yValueStart`\n        }, common), {\n          groupId: ids[1]\n        })), ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'window', 'last', Object.assign(Object.assign({\n          id: `yValuePreviousEnd`\n        }, common), {\n          groupId: ids[2]\n        })), ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'window-trailing', 'last', Object.assign(Object.assign({\n          id: `yValuePreviousStart`\n        }, common), {\n          groupId: ids[3]\n        })), ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'normal', 'current', Object.assign(Object.assign({\n          id: `yValueCumulative`\n        }, common), {\n          groupId: ids[4]\n        })), ...extraProps],\n        groupByKeys: true\n      });\n      this.animationState.transition('updateData');\n    });\n  }\n  getSeriesDomain(direction) {\n    const {\n      processedData,\n      dataModel,\n      axes\n    } = this;\n    if (!processedData || !dataModel) return [];\n    const xAxis = axes[ChartAxisDirection.X];\n    const yAxis = axes[ChartAxisDirection.Y];\n    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    const keys = dataModel.getDomain(this, `xValue`, 'key', processedData);\n    const yExtent = dataModel.getDomain(this, `yValueEnd`, 'value', processedData);\n    if (direction === ChartAxisDirection.X) {\n      if ((keyDef === null || keyDef === void 0 ? void 0 : keyDef.def.type) === 'key' && keyDef.def.valueType === 'category') {\n        return keys;\n      }\n      return fixNumericExtent(extent(keys), xAxis);\n    } else if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {\n      return fixNumericExtent(yExtent, yAxis);\n    } else {\n      const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];\n      return fixNumericExtent(fixedYExtent, yAxis);\n    }\n  }\n  createNodeData() {\n    const _super = Object.create(null, {\n      calculateScaling: {\n        get: () => super.calculateScaling\n      }\n    });\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        axes,\n        data,\n        processedData: {\n          data: groupedData\n        } = {},\n        dataModel\n      } = this;\n      const xAxis = axes[ChartAxisDirection.X];\n      const yAxis = axes[ChartAxisDirection.Y];\n      if (!xAxis || !yAxis || !data || !dataModel) {\n        return [];\n      }\n      const {\n        yKey = '',\n        xKey = '',\n        marker,\n        label,\n        fill: seriesFill,\n        stroke: seriesStroke\n      } = this;\n      const {\n        scale: xScale\n      } = xAxis;\n      const {\n        scale: yScale\n      } = yAxis;\n      const continuousY = ContinuousScale.is(yScale);\n      const xOffset = ((_a = xScale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;\n      const defs = dataModel.resolveProcessedDataDefsByIds(this, [`yValueStart`, `yValueEnd`, `yValueRaw`, `yValuePreviousStart`, `yValuePreviousEnd`, `yValueCumulative`]);\n      const createMovePoint = plainPoint => {\n        const {\n            point\n          } = plainPoint,\n          stroke = __rest(plainPoint, [\"point\"]);\n        return Object.assign(Object.assign({}, stroke), {\n          point: Object.assign(Object.assign({}, point), {\n            moveTo: true\n          })\n        });\n      };\n      const createPathCoordinates = (xValue, lastYEnd, yEnd) => {\n        const x = xScale.convert(xValue) + xOffset;\n        const prevYCoordinate = yScale.convert(lastYEnd);\n        const currYCoordinate = yScale.convert(yEnd);\n        return [{\n          point: {\n            x,\n            y: currYCoordinate\n          },\n          yValue: yEnd,\n          xValue\n        }, {\n          point: {\n            x,\n            y: prevYCoordinate\n          },\n          yValue: lastYEnd,\n          xValue\n        }];\n      };\n      const createMarkerCoordinate = (xDatum, yEnd, rawYDatum) => {\n        let currY;\n        // if not normalized, the invalid data points will be processed as `undefined` in processData()\n        // if normalized, the invalid data points will be processed as 0 rather than `undefined`\n        // check if unprocessed datum is valid as we only want to show markers for valid points\n        const normalized = this.normalizedTo && isFinite(this.normalizedTo);\n        const normalizedAndValid = normalized && continuousY && isContinuous(rawYDatum);\n        const valid = !normalized && !isNaN(rawYDatum) || normalizedAndValid;\n        if (valid) {\n          currY = yEnd;\n        }\n        const x = xScale.convert(xDatum) + xOffset;\n        const y = yScale.convert(currY);\n        return {\n          x,\n          y,\n          size: marker.size\n        };\n      };\n      const itemId = yKey;\n      const labelData = [];\n      const markerData = [];\n      const context = {\n        itemId,\n        fillData: {\n          itemId,\n          points: []\n        },\n        strokeData: {\n          itemId,\n          points: []\n        },\n        labelData,\n        nodeData: markerData,\n        scales: _super.calculateScaling.call(this),\n        visible: this.visible\n      };\n      const fillPoints = context.fillData.points;\n      const fillPhantomPoints = [];\n      const strokePoints = context.strokeData.points;\n      let datumIdx = -1;\n      let lastXDatum;\n      let lastYDatum = -Infinity;\n      groupedData === null || groupedData === void 0 ? void 0 : groupedData.forEach(datumGroup => {\n        const {\n          keys,\n          keys: [xDatum],\n          datum: datumArray,\n          values: valuesArray\n        } = datumGroup;\n        valuesArray.forEach((values, valueIdx) => {\n          var _a, _b, _c;\n          datumIdx++;\n          const seriesDatum = datumArray[valueIdx];\n          const dataValues = dataModel.resolveProcessedDataDefsValues(defs, {\n            keys,\n            values\n          });\n          const {\n            yValueRaw: yDatum,\n            yValueCumulative\n          } = dataValues;\n          let {\n            yValueStart,\n            yValueEnd,\n            yValuePreviousStart,\n            yValuePreviousEnd\n          } = dataValues;\n          const validPoint = yDatum != null;\n          // marker data\n          const point = createMarkerCoordinate(xDatum, +yValueCumulative, yDatum);\n          if (validPoint && marker) {\n            markerData.push({\n              index: datumIdx,\n              series: this,\n              itemId,\n              datum: seriesDatum,\n              midPoint: {\n                x: point.x,\n                y: point.y\n              },\n              cumulativeValue: yValueEnd,\n              yValue: yDatum,\n              xValue: xDatum,\n              yKey,\n              xKey,\n              point,\n              fill: (_a = marker.fill) !== null && _a !== void 0 ? _a : seriesFill,\n              stroke: (_b = marker.stroke) !== null && _b !== void 0 ? _b : seriesStroke,\n              strokeWidth: (_c = marker.strokeWidth) !== null && _c !== void 0 ? _c : this.getStrokeWidth(this.strokeWidth)\n            });\n          }\n          // label data\n          if (validPoint && label) {\n            const labelText = this.getLabelText(label, {\n              value: yDatum,\n              datum: seriesDatum,\n              xKey,\n              yKey,\n              xName: this.xName,\n              yName: this.yName\n            }, value => isNumber(value) ? value.toFixed(2) : String(value));\n            labelData.push({\n              index: datumIdx,\n              series: this,\n              itemId: yKey,\n              datum: seriesDatum,\n              x: point.x,\n              y: point.y,\n              label: labelText ? {\n                text: labelText,\n                fontStyle: label.fontStyle,\n                fontWeight: label.fontWeight,\n                fontSize: label.fontSize,\n                fontFamily: label.fontFamily,\n                textAlign: 'center',\n                textBaseline: 'bottom',\n                fill: label.color\n              } : undefined\n            });\n          }\n          // fill data\n          if (lastYDatum == null || yDatum == null) {\n            // Reset all coordinates to 'zero' value.\n            yValueStart = yValueStart !== null && yValueStart !== void 0 ? yValueStart : 0;\n            yValueEnd = yValueStart !== null && yValueStart !== void 0 ? yValueStart : 0;\n            yValuePreviousStart = yValuePreviousStart !== null && yValuePreviousStart !== void 0 ? yValuePreviousStart : 0;\n            yValuePreviousEnd = yValuePreviousStart !== null && yValuePreviousStart !== void 0 ? yValuePreviousStart : 0;\n          }\n          const [prevTop, prevBottom] = createPathCoordinates(lastXDatum, yValuePreviousStart, yValuePreviousEnd);\n          const [top, bottom] = createPathCoordinates(xDatum, yValueStart, yValueEnd);\n          const xValid = lastXDatum != null && xDatum != null;\n          if (xValid) {\n            fillPoints.push(prevTop);\n            fillPhantomPoints.push(prevBottom);\n            fillPoints.push(top);\n            fillPhantomPoints.push(bottom);\n          }\n          // stroke data\n          if (validPoint && lastYDatum != null && datumIdx > 0) {\n            strokePoints.push(createMovePoint(prevTop));\n            strokePoints.push(top);\n          }\n          lastXDatum = xDatum;\n          lastYDatum = yDatum;\n        });\n      });\n      if (strokePoints.length > 0) {\n        strokePoints[0] = createMovePoint(strokePoints[0]);\n      }\n      fillPhantomPoints.reverse();\n      fillPoints.push(...fillPhantomPoints);\n      return [context];\n    });\n  }\n  isPathOrSelectionDirty() {\n    return this.marker.isDirty();\n  }\n  markerFactory() {\n    const {\n      shape\n    } = this.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  updatePathNodes(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        opacity,\n        visible,\n        animationEnabled\n      } = opts;\n      const [fill, stroke] = opts.paths;\n      const {\n        seriesRectHeight: height,\n        seriesRectWidth: width\n      } = this.nodeDataDependencies;\n      const strokeWidth = this.getStrokeWidth(this.strokeWidth);\n      stroke.setProperties({\n        tag: AreaSeriesTag.Stroke,\n        fill: undefined,\n        lineJoin: stroke.lineCap = 'round',\n        pointerEvents: PointerEvents.None,\n        stroke: this.stroke,\n        strokeWidth,\n        strokeOpacity: this.strokeOpacity,\n        lineDash: this.lineDash,\n        lineDashOffset: this.lineDashOffset,\n        opacity,\n        visible\n      });\n      fill.setProperties({\n        tag: AreaSeriesTag.Fill,\n        stroke: undefined,\n        lineJoin: 'round',\n        pointerEvents: PointerEvents.None,\n        fill: this.fill,\n        fillOpacity: this.fillOpacity,\n        lineDash: this.lineDash,\n        lineDashOffset: this.lineDashOffset,\n        strokeOpacity: this.strokeOpacity,\n        fillShadow: this.shadow,\n        opacity,\n        visible: visible || animationEnabled,\n        strokeWidth\n      });\n      const updateClipPath = path => {\n        var _a, _b;\n        if (path.clipPath == null) {\n          path.clipPath = new Path2D();\n          path.clipScalingX = 1;\n          path.clipScalingY = 1;\n        }\n        (_a = path.clipPath) === null || _a === void 0 ? void 0 : _a.clear({\n          trackChanges: true\n        });\n        (_b = path.clipPath) === null || _b === void 0 ? void 0 : _b.rect(-25, -25, (width !== null && width !== void 0 ? width : 0) + 50, (height !== null && height !== void 0 ? height : 0) + 50);\n      };\n      updateClipPath(stroke);\n      updateClipPath(fill);\n    });\n  }\n  updatePaths(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.updateAreaPaths([opts.paths], [opts.contextData]);\n    });\n  }\n  updateAreaPaths(paths, contextData) {\n    this.updateFillPath(paths, contextData);\n    this.updateStrokePath(paths, contextData);\n  }\n  updateFillPath(paths, contextData) {\n    contextData.forEach(({\n      fillData\n    }, contextDataIndex) => {\n      const [fill] = paths[contextDataIndex];\n      const {\n        path: fillPath\n      } = fill;\n      fillPath.clear({\n        trackChanges: true\n      });\n      for (const {\n        point\n      } of fillData.points) {\n        if (point.moveTo) {\n          fillPath.moveTo(point.x, point.y);\n        } else {\n          fillPath.lineTo(point.x, point.y);\n        }\n      }\n      fillPath.closePath();\n      fill.checkPathDirty();\n    });\n  }\n  updateStrokePath(paths, contextData) {\n    contextData.forEach(({\n      strokeData\n    }, contextDataIndex) => {\n      const [, stroke] = paths[contextDataIndex];\n      const {\n        path: strokePath\n      } = stroke;\n      strokePath.clear({\n        trackChanges: true\n      });\n      for (const {\n        point\n      } of strokeData.points) {\n        if (point.moveTo) {\n          strokePath.moveTo(point.x, point.y);\n        } else {\n          strokePath.lineTo(point.x, point.y);\n        }\n      }\n      stroke.checkPathDirty();\n    });\n  }\n  updateMarkerSelection(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        nodeData,\n        markerSelection\n      } = opts;\n      const {\n        marker: {\n          enabled\n        }\n      } = this;\n      const data = enabled && nodeData ? nodeData : [];\n      if (this.marker.isDirty()) {\n        markerSelection.clear();\n        markerSelection.cleanup();\n      }\n      return markerSelection.update(data);\n    });\n  }\n  updateMarkerNodes(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        markerSelection,\n        isHighlight: highlighted\n      } = opts;\n      const {\n        xKey = '',\n        yKey = '',\n        marker,\n        fill,\n        stroke,\n        strokeWidth,\n        fillOpacity,\n        strokeOpacity\n      } = this;\n      const baseStyle = mergeDefaults(highlighted && this.highlightStyle.item, marker.getStyle(), {\n        fill,\n        stroke,\n        strokeWidth,\n        fillOpacity,\n        strokeOpacity\n      });\n      markerSelection.each((node, datum) => {\n        this.updateMarkerStyle(node, marker, {\n          datum,\n          highlighted,\n          xKey,\n          yKey\n        }, baseStyle);\n      });\n      if (!highlighted) {\n        this.marker.markClean();\n      }\n    });\n  }\n  updateLabelSelection(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        labelData,\n        labelSelection\n      } = opts;\n      return labelSelection.update(labelData, text => {\n        text.tag = AreaSeriesTag.Label;\n      });\n    });\n  }\n  updateLabelNodes(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        labelSelection\n      } = opts;\n      const {\n        enabled: labelEnabled,\n        fontStyle,\n        fontWeight,\n        fontSize,\n        fontFamily,\n        color\n      } = this.label;\n      labelSelection.each((text, datum) => {\n        const {\n          x,\n          y,\n          label\n        } = datum;\n        if (label && labelEnabled && this.visible) {\n          text.fontStyle = fontStyle;\n          text.fontWeight = fontWeight;\n          text.fontSize = fontSize;\n          text.fontFamily = fontFamily;\n          text.textAlign = label.textAlign;\n          text.textBaseline = label.textBaseline;\n          text.text = label.text;\n          text.x = x;\n          text.y = y - 10;\n          text.fill = color;\n          text.visible = true;\n        } else {\n          text.visible = false;\n        }\n      });\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const {\n      xKey,\n      id: seriesId,\n      axes,\n      xName,\n      yName,\n      tooltip,\n      marker,\n      dataModel\n    } = this;\n    const {\n      yKey,\n      xValue,\n      yValue,\n      datum\n    } = nodeDatum;\n    const xAxis = axes[ChartAxisDirection.X];\n    const yAxis = axes[ChartAxisDirection.Y];\n    if (!(xKey && yKey) || !(xAxis && yAxis && isNumber(yValue)) || !dataModel) {\n      return '';\n    }\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(yName);\n    const content = sanitizeHtml(xString + ': ' + yString);\n    const baseStyle = mergeDefaults({\n      fill: this.fill\n    }, marker.getStyle(), {\n      stroke: this.stroke,\n      strokeWidth: this.strokeWidth\n    });\n    const {\n      fill: color\n    } = this.getMarkerStyle(marker, {\n      datum: nodeDatum,\n      xKey,\n      yKey,\n      highlighted: false\n    }, baseStyle);\n    return tooltip.toTooltipHtml({\n      title,\n      content,\n      backgroundColor: color\n    }, {\n      datum,\n      xKey,\n      xName,\n      yKey,\n      yName,\n      color,\n      title,\n      seriesId\n    });\n  }\n  getLegendData(legendType) {\n    var _a, _b, _c, _d, _e;\n    const {\n      data,\n      id,\n      xKey,\n      yKey,\n      yName,\n      marker,\n      fill,\n      stroke,\n      fillOpacity,\n      strokeOpacity,\n      visible\n    } = this;\n    if (!(data === null || data === void 0 ? void 0 : data.length) || !xKey || !yKey || legendType !== 'category') {\n      return [];\n    }\n    return [{\n      legendType,\n      id,\n      itemId: yKey,\n      seriesId: id,\n      enabled: visible,\n      label: {\n        text: yName !== null && yName !== void 0 ? yName : yKey\n      },\n      marker: {\n        shape: marker.shape,\n        fill: (_a = marker.fill) !== null && _a !== void 0 ? _a : fill,\n        stroke: (_b = marker.stroke) !== null && _b !== void 0 ? _b : stroke,\n        fillOpacity: (_c = marker.fillOpacity) !== null && _c !== void 0 ? _c : fillOpacity,\n        strokeOpacity: (_d = marker.strokeOpacity) !== null && _d !== void 0 ? _d : strokeOpacity,\n        strokeWidth: (_e = marker.strokeWidth) !== null && _e !== void 0 ? _e : 0\n      }\n    }];\n  }\n  animateEmptyUpdateReady(animationData) {\n    const {\n      markerSelections,\n      labelSelections,\n      contextData,\n      paths\n    } = animationData;\n    const {\n      animationManager\n    } = this.ctx;\n    const {\n      seriesRectWidth: width = 0\n    } = this.nodeDataDependencies;\n    this.updateAreaPaths(paths, contextData);\n    pathSwipeInAnimation(this, animationManager, paths.flat());\n    resetMotion(markerSelections, resetMarkerPositionFn);\n    markerSwipeScaleInAnimation(this, animationManager, markerSelections, width);\n    seriesLabelFadeInAnimation(this, 'labels', animationManager, labelSelections);\n  }\n  animateReadyResize(animationData) {\n    const {\n      contextData,\n      paths\n    } = animationData;\n    this.updateAreaPaths(paths, contextData);\n    super.animateReadyResize(animationData);\n  }\n  animateWaitingUpdateReady(animationData) {\n    var _a, _b;\n    const {\n      animationManager\n    } = this.ctx;\n    const {\n      markerSelections,\n      labelSelections,\n      contextData,\n      paths,\n      previousContextData\n    } = animationData;\n    super.resetAllAnimation(animationData);\n    if (contextData.length === 0 || !previousContextData || previousContextData.length === 0) {\n      animationManager.skipCurrentBatch();\n      this.updateAreaPaths(paths, contextData);\n      return;\n    }\n    const [[fill, stroke]] = paths;\n    const [newData] = contextData;\n    const [oldData] = previousContextData;\n    const fns = prepareAreaPathAnimation(newData, oldData, (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.diff);\n    if (fns === undefined) {\n      animationManager.skipCurrentBatch();\n      this.updateAreaPaths(paths, contextData);\n      return;\n    }\n    fromToMotion(this.id, 'marker_update', animationManager, markerSelections, fns.marker);\n    fromToMotion(this.id, 'fill_path_properties', animationManager, [fill], fns.fill.pathProperties);\n    pathMotion(this.id, 'fill_path_update', animationManager, [fill], fns.fill.path);\n    this.updateStrokePath(paths, contextData);\n    pathFadeInAnimation(this, 'stroke', animationManager, [stroke]);\n    seriesLabelFadeInAnimation(this, 'labels', animationManager, labelSelections);\n  }\n  isLabelEnabled() {\n    return this.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n}\nAreaSeries.className = 'AreaSeries';\nAreaSeries.type = 'area';\n__decorate([Validate(COLOR_STRING), __metadata(\"design:type\", String)], AreaSeries.prototype, \"fill\", void 0);\n__decorate([Validate(COLOR_STRING), __metadata(\"design:type\", String)], AreaSeries.prototype, \"stroke\", void 0);\n__decorate([Validate(NUMBER$1(0, 1)), __metadata(\"design:type\", Object)], AreaSeries.prototype, \"fillOpacity\", void 0);\n__decorate([Validate(NUMBER$1(0, 1)), __metadata(\"design:type\", Object)], AreaSeries.prototype, \"strokeOpacity\", void 0);\n__decorate([Validate(OPT_LINE_DASH), __metadata(\"design:type\", Array)], AreaSeries.prototype, \"lineDash\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], AreaSeries.prototype, \"lineDashOffset\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], AreaSeries.prototype, \"xKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], AreaSeries.prototype, \"xName\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], AreaSeries.prototype, \"yKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], AreaSeries.prototype, \"yName\", void 0);\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], AreaSeries.prototype, \"normalizedTo\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Object)], AreaSeries.prototype, \"strokeWidth\", void 0);\nconst AreaSeriesModule = {\n  type: 'series',\n  optionsKey: 'series[]',\n  packageType: 'community',\n  chartTypes: ['cartesian'],\n  identifier: 'area',\n  instanceConstructor: AreaSeries,\n  stackable: true,\n  seriesDefaults: DEFAULT_CARTESIAN_CHART_OVERRIDES,\n  themeTemplate: {\n    __extends__: EXTENDS_SERIES_DEFAULTS,\n    nodeClickRange: 'nearest',\n    tooltip: {\n      position: {\n        type: 'node'\n      }\n    },\n    fillOpacity: 0.8,\n    strokeOpacity: 1,\n    strokeWidth: 0,\n    lineDash: [0],\n    lineDashOffset: 0,\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    },\n    marker: {\n      __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,\n      enabled: false,\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 0\n    },\n    label: {\n      enabled: false,\n      fontStyle: undefined,\n      fontWeight: undefined,\n      fontSize: 12,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      formatter: undefined\n    }\n  },\n  paletteFactory: params => {\n    const {\n      marker\n    } = markerPaletteFactory(params);\n    return {\n      fill: marker.fill,\n      stroke: marker.stroke,\n      marker\n    };\n  }\n};\nclass AbstractBarSeries extends CartesianSeries {\n  constructor() {\n    super(...arguments);\n    this.direction = 'vertical';\n  }\n  getBandScalePadding() {\n    return {\n      inner: 0.2,\n      outer: 0.1\n    };\n  }\n  shouldFlipXY() {\n    return this.direction === 'horizontal';\n  }\n  getBarDirection() {\n    return this.shouldFlipXY() ? ChartAxisDirection.X : ChartAxisDirection.Y;\n  }\n  getCategoryDirection() {\n    return this.shouldFlipXY() ? ChartAxisDirection.Y : ChartAxisDirection.X;\n  }\n  getValueAxis() {\n    const direction = this.getBarDirection();\n    return this.axes[direction];\n  }\n  getCategoryAxis() {\n    const direction = this.getCategoryDirection();\n    return this.axes[direction];\n  }\n}\n__decorate([Validate(DIRECTION), __metadata(\"design:type\", String)], AbstractBarSeries.prototype, \"direction\", void 0);\nfunction updateRect({\n  rect,\n  config\n}) {\n  const {\n    crisp = true,\n    fill,\n    stroke,\n    strokeWidth,\n    fillOpacity,\n    strokeOpacity,\n    lineDash,\n    lineDashOffset,\n    fillShadow,\n    visible = true\n  } = config;\n  rect.crisp = crisp;\n  rect.fill = fill;\n  rect.stroke = stroke;\n  rect.strokeWidth = strokeWidth;\n  rect.fillOpacity = fillOpacity;\n  rect.strokeOpacity = strokeOpacity;\n  rect.lineDash = lineDash;\n  rect.lineDashOffset = lineDashOffset;\n  rect.fillShadow = fillShadow;\n  rect.visible = visible;\n}\nfunction getRectConfig(_a) {\n  var _b, _c, _d, _e, _f;\n  var {\n      datum,\n      isHighlighted,\n      style,\n      highlightStyle,\n      formatter,\n      seriesId,\n      ctx: {\n        callbackCache\n      }\n    } = _a,\n    opts = __rest(_a, [\"datum\", \"isHighlighted\", \"style\", \"highlightStyle\", \"formatter\", \"seriesId\", \"ctx\"]);\n  const {\n    fill,\n    fillOpacity,\n    stroke,\n    strokeWidth\n  } = mergeDefaults(isHighlighted && highlightStyle, style);\n  const {\n    strokeOpacity,\n    fillShadow,\n    lineDash,\n    lineDashOffset\n  } = style;\n  let format;\n  if (formatter) {\n    format = callbackCache.call(formatter, Object.assign({\n      datum: datum.datum,\n      xKey: datum.xKey,\n      fill,\n      stroke,\n      strokeWidth,\n      highlighted: isHighlighted,\n      seriesId\n    }, opts));\n  }\n  return {\n    fill: (_b = format === null || format === void 0 ? void 0 : format.fill) !== null && _b !== void 0 ? _b : fill,\n    stroke: (_c = format === null || format === void 0 ? void 0 : format.stroke) !== null && _c !== void 0 ? _c : stroke,\n    strokeWidth: (_d = format === null || format === void 0 ? void 0 : format.strokeWidth) !== null && _d !== void 0 ? _d : strokeWidth,\n    fillOpacity: (_e = format === null || format === void 0 ? void 0 : format.fillOpacity) !== null && _e !== void 0 ? _e : fillOpacity,\n    strokeOpacity: (_f = format === null || format === void 0 ? void 0 : format.strokeOpacity) !== null && _f !== void 0 ? _f : strokeOpacity,\n    lineDash,\n    lineDashOffset,\n    fillShadow\n  };\n}\nfunction checkCrisp(visibleRange = []) {\n  const [visibleMin, visibleMax] = visibleRange;\n  const isZoomed = visibleMin !== 0 || visibleMax !== 1;\n  return !isZoomed;\n}\nfunction collapsedStartingBarPosition(isVertical, axes) {\n  const {\n    startingX,\n    startingY\n  } = getStartingValues(isVertical, axes);\n  const isDatumNegative = datum => {\n    var _a;\n    return isNegative((_a = datum['yValue']) !== null && _a !== void 0 ? _a : 0);\n  };\n  const calculate = (datum, prevDatum) => {\n    let x = isVertical ? datum.x : startingX;\n    let y = isVertical ? startingY : datum.y;\n    let width = isVertical ? datum.width : 0;\n    let height = isVertical ? 0 : datum.height;\n    if (prevDatum && (isNaN(x) || isNaN(y))) {\n      // Fallback\n      ({\n        x,\n        y\n      } = prevDatum);\n      width = isVertical ? prevDatum.width : 0;\n      height = isVertical ? 0 : prevDatum.height;\n      if (isVertical && !isDatumNegative(prevDatum)) {\n        y += prevDatum.height;\n      } else if (!isVertical && isDatumNegative(prevDatum)) {\n        x += prevDatum.width;\n      }\n    }\n    return {\n      x,\n      y,\n      width,\n      height\n    };\n  };\n  return {\n    isVertical,\n    calculate\n  };\n}\nfunction midpointStartingBarPosition(isVertical) {\n  return {\n    isVertical,\n    calculate: datum => {\n      return {\n        x: isVertical ? datum.x : datum.x + datum.width / 2,\n        y: isVertical ? datum.y + datum.height / 2 : datum.y,\n        width: isVertical ? datum.width : 0,\n        height: isVertical ? 0 : datum.height\n      };\n    }\n  };\n}\nfunction prepareBarAnimationFunctions(initPos) {\n  const isRemoved = datum => datum == null || isNaN(datum.x) || isNaN(datum.y);\n  const fromFn = (rect, datum, status) => {\n    if (status === 'updated' && isRemoved(datum)) {\n      status = 'removed';\n    } else if (status === 'updated' && isRemoved(rect.previousDatum)) {\n      status = 'added';\n    }\n    // Continue from current rendering location.\n    let source = {\n      x: rect.x,\n      y: rect.y,\n      width: rect.width,\n      height: rect.height\n    };\n    if (status === 'unknown' || status === 'added') {\n      source = initPos.calculate(datum, rect.previousDatum);\n    }\n    return Object.assign(Object.assign({}, source), FROM_TO_MIXINS[status]);\n  };\n  const toFn = (rect, datum, status) => {\n    if (status === 'removed' || isRemoved(datum)) {\n      return initPos.calculate(datum, rect.previousDatum);\n    }\n    return {\n      x: datum.x,\n      y: datum.y,\n      width: datum.width,\n      height: datum.height\n    };\n  };\n  return {\n    toFn,\n    fromFn\n  };\n}\nfunction getStartingValues(isVertical, axes) {\n  const axis = axes[isVertical ? ChartAxisDirection.Y : ChartAxisDirection.X];\n  let startingX = Infinity;\n  let startingY = 0;\n  if (!axis) {\n    return {\n      startingX,\n      startingY\n    };\n  }\n  if (isVertical) {\n    startingY = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.max(...axis.range));\n  } else {\n    startingX = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.min(...axis.range));\n  }\n  return {\n    startingX,\n    startingY\n  };\n}\nfunction resetBarSelectionsFn(_node, {\n  x,\n  y,\n  width,\n  height\n}) {\n  return {\n    x,\n    y,\n    width,\n    height\n  };\n}\nfunction updateLabelNode(textNode, label, labelDatum) {\n  if (label.enabled && labelDatum) {\n    const {\n      x,\n      y,\n      text,\n      textAlign,\n      textBaseline\n    } = labelDatum;\n    const {\n      color: fill,\n      fontStyle,\n      fontWeight,\n      fontSize,\n      fontFamily\n    } = label;\n    textNode.setProperties({\n      visible: true,\n      x,\n      y,\n      text,\n      fill,\n      fontStyle,\n      fontWeight,\n      fontSize,\n      fontFamily,\n      textAlign,\n      textBaseline\n    });\n  } else {\n    textNode.visible = false;\n  }\n}\nfunction adjustLabelPlacement({\n  isPositive,\n  isVertical,\n  placement,\n  padding = 0,\n  rect\n}) {\n  let x = rect.x + rect.width / 2;\n  let y = rect.y + rect.height / 2;\n  let textAlign = 'center';\n  let textBaseline = 'middle';\n  switch (placement) {\n    case 'start':\n      {\n        if (isVertical) {\n          y = isPositive ? rect.y + rect.height + padding : rect.y - padding;\n          textBaseline = isPositive ? 'top' : 'bottom';\n        } else {\n          x = isPositive ? rect.x - padding : rect.x + rect.width + padding;\n          textAlign = isPositive ? 'start' : 'end';\n        }\n        break;\n      }\n    case 'outside':\n    case 'end':\n      {\n        if (isVertical) {\n          y = isPositive ? rect.y - padding : rect.y + rect.height + padding;\n          textBaseline = isPositive ? 'bottom' : 'top';\n        } else {\n          x = isPositive ? rect.x + rect.width + padding : rect.x - padding;\n          textAlign = isPositive ? 'start' : 'end';\n        }\n        break;\n      }\n  }\n  return {\n    x,\n    y,\n    textAlign,\n    textBaseline\n  };\n}\nvar BarSeriesNodeTag;\n(function (BarSeriesNodeTag) {\n  BarSeriesNodeTag[BarSeriesNodeTag[\"Bar\"] = 0] = \"Bar\";\n  BarSeriesNodeTag[BarSeriesNodeTag[\"Label\"] = 1] = \"Label\";\n})(BarSeriesNodeTag || (BarSeriesNodeTag = {}));\nclass BarSeriesLabel extends Label {\n  constructor() {\n    super(...arguments);\n    this.placement = 'inside';\n  }\n}\n__decorate([Validate(STRING_UNION('inside', 'outside')), __metadata(\"design:type\", String)], BarSeriesLabel.prototype, \"placement\", void 0);\nclass BarSeries extends AbstractBarSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [SeriesNodePickMode.EXACT_SHAPE_MATCH],\n      pathsPerSeries: 0,\n      hasHighlightedLabels: true,\n      datumSelectionGarbageCollection: false,\n      animationResetFns: {\n        datum: resetBarSelectionsFn,\n        label: resetLabelFn\n      }\n    });\n    this.label = new BarSeriesLabel();\n    this.tooltip = new SeriesTooltip();\n    this.fill = '#c16068';\n    this.stroke = '#874349';\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.formatter = undefined;\n    this.xKey = undefined;\n    this.xName = undefined;\n    this.yKey = undefined;\n    this.yName = undefined;\n    this.stackGroup = undefined;\n    this.strokeWidth = 1;\n    this.shadow = undefined;\n    /**\r\n     * Used to get the position of bars within each group.\r\n     */\n    this.groupScale = new BandScale();\n    this.smallestDataInterval = undefined;\n  }\n  resolveKeyDirection(direction) {\n    if (this.getBarDirection() === ChartAxisDirection.X) {\n      if (direction === ChartAxisDirection.X) {\n        return ChartAxisDirection.Y;\n      }\n      return ChartAxisDirection.X;\n    }\n    return direction;\n  }\n  processData(dataController) {\n    var _a, _b, _c, _d;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        xKey,\n        yKey,\n        normalizedTo,\n        seriesGrouping: {\n          groupIndex = this.id\n        } = {},\n        data = []\n      } = this;\n      if (xKey == null || yKey == null || data == null) return;\n      const animationEnabled = !this.ctx.animationManager.isSkipped();\n      const normalizedToAbs = Math.abs(normalizedTo !== null && normalizedTo !== void 0 ? normalizedTo : NaN);\n      const isContinuousX = ContinuousScale.is((_a = this.getCategoryAxis()) === null || _a === void 0 ? void 0 : _a.scale);\n      const isContinuousY = ContinuousScale.is((_b = this.getValueAxis()) === null || _b === void 0 ? void 0 : _b.scale);\n      const stackGroupName = `bar-stack-${groupIndex}-yValues`;\n      const stackGroupTrailingName = `${stackGroupName}-trailing`;\n      const normaliseTo = normalizedToAbs && isFinite(normalizedToAbs) ? normalizedToAbs : undefined;\n      const extraProps = [];\n      if (normaliseTo) {\n        extraProps.push(normaliseGroupTo(this, [stackGroupName, stackGroupTrailingName], normaliseTo, 'range'));\n      }\n      if (animationEnabled && this.processedData) {\n        extraProps.push(diff(this.processedData));\n      }\n      if (animationEnabled) {\n        extraProps.push(animationValidation(this));\n      }\n      const visibleProps = !this.visible ? {\n        forceValue: 0\n      } : {};\n      const {\n        processedData\n      } = yield this.requestDataModel(dataController, data, {\n        props: [keyProperty(this, xKey, isContinuousX, {\n          id: 'xValue'\n        }), valueProperty(this, yKey, isContinuousY, Object.assign({\n          id: `yValue-raw`,\n          invalidValue: null\n        }, visibleProps)), ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'normal', 'current', Object.assign({\n          id: `yValue-end`,\n          invalidValue: null,\n          missingValue: 0,\n          groupId: stackGroupName,\n          separateNegative: true\n        }, visibleProps)), ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'trailing', 'current', Object.assign({\n          id: `yValue-start`,\n          invalidValue: null,\n          missingValue: 0,\n          groupId: stackGroupTrailingName,\n          separateNegative: true\n        }, visibleProps)), ...(isContinuousX ? [SMALLEST_KEY_INTERVAL] : []), ...extraProps],\n        groupByKeys: true\n      });\n      this.smallestDataInterval = {\n        x: (_d = (_c = processedData.reduced) === null || _c === void 0 ? void 0 : _c.smallestKeyInterval) !== null && _d !== void 0 ? _d : Infinity,\n        y: Infinity\n      };\n      this.animationState.transition('updateData');\n    });\n  }\n  getSeriesDomain(direction) {\n    var _a;\n    const {\n      processedData,\n      dataModel\n    } = this;\n    if (!processedData || !dataModel) return [];\n    const {\n      reduced: {\n        [SMALLEST_KEY_INTERVAL.property]: smallestX\n      } = {}\n    } = processedData;\n    const categoryAxis = this.getCategoryAxis();\n    const valueAxis = this.getValueAxis();\n    const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    const keys = dataModel.getDomain(this, `xValue`, 'key', processedData);\n    const yExtent = dataModel.getDomain(this, `yValue-end`, 'value', processedData);\n    if (direction === this.getCategoryDirection()) {\n      if ((keyDef === null || keyDef === void 0 ? void 0 : keyDef.def.type) === 'key' && (keyDef === null || keyDef === void 0 ? void 0 : keyDef.def.valueType) === 'category') {\n        return keys;\n      }\n      const scalePadding = smallestX != null && isFinite(smallestX) ? smallestX : 0;\n      const keysExtent = (_a = extent(keys)) !== null && _a !== void 0 ? _a : [NaN, NaN];\n      if (direction === ChartAxisDirection.Y) {\n        return fixNumericExtent([keysExtent[0] + -scalePadding, keysExtent[1]], categoryAxis);\n      }\n      return fixNumericExtent([keysExtent[0], keysExtent[1] + scalePadding], categoryAxis);\n    } else if (this.getValueAxis() instanceof LogAxis) {\n      return fixNumericExtent(yExtent, valueAxis);\n    } else {\n      const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];\n      return fixNumericExtent(fixedYExtent, valueAxis);\n    }\n  }\n  createNodeData() {\n    const _super = Object.create(null, {\n      calculateScaling: {\n        get: () => super.calculateScaling\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        dataModel\n      } = this;\n      const xAxis = this.getCategoryAxis();\n      const yAxis = this.getValueAxis();\n      if (!(dataModel && xAxis && yAxis)) {\n        return [];\n      }\n      const xScale = xAxis.scale;\n      const yScale = yAxis.scale;\n      const {\n        groupScale,\n        yKey = '',\n        xKey = '',\n        fill,\n        stroke,\n        strokeWidth,\n        label,\n        processedData,\n        ctx: {\n          seriesStateManager\n        },\n        smallestDataInterval\n      } = this;\n      const xBandWidth = ContinuousScale.is(xScale) ? xScale.calcBandwidth(smallestDataInterval === null || smallestDataInterval === void 0 ? void 0 : smallestDataInterval.x) : xScale.bandwidth;\n      const domain = [];\n      const {\n        index: groupIndex,\n        visibleGroupCount\n      } = seriesStateManager.getVisiblePeerGroupIndex(this);\n      for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {\n        domain.push(String(groupIdx));\n      }\n      groupScale.domain = domain;\n      groupScale.range = [0, xBandWidth !== null && xBandWidth !== void 0 ? xBandWidth : 0];\n      if (xAxis instanceof CategoryAxis) {\n        groupScale.paddingInner = xAxis.groupPaddingInner;\n      } else if (xAxis instanceof GroupedCategoryAxis) {\n        groupScale.padding = 0.1;\n      } else {\n        // Number or Time axis\n        groupScale.padding = 0;\n      }\n      // To get exactly `0` padding we need to turn off rounding\n      groupScale.round = groupScale.padding !== 0;\n      const barWidth = groupScale.bandwidth >= 1 ?\n      // Pixel-rounded value for low-volume bar charts.\n      groupScale.bandwidth :\n      // Handle high-volume bar charts gracefully.\n      groupScale.rawBandwidth;\n      const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;\n      const yRawIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-raw`).index;\n      const yStartIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-start`).index;\n      const yEndIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-end`).index;\n      const animationEnabled = !this.ctx.animationManager.isSkipped();\n      const context = {\n        itemId: yKey,\n        nodeData: [],\n        labelData: [],\n        scales: _super.calculateScaling.call(this),\n        visible: this.visible || animationEnabled\n      };\n      processedData === null || processedData === void 0 ? void 0 : processedData.data.forEach(({\n        keys,\n        datum: seriesDatum,\n        values\n      }) => {\n        const xValue = keys[xIndex];\n        const x = xScale.convert(xValue);\n        const currY = +values[0][yEndIndex];\n        const prevY = +values[0][yStartIndex];\n        const yRawValue = values[0][yRawIndex];\n        const barX = x + groupScale.convert(String(groupIndex));\n        if (isNaN(currY)) {\n          return;\n        }\n        const y = yScale.convert(currY);\n        const bottomY = yScale.convert(prevY);\n        const barAlongX = this.getBarDirection() === ChartAxisDirection.X;\n        const rect = {\n          x: barAlongX ? Math.min(y, bottomY) : barX,\n          y: barAlongX ? barX : Math.min(y, bottomY),\n          width: barAlongX ? Math.abs(bottomY - y) : barWidth,\n          height: barAlongX ? barWidth : Math.abs(bottomY - y)\n        };\n        const {\n          fontStyle: labelFontStyle,\n          fontWeight: labelFontWeight,\n          fontSize: labelFontSize,\n          fontFamily: labelFontFamily,\n          color: labelColor,\n          placement\n        } = label;\n        const labelText = this.getLabelText(this.label, {\n          datum: seriesDatum[0],\n          value: yRawValue,\n          xKey,\n          yKey,\n          xName: this.xName,\n          yName: this.yName,\n          legendItemName: this.legendItemName\n        }, value => isNumber(value) ? value.toFixed(2) : '');\n        const labelDatum = labelText ? Object.assign({\n          text: labelText,\n          fill: labelColor,\n          fontStyle: labelFontStyle,\n          fontWeight: labelFontWeight,\n          fontSize: labelFontSize,\n          fontFamily: labelFontFamily\n        }, adjustLabelPlacement({\n          isPositive: yRawValue >= 0,\n          isVertical: !barAlongX,\n          placement,\n          rect\n        })) : undefined;\n        const lengthRatioMultiplier = this.shouldFlipXY() ? rect.height : rect.width;\n        const nodeData = {\n          series: this,\n          itemId: yKey,\n          datum: seriesDatum[0],\n          cumulativeValue: currY,\n          xValue,\n          yValue: yRawValue,\n          yKey,\n          xKey,\n          capDefaults: {\n            lengthRatioMultiplier: lengthRatioMultiplier,\n            lengthMax: lengthRatioMultiplier\n          },\n          x: rect.x,\n          y: rect.y,\n          width: rect.width,\n          height: rect.height,\n          midPoint: {\n            x: rect.x + rect.width / 2,\n            y: rect.y + rect.height / 2\n          },\n          fill,\n          stroke,\n          strokeWidth,\n          label: labelDatum\n        };\n        context.nodeData.push(nodeData);\n        context.labelData.push(nodeData);\n      });\n      return [context];\n    });\n  }\n  nodeFactory() {\n    return new Rect();\n  }\n  updateDatumSelection(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      return opts.datumSelection.update(opts.nodeData, rect => {\n        rect.tag = BarSeriesNodeTag.Bar;\n      }, datum => datum.xValue);\n    });\n  }\n  updateDatumNodes(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        datumSelection,\n        isHighlight\n      } = opts;\n      const {\n        yKey = '',\n        fill,\n        stroke,\n        fillOpacity,\n        strokeOpacity,\n        lineDash,\n        lineDashOffset,\n        shadow,\n        formatter,\n        id: seriesId,\n        highlightStyle: {\n          item: itemHighlightStyle\n        },\n        ctx,\n        stackGroup\n      } = this;\n      const xAxis = this.axes[ChartAxisDirection.X];\n      const crisp = checkCrisp(xAxis === null || xAxis === void 0 ? void 0 : xAxis.visibleRange);\n      const categoryAlongX = this.getCategoryDirection() === ChartAxisDirection.X;\n      datumSelection.each((rect, datum) => {\n        const style = {\n          fill,\n          stroke,\n          fillOpacity,\n          strokeOpacity,\n          lineDash,\n          lineDashOffset,\n          fillShadow: shadow,\n          strokeWidth: this.getStrokeWidth(this.strokeWidth)\n        };\n        const visible = categoryAlongX ? datum.width > 0 : datum.height > 0;\n        const config = getRectConfig({\n          datum,\n          isHighlighted: isHighlight,\n          style,\n          highlightStyle: itemHighlightStyle,\n          formatter,\n          seriesId,\n          stackGroup,\n          ctx,\n          yKey\n        });\n        config.crisp = crisp;\n        config.visible = visible;\n        updateRect({\n          rect,\n          config\n        });\n      });\n    });\n  }\n  updateLabelSelection(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const data = this.label.enabled ? opts.labelData : [];\n      return opts.labelSelection.update(data, text => {\n        text.tag = BarSeriesNodeTag.Label;\n        text.pointerEvents = PointerEvents.None;\n      });\n    });\n  }\n  updateLabelNodes(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      opts.labelSelection.each((textNode, datum) => {\n        updateLabelNode(textNode, this.label, datum.label);\n      });\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    var _a;\n    const {\n      xKey,\n      yKey,\n      processedData,\n      ctx: {\n        callbackCache\n      }\n    } = this;\n    const xAxis = this.getCategoryAxis();\n    const yAxis = this.getValueAxis();\n    const {\n      xValue,\n      yValue,\n      datum\n    } = nodeDatum;\n    if (!processedData || !xKey || !yKey || !xAxis || !yAxis) {\n      return '';\n    }\n    const {\n      xName,\n      yName,\n      fill,\n      stroke,\n      tooltip,\n      formatter,\n      id: seriesId,\n      stackGroup\n    } = this;\n    const strokeWidth = this.getStrokeWidth(this.strokeWidth);\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml(yName);\n    const content = sanitizeHtml(xString + ': ' + yString);\n    let format;\n    if (formatter) {\n      format = callbackCache.call(formatter, {\n        datum,\n        fill,\n        stroke,\n        strokeWidth,\n        highlighted: false,\n        xKey,\n        yKey,\n        seriesId,\n        stackGroup\n      });\n    }\n    const color = (_a = format === null || format === void 0 ? void 0 : format.fill) !== null && _a !== void 0 ? _a : fill;\n    return tooltip.toTooltipHtml({\n      title,\n      content,\n      backgroundColor: color\n    }, Object.assign({\n      datum,\n      xKey,\n      xName,\n      yKey,\n      yName,\n      color,\n      title,\n      seriesId,\n      stackGroup\n    }, this.getModuleTooltipParams(datum)));\n  }\n  getLegendData(legendType) {\n    var _a;\n    const {\n      id,\n      data,\n      xKey,\n      yKey,\n      yName,\n      legendItemName,\n      fill,\n      stroke,\n      strokeWidth,\n      fillOpacity,\n      strokeOpacity,\n      visible,\n      showInLegend\n    } = this;\n    if (legendType !== 'category' || !showInLegend || !(data === null || data === void 0 ? void 0 : data.length) || !xKey || !yKey) {\n      return [];\n    }\n    return [{\n      legendType: 'category',\n      id,\n      itemId: yKey,\n      seriesId: id,\n      enabled: visible,\n      label: {\n        text: (_a = legendItemName !== null && legendItemName !== void 0 ? legendItemName : yName) !== null && _a !== void 0 ? _a : yKey\n      },\n      marker: {\n        fill,\n        stroke,\n        fillOpacity,\n        strokeOpacity,\n        strokeWidth\n      },\n      legendItemName\n    }];\n  }\n  animateEmptyUpdateReady({\n    datumSelections,\n    labelSelections,\n    annotationSelections\n  }) {\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.direction === 'vertical', this.axes));\n    fromToMotion(this.id, 'nodes', this.ctx.animationManager, datumSelections, fns);\n    seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, labelSelections);\n    seriesLabelFadeInAnimation(this, 'annotations', this.ctx.animationManager, annotationSelections);\n  }\n  animateWaitingUpdateReady(data) {\n    var _a, _b;\n    const {\n      datumSelections,\n      labelSelections,\n      annotationSelections\n    } = data;\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    const diff = (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.diff;\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.direction === 'vertical', this.axes));\n    fromToMotion(this.id, 'nodes', this.ctx.animationManager, datumSelections, fns, (_, datum) => String(datum.xValue), diff);\n    seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, labelSelections);\n    seriesLabelFadeInAnimation(this, 'annotations', this.ctx.animationManager, annotationSelections);\n  }\n  isLabelEnabled() {\n    return this.label.enabled;\n  }\n}\nBarSeries.className = 'BarSeries';\nBarSeries.type = 'bar';\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], BarSeries.prototype, \"fill\", void 0);\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], BarSeries.prototype, \"stroke\", void 0);\n__decorate([Validate(NUMBER$1(0, 1)), __metadata(\"design:type\", Object)], BarSeries.prototype, \"fillOpacity\", void 0);\n__decorate([Validate(NUMBER$1(0, 1)), __metadata(\"design:type\", Object)], BarSeries.prototype, \"strokeOpacity\", void 0);\n__decorate([Validate(OPT_LINE_DASH), __metadata(\"design:type\", Array)], BarSeries.prototype, \"lineDash\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], BarSeries.prototype, \"lineDashOffset\", void 0);\n__decorate([Validate(OPT_FUNCTION), __metadata(\"design:type\", Function)], BarSeries.prototype, \"formatter\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], BarSeries.prototype, \"xKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], BarSeries.prototype, \"xName\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], BarSeries.prototype, \"yKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], BarSeries.prototype, \"yName\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], BarSeries.prototype, \"stackGroup\", void 0);\n__decorate([Validate(OPT_NUMBER()), __metadata(\"design:type\", Number)], BarSeries.prototype, \"normalizedTo\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], BarSeries.prototype, \"strokeWidth\", void 0);\nconst BarSeriesModule = {\n  type: 'series',\n  optionsKey: 'series[]',\n  packageType: 'community',\n  chartTypes: ['cartesian'],\n  identifier: 'bar',\n  instanceConstructor: BarSeries,\n  stackable: true,\n  groupable: true,\n  seriesDefaults: {\n    axes: [{\n      type: CARTESIAN_AXIS_TYPES.NUMBER,\n      position: CARTESIAN_AXIS_POSITIONS.LEFT\n    }, {\n      type: CARTESIAN_AXIS_TYPES.CATEGORY,\n      position: CARTESIAN_AXIS_POSITIONS.BOTTOM\n    }]\n  },\n  swapDefaultAxesCondition: series => (series === null || series === void 0 ? void 0 : series.direction) === 'horizontal',\n  themeTemplate: {\n    __extends__: EXTENDS_SERIES_DEFAULTS,\n    fillOpacity: 1,\n    strokeWidth: 0,\n    lineDash: [0],\n    lineDashOffset: 0,\n    label: {\n      enabled: false,\n      fontStyle: undefined,\n      fontWeight: NORMAL,\n      fontSize: 12,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n      formatter: undefined,\n      placement: 'inside'\n    },\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    }\n  },\n  enterpriseThemeTemplate: {\n    errorBar: {\n      cap: {\n        lengthRatio: 0.3\n      }\n    }\n  },\n  paletteFactory: singleSeriesPaletteFactory\n};\nclass BubbleSeriesNodeClickEvent extends CartesianSeriesNodeClickEvent {\n  constructor(type, nativeEvent, datum, series) {\n    super(type, nativeEvent, datum, series);\n    this.sizeKey = series.sizeKey;\n  }\n}\nclass BubbleSeriesMarker extends SeriesMarker {\n  constructor() {\n    super(...arguments);\n    /**\r\n     * The series `sizeKey` values along with the `size` and `maxSize` configs will be used to\r\n     * determine the size of the marker. All values will be mapped to a marker size within the\r\n     * `[size, maxSize]` range, where the largest values will correspond to the `maxSize` and the\r\n     * lowest to the `size`.\r\n     */\n    this.maxSize = 30;\n    this.domain = undefined;\n  }\n}\n__decorate([Validate(NUMBER$1(0)), SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Object)], BubbleSeriesMarker.prototype, \"maxSize\", void 0);\n__decorate([Validate(OPT_NUMBER_ARRAY), SceneChangeDetection({\n  redraw: RedrawType.MAJOR\n}), __metadata(\"design:type\", Array)], BubbleSeriesMarker.prototype, \"domain\", void 0);\nclass BubbleSeries extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST, SeriesNodePickMode.NEAREST_NODE, SeriesNodePickMode.EXACT_SHAPE_MATCH],\n      pathsPerSeries: 0,\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        label: resetLabelFn,\n        marker: resetMarkerFn\n      }\n    });\n    this.NodeClickEvent = BubbleSeriesNodeClickEvent;\n    this.sizeScale = new LinearScale();\n    this.marker = new BubbleSeriesMarker();\n    this.label = new Label();\n    this.title = undefined;\n    this.labelKey = undefined;\n    this.xName = undefined;\n    this.yName = undefined;\n    this.sizeName = 'Size';\n    this.labelName = 'Label';\n    this.xKey = undefined;\n    this.yKey = undefined;\n    this.sizeKey = undefined;\n    this.colorKey = undefined;\n    this.colorName = 'Color';\n    this.colorRange = ['#ffff00', '#00ff00', '#0000ff'];\n    this.colorScale = new ColorScale();\n    this.tooltip = new SeriesTooltip();\n  }\n  processData(dataController) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        xKey,\n        yKey,\n        sizeKey,\n        labelKey,\n        colorScale,\n        colorDomain,\n        colorRange,\n        colorKey,\n        marker,\n        data\n      } = this;\n      if (xKey == null || yKey == null || sizeKey == null || data == null) return;\n      const {\n        isContinuousX,\n        isContinuousY\n      } = this.isContinuous();\n      const {\n        dataModel,\n        processedData\n      } = yield this.requestDataModel(dataController, data, {\n        props: [keyProperty(this, xKey, isContinuousX, {\n          id: 'xKey-raw'\n        }), keyProperty(this, yKey, isContinuousY, {\n          id: 'yKey-raw'\n        }), ...(labelKey ? [keyProperty(this, labelKey, false, {\n          id: `labelKey-raw`\n        })] : []), valueProperty(this, xKey, isContinuousX, {\n          id: `xValue`\n        }), valueProperty(this, yKey, isContinuousY, {\n          id: `yValue`\n        }), valueProperty(this, sizeKey, true, {\n          id: `sizeValue`\n        }), ...(colorKey ? [valueProperty(this, colorKey, true, {\n          id: `colorValue`\n        })] : []), ...(labelKey ? [valueProperty(this, labelKey, false, {\n          id: `labelValue`\n        })] : [])],\n        dataVisible: this.visible\n      });\n      const sizeKeyIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`).index;\n      const processedSize = (_a = processedData.domain.values[sizeKeyIdx]) !== null && _a !== void 0 ? _a : [];\n      this.sizeScale.domain = marker.domain ? marker.domain : processedSize;\n      if (colorKey) {\n        const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`).index;\n        colorScale.domain = (_b = colorDomain !== null && colorDomain !== void 0 ? colorDomain : processedData.domain.values[colorKeyIdx]) !== null && _b !== void 0 ? _b : [];\n        colorScale.range = colorRange;\n        colorScale.update();\n      }\n      this.animationState.transition('updateData');\n    });\n  }\n  getSeriesDomain(direction) {\n    const {\n      dataModel,\n      processedData\n    } = this;\n    if (!processedData || !dataModel) return [];\n    const id = direction === ChartAxisDirection.X ? `xValue` : `yValue`;\n    const dataDef = dataModel.resolveProcessedDataDefById(this, id);\n    const domain = dataModel.getDomain(this, id, 'value', processedData);\n    if ((dataDef === null || dataDef === void 0 ? void 0 : dataDef.def.type) === 'value' && (dataDef === null || dataDef === void 0 ? void 0 : dataDef.def.valueType) === 'category') {\n      return domain;\n    }\n    const axis = this.axes[direction];\n    return fixNumericExtent(extent(domain), axis);\n  }\n  createNodeData() {\n    const _super = Object.create(null, {\n      calculateScaling: {\n        get: () => super.calculateScaling\n      }\n    });\n    var _a, _b, _c, _d;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        visible,\n        axes,\n        yKey = '',\n        xKey = '',\n        label,\n        labelKey,\n        dataModel,\n        processedData,\n        colorScale,\n        sizeKey = '',\n        colorKey\n      } = this;\n      const xAxis = axes[ChartAxisDirection.X];\n      const yAxis = axes[ChartAxisDirection.Y];\n      if (!(dataModel && processedData && visible && xAxis && yAxis)) return [];\n      const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;\n      const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`).index;\n      const sizeDataIdx = sizeKey ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`).index : -1;\n      const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`).index : -1;\n      const labelDataIdx = labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`).index : -1;\n      const xScale = xAxis.scale;\n      const yScale = yAxis.scale;\n      const xOffset = ((_a = xScale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;\n      const yOffset = ((_b = yScale.bandwidth) !== null && _b !== void 0 ? _b : 0) / 2;\n      const {\n        sizeScale,\n        marker\n      } = this;\n      const nodeData = [];\n      sizeScale.range = [marker.size, marker.maxSize];\n      const font = label.getFont();\n      for (const {\n        values,\n        datum\n      } of (_c = processedData.data) !== null && _c !== void 0 ? _c : []) {\n        const xDatum = values[xDataIdx];\n        const yDatum = values[yDataIdx];\n        const x = xScale.convert(xDatum) + xOffset;\n        const y = yScale.convert(yDatum) + yOffset;\n        const labelText = this.getLabelText(label, {\n          value: labelKey ? values[labelDataIdx] : yDatum,\n          datum,\n          xKey,\n          yKey,\n          sizeKey,\n          labelKey,\n          xName: this.xName,\n          yName: this.yName,\n          sizeName: this.sizeName,\n          labelName: this.labelName\n        });\n        const size = HdpiCanvas.getTextSize(String(labelText), font);\n        const markerSize = sizeKey ? sizeScale.convert(values[sizeDataIdx]) : marker.size;\n        const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : undefined;\n        nodeData.push({\n          series: this,\n          itemId: yKey,\n          yKey,\n          xKey,\n          datum,\n          xValue: xDatum,\n          yValue: yDatum,\n          sizeValue: values[sizeDataIdx],\n          point: {\n            x,\n            y,\n            size: markerSize\n          },\n          midPoint: {\n            x,\n            y\n          },\n          fill,\n          label: Object.assign({\n            text: labelText\n          }, size)\n        });\n      }\n      return [{\n        itemId: (_d = this.yKey) !== null && _d !== void 0 ? _d : this.id,\n        nodeData,\n        labelData: nodeData,\n        scales: _super.calculateScaling.call(this),\n        visible: this.visible\n      }];\n    });\n  }\n  isPathOrSelectionDirty() {\n    return this.marker.isDirty();\n  }\n  getLabelData() {\n    var _a;\n    return (_a = this.contextNodeData) === null || _a === void 0 ? void 0 : _a.reduce((r, n) => r.concat(n.labelData), []);\n  }\n  markerFactory() {\n    const {\n      shape\n    } = this.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  updateMarkerSelection(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        nodeData,\n        markerSelection\n      } = opts;\n      if (this.marker.isDirty()) {\n        markerSelection.clear();\n        markerSelection.cleanup();\n      }\n      const data = this.marker.enabled ? nodeData : [];\n      return markerSelection.update(data, undefined, datum => this.getDatumId(datum));\n    });\n  }\n  updateMarkerNodes(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        markerSelection,\n        isHighlight: highlighted\n      } = opts;\n      const {\n        xKey = '',\n        yKey = '',\n        sizeKey = '',\n        labelKey,\n        marker\n      } = this;\n      const baseStyle = mergeDefaults(highlighted && this.highlightStyle.item, marker.getStyle());\n      this.sizeScale.range = [marker.size, marker.maxSize];\n      markerSelection.each((node, datum) => {\n        this.updateMarkerStyle(node, marker, {\n          datum,\n          highlighted,\n          xKey,\n          yKey,\n          sizeKey,\n          labelKey\n        }, baseStyle);\n      });\n      if (!highlighted) {\n        this.marker.markClean();\n      }\n    });\n  }\n  updateLabelSelection(opts) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        labelSelection\n      } = opts;\n      const {\n        label: {\n          enabled\n        }\n      } = this;\n      const placedLabels = enabled ? (_b = (_a = this.chart) === null || _a === void 0 ? void 0 : _a.placeLabels().get(this)) !== null && _b !== void 0 ? _b : [] : [];\n      const placedNodeDatum = placedLabels.map(v => Object.assign(Object.assign({}, v.datum), {\n        point: {\n          x: v.x,\n          y: v.y,\n          size: v.datum.point.size\n        }\n      }));\n      return labelSelection.update(placedNodeDatum);\n    });\n  }\n  updateLabelNodes(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        labelSelection\n      } = opts;\n      const {\n        label\n      } = this;\n      labelSelection.each((text, datum) => {\n        var _a, _b, _c, _d;\n        text.text = datum.label.text;\n        text.fill = label.color;\n        text.x = (_b = (_a = datum.point) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;\n        text.y = (_d = (_c = datum.point) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0;\n        text.fontStyle = label.fontStyle;\n        text.fontWeight = label.fontWeight;\n        text.fontSize = label.fontSize;\n        text.fontFamily = label.fontFamily;\n        text.textAlign = 'left';\n        text.textBaseline = 'top';\n      });\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    var _a;\n    const {\n      xKey,\n      yKey,\n      sizeKey,\n      axes\n    } = this;\n    const xAxis = axes[ChartAxisDirection.X];\n    const yAxis = axes[ChartAxisDirection.Y];\n    if (!xKey || !yKey || !xAxis || !yAxis || !sizeKey) {\n      return '';\n    }\n    const {\n      marker,\n      tooltip,\n      xName,\n      yName,\n      sizeName,\n      labelKey,\n      labelName,\n      id: seriesId\n    } = this;\n    const baseStyle = mergeDefaults({\n      fill: nodeDatum.fill,\n      strokeWidth: this.getStrokeWidth(marker.strokeWidth)\n    }, marker.getStyle());\n    const {\n      fill: color = 'gray'\n    } = this.getMarkerStyle(marker, {\n      datum: nodeDatum,\n      highlighted: false,\n      xKey,\n      yKey,\n      sizeKey,\n      labelKey\n    }, baseStyle);\n    const title = (_a = this.title) !== null && _a !== void 0 ? _a : yName;\n    const {\n      datum,\n      xValue,\n      yValue,\n      sizeValue,\n      label: {\n        text: labelText\n      }\n    } = nodeDatum;\n    const xString = sanitizeHtml(xAxis.formatDatum(xValue));\n    const yString = sanitizeHtml(yAxis.formatDatum(yValue));\n    let content = `<b>${sanitizeHtml(xName !== null && xName !== void 0 ? xName : xKey)}</b>: ${xString}<br>` + `<b>${sanitizeHtml(yName !== null && yName !== void 0 ? yName : yKey)}</b>: ${yString}`;\n    if (sizeKey) {\n      content += `<br><b>${sanitizeHtml(sizeName !== null && sizeName !== void 0 ? sizeName : sizeKey)}</b>: ${sanitizeHtml(String(sizeValue))}`;\n    }\n    if (labelKey) {\n      content = `<b>${sanitizeHtml(labelName !== null && labelName !== void 0 ? labelName : labelKey)}</b>: ${sanitizeHtml(labelText)}<br>` + content;\n    }\n    return tooltip.toTooltipHtml({\n      title,\n      content,\n      backgroundColor: color\n    }, {\n      datum,\n      xKey,\n      xName,\n      yKey,\n      yName,\n      sizeKey,\n      sizeName,\n      labelKey,\n      labelName,\n      title,\n      color,\n      seriesId\n    });\n  }\n  getLegendData() {\n    var _a;\n    const {\n      id,\n      data,\n      xKey,\n      yKey,\n      sizeKey,\n      yName,\n      title,\n      visible,\n      marker\n    } = this;\n    const {\n      shape,\n      fill,\n      stroke,\n      fillOpacity,\n      strokeOpacity,\n      strokeWidth\n    } = marker;\n    if (!((data === null || data === void 0 ? void 0 : data.length) && xKey && yKey && sizeKey)) {\n      return [];\n    }\n    return [{\n      legendType: 'category',\n      id,\n      itemId: yKey,\n      seriesId: id,\n      enabled: visible,\n      label: {\n        text: (_a = title !== null && title !== void 0 ? title : yName) !== null && _a !== void 0 ? _a : yKey\n      },\n      marker: {\n        shape,\n        fill: fill !== null && fill !== void 0 ? fill : 'rgba(0, 0, 0, 0)',\n        stroke: stroke !== null && stroke !== void 0 ? stroke : 'rgba(0, 0, 0, 0)',\n        fillOpacity: fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1,\n        strokeOpacity: strokeOpacity !== null && strokeOpacity !== void 0 ? strokeOpacity : 1,\n        strokeWidth: strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 0\n      }\n    }];\n  }\n  animateEmptyUpdateReady({\n    markerSelections,\n    labelSelections\n  }) {\n    markerScaleInAnimation(this, this.ctx.animationManager, markerSelections);\n    seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, labelSelections);\n  }\n  getDatumId(datum) {\n    return createDatumId([`${datum.xValue}`, `${datum.yValue}`, datum.label.text]);\n  }\n  isLabelEnabled() {\n    return this.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n}\nBubbleSeries.className = 'BubbleSeries';\nBubbleSeries.type = 'bubble';\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], BubbleSeries.prototype, \"title\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], BubbleSeries.prototype, \"labelKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], BubbleSeries.prototype, \"xName\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], BubbleSeries.prototype, \"yName\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], BubbleSeries.prototype, \"sizeName\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], BubbleSeries.prototype, \"labelName\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], BubbleSeries.prototype, \"xKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], BubbleSeries.prototype, \"yKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], BubbleSeries.prototype, \"sizeKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], BubbleSeries.prototype, \"colorKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], BubbleSeries.prototype, \"colorName\", void 0);\n__decorate([Validate(OPT_NUMBER_ARRAY), __metadata(\"design:type\", Array)], BubbleSeries.prototype, \"colorDomain\", void 0);\n__decorate([Validate(COLOR_STRING_ARRAY), __metadata(\"design:type\", Array)], BubbleSeries.prototype, \"colorRange\", void 0);\nconst BubbleSeriesModule = {\n  type: 'series',\n  optionsKey: 'series[]',\n  packageType: 'community',\n  chartTypes: ['cartesian'],\n  identifier: 'bubble',\n  instanceConstructor: BubbleSeries,\n  seriesDefaults: {\n    axes: [{\n      type: CARTESIAN_AXIS_TYPES.NUMBER,\n      position: CARTESIAN_AXIS_POSITIONS.BOTTOM\n    }, {\n      type: CARTESIAN_AXIS_TYPES.NUMBER,\n      position: CARTESIAN_AXIS_POSITIONS.LEFT\n    }]\n  },\n  themeTemplate: {\n    __extends__: EXTENDS_SERIES_DEFAULTS,\n    tooltip: {\n      position: {\n        type: 'node'\n      }\n    },\n    marker: {\n      __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,\n      maxSize: 30,\n      fillOpacity: 0.8\n    },\n    label: {\n      enabled: false,\n      fontStyle: undefined,\n      fontWeight: undefined,\n      fontSize: 12,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR\n    }\n  },\n  paletteFactory: markerPaletteFactory\n};\nconst HISTOGRAM_AGGREGATIONS = ['count', 'sum', 'mean'];\nconst HISTOGRAM_AGGREGATION = predicateWithMessage(v => HISTOGRAM_AGGREGATIONS.includes(v), `expecting a histogram aggregation keyword such as 'count', 'sum' or 'mean`);\nvar HistogramSeriesNodeTag;\n(function (HistogramSeriesNodeTag) {\n  HistogramSeriesNodeTag[HistogramSeriesNodeTag[\"Bin\"] = 0] = \"Bin\";\n  HistogramSeriesNodeTag[HistogramSeriesNodeTag[\"Label\"] = 1] = \"Label\";\n})(HistogramSeriesNodeTag || (HistogramSeriesNodeTag = {}));\nconst defaultBinCount = 10;\nclass HistogramSeries extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [SeriesNodePickMode.EXACT_SHAPE_MATCH],\n      datumSelectionGarbageCollection: false,\n      animationResetFns: {\n        datum: resetBarSelectionsFn,\n        label: resetLabelFn\n      }\n    });\n    this.label = new Label();\n    this.tooltip = new SeriesTooltip();\n    this.fill = undefined;\n    this.stroke = undefined;\n    this.fillOpacity = 1;\n    this.strokeOpacity = 1;\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.xKey = undefined;\n    this.areaPlot = false;\n    this.aggregation = 'sum';\n    this.binCount = undefined;\n    this.xName = undefined;\n    this.yKey = undefined;\n    this.yName = undefined;\n    this.strokeWidth = 1;\n    this.shadow = undefined;\n    this.calculatedBins = [];\n  }\n  // During processData phase, used to unify different ways of the user specifying\n  // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].\n  deriveBins(xDomain) {\n    if (this.binCount === undefined) {\n      const binStarts = ticks(xDomain[0], xDomain[1], defaultBinCount);\n      const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);\n      const firstBinEnd = binStarts[0];\n      const expandStartToBin = n => [n, n + binSize];\n      return [[firstBinEnd - binSize, firstBinEnd], ...binStarts.map(expandStartToBin)];\n    } else {\n      return this.calculateNiceBins(xDomain, this.binCount);\n    }\n  }\n  calculateNiceBins(domain, binCount) {\n    const startGuess = Math.floor(domain[0]);\n    const stop = domain[1];\n    const segments = binCount || 1;\n    const {\n      start,\n      binSize\n    } = this.calculateNiceStart(startGuess, stop, segments);\n    return this.getBins(start, stop, binSize, segments);\n  }\n  getBins(start, stop, step, count) {\n    const bins = [];\n    for (let i = 0; i < count; i++) {\n      const a = Math.round((start + i * step) * 10) / 10;\n      let b = Math.round((start + (i + 1) * step) * 10) / 10;\n      if (i === count - 1) {\n        b = Math.max(b, stop);\n      }\n      bins[i] = [a, b];\n    }\n    return bins;\n  }\n  calculateNiceStart(a, b, segments) {\n    const binSize = Math.abs(b - a) / segments;\n    const order = Math.floor(Math.log10(binSize));\n    const magnitude = Math.pow(10, order);\n    const start = Math.floor(a / magnitude) * magnitude;\n    return {\n      start,\n      binSize\n    };\n  }\n  processData(dataController) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        xKey,\n        yKey,\n        data,\n        areaPlot,\n        aggregation\n      } = this;\n      const props = [keyProperty(this, xKey, true), SORT_DOMAIN_GROUPS];\n      if (yKey) {\n        let aggProp = groupCount(this, 'groupCount');\n        if (aggregation === 'count') ;else if (aggregation === 'sum') {\n          aggProp = groupSum(this, 'groupAgg');\n        } else if (aggregation === 'mean') {\n          aggProp = groupAverage(this, 'groupAgg');\n        }\n        if (areaPlot) {\n          aggProp = area(this, 'groupAgg', aggProp);\n        }\n        props.push(valueProperty(this, yKey, true, {\n          invalidValue: undefined\n        }), aggProp);\n      } else {\n        let aggProp = groupCount(this, 'groupAgg');\n        if (areaPlot) {\n          aggProp = area(this, 'groupAgg', aggProp);\n        }\n        props.push(aggProp);\n      }\n      const groupByFn = dataSet => {\n        var _a;\n        const xExtent = fixNumericExtent(dataSet.domain.keys[0]);\n        if (xExtent.length === 0) {\n          // No buckets can be calculated.\n          dataSet.domain.groups = [];\n          return () => [];\n        }\n        const bins = (_a = this.bins) !== null && _a !== void 0 ? _a : this.deriveBins(xExtent);\n        const binCount = bins.length;\n        this.calculatedBins = [...bins];\n        return item => {\n          const xValue = item.keys[0];\n          for (let i = 0; i < binCount; i++) {\n            const nextBin = bins[i];\n            if (xValue >= nextBin[0] && xValue < nextBin[1]) {\n              return nextBin;\n            }\n            if (i === binCount - 1 && xValue <= nextBin[1]) {\n              // Handle edge case of a value being at the maximum extent, and the\n              // final bin aligning with it.\n              return nextBin;\n            }\n          }\n          return [];\n        };\n      };\n      if (!this.ctx.animationManager.isSkipped() && this.processedData) {\n        props.push(diff(this.processedData, false));\n      }\n      yield this.requestDataModel(dataController, data !== null && data !== void 0 ? data : [], {\n        props,\n        dataVisible: this.visible,\n        groupByFn\n      });\n      this.animationState.transition('updateData');\n    });\n  }\n  getSeriesDomain(direction) {\n    var _a, _b, _c, _d;\n    const {\n      processedData,\n      dataModel\n    } = this;\n    if (!processedData || !dataModel || !this.calculatedBins.length) return [];\n    const yDomain = dataModel.getDomain(this, `groupAgg`, 'aggregate', processedData);\n    const xDomainMin = (_a = this.calculatedBins) === null || _a === void 0 ? void 0 : _a[0][0];\n    const xDomainMax = (_b = this.calculatedBins) === null || _b === void 0 ? void 0 : _b[((_d = (_c = this.calculatedBins) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) - 1][1];\n    if (direction === ChartAxisDirection.X) {\n      return fixNumericExtent([xDomainMin, xDomainMax]);\n    }\n    return fixNumericExtent(yDomain);\n  }\n  createNodeData() {\n    const _super = Object.create(null, {\n      calculateScaling: {\n        get: () => super.calculateScaling\n      }\n    });\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        axes,\n        processedData,\n        ctx: {\n          callbackCache\n        }\n      } = this;\n      const xAxis = axes[ChartAxisDirection.X];\n      const yAxis = axes[ChartAxisDirection.Y];\n      if (!this.visible || !xAxis || !yAxis || !processedData || processedData.type !== 'grouped') {\n        return [];\n      }\n      const {\n        scale: xScale\n      } = xAxis;\n      const {\n        scale: yScale\n      } = yAxis;\n      const {\n        fill,\n        stroke,\n        strokeWidth,\n        id: seriesId,\n        yKey = '',\n        xKey = ''\n      } = this;\n      const nodeData = [];\n      const {\n        label: {\n          formatter: labelFormatter = params => String(params.value),\n          fontStyle: labelFontStyle,\n          fontWeight: labelFontWeight,\n          fontSize: labelFontSize,\n          fontFamily: labelFontFamily,\n          color: labelColor\n        }\n      } = this;\n      processedData.data.forEach(group => {\n        var _a;\n        const {\n          aggValues: [[negativeAgg, positiveAgg]] = [[0, 0]],\n          datum,\n          datum: {\n            length: frequency\n          },\n          keys: domain,\n          keys: [xDomainMin, xDomainMax]\n        } = group;\n        const xMinPx = xScale.convert(xDomainMin);\n        const xMaxPx = xScale.convert(xDomainMax);\n        const total = negativeAgg + positiveAgg;\n        const yZeroPx = yScale.convert(0);\n        const yMaxPx = yScale.convert(total);\n        const w = xMaxPx - xMinPx;\n        const h = Math.abs(yMaxPx - yZeroPx);\n        const selectionDatumLabel = total !== 0 ? {\n          text: (_a = callbackCache.call(labelFormatter, {\n            value: total,\n            datum,\n            seriesId,\n            xKey,\n            yKey,\n            xName: this.xName,\n            yName: this.yName\n          })) !== null && _a !== void 0 ? _a : String(total),\n          fontStyle: labelFontStyle,\n          fontWeight: labelFontWeight,\n          fontSize: labelFontSize,\n          fontFamily: labelFontFamily,\n          fill: labelColor,\n          x: xMinPx + w / 2,\n          y: yMaxPx + h / 2\n        } : undefined;\n        const nodeMidPoint = {\n          x: xMinPx + w / 2,\n          y: yMaxPx + h / 2\n        };\n        nodeData.push({\n          series: this,\n          datum,\n          // since each selection is an aggregation of multiple data.\n          aggregatedValue: total,\n          frequency,\n          domain: domain,\n          yKey,\n          xKey,\n          x: xMinPx,\n          y: yMaxPx,\n          xValue: xMinPx,\n          yValue: yMaxPx,\n          width: w,\n          height: h,\n          midPoint: nodeMidPoint,\n          fill: fill,\n          stroke: stroke,\n          strokeWidth: strokeWidth,\n          label: selectionDatumLabel\n        });\n      });\n      return [{\n        itemId: (_a = this.yKey) !== null && _a !== void 0 ? _a : this.id,\n        nodeData,\n        labelData: nodeData,\n        scales: _super.calculateScaling.call(this),\n        animationValid: true,\n        visible: this.visible\n      }];\n    });\n  }\n  nodeFactory() {\n    return new Rect();\n  }\n  updateDatumSelection(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        nodeData,\n        datumSelection\n      } = opts;\n      return datumSelection.update(nodeData, rect => {\n        rect.tag = HistogramSeriesNodeTag.Bin;\n        rect.crisp = true;\n      }, datum => datum.domain.join('_'));\n    });\n  }\n  updateDatumNodes(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        datumSelection,\n        isHighlight: isDatumHighlighted\n      } = opts;\n      const {\n        fillOpacity: seriesFillOpacity,\n        strokeOpacity,\n        shadow,\n        highlightStyle: {\n          item: {\n            fill: highlightedFill,\n            fillOpacity: highlightFillOpacity = seriesFillOpacity,\n            stroke: highlightedStroke,\n            strokeWidth: highlightedDatumStrokeWidth\n          }\n        }\n      } = this;\n      datumSelection.each((rect, datum, index) => {\n        var _a, _b;\n        const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== undefined ? highlightedDatumStrokeWidth : datum.strokeWidth;\n        const fillOpacity = isDatumHighlighted ? highlightFillOpacity : seriesFillOpacity;\n        rect.fill = (_a = isDatumHighlighted ? highlightedFill : undefined) !== null && _a !== void 0 ? _a : datum.fill;\n        rect.stroke = (_b = isDatumHighlighted ? highlightedStroke : undefined) !== null && _b !== void 0 ? _b : datum.stroke;\n        rect.fillOpacity = fillOpacity;\n        rect.strokeOpacity = strokeOpacity;\n        rect.strokeWidth = strokeWidth;\n        rect.lineDash = this.lineDash;\n        rect.lineDashOffset = this.lineDashOffset;\n        rect.fillShadow = shadow;\n        rect.zIndex = isDatumHighlighted ? Series.highlightedZIndex : index;\n        rect.visible = datum.height > 0; // prevent stroke from rendering for zero height columns\n      });\n    });\n  }\n\n  updateLabelSelection(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        labelData,\n        labelSelection\n      } = opts;\n      return labelSelection.update(labelData, text => {\n        text.tag = HistogramSeriesNodeTag.Label;\n        text.pointerEvents = PointerEvents.None;\n        text.textAlign = 'center';\n        text.textBaseline = 'middle';\n      });\n    });\n  }\n  updateLabelNodes(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        labelSelection\n      } = opts;\n      const labelEnabled = this.label.enabled;\n      labelSelection.each((text, datum) => {\n        const label = datum.label;\n        if (label && labelEnabled) {\n          text.text = label.text;\n          text.x = label.x;\n          text.y = label.y;\n          text.fontStyle = label.fontStyle;\n          text.fontWeight = label.fontWeight;\n          text.fontSize = label.fontSize;\n          text.fontFamily = label.fontFamily;\n          text.fill = label.fill;\n          text.visible = true;\n        } else {\n          text.visible = false;\n        }\n      });\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const {\n      xKey,\n      yKey = '',\n      axes\n    } = this;\n    const xAxis = axes[ChartAxisDirection.X];\n    const yAxis = axes[ChartAxisDirection.Y];\n    if (!xKey || !xAxis || !yAxis) {\n      return '';\n    }\n    const {\n      xName,\n      yName,\n      fill: color,\n      tooltip,\n      aggregation,\n      id: seriesId\n    } = this;\n    const {\n      aggregatedValue,\n      frequency,\n      domain: [rangeMin, rangeMax]\n    } = nodeDatum;\n    const title = `${sanitizeHtml(xName !== null && xName !== void 0 ? xName : xKey)}: ${xAxis.formatDatum(rangeMin)} - ${xAxis.formatDatum(rangeMax)}`;\n    let content = yKey ? `<b>${sanitizeHtml(yName !== null && yName !== void 0 ? yName : yKey)} (${aggregation})</b>: ${yAxis.formatDatum(aggregatedValue)}<br>` : '';\n    content += `<b>Frequency</b>: ${frequency}`;\n    const defaults = {\n      title,\n      backgroundColor: color,\n      content\n    };\n    return tooltip.toTooltipHtml(defaults, {\n      datum: {\n        data: nodeDatum.datum,\n        aggregatedValue: nodeDatum.aggregatedValue,\n        domain: nodeDatum.domain,\n        frequency: nodeDatum.frequency\n      },\n      xKey,\n      xName,\n      yKey,\n      yName,\n      color,\n      title,\n      seriesId\n    });\n  }\n  getLegendData(legendType) {\n    var _a;\n    const {\n      id,\n      data,\n      xKey,\n      yName,\n      visible,\n      fill,\n      stroke,\n      fillOpacity,\n      strokeOpacity,\n      strokeWidth\n    } = this;\n    if (!data || data.length === 0 || legendType !== 'category') {\n      return [];\n    }\n    return [{\n      legendType: 'category',\n      id,\n      itemId: xKey,\n      seriesId: id,\n      enabled: visible,\n      label: {\n        text: (_a = yName !== null && yName !== void 0 ? yName : xKey) !== null && _a !== void 0 ? _a : 'Frequency'\n      },\n      marker: {\n        fill: fill !== null && fill !== void 0 ? fill : 'rgba(0, 0, 0, 0)',\n        stroke: stroke !== null && stroke !== void 0 ? stroke : 'rgba(0, 0, 0, 0)',\n        fillOpacity: fillOpacity,\n        strokeOpacity: strokeOpacity,\n        strokeWidth\n      }\n    }];\n  }\n  animateEmptyUpdateReady({\n    datumSelections,\n    labelSelections\n  }) {\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes));\n    fromToMotion(this.id, 'datums', this.ctx.animationManager, datumSelections, fns);\n    seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, labelSelections);\n  }\n  animateWaitingUpdateReady(data) {\n    var _a, _b;\n    const diff = (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.diff;\n    const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes));\n    fromToMotion(this.id, 'datums', this.ctx.animationManager, data.datumSelections, fns, (_, datum) => this.getDatumId(datum), diff);\n    seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, data.labelSelections);\n  }\n  getDatumId(datum) {\n    return createDatumId(datum.domain.map(d => `${d}`));\n  }\n  isLabelEnabled() {\n    return this.label.enabled;\n  }\n}\nHistogramSeries.className = 'HistogramSeries';\nHistogramSeries.type = 'histogram';\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], HistogramSeries.prototype, \"fill\", void 0);\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], HistogramSeries.prototype, \"stroke\", void 0);\n__decorate([Validate(NUMBER$1(0, 1)), __metadata(\"design:type\", Object)], HistogramSeries.prototype, \"fillOpacity\", void 0);\n__decorate([Validate(NUMBER$1(0, 1)), __metadata(\"design:type\", Object)], HistogramSeries.prototype, \"strokeOpacity\", void 0);\n__decorate([Validate(OPT_LINE_DASH), __metadata(\"design:type\", Array)], HistogramSeries.prototype, \"lineDash\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], HistogramSeries.prototype, \"lineDashOffset\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], HistogramSeries.prototype, \"xKey\", void 0);\n__decorate([Validate(BOOLEAN), __metadata(\"design:type\", Boolean)], HistogramSeries.prototype, \"areaPlot\", void 0);\n__decorate([Validate(OPT_ARRAY()), __metadata(\"design:type\", Array)], HistogramSeries.prototype, \"bins\", void 0);\n__decorate([Validate(HISTOGRAM_AGGREGATION), __metadata(\"design:type\", String)], HistogramSeries.prototype, \"aggregation\", void 0);\n__decorate([Validate(OPT_NUMBER(0)), __metadata(\"design:type\", Number)], HistogramSeries.prototype, \"binCount\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], HistogramSeries.prototype, \"xName\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], HistogramSeries.prototype, \"yKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], HistogramSeries.prototype, \"yName\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], HistogramSeries.prototype, \"strokeWidth\", void 0);\nconst HistogramSeriesModule = {\n  type: 'series',\n  optionsKey: 'series[]',\n  packageType: 'community',\n  chartTypes: ['cartesian'],\n  identifier: 'histogram',\n  instanceConstructor: HistogramSeries,\n  seriesDefaults: {\n    axes: [{\n      type: CARTESIAN_AXIS_TYPES.NUMBER,\n      position: CARTESIAN_AXIS_POSITIONS.BOTTOM\n    }, {\n      type: CARTESIAN_AXIS_TYPES.NUMBER,\n      position: CARTESIAN_AXIS_POSITIONS.LEFT\n    }]\n  },\n  themeTemplate: {\n    __extends__: EXTENDS_SERIES_DEFAULTS,\n    strokeWidth: 1,\n    fillOpacity: 1,\n    strokeOpacity: 1,\n    lineDash: [0],\n    lineDashOffset: 0,\n    label: {\n      enabled: false,\n      fontStyle: undefined,\n      fontWeight: undefined,\n      fontSize: 12,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n      formatter: undefined\n    },\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    }\n  },\n  paletteFactory: ({\n    takeColors\n  }) => {\n    const {\n      fills: [fill],\n      strokes: [stroke]\n    } = takeColors(1);\n    return {\n      fill,\n      stroke\n    };\n  }\n};\nclass LineSeries extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      hasMarkers: true,\n      pickModes: [SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST, SeriesNodePickMode.NEAREST_NODE, SeriesNodePickMode.EXACT_SHAPE_MATCH],\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        path: buildResetPathFn({\n          getOpacity: () => this.getOpacity()\n        }),\n        label: resetLabelFn,\n        marker: (node, datum) => Object.assign(Object.assign({}, resetMarkerFn()), resetMarkerPositionFn(node, datum))\n      }\n    });\n    this.label = new Label();\n    this.marker = new SeriesMarker();\n    this.tooltip = new SeriesTooltip();\n    this.title = undefined;\n    this.stroke = '#874349';\n    this.lineDash = [0];\n    this.lineDashOffset = 0;\n    this.strokeWidth = 2;\n    this.strokeOpacity = 1;\n    this.xKey = undefined;\n    this.xName = undefined;\n    this.yKey = undefined;\n    this.yName = undefined;\n  }\n  processData(dataController) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        xKey,\n        yKey,\n        data\n      } = this;\n      if (xKey == null || yKey == null || data == null) return;\n      const animationEnabled = !this.ctx.animationManager.isSkipped();\n      const {\n        isContinuousX,\n        isContinuousY\n      } = this.isContinuous();\n      const props = [];\n      // If two or more datums share an x-value, i.e. lined up vertically, they will have the same datum id.\n      // They must be identified this way when animated to ensure they can be tracked when their y-value\n      // is updated. If this is a static chart, we can instead not bother with identifying datums and\n      // automatically garbage collect the marker selection.\n      if (!isContinuousX) {\n        props.push(keyProperty(this, xKey, isContinuousX, {\n          id: 'xKey'\n        }));\n        if (animationEnabled && this.processedData) {\n          props.push(diff(this.processedData));\n        }\n      }\n      if (animationEnabled) {\n        props.push(animationValidation(this, isContinuousX ? ['xValue'] : []));\n      }\n      props.push(valueProperty(this, xKey, isContinuousX, {\n        id: 'xValue'\n      }), valueProperty(this, yKey, isContinuousY, {\n        id: 'yValue',\n        invalidValue: undefined\n      }));\n      yield this.requestDataModel(dataController, data, {\n        props\n      });\n      this.animationState.transition('updateData');\n    });\n  }\n  getSeriesDomain(direction) {\n    const {\n      axes,\n      dataModel,\n      processedData\n    } = this;\n    if (!processedData || !dataModel) return [];\n    const xAxis = axes[ChartAxisDirection.X];\n    const yAxis = axes[ChartAxisDirection.Y];\n    const xDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\n    if (direction === ChartAxisDirection.X) {\n      const domain = dataModel.getDomain(this, `xValue`, 'value', processedData);\n      if ((xDef === null || xDef === void 0 ? void 0 : xDef.def.type) === 'value' && xDef.def.valueType === 'category') {\n        return domain;\n      }\n      return fixNumericExtent(extent(domain), xAxis);\n    } else {\n      const domain = dataModel.getDomain(this, `yValue`, 'value', processedData);\n      return fixNumericExtent(domain, yAxis);\n    }\n  }\n  createNodeData() {\n    const _super = Object.create(null, {\n      calculateScaling: {\n        get: () => super.calculateScaling\n      }\n    });\n    var _a, _b, _c;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        processedData,\n        dataModel,\n        axes\n      } = this;\n      const xAxis = axes[ChartAxisDirection.X];\n      const yAxis = axes[ChartAxisDirection.Y];\n      if (!processedData || !dataModel || !xAxis || !yAxis) {\n        return [];\n      }\n      const {\n        label,\n        yKey = '',\n        xKey = ''\n      } = this;\n      const xScale = xAxis.scale;\n      const yScale = yAxis.scale;\n      const xOffset = ((_a = xScale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;\n      const yOffset = ((_b = yScale.bandwidth) !== null && _b !== void 0 ? _b : 0) / 2;\n      const nodeData = [];\n      const size = this.marker.enabled ? this.marker.size : 0;\n      const xIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;\n      const yIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`).index;\n      let moveTo = true;\n      let nextPoint;\n      for (let i = 0; i < processedData.data.length; i++) {\n        const {\n          datum,\n          values\n        } = nextPoint !== null && nextPoint !== void 0 ? nextPoint : processedData.data[i];\n        const xDatum = values[xIdx];\n        const yDatum = values[yIdx];\n        if (yDatum === undefined) {\n          moveTo = true;\n        } else {\n          const x = xScale.convert(xDatum) + xOffset;\n          if (isNaN(x)) {\n            moveTo = true;\n            nextPoint = undefined;\n            continue;\n          }\n          nextPoint = ((_c = processedData.data[i + 1]) === null || _c === void 0 ? void 0 : _c.values[yIdx]) === undefined ? undefined : processedData.data[i + 1];\n          const y = yScale.convert(yDatum) + yOffset;\n          const labelText = this.getLabelText(label, {\n            value: yDatum,\n            datum,\n            xKey,\n            yKey,\n            xName: this.xName,\n            yName: this.yName\n          }, value => isNumber(value) ? value.toFixed(2) : String(value));\n          nodeData.push({\n            series: this,\n            datum,\n            yKey,\n            xKey,\n            point: {\n              x,\n              y,\n              moveTo,\n              size\n            },\n            midPoint: {\n              x,\n              y\n            },\n            yValue: yDatum,\n            xValue: xDatum,\n            capDefaults: {\n              lengthRatioMultiplier: this.marker.getDiameter(),\n              lengthMax: Infinity\n            },\n            label: labelText ? {\n              text: labelText,\n              fontStyle: label.fontStyle,\n              fontWeight: label.fontWeight,\n              fontSize: label.fontSize,\n              fontFamily: label.fontFamily,\n              textAlign: 'center',\n              textBaseline: 'bottom',\n              fill: label.color\n            } : undefined\n          });\n          moveTo = false;\n        }\n      }\n      return [{\n        itemId: yKey,\n        nodeData,\n        labelData: nodeData,\n        scales: _super.calculateScaling.call(this),\n        visible: this.visible\n      }];\n    });\n  }\n  isPathOrSelectionDirty() {\n    return this.marker.isDirty();\n  }\n  markerFactory() {\n    const {\n      shape\n    } = this.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  updatePathNodes(opts) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        paths: [lineNode],\n        opacity,\n        visible,\n        animationEnabled\n      } = opts;\n      const {\n        seriesRectHeight: height,\n        seriesRectWidth: width\n      } = this.nodeDataDependencies;\n      lineNode.setProperties({\n        fill: undefined,\n        lineJoin: 'round',\n        pointerEvents: PointerEvents.None,\n        opacity,\n        stroke: this.stroke,\n        strokeWidth: this.getStrokeWidth(this.strokeWidth),\n        strokeOpacity: this.strokeOpacity,\n        lineDash: this.lineDash,\n        lineDashOffset: this.lineDashOffset\n      });\n      if (!animationEnabled) {\n        lineNode.visible = visible;\n      }\n      if (lineNode.clipPath == null) {\n        lineNode.clipPath = new Path2D();\n        lineNode.clipScalingX = 1;\n        lineNode.clipScalingY = 1;\n      }\n      (_a = lineNode.clipPath) === null || _a === void 0 ? void 0 : _a.clear({\n        trackChanges: true\n      });\n      (_b = lineNode.clipPath) === null || _b === void 0 ? void 0 : _b.rect(-25, -25, (width !== null && width !== void 0 ? width : 0) + 50, (height !== null && height !== void 0 ? height : 0) + 50);\n    });\n  }\n  updateMarkerSelection(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let {\n        nodeData\n      } = opts;\n      const {\n        markerSelection\n      } = opts;\n      const {\n        shape,\n        enabled\n      } = this.marker;\n      nodeData = shape && enabled ? nodeData : [];\n      if (this.marker.isDirty()) {\n        markerSelection.clear();\n        markerSelection.cleanup();\n      }\n      return markerSelection.update(nodeData, undefined, datum => this.getDatumId(datum));\n    });\n  }\n  updateMarkerNodes(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        markerSelection,\n        isHighlight: highlighted\n      } = opts;\n      const {\n        xKey = '',\n        yKey = '',\n        marker,\n        stroke,\n        strokeWidth,\n        strokeOpacity\n      } = this;\n      const baseStyle = mergeDefaults(highlighted && this.highlightStyle.item, marker.getStyle(), {\n        stroke,\n        strokeWidth,\n        strokeOpacity\n      });\n      const applyTranslation = this.ctx.animationManager.isSkipped();\n      markerSelection.each((node, datum) => {\n        this.updateMarkerStyle(node, marker, {\n          datum,\n          highlighted,\n          xKey,\n          yKey\n        }, baseStyle, {\n          applyTranslation\n        });\n      });\n      if (!highlighted) {\n        this.marker.markClean();\n      }\n    });\n  }\n  updateLabelSelection(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let {\n        labelData\n      } = opts;\n      const {\n        labelSelection\n      } = opts;\n      const {\n        shape,\n        enabled\n      } = this.marker;\n      labelData = shape && enabled ? labelData : [];\n      return labelSelection.update(labelData);\n    });\n  }\n  updateLabelNodes(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        labelSelection\n      } = opts;\n      const {\n        enabled: labelEnabled,\n        fontStyle,\n        fontWeight,\n        fontSize,\n        fontFamily,\n        color\n      } = this.label;\n      labelSelection.each((text, datum) => {\n        const {\n          point,\n          label\n        } = datum;\n        if (datum && label && labelEnabled) {\n          text.fontStyle = fontStyle;\n          text.fontWeight = fontWeight;\n          text.fontSize = fontSize;\n          text.fontFamily = fontFamily;\n          text.textAlign = label.textAlign;\n          text.textBaseline = label.textBaseline;\n          text.text = label.text;\n          text.x = point.x;\n          text.y = point.y - 10;\n          text.fill = color;\n          text.visible = true;\n        } else {\n          text.visible = false;\n        }\n      });\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    var _a;\n    const {\n      xKey,\n      yKey,\n      axes\n    } = this;\n    const xAxis = axes[ChartAxisDirection.X];\n    const yAxis = axes[ChartAxisDirection.Y];\n    if (!xKey || !yKey || !xAxis || !yAxis) {\n      return '';\n    }\n    const {\n      xName,\n      yName,\n      tooltip,\n      marker,\n      id: seriesId\n    } = this;\n    const {\n      datum,\n      xValue,\n      yValue\n    } = nodeDatum;\n    const xString = xAxis.formatDatum(xValue);\n    const yString = yAxis.formatDatum(yValue);\n    const title = sanitizeHtml((_a = this.title) !== null && _a !== void 0 ? _a : yName);\n    const content = sanitizeHtml(xString + ': ' + yString);\n    const baseStyle = mergeDefaults({\n      fill: marker.stroke\n    }, marker.getStyle(), {\n      strokeWidth: this.strokeWidth\n    });\n    const {\n      fill: color\n    } = this.getMarkerStyle(marker, {\n      datum: nodeDatum,\n      xKey,\n      yKey,\n      highlighted: false\n    }, baseStyle);\n    return tooltip.toTooltipHtml({\n      title,\n      content,\n      backgroundColor: color\n    }, Object.assign({\n      datum,\n      xKey,\n      xName,\n      yKey,\n      yName,\n      title,\n      color,\n      seriesId\n    }, this.getModuleTooltipParams(datum)));\n  }\n  getLegendData(legendType) {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    const {\n      id,\n      data,\n      xKey,\n      yKey,\n      yName,\n      visible,\n      title,\n      marker,\n      stroke,\n      strokeOpacity\n    } = this;\n    if (!((data === null || data === void 0 ? void 0 : data.length) && xKey && yKey && legendType === 'category')) {\n      return [];\n    }\n    return [{\n      legendType: 'category',\n      id: id,\n      itemId: yKey,\n      seriesId: id,\n      enabled: visible,\n      label: {\n        text: (_a = title !== null && title !== void 0 ? title : yName) !== null && _a !== void 0 ? _a : yKey\n      },\n      marker: {\n        shape: marker.shape,\n        fill: (_b = marker.fill) !== null && _b !== void 0 ? _b : 'rgba(0, 0, 0, 0)',\n        stroke: (_d = (_c = marker.stroke) !== null && _c !== void 0 ? _c : stroke) !== null && _d !== void 0 ? _d : 'rgba(0, 0, 0, 0)',\n        fillOpacity: (_e = marker.fillOpacity) !== null && _e !== void 0 ? _e : 1,\n        strokeOpacity: (_g = (_f = marker.strokeOpacity) !== null && _f !== void 0 ? _f : strokeOpacity) !== null && _g !== void 0 ? _g : 1,\n        strokeWidth: (_h = marker.strokeWidth) !== null && _h !== void 0 ? _h : 0\n      }\n    }];\n  }\n  updatePaths(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      this.updateLinePaths([opts.paths], [opts.contextData]);\n    });\n  }\n  updateLinePaths(paths, contextData) {\n    contextData.forEach(({\n      nodeData\n    }, contextDataIndex) => {\n      const [lineNode] = paths[contextDataIndex];\n      const {\n        path: linePath\n      } = lineNode;\n      linePath.clear({\n        trackChanges: true\n      });\n      for (const data of nodeData) {\n        if (data.point.moveTo) {\n          linePath.moveTo(data.point.x, data.point.y);\n        } else {\n          linePath.lineTo(data.point.x, data.point.y);\n        }\n      }\n      lineNode.checkPathDirty();\n    });\n  }\n  animateEmptyUpdateReady(animationData) {\n    const {\n      markerSelections,\n      labelSelections,\n      annotationSelections,\n      contextData,\n      paths\n    } = animationData;\n    const {\n      animationManager\n    } = this.ctx;\n    const {\n      seriesRectWidth: width = 0\n    } = this.nodeDataDependencies;\n    this.updateLinePaths(paths, contextData);\n    pathSwipeInAnimation(this, animationManager, paths.flat());\n    resetMotion(markerSelections, resetMarkerPositionFn);\n    markerSwipeScaleInAnimation(this, animationManager, markerSelections, width);\n    seriesLabelFadeInAnimation(this, 'labels', animationManager, labelSelections);\n    seriesLabelFadeInAnimation(this, 'annotations', animationManager, annotationSelections);\n  }\n  animateReadyResize(animationData) {\n    const {\n      contextData,\n      paths\n    } = animationData;\n    this.updateLinePaths(paths, contextData);\n    super.animateReadyResize(animationData);\n  }\n  animateWaitingUpdateReady(animationData) {\n    var _a, _b;\n    const {\n      animationManager\n    } = this.ctx;\n    const {\n      markerSelections,\n      labelSelections,\n      annotationSelections,\n      contextData,\n      paths,\n      previousContextData\n    } = animationData;\n    super.resetAllAnimation(animationData);\n    if (contextData.length === 0 || !previousContextData || previousContextData.length === 0) {\n      animationManager.skipCurrentBatch();\n      this.updateLinePaths(paths, contextData);\n      return;\n    }\n    const [path] = paths;\n    const [newData] = contextData;\n    const [oldData] = previousContextData;\n    const fns = prepareLinePathAnimation(newData, oldData, (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.diff);\n    if (fns === undefined) {\n      animationManager.skipCurrentBatch();\n      this.updateLinePaths(paths, contextData);\n      return;\n    }\n    fromToMotion(this.id, 'marker', animationManager, markerSelections, fns.marker);\n    fromToMotion(this.id, 'path_properties', animationManager, path, fns.pathProperties);\n    pathMotion(this.id, 'path_update', animationManager, path, fns.path);\n    seriesLabelFadeInAnimation(this, 'labels', animationManager, labelSelections);\n    seriesLabelFadeInAnimation(this, 'annotations', animationManager, annotationSelections);\n  }\n  getDatumId(datum) {\n    return createDatumId([`${datum.xValue}`]);\n  }\n  isLabelEnabled() {\n    return this.label.enabled;\n  }\n  getBandScalePadding() {\n    return {\n      inner: 1,\n      outer: 0.1\n    };\n  }\n  nodeFactory() {\n    return new Group();\n  }\n}\nLineSeries.className = 'LineSeries';\nLineSeries.type = 'line';\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], LineSeries.prototype, \"title\", void 0);\n__decorate([Validate(OPT_COLOR_STRING), __metadata(\"design:type\", String)], LineSeries.prototype, \"stroke\", void 0);\n__decorate([Validate(OPT_LINE_DASH), __metadata(\"design:type\", Array)], LineSeries.prototype, \"lineDash\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], LineSeries.prototype, \"lineDashOffset\", void 0);\n__decorate([Validate(NUMBER$1(0)), __metadata(\"design:type\", Number)], LineSeries.prototype, \"strokeWidth\", void 0);\n__decorate([Validate(NUMBER$1(0, 1)), __metadata(\"design:type\", Number)], LineSeries.prototype, \"strokeOpacity\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], LineSeries.prototype, \"xKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], LineSeries.prototype, \"xName\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], LineSeries.prototype, \"yKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], LineSeries.prototype, \"yName\", void 0);\nconst LineSeriesModule = {\n  type: 'series',\n  optionsKey: 'series[]',\n  packageType: 'community',\n  chartTypes: ['cartesian'],\n  identifier: 'line',\n  instanceConstructor: LineSeries,\n  seriesDefaults: DEFAULT_CARTESIAN_CHART_OVERRIDES,\n  themeTemplate: {\n    __extends__: EXTENDS_SERIES_DEFAULTS,\n    tooltip: {\n      position: {\n        type: 'node'\n      }\n    },\n    strokeWidth: 2,\n    strokeOpacity: 1,\n    lineDash: [0],\n    lineDashOffset: 0,\n    marker: {\n      __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,\n      fillOpacity: 1,\n      strokeOpacity: 1,\n      strokeWidth: 0\n    },\n    label: {\n      enabled: false,\n      fontStyle: undefined,\n      fontWeight: undefined,\n      fontSize: 12,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      formatter: undefined\n    }\n  },\n  enterpriseThemeTemplate: {\n    errorBar: {\n      cap: {\n        lengthRatio: 1\n      }\n    }\n  },\n  paletteFactory: params => {\n    const {\n      marker\n    } = markerPaletteFactory(params);\n    return {\n      stroke: marker.fill,\n      marker\n    };\n  }\n};\nclass ScatterSeries extends CartesianSeries {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST, SeriesNodePickMode.NEAREST_NODE, SeriesNodePickMode.EXACT_SHAPE_MATCH],\n      pathsPerSeries: 0,\n      hasMarkers: true,\n      markerSelectionGarbageCollection: false,\n      animationResetFns: {\n        marker: resetMarkerFn,\n        label: resetLabelFn\n      }\n    });\n    this.marker = new SeriesMarker();\n    this.label = new Label();\n    this.title = undefined;\n    this.labelKey = undefined;\n    this.xName = undefined;\n    this.yName = undefined;\n    this.labelName = 'Label';\n    this.xKey = undefined;\n    this.yKey = undefined;\n    this.colorKey = undefined;\n    this.colorName = 'Color';\n    this.colorRange = ['#ffff00', '#00ff00', '#0000ff'];\n    this.colorScale = new ColorScale();\n    this.tooltip = new SeriesTooltip();\n  }\n  processData(dataController) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        xKey,\n        yKey,\n        labelKey,\n        data\n      } = this;\n      if (xKey == null || yKey == null || data == null) return;\n      const {\n        isContinuousX,\n        isContinuousY\n      } = this.isContinuous();\n      const {\n        colorScale,\n        colorDomain,\n        colorRange,\n        colorKey\n      } = this;\n      const {\n        dataModel,\n        processedData\n      } = yield this.requestDataModel(dataController, data, {\n        props: [keyProperty(this, xKey, isContinuousX, {\n          id: 'xKey-raw'\n        }), keyProperty(this, yKey, isContinuousY, {\n          id: 'yKey-raw'\n        }), ...(labelKey ? [keyProperty(this, labelKey, false, {\n          id: `labelKey-raw`\n        })] : []), valueProperty(this, xKey, isContinuousX, {\n          id: `xValue`\n        }), valueProperty(this, yKey, isContinuousY, {\n          id: `yValue`\n        }), ...(colorKey ? [valueProperty(this, colorKey, true, {\n          id: `colorValue`\n        })] : []), ...(labelKey ? [valueProperty(this, labelKey, false, {\n          id: `labelValue`\n        })] : [])],\n        dataVisible: this.visible\n      });\n      if (colorKey) {\n        const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`).index;\n        colorScale.domain = (_a = colorDomain !== null && colorDomain !== void 0 ? colorDomain : processedData.domain.values[colorKeyIdx]) !== null && _a !== void 0 ? _a : [];\n        colorScale.range = colorRange;\n        colorScale.update();\n      }\n      this.animationState.transition('updateData');\n    });\n  }\n  getSeriesDomain(direction) {\n    const {\n      dataModel,\n      processedData\n    } = this;\n    if (!processedData || !dataModel) return [];\n    const id = direction === ChartAxisDirection.X ? `xValue` : `yValue`;\n    const dataDef = dataModel.resolveProcessedDataDefById(this, id);\n    const domain = dataModel.getDomain(this, id, 'value', processedData);\n    if ((dataDef === null || dataDef === void 0 ? void 0 : dataDef.def.type) === 'value' && (dataDef === null || dataDef === void 0 ? void 0 : dataDef.def.valueType) === 'category') {\n      return domain;\n    }\n    const axis = this.axes[direction];\n    return fixNumericExtent(extent(domain), axis);\n  }\n  createNodeData() {\n    const _super = Object.create(null, {\n      calculateScaling: {\n        get: () => super.calculateScaling\n      }\n    });\n    var _a, _b, _c, _d;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        visible,\n        axes,\n        yKey = '',\n        xKey = '',\n        label,\n        labelKey,\n        dataModel,\n        processedData\n      } = this;\n      const xAxis = axes[ChartAxisDirection.X];\n      const yAxis = axes[ChartAxisDirection.Y];\n      if (!(dataModel && processedData && visible && xAxis && yAxis)) return [];\n      const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;\n      const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`).index;\n      const colorDataIdx = this.colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`).index : -1;\n      const labelDataIdx = this.labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`).index : -1;\n      const {\n        colorScale,\n        colorKey\n      } = this;\n      const xScale = xAxis.scale;\n      const yScale = yAxis.scale;\n      const xOffset = ((_a = xScale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;\n      const yOffset = ((_b = yScale.bandwidth) !== null && _b !== void 0 ? _b : 0) / 2;\n      const {\n        marker\n      } = this;\n      const nodeData = [];\n      const font = label.getFont();\n      for (const {\n        values,\n        datum\n      } of (_c = processedData.data) !== null && _c !== void 0 ? _c : []) {\n        const xDatum = values[xDataIdx];\n        const yDatum = values[yDataIdx];\n        const x = xScale.convert(xDatum) + xOffset;\n        const y = yScale.convert(yDatum) + yOffset;\n        const labelText = this.getLabelText(this.label, {\n          value: labelKey ? values[labelDataIdx] : yDatum,\n          datum,\n          xKey,\n          yKey,\n          labelKey,\n          xName: this.xName,\n          yName: this.yName,\n          labelName: this.labelName\n        });\n        const size = HdpiCanvas.getTextSize(labelText, font);\n        const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : undefined;\n        nodeData.push({\n          series: this,\n          itemId: yKey,\n          yKey,\n          xKey,\n          datum,\n          xValue: xDatum,\n          yValue: yDatum,\n          capDefaults: {\n            lengthRatioMultiplier: this.marker.getDiameter(),\n            lengthMax: Infinity\n          },\n          point: {\n            x,\n            y,\n            size: marker.size\n          },\n          midPoint: {\n            x,\n            y\n          },\n          fill,\n          label: Object.assign({\n            text: labelText\n          }, size)\n        });\n      }\n      return [{\n        itemId: (_d = this.yKey) !== null && _d !== void 0 ? _d : this.id,\n        nodeData,\n        labelData: nodeData,\n        scales: _super.calculateScaling.call(this),\n        visible: this.visible\n      }];\n    });\n  }\n  isPathOrSelectionDirty() {\n    return this.marker.isDirty();\n  }\n  getLabelData() {\n    var _a;\n    return (_a = this.contextNodeData) === null || _a === void 0 ? void 0 : _a.reduce((r, n) => r.concat(n.labelData), []);\n  }\n  markerFactory() {\n    const {\n      shape\n    } = this.marker;\n    const MarkerShape = getMarker(shape);\n    return new MarkerShape();\n  }\n  updateMarkerSelection(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        nodeData,\n        markerSelection\n      } = opts;\n      const {\n        marker: {\n          enabled\n        }\n      } = this;\n      if (this.marker.isDirty()) {\n        markerSelection.clear();\n        markerSelection.cleanup();\n      }\n      const data = enabled ? nodeData : [];\n      return markerSelection.update(data);\n    });\n  }\n  updateMarkerNodes(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        xKey = '',\n        yKey = '',\n        labelKey,\n        marker\n      } = this;\n      const {\n        markerSelection,\n        isHighlight: highlighted\n      } = opts;\n      const baseStyle = mergeDefaults(highlighted && this.highlightStyle.item, marker.getStyle());\n      markerSelection.each((node, datum) => {\n        this.updateMarkerStyle(node, marker, {\n          datum,\n          highlighted,\n          xKey,\n          yKey,\n          labelKey\n        }, baseStyle);\n      });\n      if (!highlighted) {\n        this.marker.markClean();\n      }\n    });\n  }\n  updateLabelSelection(opts) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        labelSelection\n      } = opts;\n      const {\n        label: {\n          enabled\n        }\n      } = this;\n      const placedLabels = enabled ? (_b = (_a = this.chart) === null || _a === void 0 ? void 0 : _a.placeLabels().get(this)) !== null && _b !== void 0 ? _b : [] : [];\n      const placedNodeDatum = placedLabels.map(v => Object.assign(Object.assign({}, v.datum), {\n        point: {\n          x: v.x,\n          y: v.y,\n          size: v.datum.point.size\n        }\n      }));\n      return labelSelection.update(placedNodeDatum);\n    });\n  }\n  updateLabelNodes(opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        labelSelection\n      } = opts;\n      const {\n        label\n      } = this;\n      labelSelection.each((text, datum) => {\n        var _a, _b, _c, _d;\n        text.text = datum.label.text;\n        text.fill = label.color;\n        text.x = (_b = (_a = datum.point) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;\n        text.y = (_d = (_c = datum.point) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0;\n        text.fontStyle = label.fontStyle;\n        text.fontWeight = label.fontWeight;\n        text.fontSize = label.fontSize;\n        text.fontFamily = label.fontFamily;\n        text.textAlign = 'left';\n        text.textBaseline = 'top';\n      });\n    });\n  }\n  getTooltipHtml(nodeDatum) {\n    const {\n      xKey,\n      yKey,\n      axes\n    } = this;\n    const xAxis = axes[ChartAxisDirection.X];\n    const yAxis = axes[ChartAxisDirection.Y];\n    if (!xKey || !yKey || !xAxis || !yAxis) {\n      return '';\n    }\n    const {\n      marker,\n      tooltip,\n      xName,\n      yName,\n      labelKey,\n      labelName,\n      id: seriesId,\n      title = yName\n    } = this;\n    const baseStyle = mergeDefaults({\n      fill: nodeDatum.fill,\n      strokeWidth: this.getStrokeWidth(marker.strokeWidth)\n    }, marker.getStyle());\n    const {\n      fill: color = 'gray'\n    } = this.getMarkerStyle(marker, {\n      datum: nodeDatum,\n      highlighted: false,\n      xKey,\n      yKey,\n      labelKey\n    }, baseStyle);\n    const {\n      datum,\n      xValue,\n      yValue,\n      label\n    } = nodeDatum;\n    const xString = sanitizeHtml(xAxis.formatDatum(xValue));\n    const yString = sanitizeHtml(yAxis.formatDatum(yValue));\n    let content = `<b>${sanitizeHtml(xName !== null && xName !== void 0 ? xName : xKey)}</b>: ${xString}<br>` + `<b>${sanitizeHtml(yName !== null && yName !== void 0 ? yName : yKey)}</b>: ${yString}`;\n    if (labelKey) {\n      content = `<b>${sanitizeHtml(labelName !== null && labelName !== void 0 ? labelName : labelKey)}</b>: ${sanitizeHtml(label.text)}<br>` + content;\n    }\n    return tooltip.toTooltipHtml({\n      title,\n      content,\n      backgroundColor: color\n    }, Object.assign({\n      datum,\n      xKey,\n      xName,\n      yKey,\n      yName,\n      labelKey,\n      labelName,\n      title,\n      color,\n      seriesId\n    }, this.getModuleTooltipParams(datum)));\n  }\n  getLegendData(legendType) {\n    var _a, _b, _c, _d, _e;\n    const {\n      id,\n      data,\n      xKey,\n      yKey,\n      yName,\n      title,\n      visible,\n      marker\n    } = this;\n    const {\n      fill,\n      stroke,\n      fillOpacity,\n      strokeOpacity,\n      strokeWidth\n    } = marker;\n    if (!((data === null || data === void 0 ? void 0 : data.length) && xKey && yKey && legendType === 'category')) {\n      return [];\n    }\n    return [{\n      legendType: 'category',\n      id,\n      itemId: yKey,\n      seriesId: id,\n      enabled: visible,\n      label: {\n        text: (_a = title !== null && title !== void 0 ? title : yName) !== null && _a !== void 0 ? _a : yKey\n      },\n      marker: {\n        shape: marker.shape,\n        fill: (_c = (_b = marker.fill) !== null && _b !== void 0 ? _b : fill) !== null && _c !== void 0 ? _c : 'rgba(0, 0, 0, 0)',\n        stroke: (_e = (_d = marker.stroke) !== null && _d !== void 0 ? _d : stroke) !== null && _e !== void 0 ? _e : 'rgba(0, 0, 0, 0)',\n        fillOpacity: fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1,\n        strokeOpacity: strokeOpacity !== null && strokeOpacity !== void 0 ? strokeOpacity : 1,\n        strokeWidth: strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 0\n      }\n    }];\n  }\n  animateEmptyUpdateReady(data) {\n    const {\n      markerSelections,\n      labelSelections,\n      annotationSelections\n    } = data;\n    markerScaleInAnimation(this, this.ctx.animationManager, markerSelections);\n    seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, labelSelections);\n    seriesLabelFadeInAnimation(this, 'annotations', this.ctx.animationManager, annotationSelections);\n  }\n  isLabelEnabled() {\n    return this.label.enabled;\n  }\n  nodeFactory() {\n    return new Group();\n  }\n}\nScatterSeries.className = 'ScatterSeries';\nScatterSeries.type = 'scatter';\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], ScatterSeries.prototype, \"title\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], ScatterSeries.prototype, \"labelKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], ScatterSeries.prototype, \"xName\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], ScatterSeries.prototype, \"yName\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], ScatterSeries.prototype, \"labelName\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], ScatterSeries.prototype, \"xKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], ScatterSeries.prototype, \"yKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], ScatterSeries.prototype, \"colorKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], ScatterSeries.prototype, \"colorName\", void 0);\n__decorate([Validate(OPT_NUMBER_ARRAY), __metadata(\"design:type\", Array)], ScatterSeries.prototype, \"colorDomain\", void 0);\n__decorate([Validate(COLOR_STRING_ARRAY), __metadata(\"design:type\", Array)], ScatterSeries.prototype, \"colorRange\", void 0);\nconst ScatterSeriesModule = {\n  type: 'series',\n  optionsKey: 'series[]',\n  packageType: 'community',\n  chartTypes: ['cartesian'],\n  identifier: 'scatter',\n  instanceConstructor: ScatterSeries,\n  seriesDefaults: {\n    axes: [{\n      type: CARTESIAN_AXIS_TYPES.NUMBER,\n      position: CARTESIAN_AXIS_POSITIONS.BOTTOM\n    }, {\n      type: CARTESIAN_AXIS_TYPES.NUMBER,\n      position: CARTESIAN_AXIS_POSITIONS.LEFT\n    }]\n  },\n  themeTemplate: {\n    __extends__: EXTENDS_SERIES_DEFAULTS,\n    tooltip: {\n      position: {\n        type: 'node'\n      }\n    },\n    marker: {\n      __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,\n      fillOpacity: 0.8\n    },\n    label: {\n      enabled: false,\n      fontStyle: undefined,\n      fontWeight: undefined,\n      fontSize: 12,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR\n    }\n  },\n  enterpriseThemeTemplate: {\n    errorBar: {\n      cap: {\n        lengthRatio: 1\n      }\n    }\n  },\n  paletteFactory: markerPaletteFactory\n};\nconst PieSeriesModule = {\n  type: 'series',\n  optionsKey: 'series[]',\n  packageType: 'community',\n  chartTypes: ['polar'],\n  identifier: 'pie',\n  instanceConstructor: PieSeries,\n  seriesDefaults: {},\n  themeTemplate: {\n    __extends__: EXTENDS_SERIES_DEFAULTS,\n    title: {\n      enabled: true,\n      fontStyle: undefined,\n      fontWeight: NORMAL,\n      fontSize: 14,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_MUTED_LABEL_COLOUR,\n      spacing: 5\n    },\n    calloutLabel: {\n      enabled: true,\n      fontStyle: undefined,\n      fontWeight: undefined,\n      fontSize: 12,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      offset: 3,\n      minAngle: 0\n    },\n    sectorLabel: {\n      enabled: true,\n      fontStyle: undefined,\n      fontWeight: NORMAL,\n      fontSize: 12,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n      positionOffset: 0,\n      positionRatio: 0.5\n    },\n    calloutLine: {\n      length: 10,\n      strokeWidth: 2\n    },\n    fillOpacity: 1,\n    strokeOpacity: 1,\n    strokeWidth: 1,\n    lineDash: [0],\n    lineDashOffset: 0,\n    rotation: 0,\n    outerRadiusOffset: 0,\n    innerRadiusOffset: 0,\n    shadow: {\n      enabled: false,\n      color: DEFAULT_SHADOW_COLOUR,\n      xOffset: 3,\n      yOffset: 3,\n      blur: 5\n    },\n    innerLabels: {\n      fontStyle: undefined,\n      fontWeight: undefined,\n      fontSize: 12,\n      fontFamily: DEFAULT_FONT_FAMILY,\n      color: DEFAULT_LABEL_COLOUR,\n      margin: 2\n    }\n  },\n  paletteFactory: ({\n    takeColors,\n    colorsCount,\n    userPalette\n  }) => {\n    const {\n      fills,\n      strokes\n    } = takeColors(colorsCount);\n    return {\n      fills,\n      strokes: userPalette ? strokes : [DEFAULT_POLAR_SERIES_STROKE],\n      calloutLine: {\n        colors: strokes\n      }\n    };\n  }\n};\nfunction registerInbuiltModules() {\n  registerModule(BackgroundModule);\n  registerModule(NavigatorModule);\n  registerModule(AreaSeriesModule);\n  registerModule(BarSeriesModule);\n  registerModule(BubbleSeriesModule);\n  registerModule(LineSeriesModule);\n  registerModule(ScatterSeriesModule);\n  registerModule(PieSeriesModule);\n  registerModule(HistogramSeriesModule);\n}\nfunction invertShapeDirection(...supportedShapes) {\n  for (const shape of supportedShapes) {\n    if (shape instanceof Rect) {\n      const {\n        x,\n        y,\n        width,\n        height\n      } = shape;\n      shape.setProperties({\n        x: y,\n        y: x,\n        width: height,\n        height: width\n      });\n    } else if (shape instanceof Line) {\n      const {\n        x1,\n        y1,\n        x2,\n        y2\n      } = shape;\n      shape.setProperties({\n        x1: y1,\n        y1: x1,\n        x2: y2,\n        y2: x2\n      });\n    }\n  }\n}\nclass HierarchyNode {\n  constructor(series, index, datum, size, colorValue, fill, stroke, sumSize, depth, parent, children) {\n    this.series = series;\n    this.index = index;\n    this.datum = datum;\n    this.size = size;\n    this.colorValue = colorValue;\n    this.fill = fill;\n    this.stroke = stroke;\n    this.sumSize = sumSize;\n    this.depth = depth;\n    this.parent = parent;\n    this.children = children;\n    this.midPoint = {\n      x: 0,\n      y: 0\n    };\n  }\n  contains(other) {\n    let current = other;\n    // Index check is a performance optimization - it does not affect correctness\n    while (current != null && current.index >= this.index) {\n      if (current === this) {\n        return true;\n      }\n      current = current.parent;\n    }\n    return false;\n  }\n  walk(callback, order = HierarchyNode.Walk.PreOrder) {\n    if (order === HierarchyNode.Walk.PreOrder) {\n      callback(this);\n    }\n    this.children.forEach(child => {\n      child.walk(callback, order);\n    });\n    if (order === HierarchyNode.Walk.PostOrder) {\n      callback(this);\n    }\n  }\n  *[Symbol.iterator]() {\n    yield this;\n    for (const child of this.children) {\n      yield* child;\n    }\n  }\n}\nHierarchyNode.Walk = {\n  PreOrder: 0,\n  PostOrder: 1\n};\nclass HierarchySeries extends Series {\n  constructor(moduleCtx) {\n    super({\n      moduleCtx,\n      pickModes: [SeriesNodePickMode.EXACT_SHAPE_MATCH],\n      contentGroupVirtual: false\n    });\n    this.childrenKey = 'children';\n    this.sizeKey = undefined;\n    this.colorKey = undefined;\n    this.colorName = undefined;\n    this.fills = Object.values(DEFAULT_FILLS);\n    this.strokes = Object.values(DEFAULT_STROKES);\n    this.colorRange = undefined;\n    this.rootNode = new HierarchyNode(this, 0, undefined, 0, undefined, undefined, undefined, 0, undefined, undefined, []);\n    this.colorDomain = [0, 0];\n    this.maxDepth = 0;\n    this.animationState = new StateMachine('empty', {\n      empty: {\n        update: {\n          target: 'ready',\n          action: data => this.animateEmptyUpdateReady(data)\n        }\n      },\n      ready: {\n        updateData: 'waiting',\n        clear: 'clearing',\n        highlight: data => this.animateReadyHighlight(data),\n        resize: data => this.animateReadyResize(data)\n      },\n      waiting: {\n        update: {\n          target: 'ready',\n          action: data => this.animateWaitingUpdateReady(data)\n        }\n      },\n      clearing: {\n        update: {\n          target: 'empty',\n          action: data => this.animateClearingUpdateEmpty(data)\n        }\n      }\n    }, () => this.checkProcessedDataAnimatable());\n  }\n  hasData() {\n    return Array.isArray(this.data) && this.data.length > 0;\n  }\n  processData() {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        childrenKey,\n        sizeKey,\n        colorKey,\n        fills,\n        strokes,\n        colorRange\n      } = this;\n      let index = 0;\n      const getIndex = () => {\n        index += 1;\n        return index;\n      };\n      let maxDepth = 0;\n      let minColor = Infinity;\n      let maxColor = -Infinity;\n      const colors = new Array(((_b = (_a = this.data) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + 1).fill(undefined);\n      const createNode = (datum, parent) => {\n        const index = getIndex();\n        const depth = parent.depth != null ? parent.depth + 1 : 0;\n        const children = childrenKey != null ? datum[childrenKey] : undefined;\n        const isLeaf = children == null || children.length === 0;\n        let size = sizeKey != null ? datum[sizeKey] : undefined;\n        if (Number.isFinite(size)) {\n          size = Math.max(size, 0);\n        } else {\n          size = isLeaf ? 1 : 0;\n        }\n        const sumSize = size;\n        maxDepth = Math.max(maxDepth, depth);\n        const color = colorKey != null ? datum[colorKey] : undefined;\n        if (typeof color === 'number') {\n          colors[index] = color;\n          minColor = Math.min(minColor, color);\n          maxColor = Math.max(maxColor, color);\n        }\n        return appendChildren(new HierarchyNode(this, index, datum, size, color, undefined, undefined, sumSize, depth, parent, []), children);\n      };\n      const appendChildren = (node, data) => {\n        data === null || data === void 0 ? void 0 : data.forEach(datum => {\n          const child = createNode(datum, node);\n          node.children.push(child);\n          node.sumSize += child.sumSize;\n        });\n        return node;\n      };\n      const rootNode = appendChildren(new HierarchyNode(this, 0, undefined, 0, undefined, undefined, undefined, 0, undefined, undefined, []), this.data);\n      const colorDomain = [minColor, maxColor];\n      let colorScale;\n      if (colorRange != null && Number.isFinite(minColor) && Number.isFinite(maxColor)) {\n        colorScale = new ColorScale();\n        colorScale.domain = colorDomain;\n        colorScale.range = colorRange;\n        colorScale.update();\n      }\n      rootNode.children.forEach((child, index) => {\n        child.walk(node => {\n          let fill;\n          const color = colors[node.index];\n          if (color != null) {\n            fill = colorScale === null || colorScale === void 0 ? void 0 : colorScale.convert(color);\n          }\n          fill !== null && fill !== void 0 ? fill : fill = fills === null || fills === void 0 ? void 0 : fills[index % fills.length];\n          node.fill = fill;\n          // FIXME: If there's a color scale, the strokes won't make sense. For now, just hard-code this default\n          node.stroke = colorScale == null ? strokes === null || strokes === void 0 ? void 0 : strokes[index % strokes.length] : 'rgba(0, 0, 0, 0.2)';\n        });\n      });\n      this.rootNode = rootNode;\n      this.maxDepth = maxDepth;\n      this.colorDomain = colorDomain;\n    });\n  }\n  update({\n    seriesRect\n  }) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.updateSelections();\n      yield this.updateNodes();\n      const animationData = this.getAnimationData();\n      const resize = this.checkResize(seriesRect);\n      if (resize) {\n        this.animationState.transition('resize', animationData);\n      }\n      this.animationState.transition('update', animationData);\n    });\n  }\n  resetAllAnimation(data) {\n    var _a;\n    const datum = (_a = this.animationResetFns) === null || _a === void 0 ? void 0 : _a.datum;\n    // Stop any running animations by prefix convention.\n    this.ctx.animationManager.stopByAnimationGroupId(this.id);\n    if (datum != null) {\n      resetMotion(data.datumSelections, datum);\n    }\n  }\n  animateEmptyUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateWaitingUpdateReady(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animateReadyHighlight(data) {\n    var _a;\n    const datum = (_a = this.animationResetFns) === null || _a === void 0 ? void 0 : _a.datum;\n    if (datum != null) {\n      resetMotion([data], datum);\n    }\n  }\n  animateReadyResize(data) {\n    this.resetAllAnimation(data);\n  }\n  animateClearingUpdateEmpty(data) {\n    this.ctx.animationManager.skipCurrentBatch();\n    this.resetAllAnimation(data);\n  }\n  animationTransitionClear() {\n    this.animationState.transition('clear', this.getAnimationData());\n  }\n  getAnimationData() {\n    const animationData = {\n      datumSelections: [this.groupSelection]\n    };\n    return animationData;\n  }\n  isProcessedDataAnimatable() {\n    return true;\n  }\n  checkProcessedDataAnimatable() {\n    if (!this.isProcessedDataAnimatable()) {\n      this.ctx.animationManager.skipCurrentBatch();\n    }\n  }\n  getLabelData() {\n    return [];\n  }\n  getSeriesDomain() {\n    return [NaN, NaN];\n  }\n  getLegendData(legendType) {\n    return legendType === 'gradient' && this.colorKey != null && this.colorRange != null ? [{\n      legendType: 'gradient',\n      enabled: this.visible,\n      seriesId: this.id,\n      colorName: this.colorName,\n      colorDomain: this.colorDomain,\n      colorRange: this.colorRange\n    }] : [];\n  }\n  getDatumIdFromData(node) {\n    return `${node.index}`;\n  }\n  getDatumId(node) {\n    return this.getDatumIdFromData(node);\n  }\n}\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], HierarchySeries.prototype, \"childrenKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], HierarchySeries.prototype, \"sizeKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], HierarchySeries.prototype, \"colorKey\", void 0);\n__decorate([Validate(OPT_STRING), __metadata(\"design:type\", String)], HierarchySeries.prototype, \"colorName\", void 0);\n__decorate([Validate(OPT_COLOR_STRING_ARRAY), __metadata(\"design:type\", Array)], HierarchySeries.prototype, \"fills\", void 0);\n__decorate([Validate(OPT_COLOR_STRING_ARRAY), __metadata(\"design:type\", Array)], HierarchySeries.prototype, \"strokes\", void 0);\n__decorate([Validate(OPT_COLOR_STRING_ARRAY), __metadata(\"design:type\", Array)], HierarchySeries.prototype, \"colorRange\", void 0);\nclass PolarAxis extends Axis {\n  constructor() {\n    super(...arguments);\n    this.shape = 'polygon';\n    this.innerRadiusRatio = 0;\n    this.defaultTickMinSpacing = 20;\n  }\n  computeLabelsBBox(_options, _seriesRect) {\n    return null;\n  }\n}\n__decorate([Validate(NUMBER$1(0, 1)), __metadata(\"design:type\", Number)], PolarAxis.prototype, \"innerRadiusRatio\", void 0);\n\n/**\r\n * Internal Use Only: Used to ensure this file is treated as a module until we can use moduleDetection flag in Ts v4.7\r\n */\nconst __FORCE_MODULE_DETECTION = 0;\nvar moduleSupport = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  extractDecoratedProperties: extractDecoratedProperties,\n  isDecoratedObject: isDecoratedObject,\n  listDecoratedProperties: listDecoratedProperties,\n  assignJsonApplyConstructedArray: assignJsonApplyConstructedArray,\n  Motion: easing,\n  resetIds: resetIds,\n  get ChartUpdateType() {\n    return ChartUpdateType;\n  },\n  extent: extent,\n  normalisedExtent: normalisedExtent,\n  normalisedExtentWithMetadata: normalisedExtentWithMetadata,\n  arraysEqual: arraysEqual,\n  toArray: toArray,\n  Validate: Validate,\n  predicateWithMessage: predicateWithMessage,\n  OPTIONAL: OPTIONAL,\n  ARRAY: ARRAY,\n  OPT_ARRAY: OPT_ARRAY,\n  NON_EMPTY_ARRAY: NON_EMPTY_ARRAY,\n  OPT_NON_EMPTY_ARRAY: OPT_NON_EMPTY_ARRAY,\n  AND: AND,\n  OR: OR,\n  LESS_THAN: LESS_THAN,\n  GREATER_THAN: GREATER_THAN,\n  FUNCTION: FUNCTION,\n  OPT_FUNCTION: OPT_FUNCTION,\n  BOOLEAN: BOOLEAN,\n  OPT_BOOLEAN: OPT_BOOLEAN,\n  STRING: STRING,\n  OPT_STRING: OPT_STRING,\n  DATE: DATE,\n  OPT_DATE: OPT_DATE,\n  DATE_ARRAY: DATE_ARRAY,\n  DATETIME_MS: DATETIME_MS,\n  OPT_DATETIME_MS: OPT_DATETIME_MS,\n  OPT_DATE_OR_DATETIME_MS: OPT_DATE_OR_DATETIME_MS,\n  COLOR_STRING: COLOR_STRING,\n  OPT_COLOR_STRING: OPT_COLOR_STRING,\n  COLOR_STRING_ARRAY: COLOR_STRING_ARRAY,\n  OPT_COLOR_STRING_ARRAY: OPT_COLOR_STRING_ARRAY,\n  NUMBER: NUMBER$1,\n  OPT_NUMBER: OPT_NUMBER,\n  NUMBER_OR_NAN: NUMBER_OR_NAN,\n  NUMBER_ARRAY: NUMBER_ARRAY,\n  OPT_NUMBER_ARRAY: OPT_NUMBER_ARRAY,\n  STRING_ARRAY: STRING_ARRAY,\n  OPT_STRING_ARRAY: OPT_STRING_ARRAY,\n  STRING_UNION: STRING_UNION,\n  BOOLEAN_ARRAY: BOOLEAN_ARRAY,\n  OPT_BOOLEAN_ARRAY: OPT_BOOLEAN_ARRAY,\n  FONT_STYLE: FONT_STYLE,\n  OPT_FONT_STYLE: OPT_FONT_STYLE,\n  FONT_WEIGHT: FONT_WEIGHT,\n  OPT_FONT_WEIGHT: OPT_FONT_WEIGHT,\n  LINE_DASH: LINE_DASH,\n  OPT_LINE_DASH: OPT_LINE_DASH,\n  LINE_CAP: LINE_CAP,\n  OPT_LINE_CAP: OPT_LINE_CAP,\n  LINE_JOIN: LINE_JOIN,\n  OPT_LINE_JOIN: OPT_LINE_JOIN,\n  POSITION: POSITION,\n  INTERACTION_RANGE: INTERACTION_RANGE,\n  TEXT_WRAP: TEXT_WRAP,\n  OVERFLOW_STRATEGY: OVERFLOW_STRATEGY,\n  TEXT_ALIGN: TEXT_ALIGN,\n  VERTICAL_ALIGN: VERTICAL_ALIGN,\n  DIRECTION: DIRECTION,\n  OPT_DIRECTION: OPT_DIRECTION,\n  Default: Default,\n  injectStyle: injectStyle,\n  clamp: clamp,\n  isEqual: isEqual,\n  isNegative: isNegative,\n  round: round$1,\n  toFixed: toFixed,\n  mod: mod,\n  deepMerge: deepMerge,\n  mergeDefaults: mergeDefaults,\n  partialAssign: partialAssign,\n  ProxyOnWrite: ProxyOnWrite,\n  ProxyPropertyOnWrite: ProxyPropertyOnWrite,\n  ActionOnSet: ActionOnSet,\n  invertShapeDirection: invertShapeDirection,\n  singleSeriesPaletteFactory: singleSeriesPaletteFactory,\n  markerPaletteFactory: markerPaletteFactory,\n  BaseModuleInstance: BaseModuleInstance,\n  REGISTERED_MODULES: REGISTERED_MODULES,\n  registerModule: registerModule,\n  hasRegisteredEnterpriseModules: hasRegisteredEnterpriseModules,\n  MODULE_CONFLICTS: MODULE_CONFLICTS,\n  registerModuleConflicts: registerModuleConflicts,\n  enterpriseModule: enterpriseModule,\n  Background: Background,\n  BackgroundModule: BackgroundModule,\n  get ChartAxisDirection() {\n    return ChartAxisDirection;\n  },\n  prepareAxisAnimationContext: prepareAxisAnimationContext,\n  prepareAxisAnimationFunctions: prepareAxisAnimationFunctions,\n  resetAxisGroupFn: resetAxisGroupFn,\n  resetAxisSelectionFn: resetAxisSelectionFn,\n  resetAxisLabelSelectionFn: resetAxisLabelSelectionFn,\n  resetAxisLineSelectionFn: resetAxisLineSelectionFn,\n  fixNumericExtent: fixNumericExtent,\n  DataModel: DataModel,\n  DataController: DataController,\n  SMALLEST_KEY_INTERVAL: SMALLEST_KEY_INTERVAL,\n  AGG_VALUES_EXTENT: AGG_VALUES_EXTENT,\n  SORT_DOMAIN_GROUPS: SORT_DOMAIN_GROUPS,\n  normaliseGroupTo: normaliseGroupTo,\n  normalisePropertyTo: normalisePropertyTo,\n  animationValidation: animationValidation,\n  accumulateGroup: accumulateGroup,\n  diff: diff,\n  createDatumId: createDatumId,\n  sum: sum,\n  groupSum: groupSum,\n  range: range,\n  count: count,\n  groupCount: groupCount,\n  average: average,\n  groupAverage: groupAverage,\n  area: area,\n  accumulatedValue: accumulatedValue,\n  trailingAccumulatedValue: trailingAccumulatedValue,\n  UpdateService: UpdateService,\n  LayoutService: LayoutService,\n  AnimationManager: AnimationManager,\n  ChartEventManager: ChartEventManager,\n  CursorManager: CursorManager,\n  HighlightManager: HighlightManager,\n  InteractionManager: InteractionManager,\n  TooltipManager: TooltipManager,\n  ZoomManager: ZoomManager,\n  get Layers() {\n    return Layers;\n  },\n  get SeriesNodePickMode() {\n    return SeriesNodePickMode;\n  },\n  keyProperty: keyProperty,\n  valueProperty: valueProperty,\n  rangedValueProperty: rangedValueProperty,\n  trailingValueProperty: trailingValueProperty,\n  trailingValue: trailingValue,\n  accumulativeValueProperty: accumulativeValueProperty,\n  trailingAccumulatedValueProperty: trailingAccumulatedValueProperty,\n  groupAccumulativeValueProperty: groupAccumulativeValueProperty,\n  SeriesNodeClickEvent: SeriesNodeClickEvent,\n  SeriesItemHighlightStyle: SeriesItemHighlightStyle,\n  HighlightStyle: HighlightStyle,\n  Series: Series,\n  seriesLabelFadeInAnimation: seriesLabelFadeInAnimation,\n  seriesLabelFadeOutAnimation: seriesLabelFadeOutAnimation,\n  resetLabelFn: resetLabelFn,\n  SeriesMarker: SeriesMarker,\n  SeriesTooltip: SeriesTooltip,\n  AbstractBarSeries: AbstractBarSeries,\n  CartesianSeriesNodeClickEvent: CartesianSeriesNodeClickEvent,\n  CartesianSeries: CartesianSeries,\n  pairContinuousData: pairContinuousData,\n  pairCategoryData: pairCategoryData,\n  determinePathStatus: determinePathStatus,\n  prepareLinePathAnimationFns: prepareLinePathAnimationFns,\n  prepareLinePathAnimation: prepareLinePathAnimation,\n  updateRect: updateRect,\n  getRectConfig: getRectConfig,\n  checkCrisp: checkCrisp,\n  collapsedStartingBarPosition: collapsedStartingBarPosition,\n  midpointStartingBarPosition: midpointStartingBarPosition,\n  prepareBarAnimationFunctions: prepareBarAnimationFunctions,\n  resetBarSelectionsFn: resetBarSelectionsFn,\n  get AreaSeriesTag() {\n    return AreaSeriesTag;\n  },\n  prepareAreaPathAnimation: prepareAreaPathAnimation,\n  markerFadeInAnimation: markerFadeInAnimation,\n  markerScaleInAnimation: markerScaleInAnimation,\n  markerSwipeScaleInAnimation: markerSwipeScaleInAnimation,\n  resetMarkerFn: resetMarkerFn,\n  resetMarkerPositionFn: resetMarkerPositionFn,\n  prepareMarkerAnimation: prepareMarkerAnimation,\n  updateLabelNode: updateLabelNode,\n  adjustLabelPlacement: adjustLabelPlacement,\n  minMax: minMax,\n  backfillPathPointData: backfillPathPointData,\n  renderPartialPath: renderPartialPath,\n  pathSwipeInAnimation: pathSwipeInAnimation,\n  pathFadeInAnimation: pathFadeInAnimation,\n  pathFadeOutAnimation: pathFadeOutAnimation,\n  buildResetPathFn: buildResetPathFn,\n  PolarSeries: PolarSeries,\n  HierarchyNode: HierarchyNode,\n  HierarchySeries: HierarchySeries,\n  get Tags() {\n    return Tags;\n  },\n  Axis: Axis,\n  AxisLabel: AxisLabel,\n  AxisTick: AxisTick,\n  PolarAxis: PolarAxis,\n  CategoryAxis: CategoryAxis,\n  __FORCE_MODULE_DETECTION: __FORCE_MODULE_DETECTION,\n  QUICK_TRANSITION: QUICK_TRANSITION,\n  INITIAL_LOAD: INITIAL_LOAD,\n  REMOVE_PHASE: REMOVE_PHASE,\n  UPDATE_PHASE: UPDATE_PHASE,\n  ADD_PHASE: ADD_PHASE,\n  LABEL_PHASE: LABEL_PHASE,\n  get RepeatType() {\n    return RepeatType;\n  },\n  isNodeArray: isNodeArray,\n  Animation: Animation,\n  StateMachine: StateMachine,\n  resetMotion: resetMotion,\n  NODE_UPDATE_PHASES: NODE_UPDATE_PHASES,\n  FROM_TO_MIXINS: FROM_TO_MIXINS,\n  fromToMotion: fromToMotion,\n  staticFromToMotion: staticFromToMotion\n});\nconst SERIES_FACTORIES = {};\nconst SERIES_DEFAULTS = {};\nconst SERIES_THEME_TEMPLATES = {};\nconst ENTERPRISE_SERIES_THEME_TEMPLATES = {};\nconst SERIES_PALETTE_FACTORIES = {};\nconst SOLO_SERIES_TYPES = new Set();\nconst STACKABLE_SERIES_TYPES = new Set();\nconst GROUPABLE_SERIES_TYPES = new Set();\nconst STACKED_BY_DEFAULT_SERIES_TYPES = new Set();\nconst SWAP_DEFAULT_AXES_CONDITIONS = {};\nconst CUSTOM_DEFAULTS_FUNCTIONS = {};\nfunction registerSeries(seriesType, chartType, cstr, defaults, theme, enterpriseTheme, paletteFactory, solo, stackable, groupable, stackedByDefault, swapDefaultAxesCondition, customDefaultsFunction) {\n  SERIES_FACTORIES[seriesType] = cstr;\n  SERIES_DEFAULTS[seriesType] = defaults;\n  registerSeriesThemeTemplate(seriesType, theme, enterpriseTheme);\n  if (paletteFactory) {\n    addSeriesPaletteFactory(seriesType, paletteFactory);\n  }\n  if (solo) {\n    addSoloSeriesType(seriesType);\n  }\n  if (stackable) {\n    addStackableSeriesType(seriesType);\n  }\n  if (groupable) {\n    addGroupableSeriesType(seriesType);\n  }\n  if (stackedByDefault) {\n    addStackedByDefaultSeriesType(seriesType);\n  }\n  if (swapDefaultAxesCondition) {\n    addSwapDefaultAxesCondition(seriesType, swapDefaultAxesCondition);\n  }\n  if (customDefaultsFunction) {\n    addCustomDefaultsFunctions(seriesType, customDefaultsFunction);\n  }\n  registerChartSeriesType(seriesType, chartType);\n}\nfunction registerSeriesThemeTemplate(seriesType, themeTemplate, enterpriseThemeTemplate = {}) {\n  const existingTemplate = SERIES_THEME_TEMPLATES[seriesType];\n  SERIES_THEME_TEMPLATES[seriesType] = jsonMerge([existingTemplate, themeTemplate]);\n  ENTERPRISE_SERIES_THEME_TEMPLATES[seriesType] = jsonMerge([existingTemplate, themeTemplate, enterpriseThemeTemplate]);\n}\nfunction getSeries(chartType, moduleCtx) {\n  const seriesConstructor = SERIES_FACTORIES[chartType];\n  if (seriesConstructor) {\n    return new seriesConstructor(moduleCtx);\n  }\n  throw new Error(`AG Charts - unknown series type: ${chartType}`);\n}\nfunction getSeriesDefaults(chartType) {\n  return SERIES_DEFAULTS[chartType];\n}\nfunction getSeriesThemeTemplate(chartType) {\n  if (hasRegisteredEnterpriseModules()) {\n    return ENTERPRISE_SERIES_THEME_TEMPLATES[chartType];\n  }\n  return SERIES_THEME_TEMPLATES[chartType];\n}\nfunction addSeriesPaletteFactory(seriesType, factory) {\n  SERIES_PALETTE_FACTORIES[seriesType] = factory;\n}\nfunction getSeriesPaletteFactory(seriesType) {\n  return SERIES_PALETTE_FACTORIES[seriesType];\n}\nfunction isSoloSeries(seriesType) {\n  return SOLO_SERIES_TYPES.has(seriesType);\n}\nfunction isStackableSeries(seriesType) {\n  return STACKABLE_SERIES_TYPES.has(seriesType);\n}\nfunction isGroupableSeries(seriesType) {\n  return GROUPABLE_SERIES_TYPES.has(seriesType);\n}\nfunction isSeriesStackedByDefault(seriesType) {\n  return STACKED_BY_DEFAULT_SERIES_TYPES.has(seriesType);\n}\nfunction addGroupableSeriesType(seriesType) {\n  GROUPABLE_SERIES_TYPES.add(seriesType);\n}\nfunction addSoloSeriesType(seriesType) {\n  SOLO_SERIES_TYPES.add(seriesType);\n}\nfunction addStackableSeriesType(seriesType) {\n  STACKABLE_SERIES_TYPES.add(seriesType);\n}\nfunction addStackedByDefaultSeriesType(seriesType) {\n  STACKED_BY_DEFAULT_SERIES_TYPES.add(seriesType);\n}\nfunction addSwapDefaultAxesCondition(seriesType, predicate) {\n  SWAP_DEFAULT_AXES_CONDITIONS[seriesType] = predicate;\n}\nfunction addCustomDefaultsFunctions(seriesType, predicate) {\n  CUSTOM_DEFAULTS_FUNCTIONS[seriesType] = predicate;\n}\nfunction isDefaultAxisSwapNeeded(opts) {\n  var _a, _b;\n  let result;\n  for (const series of (_a = opts.series) !== null && _a !== void 0 ? _a : []) {\n    const {\n      type = 'line'\n    } = series;\n    const isDefaultAxisSwapped = (_b = SWAP_DEFAULT_AXES_CONDITIONS[type]) === null || _b === void 0 ? void 0 : _b.call(SWAP_DEFAULT_AXES_CONDITIONS, series);\n    if (isDefaultAxisSwapped != null) {\n      if (result != null && result != isDefaultAxisSwapped) {\n        throw new Error('AG Charts - The provided series have incompatible directions');\n      }\n      result = isDefaultAxisSwapped;\n    }\n  }\n  return result;\n}\nfunction executeCustomDefaultsFunctions(opts, initialDefaults) {\n  var _a;\n  let result = initialDefaults;\n  for (const series of (_a = opts.series) !== null && _a !== void 0 ? _a : []) {\n    const {\n      type\n    } = series;\n    const fn = type != null ? CUSTOM_DEFAULTS_FUNCTIONS[type] : undefined;\n    if (fn !== undefined) {\n      result = Object.assign(Object.assign({}, result), fn(series));\n    }\n  }\n  return result;\n}\nfunction setupModules() {\n  var _a;\n  for (const m of REGISTERED_MODULES) {\n    if (m.packageType === 'enterprise' && !verifyIfModuleExpected(m)) {\n      Logger.errorOnce('Unexpected enterprise module registered: ' + m.identifier);\n    }\n    if (JSON_APPLY_PLUGINS.constructors != null && m.optionConstructors != null) {\n      Object.assign(JSON_APPLY_PLUGINS.constructors, m.optionConstructors);\n    }\n    if (m.type === 'root' && m.themeTemplate) {\n      for (const chartType of m.chartTypes) {\n        registerChartDefaults(chartType, m.themeTemplate);\n      }\n    }\n    if (m.type === 'root' && ((_a = m.conflicts) === null || _a === void 0 ? void 0 : _a.length)) {\n      registerModuleConflicts(m.optionsKey, m.conflicts);\n    }\n    if (m.type === 'series') {\n      if (m.chartTypes.length > 1) throw new Error('AG Charts - Module definition error: ' + m.identifier);\n      registerSeries(m.identifier, m.chartTypes[0], m.instanceConstructor, m.seriesDefaults, m.themeTemplate, m.enterpriseThemeTemplate, m.paletteFactory, m.solo, m.stackable, m.groupable, m.stackedByDefault, m.swapDefaultAxesCondition, m.customDefaultsFunction);\n    }\n    if (m.type === 'series-option' && m.themeTemplate) {\n      for (const seriesType of m.seriesTypes) {\n        registerSeriesThemeTemplate(seriesType, m.themeTemplate);\n      }\n    }\n    if (m.type === 'axis-option' && m.themeTemplate) {\n      for (const axisType of m.axisTypes) {\n        const axisTypeTheme = m.themeTemplate[axisType];\n        const theme = Object.assign(Object.assign({}, m.themeTemplate), typeof axisTypeTheme === 'object' ? axisTypeTheme : {});\n        for (const axisType of m.axisTypes) {\n          delete theme[axisType];\n        }\n        registerAxisThemeTemplate(axisType, theme);\n      }\n    }\n    if (m.type === 'axis') {\n      registerAxis(m.identifier, m.instanceConstructor);\n      if (m.themeTemplate) {\n        registerAxisThemeTemplate(m.identifier, m.themeTemplate);\n      }\n    }\n    if (m.type === 'legend') {\n      registerLegend(m.identifier, m.optionsKey, m.instanceConstructor, m.themeTemplate);\n    }\n  }\n  if (hasRegisteredEnterpriseModules()) {\n    const expectedButUnused = getUnusedExpectedModules();\n    if (expectedButUnused.length > 0) {\n      Logger.errorOnce('Enterprise modules expected but not registered: ', expectedButUnused);\n    }\n  }\n}\nclass HierarchyChart extends Chart {\n  constructor(specialOverrides, resources) {\n    super(specialOverrides, resources);\n    this._data = {};\n  }\n  performLayout() {\n    const _super = Object.create(null, {\n      performLayout: {\n        get: () => super.performLayout\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const shrinkRect = yield _super.performLayout.call(this);\n      const {\n        seriesArea: {\n          padding\n        },\n        seriesRoot\n      } = this;\n      const fullSeriesRect = shrinkRect.clone();\n      shrinkRect.shrink(padding.left, 'left');\n      shrinkRect.shrink(padding.top, 'top');\n      shrinkRect.shrink(padding.right, 'right');\n      shrinkRect.shrink(padding.bottom, 'bottom');\n      this.seriesRect = shrinkRect;\n      this.animationRect = shrinkRect;\n      this.hoverRect = shrinkRect;\n      seriesRoot.translationX = Math.floor(shrinkRect.x);\n      seriesRoot.translationY = Math.floor(shrinkRect.y);\n      yield Promise.all(this.series.map(series => __awaiter(this, void 0, void 0, function* () {\n        yield series.update({\n          seriesRect: shrinkRect\n        }); // this has to happen after the `updateAxes` call\n      })));\n\n      seriesRoot.visible = this.series[0].visible;\n      seriesRoot.setClipRectInGroupCoordinateSpace(new BBox(shrinkRect.x, shrinkRect.y, shrinkRect.width, shrinkRect.height));\n      this.layoutService.dispatchLayoutComplete({\n        type: 'layout-complete',\n        chart: {\n          width: this.scene.width,\n          height: this.scene.height\n        },\n        clipSeries: false,\n        series: {\n          rect: fullSeriesRect,\n          paddedRect: shrinkRect,\n          visible: true\n        },\n        axes: []\n      });\n      return shrinkRect;\n    });\n  }\n}\nHierarchyChart.className = 'HierarchyChart';\nHierarchyChart.type = 'hierarchy';\nfunction removeUsedEnterpriseOptions(options) {\n  var _a, _b, _c, _d;\n  const usedOptions = [];\n  const optionsChartType = getChartType(optionsType(options));\n  for (const {\n    type,\n    chartTypes,\n    optionsKey,\n    optionsInnerKey,\n    identifier\n  } of EXPECTED_ENTERPRISE_MODULES) {\n    if (optionsChartType !== 'unknown' && !chartTypes.includes(optionsChartType)) continue;\n    if (type === 'root' || type === 'legend') {\n      const optionValue = options[optionsKey];\n      if (optionValue == null) continue;\n      if (!optionsInnerKey) {\n        usedOptions.push(optionsKey);\n        delete options[optionsKey];\n      } else if (optionValue[optionsInnerKey]) {\n        usedOptions.push(`${optionsKey}.${optionsInnerKey}`);\n        delete optionValue[optionsInnerKey];\n      }\n    } else if (type === 'axis') {\n      if (!('axes' in options) || !((_a = options.axes) === null || _a === void 0 ? void 0 : _a.some(axis => axis.type === identifier))) continue;\n      usedOptions.push(`axis[type=${identifier}]`);\n      options.axes = options.axes.filter(axis => axis.type !== identifier);\n    } else if (type === 'axis-option') {\n      if (!('axes' in options) || !((_b = options.axes) === null || _b === void 0 ? void 0 : _b.some(axis => axis[optionsKey]))) continue;\n      usedOptions.push(`axis.${optionsKey}`);\n      options.axes.forEach(axis => {\n        if (axis[optionsKey]) {\n          delete axis[optionsKey];\n        }\n      });\n    } else if (type === 'series') {\n      if (!((_c = options.series) === null || _c === void 0 ? void 0 : _c.some(series => series.type === identifier))) continue;\n      usedOptions.push(`series[type=${identifier}]`);\n      options.series = options.series.filter(series => series.type !== identifier);\n    } else if (type === 'series-option') {\n      if (!((_d = options.series) === null || _d === void 0 ? void 0 : _d.some(series => series[optionsKey]))) continue;\n      usedOptions.push(`series.${optionsKey}`);\n      options.series.forEach(series => {\n        if (series[optionsKey]) {\n          delete series[optionsKey];\n        }\n      });\n    }\n  }\n  if (usedOptions.length > 0) {\n    Logger.warnOnce([`unable to use these enterprise features as 'ag-charts-enterprise' has not been loaded:`, ``, ...usedOptions, ``, 'See: https://charts.ag-grid.com/javascript/installation/'].join('\\n'));\n  }\n}\n\n/**\r\n * Groups the series options objects if they are of type `column` or `bar` and places them in an array at the index where the first instance of this series type was found.\r\n * Returns an array of arrays containing the ordered and grouped series options objects.\r\n */\nfunction groupSeriesByType(seriesOptions) {\n  var _a, _b, _c, _d;\n  const groupMap = {};\n  const stackMap = {};\n  const anyStacked = {};\n  const defaultUnstackedGroup = 'default-ag-charts-group';\n  const result = [];\n  for (const s of seriesOptions) {\n    const type = (_a = s.type) !== null && _a !== void 0 ? _a : 'line';\n    const stackable = isStackableSeries(type);\n    const groupable = isGroupableSeries(type);\n    if (!stackable && !groupable) {\n      // No need to use index for these cases.\n      result.push({\n        type: 'ungrouped',\n        opts: [s]\n      });\n      continue;\n    }\n    const {\n      stacked: sStacked,\n      stackGroup: sStackGroup,\n      grouped: sGrouped = undefined,\n      xKey\n    } = s;\n    const stacked = sStackGroup != null || sStacked === true;\n    (_b = anyStacked[type]) !== null && _b !== void 0 ? _b : anyStacked[type] = false;\n    anyStacked[type] || (anyStacked[type] = stacked && stackable);\n    const grouped = sGrouped === true;\n    let groupingKey = [sStackGroup !== null && sStackGroup !== void 0 ? sStackGroup : sStacked === true ? 'stacked' : undefined, grouped ? 'grouped' : undefined].filter(v => v != null).join('-');\n    if (!groupingKey) {\n      groupingKey = defaultUnstackedGroup;\n    }\n    const indexKey = `${type}-${xKey}-${groupingKey}`;\n    if (stacked && stackable) {\n      const updated = (_c = stackMap[indexKey]) !== null && _c !== void 0 ? _c : stackMap[indexKey] = {\n        type: 'stack',\n        opts: []\n      };\n      if (updated.opts.length === 0) result.push(updated);\n      updated.opts.push(s);\n    } else if (grouped && groupable) {\n      const updated = (_d = groupMap[indexKey]) !== null && _d !== void 0 ? _d : groupMap[indexKey] = {\n        type: 'group',\n        opts: []\n      };\n      if (updated.opts.length === 0) result.push(updated);\n      updated.opts.push(s);\n    } else {\n      result.push({\n        type: 'ungrouped',\n        opts: [s]\n      });\n    }\n  }\n  if (!Object.values(anyStacked).some(v => v)) {\n    return result;\n  }\n  return result;\n}\n/**\r\n * Transforms provided series options array into an array containing series options which are compatible with standalone charts series options.\r\n */\nfunction processSeriesOptions(_opts, seriesOptions) {\n  var _a;\n  const result = [];\n  const preprocessed = seriesOptions.map(series => {\n    var _a;\n    // Change the default for bar/columns when yKey is used to be grouped rather than stacked.\n    const sType = (_a = series.type) !== null && _a !== void 0 ? _a : 'line';\n    const groupable = isGroupableSeries(sType);\n    const stackable = isStackableSeries(sType);\n    const stackedByDefault = isSeriesStackedByDefault(sType);\n    if (series.grouped && !groupable) {\n      Logger.warnOnce(`unsupported grouping of series type: ${sType}`);\n    }\n    if (series.stacked && !stackable) {\n      Logger.warnOnce(`unsupported stacking of series type: ${sType}`);\n    }\n    if (!groupable && !stackable) {\n      return series;\n    }\n    let stacked = false;\n    let grouped = false;\n    if (series.stacked === undefined && series.grouped === undefined) {\n      stacked = stackable && stackedByDefault;\n      grouped = groupable && !stacked;\n    } else if (series.stacked === undefined) {\n      stacked = stackable && stackedByDefault && !(series.grouped && groupable);\n      grouped = groupable && !stacked && !!series.grouped;\n    } else if (series.grouped === undefined) {\n      stacked = stackable && series.stacked;\n      grouped = groupable && !stacked;\n    } else {\n      stacked = stackable && series.stacked;\n      grouped = groupable && !stacked && series.grouped;\n    }\n    return Object.assign(Object.assign({}, series), {\n      stacked,\n      grouped\n    });\n  });\n  const grouped = groupSeriesByType(preprocessed);\n  const groupCount = grouped.reduce((result, next) => {\n    var _a, _b;\n    if (next.type === 'ungrouped') return result;\n    const seriesType = (_a = next.opts[0].type) !== null && _a !== void 0 ? _a : 'line';\n    (_b = result[seriesType]) !== null && _b !== void 0 ? _b : result[seriesType] = 0;\n    result[seriesType] += next.type === 'stack' ? 1 : next.opts.length;\n    return result;\n  }, {});\n  const groupIdx = {};\n  const addSeriesGroupingMeta = group => {\n    var _a, _b;\n    let stackIdx = 0;\n    const seriesType = (_a = group.opts[0].type) !== null && _a !== void 0 ? _a : 'line';\n    (_b = groupIdx[seriesType]) !== null && _b !== void 0 ? _b : groupIdx[seriesType] = 0;\n    if (group.type === 'stack') {\n      for (const opts of group.opts) {\n        opts.seriesGrouping = {\n          groupIndex: groupIdx[seriesType],\n          groupCount: groupCount[seriesType],\n          stackIndex: stackIdx++,\n          stackCount: group.opts.length\n        };\n      }\n      groupIdx[seriesType]++;\n    } else if (group.type === 'group') {\n      for (const opts of group.opts) {\n        opts.seriesGrouping = {\n          groupIndex: groupIdx[seriesType],\n          groupCount: groupCount[seriesType],\n          stackIndex: 0,\n          stackCount: 0\n        };\n        groupIdx[seriesType]++;\n      }\n    } else {\n      for (const opts of group.opts) {\n        opts.seriesGrouping = undefined;\n      }\n    }\n    return group.opts;\n  };\n  Debug.create(true, 'opts')('processSeriesOptions() - series grouping: ', grouped);\n  for (const group of grouped) {\n    const seriesType = (_a = group.opts[0].type) !== null && _a !== void 0 ? _a : 'line';\n    if (isGroupableSeries(seriesType) || isStackableSeries(seriesType)) {\n      result.push(...addSeriesGroupingMeta(group));\n    } else {\n      result.push(...group.opts);\n    }\n  }\n  return result;\n}\nconst DEFAULT_BACKGROUND_FILL = 'white';\nconst palette$9 = {\n  fills: Array.from(Object.values(DEFAULT_FILLS)),\n  strokes: Array.from(Object.values(DEFAULT_STROKES))\n};\nconst CHART_TYPE_CONFIG = {\n  get cartesian() {\n    return {\n      seriesTypes: CHART_TYPES.cartesianTypes,\n      commonOptions: ['zoom', 'navigator']\n    };\n  },\n  get polar() {\n    return {\n      seriesTypes: CHART_TYPES.polarTypes,\n      commonOptions: []\n    };\n  },\n  get hierarchy() {\n    return {\n      seriesTypes: CHART_TYPES.hierarchyTypes,\n      commonOptions: []\n    };\n  }\n};\nconst CHART_TYPE_SPECIFIC_COMMON_OPTIONS = Object.values(CHART_TYPE_CONFIG).reduce((r, {\n  commonOptions\n}) => [...r, ...commonOptions], []);\nclass ChartTheme {\n  getPalette() {\n    return palette$9;\n  }\n  static getAxisDefaults() {\n    return {\n      top: {},\n      right: {},\n      bottom: {},\n      left: {},\n      title: {\n        enabled: false,\n        text: 'Axis Title',\n        spacing: 25,\n        fontStyle: undefined,\n        fontWeight: NORMAL,\n        fontSize: FONT_SIZE.MEDIUM,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR\n      },\n      label: {\n        fontStyle: undefined,\n        fontWeight: undefined,\n        fontSize: FONT_SIZE.SMALL,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        padding: 5,\n        rotation: undefined,\n        color: DEFAULT_LABEL_COLOUR,\n        formatter: undefined,\n        avoidCollisions: true\n      },\n      line: {\n        enabled: true,\n        width: 1,\n        color: DEFAULT_AXIS_LINE_COLOUR\n      },\n      tick: {\n        enabled: false,\n        width: 1,\n        color: DEFAULT_AXIS_LINE_COLOUR\n      },\n      gridLine: {\n        enabled: true,\n        style: [{\n          stroke: DEFAULT_AXIS_GRID_COLOUR,\n          lineDash: []\n        }]\n      },\n      crossLines: {\n        enabled: false,\n        fill: DEFAULT_CROSS_LINES_COLOUR,\n        stroke: DEFAULT_CROSS_LINES_COLOUR,\n        fillOpacity: 0.1,\n        strokeWidth: 1,\n        label: {\n          enabled: false,\n          fontStyle: undefined,\n          fontWeight: undefined,\n          fontSize: FONT_SIZE.SMALL,\n          fontFamily: DEFAULT_FONT_FAMILY,\n          padding: 5,\n          color: DEFAULT_LABEL_COLOUR\n        }\n      }\n    };\n  }\n  static getSeriesDefaults() {\n    return {\n      tooltip: {\n        enabled: true,\n        renderer: undefined\n      },\n      visible: true,\n      showInLegend: true,\n      highlightStyle: {\n        item: {\n          fill: 'rgba(255,255,255, 0.33)',\n          stroke: `rgba(0, 0, 0, 0.4)`,\n          strokeWidth: 2\n        },\n        series: {\n          dimOpacity: 1\n        },\n        text: {\n          color: 'black'\n        }\n      },\n      nodeClickRange: 'exact'\n    };\n  }\n  static getCartesianSeriesMarkerDefaults() {\n    return {\n      enabled: true,\n      shape: 'circle',\n      size: 7,\n      strokeWidth: 1,\n      formatter: undefined\n    };\n  }\n  static getLegendItemMarkerDefaults() {\n    return {\n      shape: undefined,\n      size: 15,\n      padding: 8\n    };\n  }\n  static getCaptionWrappingDefaults() {\n    return 'hyphenate';\n  }\n  static getChartDefaults() {\n    return {\n      background: {\n        visible: true,\n        fill: DEFAULT_BACKGROUND_COLOUR\n      },\n      padding: {\n        top: 20,\n        right: 20,\n        bottom: 20,\n        left: 20\n      },\n      title: {\n        enabled: false,\n        text: 'Title',\n        fontStyle: undefined,\n        fontWeight: NORMAL,\n        fontSize: FONT_SIZE.LARGE,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_LABEL_COLOUR,\n        wrapping: ChartTheme.getCaptionWrappingDefaults()\n      },\n      subtitle: {\n        enabled: false,\n        text: 'Subtitle',\n        spacing: 20,\n        fontStyle: undefined,\n        fontWeight: undefined,\n        fontSize: FONT_SIZE.MEDIUM,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: DEFAULT_MUTED_LABEL_COLOUR,\n        wrapping: ChartTheme.getCaptionWrappingDefaults()\n      },\n      footnote: {\n        enabled: false,\n        text: 'Footnote',\n        spacing: 20,\n        fontStyle: undefined,\n        fontWeight: undefined,\n        fontSize: FONT_SIZE.MEDIUM,\n        fontFamily: DEFAULT_FONT_FAMILY,\n        color: 'rgb(140, 140, 140)',\n        wrapping: ChartTheme.getCaptionWrappingDefaults()\n      },\n      legend: {\n        position: BOTTOM,\n        spacing: 30,\n        listeners: {},\n        item: {\n          paddingX: 16,\n          paddingY: 8,\n          marker: ChartTheme.getLegendItemMarkerDefaults(),\n          label: {\n            color: DEFAULT_LABEL_COLOUR,\n            fontStyle: undefined,\n            fontWeight: undefined,\n            fontSize: FONT_SIZE.SMALL,\n            fontFamily: DEFAULT_FONT_FAMILY,\n            formatter: undefined\n          }\n        },\n        reverseOrder: false,\n        pagination: {\n          marker: {\n            size: 12\n          },\n          activeStyle: {\n            fill: DEFAULT_LABEL_COLOUR\n          },\n          inactiveStyle: {\n            fill: DEFAULT_MUTED_LABEL_COLOUR\n          },\n          highlightStyle: {\n            fill: DEFAULT_LABEL_COLOUR\n          },\n          label: {\n            color: DEFAULT_LABEL_COLOUR\n          }\n        }\n      },\n      tooltip: {\n        enabled: true,\n        range: 'nearest',\n        delay: 0\n      },\n      listeners: {}\n    };\n  }\n  constructor(options) {\n    options = deepMerge({}, options !== null && options !== void 0 ? options : {});\n    const {\n      overrides = null,\n      palette = null\n    } = options;\n    const defaults = this.createChartConfigPerChartType(this.getDefaults());\n    if (overrides) {\n      const {\n        common\n      } = overrides;\n      const applyOverrides = (seriesTypes, overrideOpts) => {\n        if (!overrideOpts) return;\n        for (const s of seriesTypes) {\n          const seriesType = s;\n          defaults[seriesType] = deepMerge(defaults[seriesType], overrideOpts);\n        }\n      };\n      for (const [, {\n        seriesTypes,\n        commonOptions\n      }] of Object.entries(CHART_TYPE_CONFIG)) {\n        const cleanedCommon = Object.assign({}, common);\n        for (const commonKey of CHART_TYPE_SPECIFIC_COMMON_OPTIONS) {\n          if (!commonOptions.includes(commonKey)) {\n            delete cleanedCommon[commonKey];\n          }\n        }\n        applyOverrides(seriesTypes, cleanedCommon);\n      }\n      CHART_TYPES.seriesTypes.forEach(s => {\n        const seriesType = s;\n        if (overrides[seriesType]) {\n          defaults[seriesType] = deepMerge(defaults[seriesType], overrides[seriesType]);\n        }\n      });\n    }\n    this.palette = palette !== null && palette !== void 0 ? palette : this.getPalette();\n    this.config = Object.freeze(this.templateTheme(defaults));\n  }\n  createChartConfigPerChartType(config) {\n    Object.entries(CHART_TYPE_CONFIG).forEach(([nextType, {\n      seriesTypes\n    }]) => {\n      const typeDefaults = getChartDefaults(nextType);\n      seriesTypes.forEach(next => {\n        const alias = next;\n        if (!config[alias]) {\n          config[alias] = {};\n          deepMerge(config[alias], typeDefaults);\n        }\n      });\n    });\n    return config;\n  }\n  getDefaults() {\n    let defaults = {};\n    const getChartTypeDefaults = chartType => {\n      return Object.assign(Object.assign(Object.assign({}, getLegendThemeTemplates()), ChartTheme.getChartDefaults()), getChartDefaults(chartType));\n    };\n    const getOverridesByType = (chartType, seriesTypes) => {\n      var _a, _b, _c;\n      var _d;\n      const chartDefaults = getChartTypeDefaults(chartType);\n      const result = {};\n      for (const seriesType of seriesTypes) {\n        (_a = result[seriesType]) !== null && _a !== void 0 ? _a : result[seriesType] = deepMerge({}, chartDefaults);\n        const axes = (_b = (_d = result[seriesType]).axes) !== null && _b !== void 0 ? _b : _d.axes = {};\n        const template = getSeriesThemeTemplate(seriesType);\n        if (template) {\n          result[seriesType].series = deepMerge(result[seriesType].series, template);\n        }\n        for (const axisType of AXIS_TYPES.axesTypes) {\n          const template = getAxisThemeTemplate(axisType);\n          if (chartType === 'cartesian') {\n            axes[axisType] = deepMerge(axes[axisType], (_c = ChartTheme.cartesianAxisDefault[axisType]) !== null && _c !== void 0 ? _c : {});\n          }\n          if (template) {\n            axes[axisType] = deepMerge(axes[axisType], template);\n          }\n        }\n      }\n      return result;\n    };\n    defaults = deepMerge(defaults, getOverridesByType('cartesian', CHART_TYPES.cartesianTypes));\n    defaults = deepMerge(defaults, getOverridesByType('polar', CHART_TYPES.polarTypes));\n    defaults = deepMerge(defaults, getOverridesByType('hierarchy', CHART_TYPES.hierarchyTypes));\n    return defaults;\n  }\n  templateTheme(themeTemplate) {\n    const themeInstance = jsonMerge([themeTemplate]);\n    const {\n      extensions,\n      properties\n    } = this.getTemplateParameters();\n    jsonWalk(themeInstance, (_, node) => {\n      if (node['__extends__']) {\n        const key = node['__extends__'];\n        const source = extensions.get(key);\n        if (source == null) {\n          throw new Error('AG Charts - no template variable provided for: ' + key);\n        }\n        Object.keys(source).forEach(key => {\n          if (!(key in node)) {\n            node[key] = source[key];\n          }\n        });\n        delete node['__extends__'];\n      }\n      if (node['__overrides__']) {\n        const key = node['__overrides__'];\n        const source = extensions.get(key);\n        if (source == null) {\n          throw new Error('AG Charts - no template variable provided for: ' + key);\n        }\n        Object.assign(node, source);\n        delete node['__overrides__'];\n      }\n      if (Array.isArray(node)) {\n        for (let i = 0; i < node.length; i++) {\n          const symbol = node[i];\n          if (properties.has(symbol)) {\n            node[i] = properties.get(symbol);\n          }\n        }\n      } else {\n        for (const [name, value] of Object.entries(node)) {\n          if (properties.has(value)) {\n            node[name] = properties.get(value);\n          }\n        }\n      }\n    });\n    return themeInstance;\n  }\n  static getWaterfallSeriesDefaultPositiveColors() {\n    return {\n      fill: DEFAULT_FILLS.BLUE,\n      stroke: DEFAULT_STROKES.BLUE\n    };\n  }\n  static getWaterfallSeriesDefaultNegativeColors() {\n    return {\n      fill: DEFAULT_FILLS.ORANGE,\n      stroke: DEFAULT_STROKES.ORANGE\n    };\n  }\n  static getWaterfallSeriesDefaultTotalColors() {\n    return {\n      fill: DEFAULT_FILLS.GRAY,\n      stroke: DEFAULT_STROKES.GRAY\n    };\n  }\n  getTemplateParameters() {\n    const extensions = new Map();\n    extensions.set(EXTENDS_CHART_DEFAULTS, ChartTheme.getChartDefaults());\n    extensions.set(EXTENDS_AXES_DEFAULTS, ChartTheme.getAxisDefaults());\n    extensions.set(EXTENDS_LEGEND_DEFAULTS, ChartTheme.getChartDefaults().legend);\n    extensions.set(EXTENDS_LEGEND_ITEM_DEFAULTS, ChartTheme.getChartDefaults().legend.item);\n    extensions.set(EXTENDS_LEGEND_ITEM_MARKER_DEFAULTS, ChartTheme.getLegendItemMarkerDefaults());\n    extensions.set(EXTENDS_AXES_LABEL_DEFAULTS, ChartTheme.getAxisDefaults().label);\n    extensions.set(EXTENDS_AXES_LINE_DEFAULTS, ChartTheme.getAxisDefaults().line);\n    extensions.set(EXTENDS_AXES_TICK_DEFAULTS, ChartTheme.getAxisDefaults().tick);\n    extensions.set(EXTENDS_AXES_GRID_LINE_DEFAULTS, ChartTheme.getAxisDefaults().gridLine);\n    extensions.set(EXTENDS_SERIES_DEFAULTS, ChartTheme.getSeriesDefaults());\n    extensions.set(OVERRIDE_SERIES_LABEL_DEFAULTS, {});\n    extensions.set(EXTENDS_CARTESIAN_MARKER_DEFAULTS, ChartTheme.getCartesianSeriesMarkerDefaults());\n    const properties = new Map();\n    properties.set(DEFAULT_FONT_FAMILY, 'Verdana, sans-serif');\n    properties.set(DEFAULT_LABEL_COLOUR, 'rgb(70, 70, 70)');\n    properties.set(DEFAULT_INVERTED_LABEL_COLOUR, 'white');\n    properties.set(DEFAULT_MUTED_LABEL_COLOUR, 'rgb(140, 140, 140)');\n    properties.set(DEFAULT_AXIS_GRID_COLOUR, 'rgb(224,234,241)');\n    properties.set(DEFAULT_AXIS_LINE_COLOUR, 'rgb(195, 195, 195)');\n    properties.set(DEFAULT_CROSS_LINES_COLOUR, 'rgb(70, 70, 70)');\n    properties.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_BACKGROUND_FILL);\n    properties.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_BACKGROUND_FILL);\n    properties.set(DEFAULT_SHADOW_COLOUR, 'rgba(0, 0, 0, 0.5)');\n    properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [DEFAULT_FILLS.ORANGE, DEFAULT_FILLS.YELLOW, DEFAULT_FILLS.GREEN]);\n    properties.set(DEFAULT_HIERARCHY_FILLS, ['#ffffff', '#e0e5ea', '#c1ccd5', '#a3b4c1', '#859cad']);\n    properties.set(DEFAULT_HIERARCHY_STROKES, ['#ffffff', '#c5cbd1', '#a4b1bd', '#8498a9', '#648096']);\n    properties.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_BACKGROUND_FILL);\n    properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, ChartTheme.getWaterfallSeriesDefaultPositiveColors());\n    properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, ChartTheme.getWaterfallSeriesDefaultNegativeColors());\n    properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, ChartTheme.getWaterfallSeriesDefaultTotalColors());\n    properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, ChartTheme.getWaterfallSeriesDefaultTotalColors().stroke);\n    return {\n      extensions,\n      properties\n    };\n  }\n}\nChartTheme.cartesianAxisDefault = {\n  number: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults()), {\n    line: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults().line), {\n      enabled: false\n    })\n  }),\n  log: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults()), {\n    base: 10,\n    line: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults().line), {\n      enabled: false\n    })\n  }),\n  category: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults()), {\n    groupPaddingInner: 0.1,\n    label: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults().label), {\n      autoRotate: true\n    }),\n    gridLine: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults().gridLine), {\n      enabled: false\n    })\n  }),\n  'grouped-category': Object.assign({}, ChartTheme.getAxisDefaults()),\n  time: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults()), {\n    gridLine: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults().gridLine), {\n      enabled: false\n    })\n  })\n};\nconst DEFAULT_DARK_BACKGROUND_FILL = '#182732';\nconst DEFAULT_DARK_FILLS = {\n  BLUE: '#5090dc',\n  ORANGE: '#ffa03a',\n  GREEN: '#459d55',\n  CYAN: '#34bfe1',\n  YELLOW: '#e1cc00',\n  VIOLET: '#9669cb',\n  GRAY: '#b5b5b5',\n  MAGENTA: '#bd5aa7',\n  BROWN: '#8a6224',\n  RED: '#ef5452'\n};\nconst DEFAULT_DARK_STROKES = {\n  BLUE: '#74a8e6',\n  ORANGE: '#ffbe70',\n  GREEN: '#6cb176',\n  CYAN: '#75d4ef',\n  YELLOW: '#f6e559',\n  VIOLET: '#aa86d8',\n  GRAY: '#a1a1a1',\n  MAGENTA: '#ce7ab9',\n  BROWN: '#997b52',\n  RED: '#ff7872'\n};\nconst palette$8 = {\n  fills: Array.from(Object.values(DEFAULT_DARK_FILLS)),\n  strokes: Array.from(Object.values(DEFAULT_DARK_STROKES))\n};\nclass DarkTheme extends ChartTheme {\n  static getWaterfallSeriesDefaultPositiveColors() {\n    return {\n      fill: DEFAULT_DARK_FILLS.BLUE,\n      stroke: DEFAULT_DARK_STROKES.BLUE\n    };\n  }\n  static getWaterfallSeriesDefaultNegativeColors() {\n    return {\n      fill: DEFAULT_DARK_FILLS.ORANGE,\n      stroke: DEFAULT_DARK_STROKES.ORANGE\n    };\n  }\n  static getWaterfallSeriesDefaultTotalColors() {\n    return {\n      fill: DEFAULT_DARK_FILLS.GRAY,\n      stroke: DEFAULT_DARK_STROKES.GRAY\n    };\n  }\n  getTemplateParameters() {\n    const result = super.getTemplateParameters();\n    result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, DarkTheme.getWaterfallSeriesDefaultPositiveColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, DarkTheme.getWaterfallSeriesDefaultNegativeColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, DarkTheme.getWaterfallSeriesDefaultTotalColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, DarkTheme.getWaterfallSeriesDefaultTotalColors().stroke);\n    result.properties.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_DARK_BACKGROUND_FILL);\n    result.properties.set(DEFAULT_LABEL_COLOUR, 'white');\n    result.properties.set(DEFAULT_MUTED_LABEL_COLOUR, '#7D91A0');\n    result.properties.set(DEFAULT_AXIS_GRID_COLOUR, '#545A6E');\n    result.properties.set(DEFAULT_CROSS_LINES_COLOUR, 'white');\n    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [DEFAULT_DARK_FILLS.ORANGE, DEFAULT_DARK_FILLS.YELLOW, DEFAULT_DARK_FILLS.GREEN]);\n    result.properties.set(DEFAULT_HIERARCHY_FILLS, ['#192834', '#253746', '#324859', '#3f596c', '#4d6a80']);\n    result.properties.set(DEFAULT_HIERARCHY_STROKES, ['#192834', '#3b5164', '#496275', '#577287', '#668399']);\n    result.properties.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\n    result.properties.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\n    return result;\n  }\n  getPalette() {\n    return palette$8;\n  }\n  constructor(options) {\n    super(options);\n  }\n}\nconst MATERIAL_DARK_FILLS = {\n  BLUE: '#2196F3',\n  ORANGE: '#FF9800',\n  GREEN: '#4CAF50',\n  CYAN: '#00BCD4',\n  YELLOW: '#FFEB3B',\n  VIOLET: '#7E57C2',\n  GRAY: '#9E9E9E',\n  MAGENTA: '#F06292',\n  BROWN: '#795548',\n  RED: '#F44336'\n};\nconst MATERIAL_DARK_STROKES = {\n  BLUE: '#90CAF9',\n  ORANGE: '#FFCC80',\n  GREEN: '#A5D6A7',\n  CYAN: '#80DEEA',\n  YELLOW: '#FFF9C4',\n  VIOLET: '#B39DDB',\n  GRAY: '#E0E0E0',\n  MAGENTA: '#F48FB1',\n  BROWN: '#A1887F',\n  RED: '#EF9A9A'\n};\nconst palette$7 = {\n  fills: Array.from(Object.values(MATERIAL_DARK_FILLS)),\n  strokes: Array.from(Object.values(MATERIAL_DARK_STROKES))\n};\nclass MaterialDark extends DarkTheme {\n  static getWaterfallSeriesDefaultPositiveColors() {\n    return {\n      fill: MATERIAL_DARK_FILLS.BLUE,\n      stroke: MATERIAL_DARK_STROKES.BLUE\n    };\n  }\n  static getWaterfallSeriesDefaultNegativeColors() {\n    return {\n      fill: MATERIAL_DARK_FILLS.RED,\n      stroke: MATERIAL_DARK_STROKES.RED\n    };\n  }\n  static getWaterfallSeriesDefaultTotalColors() {\n    return {\n      fill: MATERIAL_DARK_FILLS.GRAY,\n      stroke: MATERIAL_DARK_STROKES.GRAY\n    };\n  }\n  getTemplateParameters() {\n    const result = super.getTemplateParameters();\n    result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, MaterialDark.getWaterfallSeriesDefaultPositiveColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, MaterialDark.getWaterfallSeriesDefaultNegativeColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, MaterialDark.getWaterfallSeriesDefaultTotalColors());\n    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [MATERIAL_DARK_FILLS.ORANGE, MATERIAL_DARK_FILLS.YELLOW, MATERIAL_DARK_FILLS.GREEN]);\n    result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, MaterialDark.getWaterfallSeriesDefaultTotalColors().stroke);\n    return result;\n  }\n  getPalette() {\n    return palette$7;\n  }\n}\nconst MATERIAL_LIGHT_FILLS = {\n  BLUE: '#2196F3',\n  ORANGE: '#FF9800',\n  GREEN: '#4CAF50',\n  CYAN: '#00BCD4',\n  YELLOW: '#FFEB3B',\n  VIOLET: '#7E57C2',\n  GRAY: '#9E9E9E',\n  MAGENTA: '#F06292',\n  BROWN: '#795548',\n  RED: '#F44336'\n};\nconst MATERIAL_LIGHT_STROKES = {\n  BLUE: '#1565C0',\n  ORANGE: '#E65100',\n  GREEN: '#2E7D32',\n  CYAN: '#00838F',\n  YELLOW: '#F9A825',\n  VIOLET: '#4527A0',\n  GRAY: '#616161',\n  MAGENTA: '#C2185B',\n  BROWN: '#4E342E',\n  RED: '#B71C1C'\n};\nconst palette$6 = {\n  fills: Array.from(Object.values(MATERIAL_LIGHT_FILLS)),\n  strokes: Array.from(Object.values(MATERIAL_LIGHT_STROKES))\n};\nclass MaterialLight extends ChartTheme {\n  static getWaterfallSeriesDefaultPositiveColors() {\n    return {\n      fill: MATERIAL_LIGHT_FILLS.BLUE,\n      stroke: MATERIAL_LIGHT_STROKES.BLUE\n    };\n  }\n  static getWaterfallSeriesDefaultNegativeColors() {\n    return {\n      fill: MATERIAL_LIGHT_FILLS.RED,\n      stroke: MATERIAL_LIGHT_STROKES.RED\n    };\n  }\n  static getWaterfallSeriesDefaultTotalColors() {\n    return {\n      fill: MATERIAL_LIGHT_FILLS.GRAY,\n      stroke: MATERIAL_LIGHT_STROKES.GRAY\n    };\n  }\n  getTemplateParameters() {\n    const result = super.getTemplateParameters();\n    result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, MaterialLight.getWaterfallSeriesDefaultPositiveColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, MaterialLight.getWaterfallSeriesDefaultNegativeColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, MaterialLight.getWaterfallSeriesDefaultTotalColors());\n    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [MATERIAL_LIGHT_FILLS.ORANGE, MATERIAL_LIGHT_FILLS.YELLOW, MATERIAL_LIGHT_FILLS.GREEN]);\n    result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, MaterialLight.getWaterfallSeriesDefaultTotalColors().stroke);\n    return result;\n  }\n  getPalette() {\n    return palette$6;\n  }\n}\nconst POLYCHROMA_DARK_FILLS = {\n  BLUE: '#436ff4',\n  PURPLE: '#9a7bff',\n  MAGENTA: '#d165d2',\n  PINK: '#f0598b',\n  RED: '#f47348',\n  ORANGE: '#f2a602',\n  YELLOW: '#e9e201',\n  GREEN: '#21b448',\n  CYAN: '#00b9a2',\n  MODERATE_BLUE: '#00aee4'\n};\nconst POLYCHROMA_DARK_STROKES = {\n  BLUE: '#6698ff',\n  PURPLE: '#c0a3ff',\n  MAGENTA: '#fc8dfc',\n  PINK: '#ff82b1',\n  RED: '#ff9b70',\n  ORANGE: '#ffcf4e',\n  YELLOW: '#ffff58',\n  GREEN: '#58dd70',\n  CYAN: '#51e2c9',\n  MODERATE_BLUE: '#4fd7ff'\n};\nconst POLYCHROMA_DARK_FILL_GRAY = '#bbbbbb';\nconst POLYCHROMA_DARK_STROKE_GRAY = '#eeeeee';\nconst palette$5 = {\n  fills: Array.from(Object.values(POLYCHROMA_DARK_FILLS)),\n  strokes: Array.from(Object.values(POLYCHROMA_DARK_STROKES))\n};\nclass PolychromaDark extends DarkTheme {\n  static getWaterfallSeriesDefaultPositiveColors() {\n    return {\n      fill: POLYCHROMA_DARK_FILLS.BLUE,\n      stroke: POLYCHROMA_DARK_STROKES.BLUE\n    };\n  }\n  static getWaterfallSeriesDefaultNegativeColors() {\n    return {\n      fill: POLYCHROMA_DARK_FILLS.RED,\n      stroke: POLYCHROMA_DARK_STROKES.RED\n    };\n  }\n  static getWaterfallSeriesDefaultTotalColors() {\n    return {\n      fill: POLYCHROMA_DARK_FILL_GRAY,\n      stroke: POLYCHROMA_DARK_STROKE_GRAY\n    };\n  }\n  getTemplateParameters() {\n    const result = super.getTemplateParameters();\n    result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, PolychromaDark.getWaterfallSeriesDefaultPositiveColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, PolychromaDark.getWaterfallSeriesDefaultNegativeColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, PolychromaDark.getWaterfallSeriesDefaultTotalColors());\n    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [POLYCHROMA_DARK_FILLS.BLUE, POLYCHROMA_DARK_FILLS.RED]);\n    result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, PolychromaDark.getWaterfallSeriesDefaultTotalColors().stroke);\n    return result;\n  }\n  getPalette() {\n    return palette$5;\n  }\n}\nconst POLYCHROMA_LIGHT_FILLS = {\n  BLUE: '#436ff4',\n  PURPLE: '#9a7bff',\n  MAGENTA: '#d165d2',\n  PINK: '#f0598b',\n  RED: '#f47348',\n  ORANGE: '#f2a602',\n  YELLOW: '#e9e201',\n  GREEN: '#21b448',\n  CYAN: '#00b9a2',\n  MODERATE_BLUE: '#00aee4'\n};\nconst POLYCHROMA_LIGHT_STROKES = {\n  BLUE: '#2346c9',\n  PURPLE: '#7653d4',\n  MAGENTA: '#a73da9',\n  PINK: '#c32d66',\n  RED: '#c84b1c',\n  ORANGE: '#c87f00',\n  YELLOW: '#c1b900',\n  GREEN: '#008c1c',\n  CYAN: '#00927c',\n  MODERATE_BLUE: '#0087bb'\n};\nconst POLYCHROMA_LIGHT_FILL_GRAY = '#bbbbbb';\nconst POLYCHROMA_LIGHT_STROKE_GRAY = '#888888';\nconst palette$4 = {\n  fills: Array.from(Object.values(POLYCHROMA_LIGHT_FILLS)),\n  strokes: Array.from(Object.values(POLYCHROMA_LIGHT_STROKES))\n};\nclass PolychromaLight extends ChartTheme {\n  static getWaterfallSeriesDefaultPositiveColors() {\n    return {\n      fill: POLYCHROMA_LIGHT_FILLS.BLUE,\n      stroke: POLYCHROMA_LIGHT_STROKES.BLUE\n    };\n  }\n  static getWaterfallSeriesDefaultNegativeColors() {\n    return {\n      fill: POLYCHROMA_LIGHT_FILLS.RED,\n      stroke: POLYCHROMA_LIGHT_STROKES.RED\n    };\n  }\n  static getWaterfallSeriesDefaultTotalColors() {\n    return {\n      fill: POLYCHROMA_LIGHT_FILL_GRAY,\n      stroke: POLYCHROMA_LIGHT_STROKE_GRAY\n    };\n  }\n  getTemplateParameters() {\n    const result = super.getTemplateParameters();\n    result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, PolychromaLight.getWaterfallSeriesDefaultPositiveColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, PolychromaLight.getWaterfallSeriesDefaultNegativeColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, PolychromaLight.getWaterfallSeriesDefaultTotalColors());\n    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [POLYCHROMA_LIGHT_FILLS.BLUE, POLYCHROMA_LIGHT_FILLS.RED]);\n    result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, PolychromaLight.getWaterfallSeriesDefaultTotalColors().stroke);\n    return result;\n  }\n  getPalette() {\n    return palette$4;\n  }\n}\nconst SHEETS_DARK_FILLS = {\n  BLUE: '#4472C4',\n  ORANGE: '#ED7D31',\n  GRAY: '#A5A5A5',\n  YELLOW: '#FFC000',\n  MODERATE_BLUE: '#5B9BD5',\n  GREEN: '#70AD47',\n  DARK_GRAY: '#7B7B7B',\n  DARK_BLUE: '#264478',\n  VERY_DARK_GRAY: '#636363',\n  DARK_YELLOW: '#997300'\n};\nconst SHEETS_DARK_STROKES = {\n  BLUE: '#6899ee',\n  ORANGE: '#ffa55d',\n  GRAY: '#cdcdcd',\n  YELLOW: '#ffea53',\n  MODERATE_BLUE: '#82c3ff',\n  GREEN: '#96d56f',\n  DARK_GRAY: '#a1a1a1',\n  DARK_BLUE: '#47689f',\n  VERY_DARK_GRAY: '#878787',\n  DARK_YELLOW: '#c0993d'\n};\nconst palette$3 = {\n  fills: Array.from(Object.values(SHEETS_DARK_FILLS)),\n  strokes: Array.from(Object.values(SHEETS_DARK_STROKES))\n};\nclass SheetsDark extends DarkTheme {\n  static getWaterfallSeriesDefaultPositiveColors() {\n    return {\n      fill: SHEETS_DARK_FILLS.BLUE,\n      stroke: SHEETS_DARK_STROKES.BLUE\n    };\n  }\n  static getWaterfallSeriesDefaultNegativeColors() {\n    return {\n      fill: SHEETS_DARK_FILLS.ORANGE,\n      stroke: SHEETS_DARK_STROKES.ORANGE\n    };\n  }\n  static getWaterfallSeriesDefaultTotalColors() {\n    return {\n      fill: SHEETS_DARK_FILLS.GRAY,\n      stroke: SHEETS_DARK_STROKES.GRAY\n    };\n  }\n  getTemplateParameters() {\n    const result = super.getTemplateParameters();\n    result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, SheetsDark.getWaterfallSeriesDefaultPositiveColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, SheetsDark.getWaterfallSeriesDefaultNegativeColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, SheetsDark.getWaterfallSeriesDefaultTotalColors());\n    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [SHEETS_DARK_FILLS.ORANGE, SHEETS_DARK_FILLS.YELLOW, SHEETS_DARK_FILLS.GREEN]);\n    result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, SheetsDark.getWaterfallSeriesDefaultTotalColors().stroke);\n    return result;\n  }\n  getPalette() {\n    return palette$3;\n  }\n}\nconst SHEETS_LIGHT_FILLS = {\n  BLUE: '#5281d5',\n  ORANGE: '#ff8d44',\n  GRAY: '#b5b5b5',\n  YELLOW: '#ffd02f',\n  MODERATE_BLUE: '#6aabe6',\n  GREEN: '#7fbd57',\n  DARK_GRAY: '#8a8a8a',\n  DARK_BLUE: '#335287',\n  VERY_DARK_GRAY: '#717171',\n  DARK_YELLOW: '#a98220'\n};\nconst SHEETS_LIGHT_STROKES = {\n  BLUE: '#214d9b',\n  ORANGE: '#c25600',\n  GRAY: '#7f7f7f',\n  YELLOW: '#d59800',\n  MODERATE_BLUE: '#3575ac',\n  GREEN: '#4b861a',\n  DARK_GRAY: '#575757',\n  DARK_BLUE: '#062253',\n  VERY_DARK_GRAY: '#414141',\n  DARK_YELLOW: '#734f00'\n};\nconst palette$2 = {\n  fills: Array.from(Object.values(SHEETS_LIGHT_FILLS)),\n  strokes: Array.from(Object.values(SHEETS_LIGHT_STROKES))\n};\nclass SheetsLight extends ChartTheme {\n  static getWaterfallSeriesDefaultPositiveColors() {\n    return {\n      fill: SHEETS_LIGHT_FILLS.BLUE,\n      stroke: SHEETS_LIGHT_STROKES.BLUE\n    };\n  }\n  static getWaterfallSeriesDefaultNegativeColors() {\n    return {\n      fill: SHEETS_LIGHT_FILLS.ORANGE,\n      stroke: SHEETS_LIGHT_STROKES.ORANGE\n    };\n  }\n  static getWaterfallSeriesDefaultTotalColors() {\n    return {\n      fill: SHEETS_LIGHT_FILLS.GRAY,\n      stroke: SHEETS_LIGHT_STROKES.GRAY\n    };\n  }\n  getTemplateParameters() {\n    const result = super.getTemplateParameters();\n    result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, SheetsLight.getWaterfallSeriesDefaultPositiveColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, SheetsLight.getWaterfallSeriesDefaultNegativeColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, SheetsLight.getWaterfallSeriesDefaultTotalColors());\n    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [SHEETS_LIGHT_FILLS.ORANGE, SHEETS_LIGHT_FILLS.YELLOW, SHEETS_LIGHT_FILLS.GREEN]);\n    result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, SheetsLight.getWaterfallSeriesDefaultTotalColors().stroke);\n    return result;\n  }\n  getPalette() {\n    return palette$2;\n  }\n}\nconst VIVID_DARK_FILLS = {\n  BLUE: '#0083ff',\n  ORANGE: '#ff6600',\n  GREEN: '#00af00',\n  CYAN: '#00ccff',\n  YELLOW: '#f7c700',\n  VIOLET: '#ac26ff',\n  GRAY: '#a7a7b7',\n  MAGENTA: '#e800c5',\n  BROWN: '#b54300',\n  RED: '#ff0000'\n};\nconst VIVID_DARK_STROKES = {\n  BLUE: '#67b7ff',\n  ORANGE: '#ffc24d',\n  GREEN: '#5cc86f',\n  CYAN: '#54ebff',\n  VIOLET: '#c18aff',\n  YELLOW: '#fff653',\n  GRAY: '#aeaeae',\n  MAGENTA: '#f078d4',\n  BROWN: '#ba8438',\n  RED: '#ff726e'\n};\nconst palette$1 = {\n  fills: Array.from(Object.values(VIVID_DARK_FILLS)),\n  strokes: Array.from(Object.values(VIVID_DARK_STROKES))\n};\nclass VividDark extends DarkTheme {\n  static getWaterfallSeriesDefaultPositiveColors() {\n    return {\n      fill: VIVID_DARK_FILLS.BLUE,\n      stroke: VIVID_DARK_STROKES.BLUE\n    };\n  }\n  static getWaterfallSeriesDefaultNegativeColors() {\n    return {\n      fill: VIVID_DARK_FILLS.ORANGE,\n      stroke: VIVID_DARK_STROKES.ORANGE\n    };\n  }\n  static getWaterfallSeriesDefaultTotalColors() {\n    return {\n      fill: VIVID_DARK_FILLS.GRAY,\n      stroke: VIVID_DARK_STROKES.GRAY\n    };\n  }\n  getTemplateParameters() {\n    const result = super.getTemplateParameters();\n    result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, VividDark.getWaterfallSeriesDefaultPositiveColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, VividDark.getWaterfallSeriesDefaultNegativeColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, VividDark.getWaterfallSeriesDefaultTotalColors());\n    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [VIVID_DARK_FILLS.ORANGE, VIVID_DARK_FILLS.YELLOW, VIVID_DARK_FILLS.GREEN]);\n    result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, VividDark.getWaterfallSeriesDefaultTotalColors().stroke);\n    return result;\n  }\n  getPalette() {\n    return palette$1;\n  }\n}\nconst VIVID_FILLS = {\n  BLUE: '#0083ff',\n  ORANGE: '#ff6600',\n  GREEN: '#00af00',\n  CYAN: '#00ccff',\n  YELLOW: '#f7c700',\n  VIOLET: '#ac26ff',\n  GRAY: '#a7a7b7',\n  MAGENTA: '#e800c5',\n  BROWN: '#b54300',\n  RED: '#ff0000'\n};\nconst VIVID_STROKES = {\n  BLUE: '#0f68c0',\n  ORANGE: '#d47100',\n  GREEN: '#007922',\n  CYAN: '#009ac2',\n  VIOLET: '#bca400',\n  YELLOW: '#753cac',\n  GRAY: '#646464',\n  MAGENTA: '#9b2685',\n  BROWN: '#6c3b00',\n  RED: '#cb0021'\n};\nconst palette = {\n  fills: Array.from(Object.values(VIVID_FILLS)),\n  strokes: Array.from(Object.values(VIVID_STROKES))\n};\nclass VividLight extends ChartTheme {\n  static getWaterfallSeriesDefaultPositiveColors() {\n    return {\n      fill: VIVID_FILLS.BLUE,\n      stroke: VIVID_STROKES.BLUE\n    };\n  }\n  static getWaterfallSeriesDefaultNegativeColors() {\n    return {\n      fill: VIVID_FILLS.ORANGE,\n      stroke: VIVID_STROKES.ORANGE\n    };\n  }\n  static getWaterfallSeriesDefaultTotalColors() {\n    return {\n      fill: VIVID_FILLS.GRAY,\n      stroke: VIVID_STROKES.GRAY\n    };\n  }\n  getTemplateParameters() {\n    const result = super.getTemplateParameters();\n    result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, VividLight.getWaterfallSeriesDefaultPositiveColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, VividLight.getWaterfallSeriesDefaultNegativeColors());\n    result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, VividLight.getWaterfallSeriesDefaultTotalColors());\n    result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [VIVID_FILLS.ORANGE, VIVID_FILLS.YELLOW, VIVID_FILLS.GREEN]);\n    result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, VividLight.getWaterfallSeriesDefaultTotalColors().stroke);\n    return result;\n  }\n  getPalette() {\n    return palette;\n  }\n}\nconst lightTheme = () => new ChartTheme();\nconst darkTheme = () => new DarkTheme();\nconst lightThemes = {\n  undefined: lightTheme,\n  null: lightTheme,\n  'ag-default': lightTheme,\n  'ag-sheets': () => new SheetsLight(),\n  'ag-polychroma': () => new PolychromaLight(),\n  'ag-vivid': () => new VividLight(),\n  'ag-material': () => new MaterialLight()\n};\nconst darkThemes = {\n  undefined: darkTheme,\n  null: darkTheme,\n  'ag-default-dark': darkTheme,\n  'ag-sheets-dark': () => new SheetsDark(),\n  'ag-polychroma-dark': () => new PolychromaDark(),\n  'ag-vivid-dark': () => new VividDark(),\n  'ag-material-dark': () => new MaterialDark()\n};\nconst themes$1 = Object.assign(Object.assign({}, darkThemes), lightThemes);\nfunction validateChartThemeObject(unknownObject) {\n  if (unknownObject === null) {\n    return undefined;\n  }\n  let valid = true;\n  const {\n    baseTheme,\n    palette,\n    overrides\n  } = unknownObject;\n  if (baseTheme !== undefined && typeof baseTheme !== 'string' && typeof baseTheme !== 'object') {\n    Logger.warn(`invalid theme.baseTheme type ${typeof baseTheme}, expected (string | object).`);\n    valid = false;\n  }\n  if (overrides !== undefined && typeof overrides !== 'object') {\n    Logger.warn(`invalid theme.overrides type ${typeof overrides}, expected object.`);\n    valid = false;\n  }\n  if (typeof palette === 'object') {\n    if (palette !== null) {\n      const {\n        fills,\n        strokes\n      } = palette;\n      if (!Array.isArray(fills)) {\n        Logger.warn(`theme.overrides.fills must be a defined array`);\n        valid = false;\n      }\n      if (!Array.isArray(strokes)) {\n        Logger.warn(`theme.overrides.strokes must be a defined array`);\n        valid = false;\n      }\n    }\n  } else if (palette !== undefined) {\n    Logger.warn(`invalid theme.palette type ${typeof palette}, expected object.`);\n    valid = false;\n  }\n  if (valid) {\n    return unknownObject;\n  }\n  return undefined;\n}\nfunction validateChartTheme(value) {\n  if (value === undefined || typeof value === 'string' || value instanceof ChartTheme) {\n    return value;\n  }\n  if (typeof value === 'object') {\n    return validateChartThemeObject(value);\n  }\n  Logger.warn(`invalid theme value type ${typeof value}, expected object.`);\n  return undefined;\n}\nfunction getChartTheme(unvalidatedValue) {\n  var _a;\n  // unvalidatedValue is either a built-in theme (`string | ChartTheme`) or a user defined\n  // theme (`AgChartTheme`). In the latter case, we can't make any assumption about the\n  // property types, hence why the input parameter is `unknown`. This abnormal validation\n  // is tech debt; the ideal solution would be to integrate user themes with the @Validate\n  // decorator like other chart options.\n  let value = validateChartTheme(unvalidatedValue);\n  if (value instanceof ChartTheme) {\n    return value;\n  }\n  if (value === undefined || typeof value === 'string') {\n    const stockTheme = themes$1[value];\n    if (stockTheme) {\n      return stockTheme();\n    }\n    Logger.warnOnce(`the theme [${value}] is invalid, using [ag-default] instead.`);\n    return lightTheme();\n  }\n  // Flatten recursive themes.\n  const overrides = [];\n  let palette;\n  while (typeof value === 'object') {\n    overrides.push((_a = value.overrides) !== null && _a !== void 0 ? _a : {});\n    // Use first palette found, they can't be merged.\n    if (value.palette && palette == null) {\n      palette = value.palette;\n    }\n    value = value.baseTheme;\n  }\n  overrides.reverse();\n  const flattenedTheme = Object.assign({\n    baseTheme: value,\n    overrides: jsonMerge(overrides)\n  }, palette ? {\n    palette\n  } : {});\n  const baseTheme = flattenedTheme.baseTheme ? getChartTheme(flattenedTheme.baseTheme) : lightTheme();\n  return new baseTheme.constructor(flattenedTheme);\n}\nfunction takeColours(context, colours, maxCount) {\n  const result = [];\n  for (let count = 0; count < maxCount; count++) {\n    result.push(colours[(count + context.colourIndex) % colours.length]);\n  }\n  return result;\n}\nconst noDataCloneMergeOptions = {\n  avoidDeepClone: ['data']\n};\nfunction getGlobalTooltipPositionOptions(position) {\n  // Note: we do not need to show a warning message if the validation fails. These global tooltip options\n  // are already processed at the root of the chart options. Logging a message here would trigger duplicate\n  // validation warnings.\n  if (position === undefined || typeof position !== 'object' || position === null) {\n    return {};\n  }\n  const {\n    type,\n    xOffset,\n    yOffset\n  } = position;\n  const result = {};\n  const AgTooltipPositionTypeMap = {\n    pointer: true,\n    node: true\n  };\n  const isTooltipPositionType = value => Object.keys(AgTooltipPositionTypeMap).includes(value);\n  if (typeof type === 'string' && isTooltipPositionType(type)) {\n    result.type = type;\n  }\n  if (typeof xOffset === 'number' && !isNaN(xOffset) && isFinite(xOffset)) {\n    result.xOffset = xOffset;\n  }\n  if (typeof yOffset === 'number' && !isNaN(yOffset) && isFinite(yOffset)) {\n    result.yOffset = yOffset;\n  }\n  return result;\n}\nfunction prepareOptions(options) {\n  var _a, _b, _c, _d;\n  sanityCheckOptions(options);\n  // Determine type and ensure it's explicit in the options config.\n  const type = optionsType(options);\n  const globalTooltipPositionOptions = getGlobalTooltipPositionOptions((_a = options.tooltip) === null || _a === void 0 ? void 0 : _a.position);\n  const checkSeriesType = type => {\n    if (type != null && !(isSeriesOptionType(type) || isEnterpriseSeriesType(type) || getSeriesDefaults(type))) {\n      throw new Error(`AG Charts - unknown series type: ${type}; expected one of: ${CHART_TYPES.seriesTypes}`);\n    }\n  };\n  checkSeriesType(type);\n  for (const {\n    type: seriesType\n  } of (_b = options.series) !== null && _b !== void 0 ? _b : []) {\n    if (seriesType == null) continue;\n    checkSeriesType(seriesType);\n  }\n  options = validateSoloSeries(Object.assign(Object.assign({}, options), {\n    type\n  }));\n  let defaultSeriesType = 'line';\n  if (isAgCartesianChartOptions(options)) {\n    defaultSeriesType = 'line';\n  } else if (isAgHierarchyChartOptions(options)) {\n    defaultSeriesType = 'treemap';\n  } else if (isAgPolarChartOptions(options)) {\n    defaultSeriesType = 'pie';\n  }\n  let defaultOverrides = getSeriesDefaults(type);\n  if (isDefaultAxisSwapNeeded(options)) {\n    defaultOverrides = swapAxes(defaultOverrides);\n  }\n  defaultOverrides = executeCustomDefaultsFunctions(options, defaultOverrides);\n  const conflictOverrides = resolveModuleConflicts(options);\n  removeDisabledOptions(options);\n  const {\n    context,\n    mergedOptions,\n    axesThemes,\n    seriesThemes,\n    theme\n  } = prepareMainOptions(defaultOverrides, options, conflictOverrides);\n  // Special cases where we have arrays of elements which need their own defaults.\n  // Apply series themes before calling processSeriesOptions() as it reduces and renames some\n  // properties, and in that case then cannot correctly have themes applied.\n  mergedOptions.series = processSeriesOptions(mergedOptions, ((_c = mergedOptions.series) !== null && _c !== void 0 ? _c : []).map(s => {\n    var _a;\n    const type = (_a = s.type) !== null && _a !== void 0 ? _a : defaultSeriesType;\n    const mergedSeries = mergeSeriesOptions(s, type, seriesThemes, globalTooltipPositionOptions);\n    if (type === 'pie') {\n      preparePieOptions(seriesThemes.pie, s, mergedSeries);\n    }\n    return mergedSeries;\n  })).map(s => prepareSeries(context, s)).map(s => theme.templateTheme(s));\n  const checkAxisType = type => {\n    const isAxisType = isAxisOptionType(type);\n    if (!isAxisType) {\n      Logger.warnOnce(`unknown axis type: ${type}; expected one of: ${AXIS_TYPES.axesTypes}, ignoring.`);\n    }\n    return isAxisType;\n  };\n  if ('axes' in mergedOptions) {\n    let validAxesTypes = true;\n    for (const {\n      type: axisType\n    } of (_d = mergedOptions.axes) !== null && _d !== void 0 ? _d : []) {\n      validAxesTypes && (validAxesTypes = checkAxisType(axisType));\n    }\n    const axisSource = validAxesTypes ? mergedOptions.axes : defaultOverrides.axes;\n    mergedOptions.axes = axisSource === null || axisSource === void 0 ? void 0 : axisSource.map(axis => {\n      var _a, _b, _c, _d, _e;\n      const axisType = axis.type;\n      let axisDefaults;\n      if (validAxesTypes) {\n        axisDefaults = (_a = defaultOverrides.axes) === null || _a === void 0 ? void 0 : _a.find(({\n          type\n        }) => type === axisType);\n      }\n      const axesTheme = jsonMerge([(_b = axesThemes[axisType]) !== null && _b !== void 0 ? _b : {}, (_e = (_c = axesThemes[axisType]) === null || _c === void 0 ? void 0 : _c[(_d = axis.position) !== null && _d !== void 0 ? _d : 'unknown']) !== null && _e !== void 0 ? _e : {}, axisDefaults]);\n      return prepareAxis(axis, axesTheme);\n    });\n    prepareLegendEnabledOption(options, mergedOptions);\n  }\n  prepareEnabledOptions(options, mergedOptions);\n  return mergedOptions;\n}\nfunction sanityCheckOptions(options) {\n  const deprecatedArrayProps = {\n    yKeys: 'yKey',\n    yNames: 'yName'\n  };\n  Object.entries(deprecatedArrayProps).forEach(([oldProp, newProp]) => {\n    var _a;\n    if ((_a = options.series) === null || _a === void 0 ? void 0 : _a.some(s => s[oldProp] != null)) {\n      Logger.warnOnce(`Property [series.${oldProp}] is deprecated, please use [series.${newProp}] and multiple series instead.`);\n    }\n  });\n}\nfunction hasSoloSeries(options) {\n  for (const series of options) {\n    if (isSoloSeries(series.type)) return true;\n  }\n  return false;\n}\nfunction validateSoloSeries(options) {\n  if (options.series === undefined || options.series.length <= 1 || !hasSoloSeries(options.series)) {\n    return options;\n  }\n  // If the first series is a solo-series, remove all trailing series.\n  // If the frist series is not a solo-series, remove all solo-series.\n  let series = [...options.series];\n  if (isSoloSeries(series[0].type)) {\n    Logger.warn(`series[0] of type '${series[0].type}' is incompatible with other series types. Only processing series[0]`);\n    series = series.slice(0, 1);\n  } else {\n    const rejects = Array.from(new Set(series.filter(s => isSoloSeries(s.type)).map(s => s.type)));\n    Logger.warnOnce(`Unable to mix these series types with the lead series type: ${rejects}`);\n    series = series.filter(s => !isSoloSeries(s.type));\n  }\n  return Object.assign(Object.assign({}, options), {\n    series\n  });\n}\nfunction mergeSeriesOptions(series, type, seriesThemes, globalTooltipPositionOptions) {\n  var _a, _b;\n  const mergedTooltipPosition = jsonMerge([Object.assign({}, globalTooltipPositionOptions), (_a = series.tooltip) === null || _a === void 0 ? void 0 : _a.position], noDataCloneMergeOptions);\n  return jsonMerge([(_b = seriesThemes[type]) !== null && _b !== void 0 ? _b : {}, Object.assign(Object.assign({}, series), {\n    type,\n    tooltip: Object.assign(Object.assign({}, series.tooltip), {\n      position: mergedTooltipPosition\n    })\n  })], noDataCloneMergeOptions);\n}\nfunction prepareMainOptions(defaultOverrides, options, conflictOverrides) {\n  const {\n    theme,\n    cleanedTheme,\n    axesThemes,\n    seriesThemes,\n    userPalette\n  } = prepareTheme(options);\n  const context = {\n    colourIndex: 0,\n    palette: theme.palette,\n    userPalette,\n    theme\n  };\n  defaultOverrides = theme.templateTheme(defaultOverrides);\n  const mergedOptions = jsonMerge([defaultOverrides, cleanedTheme, options, conflictOverrides], noDataCloneMergeOptions);\n  if (!enterpriseModule.isEnterprise) {\n    removeUsedEnterpriseOptions(mergedOptions);\n  }\n  return {\n    context,\n    mergedOptions,\n    axesThemes,\n    seriesThemes,\n    theme\n  };\n}\nfunction prepareTheme(options) {\n  var _a;\n  const theme = getChartTheme(options.theme);\n  const themeConfig = theme.config[optionsType(options)];\n  const seriesThemes = Object.entries(theme.config).reduce((result, [seriesType, {\n    series\n  }]) => {\n    result[seriesType] = series;\n    return result;\n  }, {});\n  const userTheme = options.theme;\n  const userPalette = typeof userTheme === 'object' && userTheme.palette ? userTheme.palette : null;\n  return {\n    theme,\n    axesThemes: (_a = themeConfig === null || themeConfig === void 0 ? void 0 : themeConfig['axes']) !== null && _a !== void 0 ? _a : {},\n    seriesThemes: seriesThemes,\n    cleanedTheme: jsonMerge([themeConfig !== null && themeConfig !== void 0 ? themeConfig : {}, {\n      axes: DELETE,\n      series: DELETE\n    }]),\n    userPalette\n  };\n}\nfunction prepareSeries(context, input, ...defaults) {\n  const paletteOptions = calculateSeriesPalette(context, input);\n  // Part of the options interface, but not directly consumed by the series implementations.\n  const removeOptions = {\n    stacked: DELETE,\n    grouped: DELETE\n  };\n  return jsonMerge([...defaults, paletteOptions, input, removeOptions], noDataCloneMergeOptions);\n}\nfunction calculateSeriesPalette(context, input) {\n  const paletteFactory = getSeriesPaletteFactory(input.type);\n  if (!paletteFactory) {\n    return {};\n  }\n  const {\n    palette: {\n      fills,\n      strokes\n    },\n    userPalette,\n    theme\n  } = context;\n  const colorsCount = Math.max(fills.length, strokes.length);\n  return paletteFactory({\n    userPalette,\n    themeTemplateParameters: theme.getTemplateParameters(),\n    colorsCount,\n    takeColors: count => {\n      const colors = {\n        fills: takeColours(context, fills, count),\n        strokes: takeColours(context, strokes, count)\n      };\n      context.colourIndex += count;\n      return colors;\n    }\n  });\n}\nfunction prepareAxis(axis, axisTheme) {\n  // Remove redundant theme overload keys.\n  const removeOptions = {\n    top: DELETE,\n    bottom: DELETE,\n    left: DELETE,\n    right: DELETE\n  };\n  // Special cross lines case where we have an array of cross line elements which need their own defaults.\n  if (axis.crossLines) {\n    if (!Array.isArray(axis.crossLines)) {\n      Logger.warn('axis[].crossLines should be an array.');\n      axis.crossLines = [];\n    }\n    const {\n      crossLines: crossLinesTheme\n    } = axisTheme;\n    axis.crossLines = axis.crossLines.map(crossLine => jsonMerge([crossLinesTheme, crossLine]));\n  }\n  const cleanTheme = {\n    crossLines: DELETE\n  };\n  return jsonMerge([axisTheme, cleanTheme, axis, removeOptions], noDataCloneMergeOptions);\n}\nfunction removeDisabledOptions(options) {\n  // Remove configurations from all option objects with a `false` value for the `enabled` property.\n  jsonWalk(options, (_, visitingUserOpts) => {\n    if (visitingUserOpts.enabled === false) {\n      Object.keys(visitingUserOpts).forEach(key => {\n        if (key === 'enabled') return;\n        delete visitingUserOpts[key];\n      });\n    }\n  }, {\n    skip: ['data', 'theme']\n  });\n}\nfunction prepareLegendEnabledOption(options, mergedOptions) {\n  var _a, _b, _c, _d;\n  // Disable legend by default for single series cartesian charts\n  if (((_a = options.legend) === null || _a === void 0 ? void 0 : _a.enabled) !== undefined || ((_b = mergedOptions.legend) === null || _b === void 0 ? void 0 : _b.enabled) !== undefined) {\n    return;\n  }\n  (_c = mergedOptions.legend) !== null && _c !== void 0 ? _c : mergedOptions.legend = {};\n  if (((_d = options.series) !== null && _d !== void 0 ? _d : []).length > 1) {\n    mergedOptions.legend.enabled = true;\n    return;\n  }\n  mergedOptions.legend.enabled = false;\n}\nfunction prepareEnabledOptions(options, mergedOptions) {\n  // Set `enabled: true` for all option objects where the user has provided values.\n  jsonWalk(options, (_, visitingUserOpts, visitingMergedOpts) => {\n    if (!visitingMergedOpts) return;\n    const {\n      _enabledFromTheme\n    } = visitingMergedOpts;\n    if (_enabledFromTheme != null) {\n      // Do not apply special handling, base enablement on theme.\n      delete visitingMergedOpts._enabledFromTheme;\n    }\n    if (!('enabled' in visitingMergedOpts)) return;\n    if (_enabledFromTheme) return;\n    if (visitingUserOpts.enabled == null) {\n      visitingMergedOpts.enabled = true;\n    }\n  }, {\n    skip: ['data', 'theme']\n  }, mergedOptions);\n  // Cleanup any special properties.\n  jsonWalk(mergedOptions, (_, visitingMergedOpts) => {\n    if (visitingMergedOpts._enabledFromTheme != null) {\n      // Do not apply special handling, base enablement on theme.\n      delete visitingMergedOpts._enabledFromTheme;\n    }\n  }, {\n    skip: ['data', 'theme']\n  });\n}\nfunction preparePieOptions(pieSeriesTheme, seriesOptions, mergedSeries) {\n  if (Array.isArray(seriesOptions.innerLabels)) {\n    mergedSeries.innerLabels = seriesOptions.innerLabels.map(ln => {\n      return jsonMerge([pieSeriesTheme.innerLabels, ln]);\n    });\n  } else {\n    mergedSeries.innerLabels = DELETE;\n  }\n}\nclass PolarChart extends Chart {\n  constructor(specialOverrides, resources) {\n    super(specialOverrides, resources);\n    this.padding = new Padding(40);\n    this.axisGroup.zIndex = Layers.AXIS_FOREGROUND_ZINDEX;\n  }\n  performLayout() {\n    const _super = Object.create(null, {\n      performLayout: {\n        get: () => super.performLayout\n      }\n    });\n    return __awaiter(this, void 0, void 0, function* () {\n      const shrinkRect = yield _super.performLayout.call(this);\n      const fullSeriesRect = shrinkRect.clone();\n      this.computeSeriesRect(shrinkRect);\n      yield this.computeCircle(shrinkRect);\n      this.axes.forEach(axis => axis.update());\n      this.hoverRect = shrinkRect;\n      this.layoutService.dispatchLayoutComplete({\n        type: 'layout-complete',\n        chart: {\n          width: this.scene.width,\n          height: this.scene.height\n        },\n        clipSeries: false,\n        series: {\n          rect: fullSeriesRect,\n          paddedRect: shrinkRect,\n          visible: true\n        },\n        axes: []\n      });\n      return shrinkRect;\n    });\n  }\n  updateAxes(cx, cy, radius) {\n    var _a, _b;\n    const angleAxis = this.axes.find(axis => axis.direction === ChartAxisDirection.X);\n    const radiusAxis = this.axes.find(axis => axis.direction === ChartAxisDirection.Y);\n    if (!(angleAxis instanceof PolarAxis) || !(radiusAxis instanceof PolarAxis)) {\n      return;\n    }\n    const angleScale = angleAxis.scale;\n    const angles = (_a = angleScale.ticks) === null || _a === void 0 ? void 0 : _a.call(angleScale).map(value => angleScale.convert(value));\n    const innerRadiusRatio = radiusAxis.innerRadiusRatio;\n    angleAxis.innerRadiusRatio = innerRadiusRatio;\n    (_b = angleAxis.computeRange) === null || _b === void 0 ? void 0 : _b.call(angleAxis);\n    angleAxis.gridLength = radius;\n    radiusAxis.gridAngles = angles;\n    radiusAxis.gridRange = angleAxis.range;\n    radiusAxis.range = [radius, radius * innerRadiusRatio];\n    [angleAxis, radiusAxis].forEach(axis => {\n      axis.translation.x = cx;\n      axis.translation.y = cy;\n      axis.calculateLayout();\n    });\n  }\n  computeSeriesRect(shrinkRect) {\n    const {\n      seriesArea: {\n        padding\n      }\n    } = this;\n    shrinkRect.shrink(padding.left, 'left');\n    shrinkRect.shrink(padding.top, 'top');\n    shrinkRect.shrink(padding.right, 'right');\n    shrinkRect.shrink(padding.bottom, 'bottom');\n    this.seriesRect = shrinkRect;\n    this.animationRect = shrinkRect;\n  }\n  computeCircle(seriesBox) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const polarSeries = this.series.filter(series => {\n        return series instanceof PolarSeries;\n      });\n      const polarAxes = this.axes.filter(axis => {\n        return axis instanceof PolarAxis;\n      });\n      const setSeriesCircle = (cx, cy, r) => {\n        this.updateAxes(cx, cy, r);\n        polarSeries.forEach(series => {\n          series.centerX = cx;\n          series.centerY = cy;\n          series.radius = r;\n        });\n        const pieSeries = polarSeries.filter(s => s instanceof PieSeries);\n        if (pieSeries.length > 1) {\n          const innerRadii = pieSeries.map(series => {\n            const innerRadius = series.getInnerRadius();\n            return {\n              series,\n              innerRadius\n            };\n          }).sort((a, b) => a.innerRadius - b.innerRadius);\n          innerRadii[innerRadii.length - 1].series.surroundingRadius = undefined;\n          for (let i = 0; i < innerRadii.length - 1; i++) {\n            innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;\n          }\n        }\n      };\n      const centerX = seriesBox.x + seriesBox.width / 2;\n      const centerY = seriesBox.y + seriesBox.height / 2;\n      const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);\n      let radius = initialRadius;\n      setSeriesCircle(centerX, centerY, radius);\n      const shake = ({\n        hideWhenNecessary = false\n      } = {}) => __awaiter(this, void 0, void 0, function* () {\n        const labelBoxes = [];\n        for (const series of [...polarAxes, ...polarSeries]) {\n          const box = yield series.computeLabelsBBox({\n            hideWhenNecessary\n          }, seriesBox);\n          if (box) {\n            labelBoxes.push(box);\n          }\n        }\n        if (labelBoxes.length === 0) {\n          setSeriesCircle(centerX, centerY, initialRadius);\n          return;\n        }\n        const labelBox = BBox.merge(labelBoxes);\n        const refined = this.refineCircle(labelBox, radius, seriesBox);\n        setSeriesCircle(refined.centerX, refined.centerY, refined.radius);\n        if (refined.radius === radius) {\n          return;\n        }\n        radius = refined.radius;\n      });\n      yield shake(); // Initial attempt\n      yield shake(); // Precise attempt\n      yield shake(); // Just in case\n      yield shake({\n        hideWhenNecessary: true\n      }); // Hide unnecessary labels\n      yield shake({\n        hideWhenNecessary: true\n      }); // Final result\n      return {\n        radius,\n        centerX,\n        centerY\n      };\n    });\n  }\n  refineCircle(labelsBox, radius, seriesBox) {\n    const minCircleRatio = 0.5; // Prevents reduced circle to be too small\n    const circleLeft = -radius;\n    const circleTop = -radius;\n    const circleRight = radius;\n    const circleBottom = radius;\n    // Label padding around the circle\n    let padLeft = Math.max(0, circleLeft - labelsBox.x);\n    let padTop = Math.max(0, circleTop - labelsBox.y);\n    let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);\n    let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);\n    padLeft = padRight = Math.max(padLeft, padRight);\n    padTop = padBottom = Math.max(padTop, padBottom);\n    // Available area for the circle (after the padding will be applied)\n    const availCircleWidth = seriesBox.width - padLeft - padRight;\n    const availCircleHeight = seriesBox.height - padTop - padBottom;\n    let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;\n    const minHorizontalRadius = minCircleRatio * seriesBox.width / 2;\n    const minVerticalRadius = minCircleRatio * seriesBox.height / 2;\n    const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);\n    if (newRadius < minRadius) {\n      // If the radius is too small, reduce the label padding\n      newRadius = minRadius;\n      const horizontalPadding = padLeft + padRight;\n      const verticalPadding = padTop + padBottom;\n      if (2 * newRadius + verticalPadding > seriesBox.height) {\n        const padHeight = seriesBox.height - 2 * newRadius;\n        if (Math.min(padTop, padBottom) * 2 > padHeight) {\n          padTop = padHeight / 2;\n          padBottom = padHeight / 2;\n        } else if (padTop > padBottom) {\n          padTop = padHeight - padBottom;\n        } else {\n          padBottom = padHeight - padTop;\n        }\n      }\n      if (2 * newRadius + horizontalPadding > seriesBox.width) {\n        const padWidth = seriesBox.width - 2 * newRadius;\n        if (Math.min(padLeft, padRight) * 2 > padWidth) {\n          padLeft = padWidth / 2;\n          padRight = padWidth / 2;\n        } else if (padLeft > padRight) {\n          padLeft = padWidth - padRight;\n        } else {\n          padRight = padWidth - padLeft;\n        }\n      }\n    }\n    const newWidth = padLeft + 2 * newRadius + padRight;\n    const newHeight = padTop + 2 * newRadius + padBottom;\n    return {\n      centerX: seriesBox.x + (seriesBox.width - newWidth) / 2 + padLeft + newRadius,\n      centerY: seriesBox.y + (seriesBox.height - newHeight) / 2 + padTop + newRadius,\n      radius: newRadius\n    };\n  }\n}\nPolarChart.className = 'PolarChart';\nPolarChart.type = 'polar';\nconst debug = Debug.create(true, 'opts');\nfunction chartType(options) {\n  if (isAgCartesianChartOptions(options)) {\n    return 'cartesian';\n  } else if (isAgPolarChartOptions(options)) {\n    return 'polar';\n  } else if (isAgHierarchyChartOptions(options)) {\n    return 'hierarchy';\n  }\n  throw new Error(`AG Chart - unknown type of chart for options with type: ${options.type}`);\n}\n/**\r\n * Factory for creating and updating instances of AgChartInstance.\r\n *\r\n * @docsInterface\r\n */\nclass AgCharts {\n  static licenseCheck(options) {\n    var _a, _b, _c;\n    if (this.licenseChecked) return;\n    this.licenseManager = (_a = enterpriseModule.licenseManager) === null || _a === void 0 ? void 0 : _a.call(enterpriseModule, options);\n    (_b = this.licenseManager) === null || _b === void 0 ? void 0 : _b.setLicenseKey(this.licenseKey);\n    (_c = this.licenseManager) === null || _c === void 0 ? void 0 : _c.validateLicense();\n    this.licenseChecked = true;\n  }\n  static setLicenseKey(licenseKey) {\n    this.licenseKey = licenseKey;\n  }\n  /**\r\n   * Create a new `AgChartInstance` based upon the given configuration options.\r\n   */\n  static create(options) {\n    var _a, _b, _c;\n    this.licenseCheck(options);\n    const chart = AgChartsInternal.createOrUpdate(options);\n    if ((_a = this.licenseManager) === null || _a === void 0 ? void 0 : _a.isDisplayWatermark()) {\n      (_b = enterpriseModule.injectWatermark) === null || _b === void 0 ? void 0 : _b.call(enterpriseModule, (_c = options.document) !== null && _c !== void 0 ? _c : document, chart.chart.element, this.licenseManager.getWatermarkMessage());\n    }\n    return chart;\n  }\n  /**\r\n   * Update an existing `AgChartInstance`. Options provided should be complete and not\r\n   * partial.\r\n   *\r\n   * __NOTE__: As each call could trigger a chart redraw, multiple calls to update options in\r\n   * quick succession could result in undesirable flickering, so callers should batch up and/or\r\n   * debounce changes to avoid unintended partial update renderings.\r\n   */\n  static update(chart, options) {\n    if (!AgChartInstanceProxy.isInstance(chart)) {\n      throw new Error(AgCharts.INVALID_CHART_REF_MESSAGE);\n    }\n    AgChartsInternal.createOrUpdate(options, chart);\n  }\n  /**\r\n   * Update an existing `AgChartInstance` by applying a partial set of option changes.\r\n   *\r\n   * __NOTE__: As each call could trigger a chart redraw, each individual delta options update\r\n   * should leave the chart in a valid options state. Also, multiple calls to update options in\r\n   * quick succession could result in undesirable flickering, so callers should batch up and/or\r\n   * debounce changes to avoid unintended partial update renderings.\r\n   */\n  static updateDelta(chart, deltaOptions) {\n    if (!AgChartInstanceProxy.isInstance(chart)) {\n      throw new Error(AgCharts.INVALID_CHART_REF_MESSAGE);\n    }\n    AgChartsInternal.updateUserDelta(chart, deltaOptions);\n  }\n  /**\r\n   * Starts a browser-based image download for the given `AgChartInstance`.\r\n   */\n  static download(chart, options) {\n    if (!(chart instanceof AgChartInstanceProxy)) {\n      throw new Error(AgCharts.INVALID_CHART_REF_MESSAGE);\n    }\n    AgChartsInternal.download(chart, options);\n  }\n  /**\r\n   * Returns a base64-encoded image data URL for the given `AgChartInstance`.\r\n   */\n  static getImageDataURL(chart, options) {\n    if (!(chart instanceof AgChartInstanceProxy)) {\n      throw new Error(AgCharts.INVALID_CHART_REF_MESSAGE);\n    }\n    return AgChartsInternal.getImageDataURL(chart, options);\n  }\n}\nAgCharts.INVALID_CHART_REF_MESSAGE = 'AG Charts - invalid chart reference passed';\nAgCharts.licenseChecked = false;\n/** @deprecated use AgCharts instead */\nclass AgChart {\n  static warnDeprecated(memberName) {\n    const warnDeprecated = createDeprecationWarning();\n    warnDeprecated(`AgChart.${memberName}`, `Use AgCharts.${memberName} instead`);\n  }\n  static create(options) {\n    AgChart.warnDeprecated('create');\n    return AgCharts.create(options);\n  }\n  static update(chart, options) {\n    AgChart.warnDeprecated('update');\n    return AgCharts.update(chart, options);\n  }\n  static updateDelta(chart, deltaOptions) {\n    AgChart.warnDeprecated('updateDelta');\n    return AgCharts.updateDelta(chart, deltaOptions);\n  }\n  static download(chart, options) {\n    AgChart.warnDeprecated('download');\n    return AgCharts.download(chart, options);\n  }\n  static getImageDataURL(chart, options) {\n    AgChart.warnDeprecated('getImageDataURL');\n    return AgCharts.getImageDataURL(chart, options);\n  }\n}\nclass AgChartsInternal {\n  static initialiseModules() {\n    if (AgChartsInternal.initialised) return;\n    registerInbuiltModules();\n    setupModules();\n    AgChartsInternal.initialised = true;\n  }\n  static createOrUpdate(userOptions, proxy) {\n    var _a;\n    var _b;\n    AgChartsInternal.initialiseModules();\n    debug('>>> AgChartV2.createOrUpdate() user options', userOptions);\n    const {\n        overrideDevicePixelRatio,\n        document,\n        window: userWindow\n      } = userOptions,\n      chartOptions = __rest(userOptions, [\"overrideDevicePixelRatio\", \"document\", \"window\"]);\n    const specialOverrides = {\n      overrideDevicePixelRatio,\n      document,\n      window: userWindow\n    };\n    const processedOptions = prepareOptions(chartOptions);\n    let chart = proxy === null || proxy === void 0 ? void 0 : proxy.chart;\n    if (chart == null || chartType(chartOptions) !== chartType(chart.processedOptions)) {\n      chart = AgChartsInternal.createChartInstance(processedOptions, specialOverrides, chart);\n    }\n    if (proxy == null) {\n      proxy = new AgChartInstanceProxy(chart);\n    } else {\n      proxy.chart = chart;\n    }\n    if (Debug.check() && typeof window !== 'undefined') {\n      (_a = (_b = window).agChartInstances) !== null && _a !== void 0 ? _a : _b.agChartInstances = {};\n      window.agChartInstances[chart.id] = chart;\n    }\n    const chartToUpdate = chart;\n    chartToUpdate.queuedUserOptions.push(chartOptions);\n    const dequeue = () => {\n      // If there are a lot of update calls, `requestFactoryUpdate()` may skip callbacks,\n      // so we need to remove all queue items up to the last successfully applied item.\n      const queuedOptionsIdx = chartToUpdate.queuedUserOptions.indexOf(chartOptions);\n      chartToUpdate.queuedUserOptions.splice(0, queuedOptionsIdx);\n    };\n    chartToUpdate.requestFactoryUpdate(() => __awaiter(this, void 0, void 0, function* () {\n      // Chart destroyed, skip processing.\n      if (chartToUpdate.destroyed) return;\n      const deltaOptions = jsonDiff(chartToUpdate.processedOptions, processedOptions);\n      if (deltaOptions == null) {\n        dequeue();\n        return;\n      }\n      yield AgChartsInternal.updateDelta(chartToUpdate, deltaOptions, chartOptions);\n      dequeue();\n    }));\n    return proxy;\n  }\n  static updateUserDelta(proxy, deltaOptions) {\n    var _a;\n    const {\n      chart,\n      chart: {\n        queuedUserOptions\n      }\n    } = proxy;\n    const lastUpdateOptions = (_a = queuedUserOptions[queuedUserOptions.length - 1]) !== null && _a !== void 0 ? _a : chart.userOptions;\n    const userOptions = jsonMerge([lastUpdateOptions, deltaOptions]);\n    debug('>>> AgChartV2.updateUserDelta() user delta', deltaOptions);\n    debug('AgChartV2.updateUserDelta() - base options', lastUpdateOptions);\n    AgChartsInternal.createOrUpdate(userOptions, proxy);\n  }\n  /**\r\n   * Returns the content of the current canvas as an image.\r\n   * @param opts The download options including `width` and `height` of the image as well as `fileName` and `fileFormat`.\r\n   */\n  static download(proxy, opts) {\n    const asyncDownload = () => __awaiter(this, void 0, void 0, function* () {\n      const maybeClone = yield AgChartsInternal.prepareResizedChart(proxy, opts);\n      const {\n        chart\n      } = maybeClone;\n      chart.scene.download(opts === null || opts === void 0 ? void 0 : opts.fileName, opts === null || opts === void 0 ? void 0 : opts.fileFormat);\n      if (maybeClone !== proxy) {\n        maybeClone.destroy();\n      }\n    });\n    asyncDownload().catch(e => Logger.errorOnce(e));\n  }\n  static getImageDataURL(proxy, opts) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const maybeClone = yield AgChartsInternal.prepareResizedChart(proxy, opts);\n      const {\n        chart\n      } = maybeClone;\n      const result = chart.scene.canvas.getDataURL(opts === null || opts === void 0 ? void 0 : opts.fileFormat);\n      if (maybeClone !== proxy) {\n        maybeClone.destroy();\n      }\n      return result;\n    });\n  }\n  static prepareResizedChart(proxy, opts) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const {\n        chart\n      } = proxy;\n      let {\n        width,\n        height\n      } = opts !== null && opts !== void 0 ? opts : {};\n      const currentWidth = chart.width;\n      const currentHeight = chart.height;\n      const unchanged = width === undefined && height === undefined || chart.scene.canvas.pixelRatio === 1 && currentWidth === width && currentHeight === height;\n      if (unchanged) {\n        return proxy;\n      }\n      width !== null && width !== void 0 ? width : width = currentWidth;\n      height !== null && height !== void 0 ? height : height = currentHeight;\n      const options = Object.assign(Object.assign({}, chart.userOptions), {\n        container: document.createElement('div'),\n        width,\n        height,\n        autoSize: false,\n        overrideDevicePixelRatio: 1\n      });\n      if (hasRegisteredEnterpriseModules()) {\n        // Disable enterprise features that may interfere with image generation.\n        (_a = options.animation) !== null && _a !== void 0 ? _a : options.animation = {};\n        options.animation.enabled = false;\n      }\n      const clonedChart = AgChartsInternal.createOrUpdate(options);\n      yield clonedChart.chart.waitForUpdate();\n      return clonedChart;\n    });\n  }\n  static createChartInstance(options, specialOverrides, oldChart) {\n    const transferableResource = oldChart === null || oldChart === void 0 ? void 0 : oldChart.destroy({\n      keepTransferableResources: true\n    });\n    if (isAgCartesianChartOptions(options)) {\n      return new CartesianChart(specialOverrides, transferableResource);\n    } else if (isAgHierarchyChartOptions(options)) {\n      return new HierarchyChart(specialOverrides, transferableResource);\n    } else if (isAgPolarChartOptions(options)) {\n      return new PolarChart(specialOverrides, transferableResource);\n    }\n    throw new Error(`AG Charts - couldn't apply configuration, check options are correctly structured and series types are specified`);\n  }\n  static updateDelta(chart, processedOptions, userOptions) {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      if (processedOptions.type == null) {\n        processedOptions = Object.assign(Object.assign({}, processedOptions), {\n          type: (_a = chart.processedOptions.type) !== null && _a !== void 0 ? _a : optionsType(processedOptions)\n        });\n      }\n      if (chart.destroyed) return;\n      debug('AgChartV2.updateDelta() - applying delta', processedOptions);\n      applyChartOptions(chart, processedOptions, userOptions);\n    });\n  }\n}\nAgChartsInternal.initialised = false;\nfunction applyChartOptions(chart, processedOptions, userOptions) {\n  var _a, _b, _c, _d;\n  const completeOptions = jsonMerge([(_a = chart.processedOptions) !== null && _a !== void 0 ? _a : {}, processedOptions], noDataCloneMergeOptions);\n  const modulesChanged = applyModules(chart, completeOptions);\n  const skip = ['type', 'data', 'series', 'listeners', 'theme', 'legend.listeners'];\n  if (isAgCartesianChartOptions(processedOptions) || isAgPolarChartOptions(processedOptions)) {\n    // Append axes to defaults.\n    skip.push('axes');\n  } else if (isAgHierarchyChartOptions(processedOptions)) ;else {\n    throw new Error(`AG Charts - couldn't apply configuration, check type of options and chart: ${processedOptions['type']}`);\n  }\n  // Needs to be done before applying the series to detect if a seriesNode[Double]Click listener has been added\n  if (processedOptions.listeners) {\n    registerListeners(chart, processedOptions.listeners);\n  }\n  applyOptionValues(chart, processedOptions, {\n    skip\n  });\n  let forceNodeDataRefresh = false;\n  let seriesRecreated = false;\n  if (processedOptions.series && processedOptions.series.length > 0) {\n    seriesRecreated = applySeries(chart, processedOptions);\n    forceNodeDataRefresh = true;\n  }\n  if ('axes' in completeOptions && Array.isArray(completeOptions.axes)) {\n    const axesPresent = applyAxes(chart, completeOptions, seriesRecreated);\n    if (axesPresent) {\n      forceNodeDataRefresh = true;\n    }\n  }\n  const seriesOpts = processedOptions.series;\n  const seriesDataUpdate = !!processedOptions.data || (seriesOpts === null || seriesOpts === void 0 ? void 0 : seriesOpts.some(s => s.data != null));\n  const legendKeys = getLegendKeys();\n  const optionsHaveLegend = Object.values(legendKeys).some(legendKey => processedOptions[legendKey] != null);\n  const otherRefreshUpdate = processedOptions.title != null && processedOptions.subtitle != null;\n  forceNodeDataRefresh = forceNodeDataRefresh || seriesDataUpdate || optionsHaveLegend || otherRefreshUpdate;\n  if (processedOptions.data) {\n    chart.data = processedOptions.data;\n  }\n  if ((_b = processedOptions.legend) === null || _b === void 0 ? void 0 : _b.listeners) {\n    Object.assign(chart.legend.listeners, (_c = processedOptions.legend.listeners) !== null && _c !== void 0 ? _c : {});\n  }\n  if (processedOptions.listeners) {\n    chart.updateAllSeriesListeners();\n  }\n  chart.processedOptions = completeOptions;\n  chart.userOptions = jsonMerge([(_d = chart.userOptions) !== null && _d !== void 0 ? _d : {}, userOptions], noDataCloneMergeOptions);\n  const majorChange = forceNodeDataRefresh || modulesChanged;\n  const updateType = majorChange ? ChartUpdateType.PROCESS_DATA : ChartUpdateType.PERFORM_LAYOUT;\n  debug('AgChartV2.applyChartOptions() - update type', ChartUpdateType[updateType]);\n  chart.update(updateType, {\n    forceNodeDataRefresh,\n    newAnimationBatch: true\n  });\n}\nfunction applyModules(chart, options) {\n  const matchingChartType = module => {\n    return chart instanceof CartesianChart && module.chartTypes.includes('cartesian') || chart instanceof PolarChart && module.chartTypes.includes('polar') || chart instanceof HierarchyChart && module.chartTypes.includes('hierarchy');\n  };\n  let modulesChanged = false;\n  const processModules = (moduleType, add, remove) => {\n    const modules = REGISTERED_MODULES.filter(m => m.type === moduleType);\n    for (const next of modules) {\n      const shouldBeEnabled = matchingChartType(next) && options[next.optionsKey] != null;\n      const isEnabled = chart.isModuleEnabled(next);\n      if (shouldBeEnabled === isEnabled) continue;\n      modulesChanged = true;\n      if (shouldBeEnabled) {\n        add(next);\n      } else {\n        remove(next);\n      }\n    }\n  };\n  processModules('root', next => chart.addModule(next), next => chart.removeModule(next));\n  processModules('legend', next => chart.addLegendModule(next), next => chart.removeLegendModule(next));\n  return modulesChanged;\n}\nfunction applySeries(chart, options) {\n  const optSeries = options.series;\n  if (!optSeries) {\n    return false;\n  }\n  const keysToConsider = ['type', 'direction', 'xKey', 'yKey', 'sizeKey', 'angleKey', 'stacked', 'stackGroup'];\n  let matchingTypes = chart.series.length === optSeries.length;\n  for (let i = 0; i < chart.series.length && matchingTypes; i++) {\n    for (const key of keysToConsider) {\n      matchingTypes && (matchingTypes = chart.series[i][key] === optSeries[i][key]);\n    }\n  }\n  // Try to optimise series updates if series count and types didn't change.\n  if (matchingTypes) {\n    chart.series.forEach((s, i) => {\n      var _a, _b, _c, _d;\n      const previousOpts = (_c = (_b = (_a = chart.processedOptions) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b[i]) !== null && _c !== void 0 ? _c : {};\n      const seriesDiff = jsonDiff(previousOpts, (_d = optSeries[i]) !== null && _d !== void 0 ? _d : {});\n      if (!seriesDiff) {\n        return;\n      }\n      debug(`AgChartV2.applySeries() - applying series diff idx ${i}`, seriesDiff);\n      applySeriesValues(s, seriesDiff, {\n        path: `series[${i}]`,\n        index: i\n      });\n      s.markNodeDataDirty();\n    });\n    return false;\n  }\n  debug(`AgChartV2.applySeries() - creating new series instances`);\n  chart.series = createSeries(chart, optSeries);\n  return true;\n}\nfunction applyAxes(chart, options, forceRecreate) {\n  const optAxes = options.axes;\n  if (!optAxes) {\n    return false;\n  }\n  const matchingTypes = !forceRecreate && chart.axes.length === optAxes.length && chart.axes.every((a, i) => a.type === optAxes[i].type);\n  // Try to optimise series updates if series count and types didn't change.\n  if (matchingTypes) {\n    const oldOpts = chart.processedOptions;\n    if (isAgCartesianChartOptions(oldOpts)) {\n      chart.axes.forEach((a, i) => {\n        var _a, _b;\n        const previousOpts = (_b = (_a = oldOpts.axes) === null || _a === void 0 ? void 0 : _a[i]) !== null && _b !== void 0 ? _b : {};\n        const axisDiff = jsonDiff(previousOpts, optAxes[i]);\n        debug(`AgChartV2.applyAxes() - applying axis diff idx ${i}`, axisDiff);\n        const path = `axes[${i}]`;\n        const skip = ['axes[].type'];\n        applyOptionValues(a, axisDiff, {\n          path,\n          skip\n        });\n      });\n      return true;\n    }\n  }\n  chart.axes = createAxis(chart, optAxes);\n  return true;\n}\nfunction createSeries(chart, options) {\n  var _a;\n  const series = [];\n  const moduleContext = chart.getModuleContext();\n  let index = 0;\n  for (const seriesOptions of options !== null && options !== void 0 ? options : []) {\n    const path = `series[${index++}]`;\n    const type = (_a = seriesOptions.type) !== null && _a !== void 0 ? _a : 'unknown';\n    if (isEnterpriseSeriesType(type) && !isEnterpriseSeriesTypeLoaded(type)) {\n      continue;\n    }\n    const seriesInstance = getSeries(type, moduleContext);\n    applySeriesOptionModules(seriesInstance, seriesOptions);\n    applySeriesValues(seriesInstance, seriesOptions, {\n      path,\n      index\n    });\n    series.push(seriesInstance);\n  }\n  return series;\n}\nfunction applySeriesOptionModules(series, options) {\n  const seriesOptionModules = REGISTERED_MODULES.filter(m => m.type === 'series-option');\n  for (const mod of seriesOptionModules) {\n    const supportedSeriesTypes = mod.seriesTypes;\n    if (mod.optionsKey in options && supportedSeriesTypes.includes(series.type)) {\n      series.getModuleMap().addModule(mod);\n    }\n  }\n}\nfunction createAxis(chart, options) {\n  const axes = [];\n  const skip = ['axes[].type'];\n  const moduleContext = chart.getModuleContext();\n  let index = 0;\n  for (const axisOptions of options !== null && options !== void 0 ? options : []) {\n    const axis = getAxis(axisOptions.type, moduleContext);\n    const path = `axes[${index++}]`;\n    applyAxisModules(axis, axisOptions);\n    applyOptionValues(axis, axisOptions, {\n      path,\n      skip\n    });\n    axes.push(axis);\n  }\n  return axes;\n}\nfunction applyAxisModules(axis, options) {\n  let modulesChanged = false;\n  const rootModules = REGISTERED_MODULES.filter(m => m.type === 'axis-option');\n  for (const next of rootModules) {\n    const shouldBeEnabled = options[next.optionsKey] != null;\n    const moduleMap = axis.getModuleMap();\n    const isEnabled = moduleMap.isModuleEnabled(next);\n    if (shouldBeEnabled === isEnabled) continue;\n    modulesChanged = true;\n    if (shouldBeEnabled) {\n      moduleMap.addModule(next);\n    } else {\n      moduleMap.removeModule(next);\n    }\n  }\n  return modulesChanged;\n}\nfunction registerListeners(source, listeners) {\n  source.clearEventListeners();\n  const entries = Object.entries(listeners !== null && listeners !== void 0 ? listeners : {});\n  for (const [property, listener] of entries) {\n    if (typeof listener !== 'function') continue;\n    source.addEventListener(property, listener);\n  }\n}\nfunction applyOptionValues(target, options, {\n  skip,\n  path\n} = {}) {\n  const applyOpts = Object.assign(Object.assign(Object.assign({}, getJsonApplyOptions()), {\n    skip\n  }), path ? {\n    path\n  } : {});\n  return jsonApply(target, options, applyOpts);\n}\nfunction applySeriesValues(target, options, {\n  path,\n  index\n} = {}) {\n  var _a, _b;\n  const skip = ['series[].listeners', 'series[].seriesGrouping'];\n  const jsonApplyOptions = getJsonApplyOptions();\n  const ctrs = (_a = jsonApplyOptions.constructors) !== null && _a !== void 0 ? _a : {};\n  const seriesTypeOverrides = {\n    constructors: Object.assign(Object.assign({}, ctrs), {\n      title: target.type === 'pie' ? PieTitle : ctrs['title']\n    })\n  };\n  const applyOpts = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, jsonApplyOptions), seriesTypeOverrides), {\n    skip: ['series[].type', ...(skip !== null && skip !== void 0 ? skip : [])]\n  }), path ? {\n    path\n  } : {}), {\n    idx: index !== null && index !== void 0 ? index : -1\n  });\n  const result = jsonApply(target, options, applyOpts);\n  if ((options === null || options === void 0 ? void 0 : options.listeners) != null) {\n    registerListeners(target, options.listeners);\n  }\n  const {\n    seriesGrouping\n  } = options;\n  if ('seriesGrouping' in (options !== null && options !== void 0 ? options : {})) {\n    if (seriesGrouping) {\n      target.seriesGrouping = Object.freeze(Object.assign(Object.assign({}, (_b = target.seriesGrouping) !== null && _b !== void 0 ? _b : {}), seriesGrouping));\n    } else {\n      target.seriesGrouping = seriesGrouping;\n    }\n  }\n  return result;\n}\n\n// DO NOT UPDATE MANUALLY: Generated from script during build time\nconst VERSION = '9.0.1';\nconst themes = Object.entries(themes$1).reduce((obj, [name, factory]) => {\n  obj[name] = factory();\n  return obj;\n}, {});\nvar integratedChartsTheme = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  themes: themes,\n  getChartTheme: getChartTheme,\n  ChartTheme: ChartTheme,\n  EXTENDS_CHART_DEFAULTS: EXTENDS_CHART_DEFAULTS,\n  EXTENDS_LEGEND_DEFAULTS: EXTENDS_LEGEND_DEFAULTS,\n  EXTENDS_LEGEND_ITEM_DEFAULTS: EXTENDS_LEGEND_ITEM_DEFAULTS,\n  EXTENDS_LEGEND_ITEM_MARKER_DEFAULTS: EXTENDS_LEGEND_ITEM_MARKER_DEFAULTS,\n  EXTENDS_AXES_DEFAULTS: EXTENDS_AXES_DEFAULTS,\n  EXTENDS_AXES_LABEL_DEFAULTS: EXTENDS_AXES_LABEL_DEFAULTS,\n  EXTENDS_AXES_LINE_DEFAULTS: EXTENDS_AXES_LINE_DEFAULTS,\n  EXTENDS_AXES_TICK_DEFAULTS: EXTENDS_AXES_TICK_DEFAULTS,\n  EXTENDS_AXES_GRID_LINE_DEFAULTS: EXTENDS_AXES_GRID_LINE_DEFAULTS,\n  EXTENDS_SERIES_DEFAULTS: EXTENDS_SERIES_DEFAULTS,\n  EXTENDS_CARTESIAN_MARKER_DEFAULTS: EXTENDS_CARTESIAN_MARKER_DEFAULTS,\n  OVERRIDE_SERIES_LABEL_DEFAULTS: OVERRIDE_SERIES_LABEL_DEFAULTS,\n  DEFAULT_FONT_FAMILY: DEFAULT_FONT_FAMILY,\n  DEFAULT_LABEL_COLOUR: DEFAULT_LABEL_COLOUR,\n  DEFAULT_INVERTED_LABEL_COLOUR: DEFAULT_INVERTED_LABEL_COLOUR,\n  DEFAULT_INSIDE_SERIES_LABEL_COLOUR: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n  DEFAULT_MUTED_LABEL_COLOUR: DEFAULT_MUTED_LABEL_COLOUR,\n  DEFAULT_AXIS_GRID_COLOUR: DEFAULT_AXIS_GRID_COLOUR,\n  DEFAULT_AXIS_LINE_COLOUR: DEFAULT_AXIS_LINE_COLOUR,\n  DEFAULT_CROSS_LINES_COLOUR: DEFAULT_CROSS_LINES_COLOUR,\n  DEFAULT_BACKGROUND_COLOUR: DEFAULT_BACKGROUND_COLOUR,\n  DEFAULT_SHADOW_COLOUR: DEFAULT_SHADOW_COLOUR,\n  DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS: DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,\n  DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS: DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,\n  DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS: DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,\n  DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE: DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,\n  DEFAULT_POLAR_SERIES_STROKE: DEFAULT_POLAR_SERIES_STROKE,\n  DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: DEFAULT_DIVERGING_SERIES_COLOUR_RANGE,\n  DEFAULT_HIERARCHY_FILLS: DEFAULT_HIERARCHY_FILLS,\n  DEFAULT_HIERARCHY_STROKES: DEFAULT_HIERARCHY_STROKES,\n  FONT_SIZE: FONT_SIZE,\n  BOLD: BOLD,\n  NORMAL: NORMAL,\n  BOTTOM: BOTTOM,\n  CARTESIAN_AXIS_POSITIONS: CARTESIAN_AXIS_POSITIONS,\n  CARTESIAN_AXIS_TYPES: CARTESIAN_AXIS_TYPES,\n  POLAR_AXIS_TYPES: POLAR_AXIS_TYPES,\n  CIRCLE: CIRCLE\n});\nvar sparklinesScale = /*#__PURE__*/Object.freeze({\n  __proto__: null,\n  TimeScale: TimeScale,\n  BandScale: BandScale,\n  ContinuousScale: ContinuousScale,\n  ColorScale: ColorScale,\n  LinearScale: LinearScale\n});\nexport { AgChart, AgCharts, AgErrorBarSupportedSeriesTypes, Marker, VERSION, moduleSupport as _ModuleSupport, sparklinesScale as _Scale, integratedChartsScene as _Scene, integratedChartsTheme as _Theme, sparklinesUtil as _Util, __FORCE_MODULE_DETECTION$1 as __FORCE_MODULE_DETECTION, index as time };","map":{"version":3,"names":["AgErrorBarSupportedSeriesTypes","__FORCE_MODULE_DETECTION$1","TimeInterval","constructor","_encode","_decode","_rangeCallback","floor","date","d","Date","e","ceil","Number","range","start","stop","extend","_a","rangeCallback","call","e0","e1","push","CountableTimeInterval","getOffset","snapTo","step","s","Math","every","options","offset","initialOffset","encode","decode","encoded","encode$b","getTime","decode$b","millisecond","getFullYear","durationSecond","durationMinute","durationHour","durationDay","durationWeek","durationMonth","durationYear","offset$2","getTimezoneOffset","encode$a","decode$a","second","offset$1","encode$9","decode$9","minute","encode$8","decode$8","hour","encode$7","tzOffsetMs","decode$7","setDate","getDate","day","weekday","n","base","dateMs","sunday","monday","tuesday","wednesday","thursday","friday","saturday","encode$6","getMonth","decode$6","year","month","encode$5","decode$5","setFullYear","setMonth","setHours","encode$4","decode$4","utcMinute","encode$3","decode$3","utcHour","encode$2","decode$2","setUTCDate","getUTCDate","setUTCHours","utcDay","encode$1","getUTCFullYear","getUTCMonth","decode$1","UTC","utcMonth","setUTCFullYear","setUTCMonth","utcYear","index","Object","freeze","__proto__","__rest","t","p","prototype","hasOwnProperty","indexOf","getOwnPropertySymbols","i","length","propertyIsEnumerable","__decorate","decorators","target","key","desc","c","arguments","r","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__metadata","metadataKey","metadataValue","metadata","__awaiter","thisArg","_arguments","P","generator","adopt","value","resolve","Promise","reject","fulfilled","next","rejected","result","done","then","apply","SuppressedError","error","suppressed","message","Error","name","enterpriseModule","isEnterprise","BaseModuleInstance","destroyFns","destroy","destroyFn","REGISTERED_MODULES","registerModule","module","otherModule","find","other","type","optionsKey","identifier","packageType","splice","hasRegisteredEnterpriseModules","some","m","MODULE_CONFLICTS","Map","registerModuleConflicts","source","targets","set","extent","values","undefined","min","Infinity","max","v","isFinite","normalisedExtent","normalisedExtentWithMetadata","clipped","NaN","isNaN","arraysEqual","a","b","Array","isArray","toArray","doOnceFlags","doOnce","func","Logger","log","logContent","console","warn","table","warnOnce","errorOnce","windowValue","WINDOW","window","LONG_TIME_PERIOD_THRESHOLD","timeOfLastLog","now","logTimeGap","timeSinceLastLog","prettyDuration","toFixed","Debug","create","debugSelectors","check","chartDebug","selector","includes","BREAK_TRANSFORM_CHAIN","Symbol","CONFIG_KEY","initialiseConfig","propertyKeyOrSymbol","propertyKey","valueStoreKey","config","setters","getters","descriptor","prevSet","prevGet","get","getter","_b","transformFn","setter","oldValue","f","enumerable","configurable","addTransformToInstanceProperty","setTransform","getTransform","toString","unshift","isDecoratedObject","listDecoratedProperties","Set","add","getPrototypeOf","from","flatMap","configMap","keys","extractDecoratedProperties","reduce","createDeprecationWarning","msg","filter","join","CLASS_INSTANCE_TYPE","jsonDiff","sourceType","classify","targetType","targetArray","targetElement","assign","lhs","rhs","allProps","propsChangedCount","prop","take","lhsType","rhsType","diff","DELETE","NOT_SPECIFIED","jsonMerge","json","opts","avoidDeepClone","jsonTypes","map","finalValue","props","concat","nextProp","j","lastValue","types","jsonApply","params","_c","path","matcherPath","replace","skip","constructors","constructedArrays","WeakMap","allowedTypes","idx","targetAny","property","propertyMatcherPath","newValue","propertyPath","targetClass","currentValue","ctr","currentValueType","newValueType","allowableTypes","newValueArray","jsonWalk","visit","jsons","jsonType","forEach","element","o","otherValues","valueType","isBrowser","HTMLElement","twoPi","PI","normalizeAngle360","radians","normalizeAngle360Inclusive","normalizeAngle180","toRadians","degrees","toDegrees","angleBetween","angle0","angle1","clamp$1","x","BandScale","cache","cacheProps","ordinalRange","_domain","_bandwidth","_rawBandwidth","_paddingInner","_paddingOuter","round","didChange","refresh","update","domain","ticks","interval","abs","_","convert","invert","position","findIndex","bandwidth","rawBandwidth","padding","paddingInner","paddingOuter","count","r0","r1","width","rawStep","fullBandWidth","x0","bw","clamp","isEqual","epsilon","isNegative","sign","is","round$1","decimals","pow","fractionOrSignificantDigits","power","LN10","mod","Color","g","validColorString","str","parseHex","stringToRgba","nameToHex","toLowerCase","fromString","fromHexString","hex","fromRgbaString","tryParseFromString","fromArray","input","slice","parts","parseInt","split","po","pc","contents","substring","rgba","part","parseFloat","arr","fromHSB","h","alpha","rgb","HSBtoRGB","fromHSL","l","HSLtoRGB","padHex","toHexString","toRgbaString","fractionDigits","components","k","toHSB","RGBtoHSB","RGBtoHSL","delta","q","hueToRgb","S","H","rc","gc","bc","B","derive","hueShift","saturationFactor","brightnessFactor","opacityFactor","hsb","brighter","darker","interpolate","color","c0","c1","y","aliceblue","antiquewhite","aqua","aquamarine","azure","beige","bisque","black","blanchedalmond","blue","blueviolet","brown","burlywood","cadetblue","chartreuse","chocolate","coral","cornflowerblue","cornsilk","crimson","cyan","darkblue","darkcyan","darkgoldenrod","darkgray","darkgreen","darkgrey","darkkhaki","darkmagenta","darkolivegreen","darkorange","darkorchid","darkred","darksalmon","darkseagreen","darkslateblue","darkslategray","darkslategrey","darkturquoise","darkviolet","deeppink","deepskyblue","dimgray","dimgrey","dodgerblue","firebrick","floralwhite","forestgreen","fuchsia","gainsboro","ghostwhite","gold","goldenrod","gray","green","greenyellow","grey","honeydew","hotpink","indianred","indigo","ivory","khaki","lavender","lavenderblush","lawngreen","lemonchiffon","lightblue","lightcoral","lightcyan","lightgoldenrodyellow","lightgray","lightgreen","lightgrey","lightpink","lightsalmon","lightseagreen","lightskyblue","lightslategray","lightslategrey","lightsteelblue","lightyellow","lime","limegreen","linen","magenta","maroon","mediumaquamarine","mediumblue","mediumorchid","mediumpurple","mediumseagreen","mediumslateblue","mediumspringgreen","mediumturquoise","mediumvioletred","midnightblue","mintcream","mistyrose","moccasin","navajowhite","navy","oldlace","olive","olivedrab","orange","orangered","orchid","palegoldenrod","palegreen","paleturquoise","palevioletred","papayawhip","peachpuff","peru","pink","plum","powderblue","purple","rebeccapurple","red","rosybrown","royalblue","saddlebrown","salmon","sandybrown","seagreen","seashell","sienna","silver","skyblue","slateblue","slategray","slategrey","snow","springgreen","steelblue","tan","teal","thistle","tomato","transparent","turquoise","violet","wheat","white","whitesmoke","yellow","yellowgreen","Validate","predicate","cleanKey","className","targetClassName","stringify","JSON","predicateWithMessage","OPTIONAL","ctx","ARRAY","OPT_ARRAY","NON_EMPTY_ARRAY","OPT_NON_EMPTY_ARRAY","AND","predicates","OR","isComparable","LESS_THAN","otherField","GREATER_THAN","FUNCTION","OPT_FUNCTION","BOOLEAN","OPT_BOOLEAN","STRING","OPT_STRING","DATE","OPT_DATE","DATE_ARRAY","DATETIME_MS","NUMBER$1","OPT_DATETIME_MS","OPT_DATE_OR_DATETIME_MS","colorMessage","COLOR_STRING","OPT_COLOR_STRING","COLOR_STRING_ARRAY","OPT_COLOR_STRING_ARRAY","numberMessage","prefix","OPT_NUMBER","NUMBER_OR_NAN","NUMBER_ARRAY","OPT_NUMBER_ARRAY","STRING_ARRAY","OPT_STRING_ARRAY","STRING_UNION","BOOLEAN_ARRAY","OPT_BOOLEAN_ARRAY","FONT_WEIGHTS","FONT_STYLE","OPT_FONT_STYLE","FONT_WEIGHT","OPT_FONT_WEIGHT","LINE_DASH","OPT_LINE_DASH","LINE_CAPS","LINE_CAP","OPT_LINE_CAP","LINE_JOINS","LINE_JOIN","OPT_LINE_JOIN","POSITIONS","POSITION","INTERACTION_RANGES","INTERACTION_RANGE","TEXT_WRAPS","TEXT_WRAP","OVERFLOW_STRAGEGIES","OVERFLOW_STRATEGY","TEXT_ALIGNS","TEXT_ALIGN","VERTICAL_ALIGNS","VERTICAL_ALIGN","DIRECTIONS","DIRECTION","OPT_DIRECTION","ChartAxisDirection","RedrawType","functionConstructorAvailable","Function","STRING_FUNCTION_USEABLE","SceneChangeDetection","changeCb","convertor","privateKey","prepareFastGetSet","prepareSlowGetSet","redraw","TRIVIAL","checkDirtyOnAssignment","setterJs","NONE","getterJs","markDirty","markDirtyTransform","_dirtyPath","_dirtyFont","_dirty","ChangeDetectable","MAJOR","_source","markClean","_opts","isDirty","ID_MAP","resetIds","createId","instance","nextId","nearestSquared","point","objects","maxDistanceSquared","nearest","distanceSquared","obj","thisDistance","nearestSquaredInContainer","container","tpoint","transformPoint","child","children","BBox","height","clone","equals","containsPoint","collidesBBox","isInfinite","dx","dy","nearestBox","boxes","shrink","amount","pos","amt","entries","grow","paddingCopy","merge","left","top","right","bottom","box","zero","Matrix","elements","setElements","identity","AxB","A","C","multiplySelf","multiply","preMultiplySelf","inverse","el","rD","inverseTo","invertSelf","transformBBox","bbox","xx","xy","yx","yy","h_w","h_h","cx","cy","w","toContext","transform","flyweight","sourceMatrix","updateTransformMatrix","matrix","scalingX","scalingY","rotation","translationX","translationY","bbcx","bbcy","sx","sy","scx","scy","scalingCenterX","scalingCenterY","cos","sin","rcx","rcy","rotationCenterX","rotationCenterY","tx","ty","tx4","ty4","fromContext","domMatrix","PointerEvents","zIndexChangedCallback","parent","dirtyZIndex","zIndexChanged","Node","datum","_datum","_parent","previousDatum","_previousDatum","_setLayerManager","_layerManager","_debug","debug","_children","_virtualChildren","layerManager","virtualChildren","hasVirtualChildren","setProperties","styles","pickKeys","append","nodes","node","childSet","id","isVirtual","appendChild","removeChild","calculateCumulativeMatrix","computeTransformMatrix","inverseTransformPoint","inverseTransformBBox","dirtyTransform","tag","serialNumber","_nextSerialNumber","isContainerNode","inverseMatrix","visible","zIndex","zIndexSubOrder","pointerEvents","All","_x","_y","pickNode","None","computeTransformedBBox","hit","findNodes","childResult","computeBBox","render","renderCtx","stats","nodesRendered","clearBBox","topLeft","bottomRight","clearRect","parentType","dirty","force","recursive","visibilityChanged","nodeCount","dirtyCount","visibleCount","countChild","childCount","childVisibleCount","childDirtyCount","Boolean","DropShadow","enabled","xOffset","yOffset","blur","MOBILE","isDesktop","navigator","userAgent","test","HdpiCanvas","_enabled","_pixelRatio","_width","_height","document","domLayer","overrideDevicePixelRatio","createElement","realContext","getContext","imageSource","canvas","style","userSelect","display","String","opacity","context","setPixelRatio","resize","_container","remove","parentNode","snapshot","clear","save","resetTransform","restore","toImage","img","src","getDataURL","toDataURL","download","fileName","fileFormat","trim","dataUrl","href","body","click","pixelRatio","ratio","devicePixelRatio","overrideScale","pixelated","imageRendering","textMeasuringContext","_textMeasuringContext","svgText","_svgText","xmlns","svg","createElementNS","setAttribute","classList","visibility","has","_has","isChrome","isFirefox","isSafari","textMetrics","measureText","actualBoundingBoxDescent","text","font","textBaseline","textAlign","getTextSize","metrics","actualBoundingBoxAscent","measureSvgText","textSizeCache","fontCache","size","textContent","getBBox","scale","depth","overrides","$save","$restore","$setTransform","verifyDepthZero","globalThis","Gradient","stops","LinearGradient","angle","createGradient","angleOffset","diagonal","sqrt","diagonalAngle","atan2","quarteredAngle","gradient","createLinearGradient","addColorStop","LINEAR_GRADIENT_REGEXP","Shape","fillOpacity","strokeOpacity","fill","defaultStyles","stroke","strokeWidth","lineDash","lineDashOffset","lineCap","lineJoin","fillShadow","restoreOwnStyles","getOwnPropertyNames","updateGradient","linearGradientMatch","startsWith","exec","colors","colorsPart","colorRegex","align","alignedStart","fillStroke","renderFill","renderStroke","globalAlpha","applyFill","applyFillAlpha","applyShadow","shadowColor","fillStyle","shadowOffsetX","shadowOffsetY","shadowBlur","strokeStyle","lineWidth","setLineDash","isPointInPath","MINOR","ellipsis","SceneFontChangeDetection","Text","lines","fontSize","fontFamily","lineHeight","_setLines","splitText","_font","getFont","getPreciseBBox","getApproximateBBox","getLineHeight","line","fontBoundingBoxAscent","emHeightAscent","fontBoundingBoxDescent","emHeightDescent","forceRender","nodesSkipped","renderLines","fillText","strokeText","renderCallback","lineHeights","totalHeight","offsetY","getVerticalOffset","wrap","maxWidth","maxHeight","textProps","wrapping","overflow","canOverflow","measurer","createTextMeasurer","truncateLine","cumulativeHeight","wrappedLine","wrapLine","truncated","initialSize","words","wrapResult","wrapLineSequentially","wordsBrokenOrTruncated","linesTruncated","linesCount","balanced","wrapLineBalanced","wrappedText","ln","breakWord","word","firstLineWidth","hyphens","isPunctuationAt","punctuationMarks","breaks","partWidth","limit","ellipsisMode","trimEnd","ellipsisWidth","trunc","truncWidth","defaultLineHeightRatio","hyphenate","spaceWidth","currentLine","getReturnValue","truncateLastLine","lastLine","addNewLine","expectedHeight","wordWidth","expectedSpaceWidth","expectedLineWidth","availWidth","totalWordsWidth","sum","totalSpaceWidth","averageLineWidth","newLine","setFont","fontStyle","fontWeight","setAlign","getLineWidth","fontProps","baselineDistance","actualBoundingBoxLeft","firstLineHeight","lineSize","ProxyOnWrite","proxyProperty","ProxyPropertyOnWrite","childName","childProperty","ActionOnSet","newValueFn","oldValueFn","changeValue","changeValueFn","Caption","computeTextWrap","containerWidth","containerHeight","wrapped","SMALL_PADDING","LARGE_PADDING","AxisTitle","spacing","formatter","zipObject","zipped","interpolateNumber","interpolateColor","linear","easeIn","easeOut","easeInOut","easeInQuad","easeOutQuad","easeInOutQuad","easing","QUICK_TRANSITION","INITIAL_LOAD","animationDuration","animationDelay","REMOVE_PHASE","UPDATE_PHASE","ADD_PHASE","LABEL_PHASE","RepeatType","isNodeArray","array","Animation","_d","_e","_f","_g","_h","_j","_k","elapsed","iteration","isPlaying","isReverse","groupId","autoplay","delay","duration","ease","repeat","repeatType","Loop","onComplete","onPlay","onStop","onRepeat","onUpdate","createInterpolator","to","play","pause","reset","deltaState","time","Reverse","interpolateValue","interpolatorEntries","interpolator","NODE_UPDATE_PHASES","FROM_TO_MIXINS","added","updated","removed","unknown","fromToMotion","subId","animationManager","selectionsOrNodes","fns","getDatumId","defaultDuration","fromFn","toFn","intermediateFn","isNodes","selections","ids","processNodes","liveNodes","prevFromProps","liveNodeIndex","nodeIndex","isLive","last","lastLive","prev","prevLive","nextLive","animationId","stopByAnimationId","status","calculateStatus","finish","toDelay","toDuration","toStart","toFinish","animate","selectionIndex","selection","isGarbage","cleanup","staticFromToMotion","extraOpts","fromToMotion$1","group","content","optionalGroup","nonCapturingGroup","formatRegEx","symbol","comma","precision","tilde","RegExp","surroundedRegEx","suffix","parseFormatter","surrounded","match","format","precisionIsNaN","formatBody","decimalTypes","integerTypes","formatterPrecision","removeTrailingZeros","insertSeparator","addSign","getSIPrefix","addPadding","absFloor","fromCharCode","X","toUpperCase","toExponential","E","F","log10","G","getSIPrefixPower","%","numString","separator","dotIndex","integerChars","fractionalPart","siPrefixes","minSIPrefix","maxSIPrefix","minusSign","num","signType","plusSign","padStart","padEnd","padWidth","padLeft","padRight","tickFormat","digits","exp","minCount","maxCount","range$1","tickStep","NumericTicks","tickMultipliers","multiplier","isWithinBounds","diffCount","sort","singleTickDomain","end","countDigits","expNo","fractionalDigits","ContinuousScale","nice","tickCount","defaultTickCount","minTickCount","maxTickCount","niceDomain","defaultClampMode","transformInvert","calcBandwidth","smallestInterval","getDomain","maxRange","intervals","maxBands","bands","fromDomain","clampMode","d0","d1","isReversed","rMin","rMax","toDomain","getPixelRange","isDenseInterval","availableRange","defaultMaxTickCount","LinearScale","updateNiceDomain","getTickStep","maxAttempts","prev0","prev1","specifier","ascendingStringNumberUndefined","localeCompare","compoundAscending","comparator","toLiteral","Group","layer","moveLayer","isLayer","lastBBox","scene","removeLayer","getComputedOpacity","getVisibility","addLayer","clipRect","clipBBox","resized","canvasCtxTransform","isChildDirty","isChildLayerDirty","currentBBox","counts","layersSkipped","groupVisible","ctxTransform","clipCtx","sortChildren","renderContextChanged","childRenderContext","skipped","layersRendered","beginPath","moveTo","lineTo","closePath","clip","setClipRectInGroupCoordinateSpace","Selection","select","classOrFactory","garbageCollection","selectAll","results","traverse","selectByClass","Class","selectByTag","autoCleanup","garbageBin","_nodesMap","_nodes","data","nodeFactory","isPrototypeOf","createNode","initializer","dataMap","datumId","newDatum","delete","maxLength","hasGarbage","each","iterate","iterator","Line","x1","y1","x2","y2","px","py","linearRoot","quadraticRoots","D","roots","t1","t2","cubicRoots","Q","R","third","T","Im","theta","acos","thirdA","twoSqrtQ","t3","segmentIntersection","ax1","ay1","ax2","ay2","bx1","by1","bx2","by2","ua","ub","cubicSegmentIntersections","px1","py1","px2","py2","px3","py3","px4","py4","intersections","bx","bezierCoefficients","by","tt","ttt","P1","P2","P3","P4","arcIntersections","startAngle","endAngle","counterClockwise","y0","i1x","i2x","isXInsideLine","a1","a2","isPointInSector","sector","radius","innerRadius","outerRadius","lineCollidesSector","outerStart","outerEnd","innerStart","innerEnd","boxCollidesSector","topRight","bottomLeft","Command","Path2D","previousCommands","previousParams","previousClosedPath","commands","_closedPath","draw","command","Move","Curve","bezierCurveTo","Arc","arc","ClosePath","rect","sAngle","eAngle","antiClockwise","endX","endY","cubicCurveTo","cx1","cy1","cx2","cy2","closedPath","trackChanges","cn","ox","oy","intersectionCount","ci","pi","getPoints","coords","ScenePathChangeDetection","Path","clipScalingX","clipScalingY","dirtyPath","checkPathDirty","clipPath","isDirtyPath","updatePath","op","clipScale","clipMode","Sector","centerX","centerY","inset","fullPie","baseInnerRadius","innerAngleOffset","outerAngleOffset","sweep","outerAngleExceeded","innerAngleExceeded","hypot","midAngle","deepMerge","isPlainObject","isObjectLike","isObject","mergeDefaults","sources","partialAssign","keysToCopy","sanitizeHtml","innerHTML","isString","isStringObject","isDate","isDiscrete","isContinuous","isNumberObject","isNumber","valueOf","checkDatum","isContinuousScale","memorizedFns","memo","fnGenerator","serialisedParams","SMALLEST_KEY_INTERVAL","initialValue","reducer","prevX","smallestSoFar","nextX","AGG_VALUES_EXTENT","calculate","processedData","aggValues","SORT_DOMAIN_GROUPS","groups","normaliseFnBuilder","normaliseTo","mode","normalise","val","valueIndexes","valuesExtent","valueIdx","valIdx","normaliseGroupTo","scope","matchGroupIds","scopes","adjust","normalisePropertyFnBuilder","zeroDomain","rangeMin","rangeMax","normaliseSpan","span","pData","pIdx","groupValues","normalisePropertyTo","animationValidation","valueKeyIds","defs","uniqueKeys","orderedKeys","valueKeys","processKey","def","keyValues","keyValue","buildGroupAccFn","separateNegative","acc","currentVal","accIndex","buildGroupWindowAccFn","lastValues","firstRow","sumValue","accumulateGroup","matchGroupId","modeParam","endsWith","previousData","updateMovedDatums","changed","moved","addedIndices","updatedIndices","removedIndices","prevId","createDatumId","Label","calculateLabelRotation","parallelFlipRotation","regularFlipRotation","configuredRotation","parallelFlipFlag","regularFlipFlag","defaultRotation","parallel","getLabelSpacing","minSpacing","rotated","getTextBaseline","labelRotation","sideFlag","getTextAlign","labelAutoRotation","labelRotated","labelAutoRotated","alignFlag","calculateLabelBBox","labelX","labelY","labelMatrix","translatedBBox","label","Layers","Marker","half","applyPath","moves","mx","my","Circle","DEFAULT_FILLS","BLUE","ORANGE","GREEN","CYAN","YELLOW","VIOLET","GRAY","MAGENTA","BROWN","RED","DEFAULT_STROKES","ModuleMap","modules","addModule","moduleContext","createModuleContext","moduleInstance","instanceConstructor","removeModule","isModuleEnabled","Listeners","registeredListeners","addListener","eventType","handler","meta","record","removeListener","eventSymbol","listeners","matchIndex","listener","dispatch","ResultArray","getListenersByType","dispatchWrapHandlers","wrapFn","Observable","eventListeners","addEventListener","eventTypeListeners","removeEventListener","hasEventListener","clearEventListeners","fireEvent","event","extendDomain","sumValues","accumulator","aggregateFunction","groupSum","groupAggregateFunction","groupCount","average","groupAverage","finalFunction","area","aggFn","keyRange","keyWidth","accumulatedValue","onlyPositive","trailingAccumulatedValue","trailingValue","SeriesNodePickMode","basicContinuousCheckDatumValidation","basicDiscreteCheckDatumValidation","keyProperty","propName","continuous","validation","valueProperty","rangedValueProperty","defOpts","processor","trailingValueProperty","accumulativeValueProperty","trailingAccumulatedValueProperty","groupAccumulativeValueProperty","SeriesNodeClickEvent","series","seriesId","SeriesItemHighlightStyle","SeriesHighlightStyle","dimOpacity","TextHighlightStyle","HighlightStyle","item","SeriesHighlight","Series","_data","onDataChange","_chartData","nodeDataRefresh","setChartData","hasData","_visible","visibleChanged","onSeriesGroupingChange","rootGroup","highlightGroup","annotationGroup","seriesStateManager","deregisterSeries","registerSeries","seriesGrouping","seriesLayerManager","changeGroup","getGroupZIndexSubOrder","oldGrouping","getBandScalePadding","inner","outer","seriesOpts","NodeClickEvent","axes","Y","directions","showInLegend","cursor","nodeClickRange","_declarationOrder","seriesListeners","highlightStyle","moduleMap","nodeDataDependencies","moduleCtx","useLabelLayer","pickModes","NEAREST_BY_MAIN_AXIS_FIRST","directionKeys","directionNames","contentGroupVirtual","canHaveAxes","contentGroup","SERIES_LAYER_ZINDEX","highlightNode","highlightLabel","labelGroup","SERIES_LABEL_ZINDEX","subIndex","mainAdjust","main","addChartEventListeners","releaseGroup","getDirectionValues","direction","properties","resolvedDirection","resolveKeyDirection","addValues","items","getKeys","getNames","seriesDomain","getSeriesDomain","moduleDomains","total","current","markNodeDataDirty","getOpacity","defaultOpacity","isItemIdHighlighted","This","Other","getStrokeWidth","defaultStrokeWidth","highlightManager","getActiveHighlight","getModuleTooltipParams","limitPickModes","pickMode","EXACT_SHAPE_MATCH","pickNodeExactShape","NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST","pickNodeMainAxisFirst","NEAREST_NODE","pickNodeClosestDatum","distance","_point","_requireCategoryAxis","fireNodeClickEvent","fireNodeDoubleClickEvent","toggleSeriesItem","itemId","isEnabled","getModuleMap","getLabelText","defaultFormatter","callbackCache","getMarkerStyle","marker","defaultStyle","getStyle","defaultSize","markerStyle","updateMarkerStyle","markerNode","applyTranslation","activeStyle","shape","getMinRect","checkResize","newSeriesRect","newNodeDataDependencies","seriesRectWidth","seriesRectHeight","highlightedZIndex","newVal","oldVal","seriesLabelFadeInAnimation","labelSelections","seriesLabelFadeOutAnimation","resetLabelFn","_node","CONSTANTS","periods","days","shortDays","months","shortMonths","dayOfYear","startOfYear","startOffset","timeDiff","timeOneDay","weekOfYear","startDay","startOfYearDay","getDay","firstWeekStartOffset","SUNDAY","MONDAY","THURSDAY","isoWeekOfYear","firstOfYear","firstOfYearDay","firstThursdayOffset","timezone","unsignedOffset","pad","FORMATTERS","getMilliseconds","getHours","I","hours","M","getMinutes","L","getSeconds","u","U","V","W","Z","PADS","padChar","output","buildFormatter","formatString","formatParts","nextEscapeIdx","literalPart","maybePadSpecifier","maybePad","maybeFormatterSpecifier","maybeFormatter","dateTime","dateTimeAsDate","interpolatePattern","formats","args","valueName","formatName","locales","toLocaleString","toDateString","injectStyle","cssStyle","styleElement","head","insertBefore","querySelector","DEFAULT_TOOLTIP_CLASS","DEFAULT_TOOLTIP_DARK_CLASS","defaultTooltipCss","toTooltipHtml","defaults","title","backgroundColor","titleHtml","contentHtml","POSITION_TYPES","POSITION_TYPE","TooltipPosition","Tooltip","canvasElement","enableInteraction","showArrow","class","lastClass","lastVisibilityChange","showTimeout","_showArrow","tooltipRoot","IntersectionObserver","observer","entry","intersectionRatio","toggle","root","observe","tooltipDocuments","unobserve","isVisible","contains","updateClass","newClass","wasVisible","nowVisible","timeSinceLastVisibilityChangeMs","toggleClass","include","animatedMoveThresholdMs","thrashingThresholdMs","noAnimation","show","html","instantly","low","actual","high","canvasRect","getBoundingClientRect","naiveLeft","offsetX","clientWidth","naiveTop","clientHeight","windowBounds","getWindowBoundingBox","maxLeft","maxTop","constrained","defaultShowArrow","updateShowArrow","setTimeout","innerWidth","innerHeight","clearTimeout","pointerLeftOntoTooltip","sourceEvent","relatedTarget","classes","classListContains","SeriesTooltipInteraction","SeriesTooltip","renderer","interaction","formatFn","rendererFn","preparePieSeriesAnimationFunctions","initialLoad","rotationDegrees","scaleFn","oldScaleFn","oldScale","scaleToNewRadius","scaleToOldRadius","sect","sectorFormat","radii","_sect","innerCircle","resetPieSelectionsFn","resetMotion","propsFn","resetMotion$1","StateMachine","initialState","states","preTransitionCb","state","transition","currentStateConfig","destinationTransition","destinationState","action","DataModelSeries","isContinuousX","isContinuousY","requestDataModel","dataController","listenerProps","moreProps","dataModel","request","isProcessedDataAnimatable","validationResults","reduced","checkProcessedDataAnimatable","skipCurrentBatch","PolarSeries","animationResetFns","sectorGroup","itemSelection","labelSelection","highlightSelection","animationState","empty","animateEmptyUpdateReady","ready","updateData","highlight","animateReadyHighlight","highlightMarkers","animateReadyHighlightMarkers","animateReadyResize","waiting","animateWaitingUpdateReady","clearing","animateClearingUpdateEmpty","getLabelData","computeLabelsBBox","_options","_seriesRect","resetAllAnimation","stopByAnimationGroupId","animationTransitionClear","getAnimationData","seriesRect","PieSeriesNodeClickEvent","nativeEvent","angleKey","radiusKey","calloutLabelKey","sectorLabelKey","PieNodeTag","PieSeriesCalloutLabel","minAngle","maxCollisionOffset","avoidCollisions","PieSeriesSectorLabel","positionOffset","positionRatio","PieSeriesCalloutLine","PieTitle","DoughnutInnerLabel","margin","DoughnutInnerCircle","PieSeries","previousRadiusScale","radiusScale","backgroundGroup","SERIES_BACKGROUND_ZINDEX","innertCircleGroup","nodeData","seriesItemEnabled","calloutLabel","sectorLabel","calloutLine","tooltip","angleName","innerLabels","radiusName","radiusMin","radiusMax","calloutLabelName","sectorLabelName","legendItemKey","fills","strokes","outerRadiusOffset","outerRadiusRatio","innerRadiusOffset","innerRadiusRatio","shadow","surroundingRadius","angleScale","pieCalloutLabels","pieSectorLabels","calloutLabelSelection","sectorLabelSelection","innerLabelsSelection","innerCircleSelection","chartEventManager","onLegendItemClick","processSeriesItemEnabled","processData","animationEnabled","isSkipped","extraKeyProps","extraProps","maybeRefreshNodeData","createNodeData","getProcessedDataIndexes","angleIdx","resolveProcessedDataIndexById","radiusIdx","calloutLabelIdx","sectorLabelIdx","legendItemIdx","currentStart","angleValue","radiusValue","legendItemValue","labels","getLabels","getSectorFormat","midCos","midSin","labelData","skipDisabled","calloutLabelValue","sectorLabelValue","labelFormatterParams","getTextAlignment","hidden","collisionTextAlign","collisionOffsetY","legendItem","quadrantTextOpts","midAngle180","quadrantStart","quadrantOffset","quadrant","quadrantIndex","formatIndex","highlightedDatum","isDatumHighlighted","highlighted","getInnerRadius","getOuterRadius","updateRadiusScale","newRange","getTitleTranslationY","titleOffset","updateTitleNodes","titleBox","bboxIntersectsSurroundingSeries","updateNodeMidPoint","updateSelections","updateNodes","oldTitle","midPoint","updateGroupSelection","updateInnerCircleSelection","Callout","circleRadius","antiAliasingPadding","datums","updateSectorFn","_index","animationDisabled","updateCalloutLineNodes","updateCalloutLabelNodes","updateSectorLabelNodes","updateInnerLabelNodes","calloutLength","calloutStrokeWidth","calloutColors","isMoved","paddedLength","getLabelOverflow","seriesLeft","seriesRight","seriesTop","seriesBottom","errPx","visibleTextPart","hasVerticalOverflow","textLength","hasSurroundingSeriesOverflow","corners","sur2","corner","computeCalloutLabelCollisionOffsets","shouldSkip","fullData","leftLabels","rightLabels","topLabels","bottomLabels","tempTextNode","getTextBBox","labelRadius","avoidNeighbourYCollision","collidesOrBehind","avoidYCollisions","midLabel","midIndex","avoidXCollisions","labelsCollideLabelsByY","paddedBoxes","labelsCollideLabelsByX","sectors","labelsCollideSectors","displayText","textBoxes","titleCleanArea","hideWhenNecessary","isTooShort","isDoughnut","singleVisibleSector","isTextVisible","shouldPutTextInCenter","sectorBounds","textBBoxes","margins","getMarginTop","getMarginBottom","totalWidth","labelsVisible","textBottoms","getDatumLegendName","nodeDatum","getTooltipHtml","labelText","getLegendData","legendType","titleText","legendData","labelParts","toggleOtherSeriesItems","datumToggledLegendItemValue","datumItemId","supportedDiff","hasKeys","hasUniqueKeys","getDatumIdFromData","JSON_APPLY_PLUGINS","assignJsonApplyConstructedArray","ctor","JSON_APPLY_OPTIONS","subtitle","footnote","getJsonApplyOptions","Range","startLine","endLine","isRange","fillActive","strokeActive","horizontalCrosslineTranslationDirections","xTranslationDirection","yTranslationDirection","inside","insideLeft","insideRight","insideTop","insideBottom","insideTopLeft","insideBottomLeft","insideTopRight","insideBottomRight","verticalCrossLineTranslationDirections","calculateLabelTranslation","yDirection","crossLineTranslationDirections","xTranslation","yTranslation","calculateLabelChartPadding","chartPadding","POSITION_TOP_COORDINATES","xEnd","yStart","yEnd","POSITION_LEFT_COORDINATES","xStart","POSITION_RIGHT_COORDINATES","POSITION_BOTTOM_COORDINATES","POSITION_INSIDE_COORDINATES","POSITION_TOP_LEFT_COORDINATES","POSITION_BOTTOM_LEFT_COORDINATES","POSITION_TOP_RIGHT_COORDINATES","POSITION_BOTTOM_RIGHT_COORDINATES","labeldDirectionHandling","CROSSLINE_LABEL_POSITIONS","OPT_CROSSLINE_LABEL_POSITION","OPT_CROSSLINE_TYPE","CartesianCrossLineLabel","CartesianCrossLine","clippedRange","gridLength","LINE_LAYER_ZINDEX","crossLineRange","crossLineLabel","labelPoint","getZIndex","calculateLayout","dataCreated","crossLineBox","labelBox","computeLabelBBox","updateRangeNode","updateLabel","positionLabel","clippedRangeClamper","getRange","clampedYStart","clampedYEnd","validRange","reverse","RANGE_LAYER_ZINDEX","tempText","calculatePadding","labelPadding","crossLineLabelBBox","SERIES_CROSSLINE_LINE_ZINDEX","SERIES_CROSSLINE_RANGE_ZINDEX","LogScale","baseLog","basePow","updateLogFn","updatePowFn","log2","logBase","pow10","n0","n1","p0","p1","absDiff","isBaseInteger","isDiffLarge","ticks$1","isPositive","availableSpacing","lastTickPosition","nextMagnitudeTickPosition","tickPosition","prevSpacing","nextSpacing","fits","DefaultTimeFormats","formatStrings","MILLISECOND","SECOND","MINUTE","HOUR","WEEK_DAY","SHORT_MONTH","MONTH","SHORT_YEAR","YEAR","toNumber","TimeScale","week","tickIntervals","calculateDefaultTickFormat","defaultTimeFormat","updateFormat","getLowestGranularityFormat","firstTick","lastTick","startYear","stopYear","yearChange","buildFormatString","formatStringArray","timeEndIndex","weekDayIndex","defaultTickFormat","getTickInterval","countableTimeInterval","diff0","diff1","t0","getTicksForInterval","getDefaultTicks","absInterval","reversedInterval","timeInterval","tickInterval","stopDate","setMilliseconds","updateNiceDomainIteration","intervalRange","Padding","sparklinesUtil","isNumberEqual","interpolateString","areArrayNumbersEqual","arrA","arrB","circleRectOverlap","edgeX","edgeY","rectRectOverlap","w2","h2","xOverlap","yOverlap","rectContainsRect","r2x","r2y","r2w","r2h","isPointLabelDatum","placeLabels","bounds","withinBounds","overlapPoints","overlapLabels","axisLabelsOverlap","GRID_STYLE_KEYS","GRID_STYLE","AxisGridLine","Default","defaultValue","replaces","__","AxisLabel","autoWrap","mirrored","getSideFlag","AxisLine","OPT_TICK_INTERVAL","AxisTick","prepareAxisAnimationContext","axis","requestedRangeMin","requestedRangeMax","fullCircle","halfCircle","normaliseEndRotation","directDistance","prepareAxisAnimationFunctions","outOfBounds","fromBase","toBase","tick","_status","_group","resetAxisGroupFn","resetAxisSelectionFn","rangeVisible","resetAxisLabelSelectionFn","resetAxisLineSelectionFn","Tags","TickGenerationType","Axis","crossLines","_crossLines","crossLine","detachCrossLine","assignCrossLineArrayConstructor","attachCrossLine","initCrossLine","dataDomain","boundSeries","includeInvisibleDomains","axisGroup","AXIS_ZINDEX","lineNode","tickLineGroup","tickLabelGroup","crossLineGroup","gridGroup","gridLineGroup","AXIS_GRID_ZINDEX","tickLineGroupSelection","tickLabelGroupSelection","gridLineGroupSelection","createTick","gridLine","createLabel","defaultTickMinSpacing","translation","layout","visibleRange","_titleCaption","_gridLength","gridPadding","seriesAreaPadding","tickGenerationResult","maxThickness","refreshScale","interactionManager","checkAxisHover","resetSelectionNodes","animateReadyUpdate","previousSize","layoutService","chart","updateService","minRect","updateRange","rr","vr","shift","setCrossLinesVisible","attachAxis","axisNode","gridNode","detachAxis","inRange","tolerance","onLabelFormatChange","logScale","defaultLabelFormatter","labelFormatter","setDomain","tickValues","tickMin","tickMax","setTickInterval","setTickCount","isInAxis","axisHover","primaryTickCount","calculateRotations","updatePosition","lineData","getAxisLineCoordinates","tickData","combinedRotation","ticksResult","previousTicks","tickId","calculateUpdateDiff","updateAxisLine","updateLabels","updateVisibility","updateGridLines","updateTickLines","updateTitle","anyTickVisible","updateCrossLines","updateLayoutState","getTickLineCoordinates","getTickLabelProps","tickLabel","tickSize","setTitleProps","caption","titleNode","tickSpace","titleRotationFlag","getTitleFormatterParams","updateScale","generateTicks","lineBox","tickLineBox","labelProps","getTransformBox","axisRotation","getAxisTransform","contentBox","tickWidth","transformedBBox","anySeriesActive","isAnySeriesActive","calculateDomain","secondaryAxis","initialRotation","estimateTickCount","maxSpacing","maxIterations","rawTicks","labelCount","autoRotation","labelOverlap","terminate","tickStrategies","getTickStrategies","strategy","checkLabelOverlap","avoidLabelCollisions","filterTicks","autoRotate","strategies","tickGenerationType","VALUES","CREATE_SECONDARY","FILTER","CREATE","tickGenerationStrategy","createTickData","tickFilterStrategy","autoWrapStrategy","wrapLabels","autoRotateStrategy","getAutoRotation","regenerateTicks","unchanged","prevTicks","getTicks","shouldTerminate","createLabelData","labelSpacing","tickDatum","labelDatum","autoRotateAngle","updateSecondaryAxisTicks","createTicks","halfBandwidth","tickIdCounts","rawTick","formatTick","tickSpacing","keepEvery","rangeWithBleed","calculateRangeWithBleed","defaultMinSpacing","clampMaxTickCount","minRectDistance","calculateAvailableRange","visibleScale","linkedTo","visibleSeries","domains","normaliseDataDomain","_primaryTickCount","GridLine","TickLine","TickLabel","defaultMaxWidth","defaultMaxHeight","tickBBox","formatDatum","clipTickLines","clipGrid","_max","names","getLayoutState","axisContext","createAxisContext","axisId","scaleValueFormatter","scaleBandwidth","scaleConvert","scaleInvert","selectionCtx","previous","CartesianAxisLabel","CartesianAxis","thickness","updateDirection","CategoryAxis","_paddingOverrideEnabled","groupPaddingInner","uniqueValues","paddings","TreeNode","number","subtreeLeft","subtreeRight","screenX","screenY","leafCount","prelim","ancestor","change","getLeftSibling","getLeftmostSibling","nextLeft","thread","nextRight","getSiblings","ticksToTree","insertTick","pathParts","lastPartIndex","pathPart","partIndex","existingNode","isNotLeaf","moveSubtree","wm","wp","subtrees","vim","defaultAncestor","executeShifts","apportion","vop","vip","vom","sip","sop","sim","som","firstWalk","midpoint","leftSibling","Dimensions","secondWalk","thirdWalk","treeLayout","TreeLayout","dimensions","leafNodes","nonLeafNodes","shiftX","shiftY","flipX","xSteps","ySteps","existingSpacingX","desiredSpacingX","existingSpacingY","desiredSpacingY","screenDimensions","GroupedCategoryAxisLabel","grid","GroupedCategoryAxis","tickScale","labelColor","gridLineSelection","axisLineSelection","separatorSelection","resizeTickTree","tickTreeLayout","isNumericX","tickTree","tickScaleDomain","computedLayout","updateTitleCaption","updateCategoryLabels","updateSeparators","updateAxisLines","updateCategoryGridLines","tickLabelLayout","separatorLayout","axisLineLayout","gridSelection","styleCount","computeLayout","rangeStart","rangeEnd","rangeLength","isHorizontal","treeLabels","isLabelTree","copyLabelProps","labelBBoxes","maxLeafLabelWidth","setLabelProps","isCaptionEnabled","isInRange","labelGrid","separatorData","isLeaf","minX","separatorBoxes","separatorBox","axisLineBoxes","lineCount","HdpiOffscreenCanvas","isSupported","OffscreenCanvas","transferToImageBitmap","close","DebugSelectors","advancedCompositeIdentifier","domCompositeIdentifier","Scene","layers","_nextZIndex","_nextLayerId","_root","SCENE","pendingSize","lessThanZero","nan","layeredModes","advLayer","newLayer","sortLayers","domCanvases","newLayerIndex","lastLayer","insertAdjacentElement","newZIndex","newZIndexSubOrder","strip","debugSplitTimes","performance","extraDebugStats","redrawType","tree","buildTree","debugStats","debugNodes","SCENE_STATS_VERBOSE","canvasCleared","dirtyTree","paths","buildDirtyTree","SCENE_DIRTY_TREE","drawImage","debugSceneNodeHighlight","renderCtxStats","SCENE_STATS","pct","rendered","lastSplit","splits","extras","detailedStats","statsSize","fillRect","stat","regexpPredicate","matcher","stringPredicate","sceneNodeHighlight","strokeRect","virtualParentDirty","virtualParent","childTree","treeNodeName","childNode","selectedKey","childrenDirtyTree","sleep","sleepTimeoutMs","CallbackCache","fn","paramCache","invoke","invalidateCache","Mutex","available","acquireQueue","acquire","cb","dispatchNext","acquireImmediately","waitForClearAcquireQueue","debouncedAnimationFrame","buildScheduler","_delayMs","requestAnimationFrame","debouncedCallback","delayMs","scheduleFn","scheduleCount","promiseRunning","awaitingPromise","awaitingDone","busy","scheduleCb","maybePromise","catch","schedule","await","SizeMonitor","init","ResizeObserver","resizeObserver","contentRect","checkSize","checkClientSize","pollerHandler","setInterval","documentReady","readyState","readyEventFn","newState","oldState","queuedObserveRequests","clearInterval","disconnect","ownerDocument","ChartHighlight","ChartUpdateType","DataDomain","continuousDomain","discreteDomain","toKeyString","accuracy","isInteger","fixNumericExtentInternal","fixNumericExtent","fixedExtent","paddingMin","paddingMax","INVALID_VALUE","DataModel","dataVisible","missing","aggregates","groupProcessors","propertyProcessors","reducers","processors","verifyMatchGroupId","verifyMatchIds","matchIds","matchId","searchId","resolveProcessedDataDefById","resolveProcessedDataIndicesById","resolveProcessedDataDefsById","resolveProcessedDataDefsByIds","searchIds","resolveProcessedDataDefsValues","searchScope","allDefs","matches","domainProp","firstMatch","groupByKeys","groupByFn","extractData","groupData","postProcessGroups","aggregateData","postProcessProperties","reduceData","postProcessData","logProcessedData","valueGroupIdxLookup","matchScope","defScope","defId","valueIdxLookup","noScopesToMatch","scopeMatch","compareTo","anyScope","noScopes","propId","idMatch","keyDefs","valueDefs","processValue","allScopesHaveSameDefs","initDataDomainProcessor","resultData","resultDataIdx","partialValidDataCount","validScopes","keyIdx","propertyDomain","groupingFn","dataEntry","groupStr","existingData","resultGroups","dataIndex","aggDefs","resultAggValues","resultAggValueIndices","resultAggFns","resultGroupAggFns","resultFinalFns","resultIdx","indices","scopeValid","matchScopes","as","groupAggValues","distinctValues","valuesToAgg","valuesAgg","finalValues","affectedIndices","updatedDomains","groupProcessorIndices","groupProcessorInitFns","valueDef","updateDomains","valueIndex","adjustFn","reducerDefs","accValues","reducerIndex","accIdx","processorDefs","scopesCount","processorFns","initDataDomainKey","updateDataDomain","initDataDomain","accessors","buildAccessors","hasAccessor","valueInDatum","missingValue","forceValue","valueNegative","missingValueDef","valid","invalidValue","isPath","fnBody","logValues","flattenedValues","skipKeys","skipAggValues","DataController","requested","resultCb","execute","merged","mergeRequested","debugMode","resultCbs","rejects","splitResult","grouped","groupMatch","gr","propMatch","existing","mergeOpts","DataService","getSeries","BaseManager","listenerSymbol","DEBUG_SELECTORS","AnimationManager","chartUpdateMutex","batch","AnimationBatch","requestId","skipAnimations","disableInteractions","immutable","controllers","failsafeOnError","random","controller","requestAnimation","resume","cancelAnimation","isActive","stack","isSkippingFrames","scheduleAnimationFrame","prevTime","onAnimationFrame","executeAnimationFrame","deltaTime","controllersCount","deltaMs","cancelAnimationFrame","startBatch","endBatch","ChartEventManager","legendItemClick","legendItemName","legendItemDoubleClick","numVisibleItems","CursorManager","updateCursor","callerId","applyStates","styleToApply","getCursor","HighlightManager","highlightStates","pickedStates","updateHighlight","applyHighlightStates","activeHighlight","updatePicked","clickableDatum","applyPickedStates","getActivePicked","activePicked","previousHighlight","pop","currentHighlight","WINDOW_EVENT_HANDLERS","EVENT_HANDLERS","CSS","InteractionManager","eventHandler","processEvent","mouseDown","touchDown","pausers","animation","rootElement","passive","interactionDocuments","pauseType","decideInteractionEventTypes","dispatchEvent","calculateCoordinates","pauses","interactionEvent","bypassPause","consumed","buildEvent","dragStart","dragStartElement","isEventOverElement","mouseButtonDown","MouseEvent","buttons","parentElement","clientX","clientY","pageX","pageY","fixOffsets","TouchEvent","lastTouch","touches","changedTouches","NULL_COORDS","PageTransitionEvent","persisted","offsets","offsetLeft","offsetTop","offsetParent","offsetDragStart","offsetEvent","pageRect","builtEvent","consume","TooltipManager","exclusiveAreas","checkExclusiveRects","updateTooltip","updateExclusiveRect","removeTooltip","getTooltipMeta","newAppliedExclusiveArea","entryId","appliedExclusiveArea","contentToApply","metaToApply","appliedState","renderInstantly","makeTooltipMeta","refPoint","yBar","upperPoint","scrollX","scrollY","ZoomManager","updateAxes","removedAxes","AxisZoomManager","initialZoom","newZoom","updateZoom","getDirection","updateAxisZoom","getZoom","getAxisZoom","getAxisZooms","zoom","currentZoom","prevZoom","LayoutService","layoutComplete","isLayoutStage","isLayoutComplete","dispatchPerformLayout","stage","dispatchLayoutComplete","gridLayout","orientation","bboxes","itemPaddingY","itemPaddingX","forceResult","horizontal","primary","secondary","processedBBoxCount","rawPages","unprocessedBBoxes","processBBoxes","pageIndices","buildPages","indexOffset","minGuess","startingGuess","estimateStartingGuess","guess","calculatePage","primaryCount","sumSecondary","currentMaxSecondary","currentPrimaryIndices","maxPrimaryValues","bboxIndex","primaryValueIdx","primaryValue","currentSecondaryDimension","returnResult","sumPrimary","maxPageWidth","maxPageHeight","pages","transpose","endIndex","columns","colIndices","colBBoxes","columnHeight","columnWidth","pageWidth","pageHeight","column","startIndex","innerData","dataIdx","itemIdx","primarySum","Cross","Diamond","Heart","rad","degree","Plus","Square","hs","Triangle","MARKER_SHAPES","circle","cross","diamond","heart","plus","square","triangle","MARKER_SUPPORTED_SHAPES","isMarkerShape","getMarker","MarkerLabel","_marker","_markerSize","_spacing","markerSize","PaginationLabel","PaginationMarkerStyle","PaginationMarker","onMarkerShapeChange","Pagination","chartUpdateCallback","pageUpdateCallback","cursorManager","labelNode","inactiveStyle","totalPages","currentPage","nextButtonDisabled","previousButtonDisabled","_orientation","_nextButton","_previousButton","nextButton","previousButton","onPaginationClick","onPaginationMouseMove","updateMarkers","updateGroupVisibility","updatePositions","enableOrDisableButtons","updateLabelPosition","updateNextButtonPosition","markerPadding","labelBBox","highlightActive","buttonStyle","button","disabled","updateMarker","zeroPagesToDisplay","onLastPage","onFirstPage","nextButtonContainsPoint","previousButtonContainsPoint","incrementPage","onPaginationChanged","decrementPage","SCENE_RENDER","attachPagination","ORIENTATIONS","OPT_ORIENTATION","LegendLabel","LegendMarker","_shape","LegendItem","paddingX","paddingY","toggleSeriesVisible","LegendListeners","Legend","getOrientation","LEGEND_ZINDEX","oldSize","maxPageSize","paginationTrackingIndex","truncatedItems","reverseOrder","characterWidths","pagination","page","updatePageNumber","bypass","checkLegendClick","checkLegendDoubleClick","handleLegendMouseMove","positionLegend","shrinkRect","detachLegend","getCharacterWidths","cw","attachLegend","getItemLabel","performLayout","markerShape","itemMaxWidthPercentage","maxItemWidth","paddedMarkerWidth","markerLabel","truncate","updatePagination","pageNumber","maxCharLength","textChars","addEllipsis","labelWidth","truncatedText","cumulativeWidth","char","trackingIndex","paginationBBox","paginationVertical","calculatePagination","newCurrentPage","paginationComponentPadding","legendItemsWidth","legendItemsHeight","paginationX","paginationY","lastPassPaginationBBox","stableOutput","visibleStart","visibleEnd","columnCount","rowCount","itemHeight","rowSumColumnWidths","pageIndex","columnIndex","rowIndex","itemMarker","markerFill","markerStroke","markerStrokeWidth","markerFillOpacity","markerStrokeOpacity","getDatumForPoint","visibleChildBBoxes","closestLeftTop","dist","childBBox","distX","distY","toTheLeftTop","pageBBox","computePagedBBox","actualBBox","dataService","legendBBox","pointerInsideLegend","chartSeries","newEnabled","PROCESS_DATA","forceNodeDataRefresh","clickedItem","tooltipManager","pointerOverLegendDatum","newShrinkRect","legendWidth","legendHeight","calculateLegendDimensions","calculateTranslationPerpendicularDimension","legendPadding","legendPositionedBBox","aspectRatio","maxCoefficient","minHeightCoefficient","minWidthCoefficient","heightCoefficient","widthCoefficient","Overlay","alignItems","boxSizing","justifyContent","innerText","hide","ChartOverlays","noData","SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION","SeriesLayerManager","expectedSeriesCount","setSeriesCount","requestGroup","seriesConfig","seriesRootGroup","seriesHighlightGroup","seriesAnnotationGroup","groupIndex","lookupIndex","lookupIdx","groupInfo","seriesIds","annotation","layerState","leadSeriesConfig","SeriesStateManager","grouping","getVisiblePeerGroupIndex","visibleGroupCount","visibleGroups","BaseLayoutProcessor","chartLike","positionPadding","positionCaptions","clipSeries","paddedRect","seriesArea","seriesRoot","updateCaption","defaultCaptionHeight","captionLineHeight","positionTopAndShrinkBBox","baseY","bboxHeight","positionBottomAndShrinkBBox","defaultTitleSpacing","UpdateService","updateCallback","FULL","dispatchUpdateComplete","initialiseSpecialOverrides","globalWindow","global","globalDocument","sceneMode","SeriesArea","Chart","getOptions","queuedUserOptions","lastUpdateOptions","userOptions","autoSizeChanged","_lastAutoSize","destroyed","_destroyed","specialOverrides","resources","processedOptions","_firstAutoSize","_destroyFns","legendModules","legends","_pendingFactoryUpdatesCount","_performUpdateNoRenderCount","_performUpdateType","_performUpdateSkipAnimations","updateShortcutCount","seriesToUpdate","updateMutex","updateRequestors","performUpdateTrigger","performUpdate","_lastPerformUpdateError","_axes","_series","lastInteractionEvent","pointerScheduler","handlePointer","onSeriesNodeClick","seriesNodeClickEvent","onSeriesNodeDoubleClick","seriesNodeDoubleClick","axisGridGroup","autoSize","zoomManager","overlays","rawResize","onClick","onDoubleClick","onMouseMove","onLeave","disablePointer","changeHighlightDatum","legend","getModuleContext","legendConstructor","addLegendModule","removeLegendModule","keepTransferableResources","removeAllSeries","highlightOnly","requestFactoryUpdate","performUpdateType","lastPerformUpdateError","newAnimationBatch","backOffMs","PERFORM_LAYOUT","checkUpdateShortcut","checkFirstAutoSize","processLayout","SERIES_UPDATE","seriesUpdates","all","TOOLTIP_RECALCULATION","tooltipMeta","isHovered","durationMs","checkUpdateType","maxShortcuts","addSeries","allSeries","canAdd","initSeries","addSeriesListeners","updateAllSeriesListeners","assignSeriesToAxes","seriesAxis","assignAxesToSeries","directionToAxesMap","directionAxes","seriesKeys","newAxis","findMatchingAxis","axisKeys","directionKey","autoWidth","authHeight","seriesPromises","updateLegend","isCategoryLegendData","validateCategoryLegendData","labelMarkerFills","seriesType","seriesMarkers","oldRect","animationRect","handleNoDataOverlay","pickSeriesNode","exactMatchOnly","maxDistance","reverseSeries","lastPick","hoverRect","handlePointerTooltip","handlePointerNode","pixelRange","pick","isNewDatum","isPixelRange","tooltipEnabled","exactlyMatched","rangeMatched","shouldUpdateTooltip","found","checkSeriesNodeRange","checkSeriesNodeClick","checkSeriesNodeDoubleClick","callback","nearestNode","pickedNode","newSeries","lastSeries","lastDatum","updateAll","waitForUpdate","timeoutMs","shouldDisplayNoDataOverlay","minRects","ArcType","Open","Chord","Round","convertColorStringToHsla","interpolateHsla","xH","yH","deltaH","ColorScale","parsedRange","LinearGradientFill","_mask","mask","newMask","pixelLength","maskBbox","colorScale","i0","i1","Rect","borderPath","crisp","lastUpdatePathStrokeWidth","effectiveStrokeWidth","microPixelEffectOpacity","pixelSize","lx","borderClipPath","ly","halfStrokeWidth","borderActive","Image","sourceImage","image","motion","integratedChartsScene","DEFAULT_DIRECTION_KEYS","DEFAULT_DIRECTION_NAMES","CartesianSeriesNodeClickEvent","xKey","yKey","CartesianSeries","contextNodeData","_contextNodeData","pathsPerSeries","hasMarkers","hasHighlightedLabels","pathsZIndexSubOrderOffset","datumSelectionGarbageCollection","markerSelectionGarbageCollection","otherOpts","useSeriesGroupLayer","markerFactory","highlightLabelSelection","annotationSelections","subGroups","subGroupId","onLegendItemDoubleClick","previousContextData","seriesHighlighted","highlightItems","updateHighlightSelection","animationData","anySeriesItemEnabled","isPathOrSelectionDirty","animationValid","updateSeriesGroups","updateSeriesGroupSelections","subGroup","seriesIdx","datumSelection","markerSelection","contextData","updatePaths","updateDatumSelection","updateLabelSelection","updateMarkerSelection","MarkerShape","dataNodeGroup","markerGroup","totalGroups","pathOffset","superFn","highlightedItems","subGroupOpacity","updateMarkerNodes","isHighlight","updateDatumNodes","updateLabelNodes","subGroupVisible","updatePathNodes","getHighlightLabelData","highlightedItem","labelItem","ld","getHighlightData","_nodeData","labelItems","labelsEnabled","isLabelEnabled","updateHighlightSelectionItem","updateHighlightSelectionLabel","pickNodeExact","xAxis","yAxis","hitPoint","minDistance","closestDatum","datumX","datumY","modPick","pickNodeNearest","requireCategoryAxis","primaryDirection","hitPointCoords","newMinDistance","closestDistanceSquared","matchedLegendItemName","totalVisibleItems","shouldFlipXY","datumSelections","markerSelections","calculateScaling","addScale","CartesianChart","paired","_lastAxisWidths","_lastVisibility","_super","seriesPaddedRect","inputShrinkRect","axisWidths","liveAxisWidths","stableOutputs","otherAxisWidths","otherVisibility","otherW","ceilValues","records","out","lastPassAxisWidths","lastPassVisibility","primaryTickCounts","updateAxesPass","clipRectPadding","lastPassSeriesRect","visited","newAxisWidths","paddedBounds","applySeriesPadding","crossLinePadding","buildCrossLinePadding","axisBound","buildAxisBound","buildSeriesRect","newClipSeries","axisThickness","axisOffset","calculateAxisDimensions","addInterAxisPadding","positionAxis","side","reversedAxes","dir","horizontalPadding","verticalPadding","clampToOutsideSeriesRect","dimension","clampBounds","axisLeftRightRange","rangeClipped","paddedBoundsCoefficient","axisPadding","AgChartInstanceProxy","isInstance","validateImplementation","chartProps","signatureProps","calculateNiceSecondaryAxis","calculateNiceStart","segments","order","magnitude","stepPower","calculateNextNiceStep","NumberAxisTick","NumberAxis","NON_ZERO_NUMBER","LogAxis","isInverted","crossesZero","hasZeroExtent","invalidDomain","TimeAxisTick","TimeAxis","datumFormat","datumFormatter","_min","AXIS_CONSTRUCTORS","registerAxis","axisType","getAxis","axisConstructor","AXIS_TYPES","axesTypes","AXIS_THEME_TEMPLATES","registerAxisThemeTemplate","theme","getAxisThemeTemplate","EXPECTED_ENTERPRISE_MODULES","chartTypes","optionsInnerKey","isEnterpriseSeriesType","getEnterpriseSeriesChartTypes","isEnterpriseSeriesTypeLoaded","useCount","isEnterpriseCartesian","isEnterprisePolar","isEnterpriseHierarchy","verifyIfModuleExpected","stub","getUnusedExpectedModules","LEGEND_KEYS","category","registerLegend","LEGEND_THEME_TEMPLATES","getLegendThemeTemplates","getLegendKeys","Background","rectNode","onLayoutComplete","BackgroundModule","NavigatorHandle","rh","gripLineGap","gripLineLength","rangeHandle","NavigatorMask","rm","rangeMask","RangeHandle","_fill","_stroke","_strokeWidth","_lineCap","_centerX","_centerY","_gripLineGap","_gripLineLength","ax","ay","axw","ayh","markDirtyOnChange","RangeMask","minRange","onRangeChange","computeVisibleRangeBBox","maxX","RangeSelector","updateHandles","minHandle","maxHandle","Navigator","rs","minHandleDragging","maxHandleDragging","panHandleOffset","interactionOpts","onDragStart","onDrag","onDragStop","navigatorTotalHeight","getRatio","stopHandleDragging","NavigatorModule","themeTemplate","singleSeriesPaletteFactory","takeColors","markerPaletteFactory","FONT_SIZE","SMALL","MEDIUM","LARGE","BOLD","NORMAL","BOTTOM","LEFT","TOP","CARTESIAN_AXIS_POSITIONS","CATEGORY","NUMBER","TIME","LOG","CARTESIAN_AXIS_TYPES","ANGLE_CATEGORY","ANGLE_NUMBER","RADIUS_CATEGORY","RADIUS_NUMBER","POLAR_AXIS_TYPES","CIRCLE","TYPES","DEFAULTS","CHART_TYPES","isCartesian","isPolar","isHierarchy","seriesTypes","cartesianTypes","polarTypes","hierarchyTypes","registerChartSeriesType","chartType","registerChartDefaults","getChartDefaults","getChartType","optionsType","isAgCartesianChartOptions","specifiedType","isAgHierarchyChartOptions","isAgPolarChartOptions","isSeriesOptionType","isAxisOptionType","DEFAULT_CARTESIAN_CHART_OVERRIDES","swapAxes","axis0","axis1","resolveModuleConflicts","conflictOverrides","conflicts","conflict","EXTENDS_CHART_DEFAULTS","EXTENDS_LEGEND_DEFAULTS","EXTENDS_LEGEND_ITEM_DEFAULTS","EXTENDS_LEGEND_ITEM_MARKER_DEFAULTS","EXTENDS_AXES_DEFAULTS","EXTENDS_AXES_LABEL_DEFAULTS","EXTENDS_AXES_LINE_DEFAULTS","EXTENDS_AXES_TICK_DEFAULTS","EXTENDS_AXES_GRID_LINE_DEFAULTS","EXTENDS_SERIES_DEFAULTS","EXTENDS_CARTESIAN_MARKER_DEFAULTS","OVERRIDE_SERIES_LABEL_DEFAULTS","DEFAULT_FONT_FAMILY","DEFAULT_LABEL_COLOUR","DEFAULT_INVERTED_LABEL_COLOUR","DEFAULT_INSIDE_SERIES_LABEL_COLOUR","DEFAULT_MUTED_LABEL_COLOUR","DEFAULT_AXIS_GRID_COLOUR","DEFAULT_AXIS_LINE_COLOUR","DEFAULT_CROSS_LINES_COLOUR","DEFAULT_BACKGROUND_COLOUR","DEFAULT_SHADOW_COLOUR","DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS","DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS","DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS","DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE","DEFAULT_POLAR_SERIES_STROKE","DEFAULT_DIVERGING_SERIES_COLOUR_RANGE","DEFAULT_HIERARCHY_FILLS","DEFAULT_HIERARCHY_STROKES","pathMotion","addPhaseFn","updatePhaseFn","removePhaseFn","phase","updateFn","preInit","MARKER_SHAPE","SeriesMarker","getDiameter","markerFadeInAnimation","markerScaleInAnimation","markerSwipeScaleInAnimation","seriesWidth","tweakFactor","delayRatio","resetMarkerFn","resetMarkerPositionFn","prepareMarkerAnimation","pairMap","parentStatus","readFirstPair","xValue","markerStatus","minMax","intersectionOnLine","targetX","backfillPathPoint","process","processFn","prevMarkerIdx","nextMarkerIdx","toProcess","backfillPathPointData","splitMode","sIdx","eIdx","calculatePoint","xd","yd","xr","yr","renderPartialPath","pairData","ratios","linePath","previousTo","moveToRatio","midPointX","midPointY","pathSwipeInAnimation","pathFadeInAnimation","pathFadeOutAnimation","buildResetPathFn","scaling","domainRatio","matchingIndex","closeMatch","an","bn","calculateMoveTo","pairContinuousData","newData","oldData","backfillSplitMode","toNewScale","oldDatum","scales","yValue","toOldScale","resultMap","pairUp","resultPoint","oldIdx","newIdx","minFromNode","maxFromNode","minToNode","maxToNode","fromShifted","toUnshifted","NA","pairCategoryData","multiDatum","resultMapSingle","resultMapMulti","previousResultPoint","previousXValue","addToResultMap","oldIndex","newIndex","isXUnordered","before","after","previousX","pathPoint","determinePathStatus","prepareLinePathPropertyAnimation","visibleToggleMode","_path","mixin","prepareLinePathAnimationFns","move","in","pathProperties","prepareLinePathAnimation","isCategoryBased","pathFns","AreaSeriesTag","splitFillPoints","points","fillData","prepPoints","pairFillCategoryData","oldPoints","newPoints","pairOpts","pairFillContinuousData","prepareAreaPathAnimation","prepareMarkerPairs","prepareFillPairs","markerPairMap","AreaSeries","xName","normalizedTo","common","keyDef","yExtent","fixedYExtent","groupedData","seriesFill","seriesStroke","xScale","yScale","continuousY","createMovePoint","plainPoint","createPathCoordinates","lastYEnd","prevYCoordinate","currYCoordinate","createMarkerCoordinate","xDatum","rawYDatum","currY","normalized","normalizedAndValid","markerData","strokeData","fillPoints","fillPhantomPoints","strokePoints","datumIdx","lastXDatum","lastYDatum","datumGroup","datumArray","valuesArray","seriesDatum","dataValues","yValueRaw","yDatum","yValueCumulative","yValueStart","yValueEnd","yValuePreviousStart","yValuePreviousEnd","validPoint","cumulativeValue","yName","prevTop","prevBottom","xValid","Stroke","Fill","updateClipPath","updateAreaPaths","updateFillPath","updateStrokePath","contextDataIndex","fillPath","strokePath","baseStyle","labelEnabled","xString","yString","flat","AreaSeriesModule","stackable","seriesDefaults","__extends__","paletteFactory","AbstractBarSeries","getBarDirection","getCategoryDirection","getValueAxis","getCategoryAxis","updateRect","getRectConfig","isHighlighted","checkCrisp","visibleMin","visibleMax","isZoomed","collapsedStartingBarPosition","isVertical","startingX","startingY","getStartingValues","isDatumNegative","prevDatum","midpointStartingBarPosition","prepareBarAnimationFunctions","initPos","isRemoved","resetBarSelectionsFn","updateLabelNode","textNode","adjustLabelPlacement","placement","BarSeriesNodeTag","BarSeriesLabel","BarSeries","stackGroup","groupScale","smallestDataInterval","normalizedToAbs","stackGroupName","stackGroupTrailingName","visibleProps","smallestKeyInterval","smallestX","categoryAxis","valueAxis","scalePadding","keysExtent","xBandWidth","groupIdx","barWidth","xIndex","yRawIndex","yStartIndex","yEndIndex","prevY","yRawValue","barX","bottomY","barAlongX","labelFontStyle","labelFontWeight","labelFontSize","labelFontFamily","lengthRatioMultiplier","capDefaults","lengthMax","Bar","itemHighlightStyle","categoryAlongX","BarSeriesModule","groupable","swapDefaultAxesCondition","enterpriseThemeTemplate","errorBar","cap","lengthRatio","BubbleSeriesNodeClickEvent","sizeKey","BubbleSeriesMarker","maxSize","BubbleSeries","sizeScale","labelKey","sizeName","labelName","colorKey","colorName","colorRange","colorDomain","sizeKeyIdx","processedSize","colorKeyIdx","dataDef","xDataIdx","yDataIdx","sizeDataIdx","colorDataIdx","labelDataIdx","sizeValue","placedLabels","placedNodeDatum","BubbleSeriesModule","HISTOGRAM_AGGREGATIONS","HISTOGRAM_AGGREGATION","HistogramSeriesNodeTag","defaultBinCount","HistogramSeries","areaPlot","aggregation","binCount","calculatedBins","deriveBins","xDomain","binStarts","binSize","firstBinEnd","expandStartToBin","calculateNiceBins","startGuess","getBins","bins","aggProp","dataSet","xExtent","nextBin","yDomain","xDomainMin","xDomainMax","negativeAgg","positiveAgg","frequency","xMinPx","xMaxPx","yZeroPx","yMaxPx","selectionDatumLabel","nodeMidPoint","aggregatedValue","Bin","seriesFillOpacity","highlightedFill","highlightFillOpacity","highlightedStroke","highlightedDatumStrokeWidth","HistogramSeriesModule","LineSeries","xDef","xIdx","yIdx","nextPoint","updateLinePaths","LineSeriesModule","ScatterSeries","ScatterSeriesModule","PieSeriesModule","colorsCount","userPalette","registerInbuiltModules","invertShapeDirection","supportedShapes","HierarchyNode","colorValue","sumSize","walk","Walk","PreOrder","PostOrder","HierarchySeries","childrenKey","rootNode","maxDepth","getIndex","minColor","maxColor","appendChildren","groupSelection","PolarAxis","__FORCE_MODULE_DETECTION","moduleSupport","Motion","SERIES_FACTORIES","SERIES_DEFAULTS","SERIES_THEME_TEMPLATES","ENTERPRISE_SERIES_THEME_TEMPLATES","SERIES_PALETTE_FACTORIES","SOLO_SERIES_TYPES","STACKABLE_SERIES_TYPES","GROUPABLE_SERIES_TYPES","STACKED_BY_DEFAULT_SERIES_TYPES","SWAP_DEFAULT_AXES_CONDITIONS","CUSTOM_DEFAULTS_FUNCTIONS","cstr","enterpriseTheme","solo","stackedByDefault","customDefaultsFunction","registerSeriesThemeTemplate","addSeriesPaletteFactory","addSoloSeriesType","addStackableSeriesType","addGroupableSeriesType","addStackedByDefaultSeriesType","addSwapDefaultAxesCondition","addCustomDefaultsFunctions","existingTemplate","seriesConstructor","getSeriesDefaults","getSeriesThemeTemplate","factory","getSeriesPaletteFactory","isSoloSeries","isStackableSeries","isGroupableSeries","isSeriesStackedByDefault","isDefaultAxisSwapNeeded","isDefaultAxisSwapped","executeCustomDefaultsFunctions","initialDefaults","setupModules","optionConstructors","axisTypes","axisTypeTheme","expectedButUnused","HierarchyChart","fullSeriesRect","removeUsedEnterpriseOptions","usedOptions","optionsChartType","optionValue","groupSeriesByType","seriesOptions","groupMap","stackMap","anyStacked","defaultUnstackedGroup","stacked","sStacked","sStackGroup","sGrouped","groupingKey","indexKey","processSeriesOptions","preprocessed","sType","addSeriesGroupingMeta","stackIdx","stackIndex","stackCount","DEFAULT_BACKGROUND_FILL","palette$9","CHART_TYPE_CONFIG","cartesian","commonOptions","polar","hierarchy","CHART_TYPE_SPECIFIC_COMMON_OPTIONS","ChartTheme","getPalette","getAxisDefaults","getCartesianSeriesMarkerDefaults","getLegendItemMarkerDefaults","getCaptionWrappingDefaults","background","palette","createChartConfigPerChartType","getDefaults","applyOverrides","overrideOpts","cleanedCommon","commonKey","templateTheme","nextType","typeDefaults","alias","getChartTypeDefaults","getOverridesByType","chartDefaults","template","cartesianAxisDefault","themeInstance","extensions","getTemplateParameters","getWaterfallSeriesDefaultPositiveColors","getWaterfallSeriesDefaultNegativeColors","getWaterfallSeriesDefaultTotalColors","DEFAULT_DARK_BACKGROUND_FILL","DEFAULT_DARK_FILLS","DEFAULT_DARK_STROKES","palette$8","DarkTheme","MATERIAL_DARK_FILLS","MATERIAL_DARK_STROKES","palette$7","MaterialDark","MATERIAL_LIGHT_FILLS","MATERIAL_LIGHT_STROKES","palette$6","MaterialLight","POLYCHROMA_DARK_FILLS","PURPLE","PINK","MODERATE_BLUE","POLYCHROMA_DARK_STROKES","POLYCHROMA_DARK_FILL_GRAY","POLYCHROMA_DARK_STROKE_GRAY","palette$5","PolychromaDark","POLYCHROMA_LIGHT_FILLS","POLYCHROMA_LIGHT_STROKES","POLYCHROMA_LIGHT_FILL_GRAY","POLYCHROMA_LIGHT_STROKE_GRAY","palette$4","PolychromaLight","SHEETS_DARK_FILLS","DARK_GRAY","DARK_BLUE","VERY_DARK_GRAY","DARK_YELLOW","SHEETS_DARK_STROKES","palette$3","SheetsDark","SHEETS_LIGHT_FILLS","SHEETS_LIGHT_STROKES","palette$2","SheetsLight","VIVID_DARK_FILLS","VIVID_DARK_STROKES","palette$1","VividDark","VIVID_FILLS","VIVID_STROKES","VividLight","lightTheme","darkTheme","lightThemes","null","ag-sheets","ag-polychroma","ag-vivid","ag-material","darkThemes","ag-sheets-dark","ag-polychroma-dark","ag-vivid-dark","ag-material-dark","themes$1","validateChartThemeObject","unknownObject","baseTheme","validateChartTheme","getChartTheme","unvalidatedValue","stockTheme","flattenedTheme","takeColours","colours","colourIndex","noDataCloneMergeOptions","getGlobalTooltipPositionOptions","AgTooltipPositionTypeMap","pointer","isTooltipPositionType","prepareOptions","sanityCheckOptions","globalTooltipPositionOptions","checkSeriesType","validateSoloSeries","defaultSeriesType","defaultOverrides","removeDisabledOptions","mergedOptions","axesThemes","seriesThemes","prepareMainOptions","mergedSeries","mergeSeriesOptions","preparePieOptions","pie","prepareSeries","checkAxisType","isAxisType","validAxesTypes","axisSource","axisDefaults","axesTheme","prepareAxis","prepareLegendEnabledOption","prepareEnabledOptions","deprecatedArrayProps","yKeys","yNames","oldProp","newProp","hasSoloSeries","mergedTooltipPosition","cleanedTheme","prepareTheme","themeConfig","userTheme","paletteOptions","calculateSeriesPalette","removeOptions","themeTemplateParameters","axisTheme","crossLinesTheme","cleanTheme","visitingUserOpts","visitingMergedOpts","_enabledFromTheme","pieSeriesTheme","PolarChart","AXIS_FOREGROUND_ZINDEX","computeSeriesRect","computeCircle","angleAxis","radiusAxis","angles","computeRange","gridAngles","gridRange","seriesBox","polarSeries","polarAxes","setSeriesCircle","pieSeries","innerRadii","initialRadius","shake","labelBoxes","refined","refineCircle","labelsBox","minCircleRatio","circleLeft","circleTop","circleRight","circleBottom","padTop","padBottom","availCircleWidth","availCircleHeight","newRadius","minHorizontalRadius","minVerticalRadius","minRadius","padHeight","newWidth","newHeight","AgCharts","licenseCheck","licenseChecked","licenseManager","setLicenseKey","licenseKey","validateLicense","AgChartsInternal","createOrUpdate","isDisplayWatermark","injectWatermark","getWatermarkMessage","INVALID_CHART_REF_MESSAGE","updateDelta","deltaOptions","updateUserDelta","getImageDataURL","AgChart","warnDeprecated","memberName","initialiseModules","initialised","proxy","userWindow","chartOptions","createChartInstance","agChartInstances","chartToUpdate","dequeue","queuedOptionsIdx","asyncDownload","maybeClone","prepareResizedChart","currentWidth","currentHeight","clonedChart","oldChart","transferableResource","applyChartOptions","completeOptions","modulesChanged","applyModules","registerListeners","applyOptionValues","seriesRecreated","applySeries","axesPresent","applyAxes","seriesDataUpdate","legendKeys","optionsHaveLegend","legendKey","otherRefreshUpdate","majorChange","updateType","matchingChartType","processModules","moduleType","shouldBeEnabled","optSeries","keysToConsider","matchingTypes","previousOpts","seriesDiff","applySeriesValues","createSeries","forceRecreate","optAxes","oldOpts","axisDiff","createAxis","seriesInstance","applySeriesOptionModules","seriesOptionModules","supportedSeriesTypes","axisOptions","applyAxisModules","rootModules","applyOpts","jsonApplyOptions","ctrs","seriesTypeOverrides","VERSION","themes","integratedChartsTheme","sparklinesScale","_ModuleSupport","_Scale","_Scene","_Theme","_Util"],"sources":["/Users/elyhlapetina/Documents/GitHub/FinView/node_modules/ag-charts-community/dist/package/main.esm.js"],"sourcesContent":["const AgErrorBarSupportedSeriesTypes = ['bar', 'line', 'scatter'];\n\n/**\r\n * Internal Use Only: Used to ensure this file is treated as a module until we can use moduleDetection flag in Ts v4.7\r\n */\r\nconst __FORCE_MODULE_DETECTION$1 = 0;\n\n/**\r\n * The interval methods don't mutate Date parameters.\r\n */\r\nclass TimeInterval {\r\n    constructor(_encode, _decode, _rangeCallback) {\r\n        this._encode = _encode;\r\n        this._decode = _decode;\r\n        this._rangeCallback = _rangeCallback;\r\n    }\r\n    /**\r\n     * Returns a new date representing the latest interval boundary date before or equal to date.\r\n     * For example, `day.floor(date)` typically returns 12:00 AM local time on the given date.\r\n     * @param date\r\n     */\r\n    floor(date) {\r\n        const d = new Date(date);\r\n        const e = this._encode(d);\r\n        return this._decode(e);\r\n    }\r\n    /**\r\n     * Returns a new date representing the earliest interval boundary date after or equal to date.\r\n     * @param date\r\n     */\r\n    ceil(date) {\r\n        const d = new Date(Number(date) - 1);\r\n        const e = this._encode(d);\r\n        return this._decode(e + 1);\r\n    }\r\n    /**\r\n     * Returns an array of dates representing every interval boundary after or equal to start (inclusive) and before stop (exclusive).\r\n     * @param start Range start.\r\n     * @param stop Range end.\r\n     * @param extend If specified, the requested range will be extended to the closest \"nice\" values.\r\n     */\r\n    range(start, stop, extend) {\r\n        var _a;\r\n        const rangeCallback = (_a = this._rangeCallback) === null || _a === void 0 ? void 0 : _a.call(this, start, stop);\r\n        const e0 = this._encode(extend ? this.floor(start) : this.ceil(start));\r\n        const e1 = this._encode(extend ? this.ceil(stop) : this.floor(stop));\r\n        if (e1 < e0) {\r\n            return [];\r\n        }\r\n        const range = [];\r\n        for (let e = e0; e <= e1; e++) {\r\n            const d = this._decode(e);\r\n            range.push(d);\r\n        }\r\n        rangeCallback === null || rangeCallback === void 0 ? void 0 : rangeCallback();\r\n        return range;\r\n    }\r\n}\r\nclass CountableTimeInterval extends TimeInterval {\r\n    getOffset(snapTo, step) {\r\n        const s = typeof snapTo === 'number' || snapTo instanceof Date ? this._encode(new Date(snapTo)) : 0;\r\n        return Math.floor(s) % step;\r\n    }\r\n    /**\r\n     * Returns a filtered view of this interval representing every step'th date.\r\n     * It can be a number of minutes, hours, days etc.\r\n     * Must be a positive integer.\r\n     * @param step\r\n     */\r\n    every(step, options) {\r\n        let offset = 0;\r\n        let rangeCallback;\r\n        const { snapTo = 'start' } = options !== null && options !== void 0 ? options : {};\r\n        if (typeof snapTo === 'string') {\r\n            const initialOffset = offset;\r\n            rangeCallback = (start, stop) => {\r\n                const s = snapTo === 'start' ? start : stop;\r\n                offset = this.getOffset(s, step);\r\n                return () => (offset = initialOffset);\r\n            };\r\n        }\r\n        else if (typeof snapTo === 'number') {\r\n            offset = this.getOffset(new Date(snapTo), step);\r\n        }\r\n        else if (snapTo instanceof Date) {\r\n            offset = this.getOffset(snapTo, step);\r\n        }\r\n        const encode = (date) => {\r\n            const e = this._encode(date);\r\n            return Math.floor((e - offset) / step);\r\n        };\r\n        const decode = (encoded) => {\r\n            return this._decode(encoded * step + offset);\r\n        };\r\n        return new TimeInterval(encode, decode, rangeCallback);\r\n    }\r\n}\n\nfunction encode$b(date) {\r\n    return date.getTime();\r\n}\r\nfunction decode$b(encoded) {\r\n    return new Date(encoded);\r\n}\r\nconst millisecond = new CountableTimeInterval(encode$b, decode$b);\n\n// Common time unit sizes in milliseconds.\r\nnew Date(0).getFullYear();\r\nconst durationSecond = 1000;\r\nconst durationMinute = durationSecond * 60;\r\nconst durationHour = durationMinute * 60;\r\nconst durationDay = durationHour * 24;\r\nconst durationWeek = durationDay * 7;\r\nconst durationMonth = durationDay * 30;\r\nconst durationYear = durationDay * 365;\n\nconst offset$2 = new Date().getTimezoneOffset() * durationMinute;\r\nfunction encode$a(date) {\r\n    return Math.floor((date.getTime() - offset$2) / durationSecond);\r\n}\r\nfunction decode$a(encoded) {\r\n    return new Date(offset$2 + encoded * durationSecond);\r\n}\r\nconst second = new CountableTimeInterval(encode$a, decode$a);\n\nconst offset$1 = new Date().getTimezoneOffset() * durationMinute;\r\nfunction encode$9(date) {\r\n    return Math.floor((date.getTime() - offset$1) / durationMinute);\r\n}\r\nfunction decode$9(encoded) {\r\n    return new Date(offset$1 + encoded * durationMinute);\r\n}\r\nconst minute = new CountableTimeInterval(encode$9, decode$9);\n\nconst offset = new Date().getTimezoneOffset() * durationMinute;\r\nfunction encode$8(date) {\r\n    return Math.floor((date.getTime() - offset) / durationHour);\r\n}\r\nfunction decode$8(encoded) {\r\n    return new Date(offset + encoded * durationHour);\r\n}\r\nconst hour = new CountableTimeInterval(encode$8, decode$8);\n\nfunction encode$7(date) {\r\n    const tzOffsetMs = date.getTimezoneOffset() * 60000;\r\n    return Math.floor((date.getTime() - tzOffsetMs) / durationDay);\r\n}\r\nfunction decode$7(encoded) {\r\n    const d = new Date(1970, 0, 1);\r\n    d.setDate(d.getDate() + encoded);\r\n    return d;\r\n}\r\nconst day = new CountableTimeInterval(encode$7, decode$7);\n\n// Set date to n-th day of the week.\r\nfunction weekday(n) {\r\n    const base = new Date(2023, 0, 1 + n).getTime();\r\n    function encode(date) {\r\n        const dateMs = date.getTime();\r\n        return Math.floor((dateMs - base) / durationWeek);\r\n    }\r\n    function decode(encoded) {\r\n        const d = new Date(base);\r\n        d.setDate(d.getDate() + encoded * 7);\r\n        return d;\r\n    }\r\n    return new CountableTimeInterval(encode, decode);\r\n}\r\nconst sunday = weekday(0);\r\nconst monday = weekday(1);\r\nconst tuesday = weekday(2);\r\nconst wednesday = weekday(3);\r\nconst thursday = weekday(4);\r\nconst friday = weekday(5);\r\nconst saturday = weekday(6);\n\nfunction encode$6(date) {\r\n    return date.getFullYear() * 12 + date.getMonth();\r\n}\r\nfunction decode$6(encoded) {\r\n    const year = Math.floor(encoded / 12);\r\n    const month = encoded - year * 12;\r\n    return new Date(year, month, 1);\r\n}\r\nconst month = new CountableTimeInterval(encode$6, decode$6);\n\nfunction encode$5(date) {\r\n    return date.getFullYear();\r\n}\r\nfunction decode$5(encoded) {\r\n    // Note: assigning years through the constructor\r\n    // will break for years 0 - 99 AD (will turn 1900's).\r\n    const d = new Date();\r\n    d.setFullYear(encoded);\r\n    d.setMonth(0, 1);\r\n    d.setHours(0, 0, 0, 0);\r\n    return d;\r\n}\r\nconst year = new CountableTimeInterval(encode$5, decode$5);\n\nfunction encode$4(date) {\r\n    return Math.floor(date.getTime() / durationMinute);\r\n}\r\nfunction decode$4(encoded) {\r\n    return new Date(encoded * durationMinute);\r\n}\r\nconst utcMinute = new CountableTimeInterval(encode$4, decode$4);\n\nfunction encode$3(date) {\r\n    return Math.floor(date.getTime() / durationHour);\r\n}\r\nfunction decode$3(encoded) {\r\n    return new Date(encoded * durationHour);\r\n}\r\nconst utcHour = new CountableTimeInterval(encode$3, decode$3);\n\nfunction encode$2(date) {\r\n    return Math.floor(date.getTime() / durationDay);\r\n}\r\nfunction decode$2(encoded) {\r\n    const d = new Date(0);\r\n    d.setUTCDate(d.getUTCDate() + encoded);\r\n    d.setUTCHours(0, 0, 0, 0);\r\n    return d;\r\n}\r\nconst utcDay = new CountableTimeInterval(encode$2, decode$2);\n\nfunction encode$1(date) {\r\n    return date.getUTCFullYear() * 12 + date.getUTCMonth();\r\n}\r\nfunction decode$1(encoded) {\r\n    const year = Math.floor(encoded / 12);\r\n    const month = encoded - year * 12;\r\n    return new Date(Date.UTC(year, month, 1));\r\n}\r\nconst utcMonth = new CountableTimeInterval(encode$1, decode$1);\n\nfunction encode(date) {\r\n    return date.getUTCFullYear();\r\n}\r\nfunction decode(encoded) {\r\n    // Note: assigning years through the constructor\r\n    // will break for years 0 - 99 AD (will turn 1900's).\r\n    const d = new Date();\r\n    d.setUTCFullYear(encoded);\r\n    d.setUTCMonth(0, 1);\r\n    d.setUTCHours(0, 0, 0, 0);\r\n    return d;\r\n}\r\nconst utcYear = new CountableTimeInterval(encode, decode);\n\nvar index = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    millisecond: millisecond,\n    second: second,\n    minute: minute,\n    hour: hour,\n    day: day,\n    sunday: sunday,\n    monday: monday,\n    tuesday: tuesday,\n    wednesday: wednesday,\n    thursday: thursday,\n    friday: friday,\n    saturday: saturday,\n    month: month,\n    year: year,\n    utcMinute: utcMinute,\n    utcHour: utcHour,\n    utcDay: utcDay,\n    utcMonth: utcMonth,\n    utcYear: utcYear\n});\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\ntypeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\r\n    var e = new Error(message);\r\n    return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\r\n};\n\nconst enterpriseModule = {\r\n    isEnterprise: false,\r\n};\n\nclass BaseModuleInstance {\r\n    constructor() {\r\n        this.destroyFns = [];\r\n    }\r\n    destroy() {\r\n        for (const destroyFn of this.destroyFns) {\r\n            destroyFn();\r\n        }\r\n    }\r\n}\r\nconst REGISTERED_MODULES = [];\r\nfunction registerModule(module) {\r\n    const otherModule = REGISTERED_MODULES.find((other) => {\r\n        return (module.type === other.type &&\r\n            module.optionsKey === other.optionsKey &&\r\n            module.identifier === other.identifier);\r\n    });\r\n    if (otherModule) {\r\n        if (module.packageType === 'enterprise' && otherModule.packageType === 'community') {\r\n            // Replace the community module with an enterprise version\r\n            const index = REGISTERED_MODULES.indexOf(otherModule);\r\n            REGISTERED_MODULES.splice(index, 1, module);\r\n        }\r\n    }\r\n    else {\r\n        // Simply register the module\r\n        REGISTERED_MODULES.push(module);\r\n    }\r\n}\r\nfunction hasRegisteredEnterpriseModules() {\r\n    return REGISTERED_MODULES.some((m) => m.packageType === 'enterprise');\r\n}\r\nconst MODULE_CONFLICTS = new Map();\r\nfunction registerModuleConflicts(source, targets) {\r\n    MODULE_CONFLICTS.set(source, targets);\r\n}\n\nfunction extent(values) {\r\n    const { length } = values;\r\n    if (length === 0) {\r\n        return undefined;\r\n    }\r\n    let min = Infinity;\r\n    let max = -Infinity;\r\n    for (let i = 0; i < length; i++) {\r\n        let v = values[i];\r\n        if (v instanceof Date) {\r\n            v = v.getTime();\r\n        }\r\n        if (typeof v !== 'number') {\r\n            continue;\r\n        }\r\n        if (v < min) {\r\n            min = v;\r\n        }\r\n        if (v > max) {\r\n            max = v;\r\n        }\r\n    }\r\n    const extent = [min, max];\r\n    if (extent.some((v) => !isFinite(v))) {\r\n        return undefined;\r\n    }\r\n    return extent;\r\n}\r\nfunction normalisedExtent(d, min, max) {\r\n    return normalisedExtentWithMetadata(d, min, max).extent;\r\n}\r\nfunction normalisedExtentWithMetadata(d, min, max) {\r\n    var _a;\r\n    let clipped = false;\r\n    if (d.length > 2) {\r\n        d = (_a = extent(d)) !== null && _a !== void 0 ? _a : [NaN, NaN];\r\n    }\r\n    if (!isNaN(min)) {\r\n        clipped || (clipped = min > d[0]);\r\n        d = [min, d[1]];\r\n    }\r\n    if (!isNaN(max)) {\r\n        clipped || (clipped = max < d[1]);\r\n        d = [d[0], max];\r\n    }\r\n    if (d[0] > d[1]) {\r\n        d = [];\r\n    }\r\n    return { extent: d, clipped };\r\n}\r\nfunction arraysEqual(a, b) {\r\n    if (a == null || b == null || a.length !== b.length) {\r\n        return false;\r\n    }\r\n    for (let i = 0; i < a.length; i++) {\r\n        if (Array.isArray(a[i]) && Array.isArray(b[i])) {\r\n            if (!arraysEqual(a[i], b[i])) {\r\n                return false;\r\n            }\r\n        }\r\n        else if (a[i] !== b[i]) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}\r\nfunction toArray(value) {\r\n    if (typeof value === 'undefined') {\r\n        return [];\r\n    }\r\n    return Array.isArray(value) ? value : [value];\r\n}\n\nconst doOnceFlags = {};\r\n/**\r\n * If the key was passed before, then doesn't execute the func\r\n */\r\nfunction doOnce(func, key) {\r\n    if (doOnceFlags[key]) {\r\n        return;\r\n    }\r\n    func();\r\n    doOnceFlags[key] = true;\r\n}\n\n/* eslint-disable no-console */\r\nconst Logger = {\r\n    log(...logContent) {\r\n        console.log(...logContent);\r\n    },\r\n    warn(message, ...logContent) {\r\n        console.warn(`AG Charts - ${message}`, ...logContent);\r\n    },\r\n    error(message, ...logContent) {\r\n        if (typeof message === 'object') {\r\n            console.error(`AG Charts error`, message, ...logContent);\r\n        }\r\n        else {\r\n            console.error(`AG Charts - ${message}`, ...logContent);\r\n        }\r\n    },\r\n    table(...logContent) {\r\n        console.table(...logContent);\r\n    },\r\n    warnOnce(message, ...logContent) {\r\n        doOnce(() => Logger.warn(message, ...logContent), `Logger.warn: ${message}`);\r\n    },\r\n    errorOnce(message, ...logContent) {\r\n        doOnce(() => Logger.error(message, ...logContent), `Logger.warn: ${message}`);\r\n    },\r\n};\n\nfunction windowValue(name) {\r\n    /**\r\n     * Redeclaration of window that is safe for use with Gatsby server-side (webpack) compilation.\r\n     */\r\n    const WINDOW = typeof window !== 'undefined'\r\n        ? window\r\n        : // typeof global !== 'undefined' ? (global as any) :\r\n            undefined;\r\n    return WINDOW === null || WINDOW === void 0 ? void 0 : WINDOW[name];\r\n}\n\nconst LONG_TIME_PERIOD_THRESHOLD = 2000;\r\nlet timeOfLastLog = Date.now();\r\nconst logTimeGap = () => {\r\n    const timeSinceLastLog = Date.now() - timeOfLastLog;\r\n    if (timeSinceLastLog > LONG_TIME_PERIOD_THRESHOLD) {\r\n        const prettyDuration = (Math.floor(timeSinceLastLog / 100) / 10).toFixed(1);\r\n        Logger.log(`**** ${prettyDuration}s since last log message ****`);\r\n    }\r\n    timeOfLastLog = Date.now();\r\n};\r\nconst Debug = {\r\n    create(...debugSelectors) {\r\n        return (...logContent) => {\r\n            if (Debug.check(...debugSelectors)) {\r\n                if (typeof logContent[0] === 'function') {\r\n                    logContent = toArray(logContent[0]());\r\n                }\r\n                logTimeGap();\r\n                Logger.log(...logContent);\r\n            }\r\n        };\r\n    },\r\n    check(...debugSelectors) {\r\n        if (debugSelectors.length === 0) {\r\n            debugSelectors.push(true);\r\n        }\r\n        const chartDebug = toArray(windowValue('agChartsDebug'));\r\n        return chartDebug.some((selector) => debugSelectors.includes(selector));\r\n    },\r\n};\n\nconst BREAK_TRANSFORM_CHAIN = Symbol('BREAK');\r\nconst CONFIG_KEY = '__decorator_config';\r\nfunction initialiseConfig(target, propertyKeyOrSymbol, propertyKey, valueStoreKey) {\r\n    if (Object.getOwnPropertyDescriptor(target, CONFIG_KEY) == null) {\r\n        Object.defineProperty(target, CONFIG_KEY, { value: {} });\r\n    }\r\n    const config = target[CONFIG_KEY];\r\n    if (config[propertyKey] != null) {\r\n        return config[propertyKey];\r\n    }\r\n    config[propertyKey] = { setters: [], getters: [] };\r\n    const descriptor = Object.getOwnPropertyDescriptor(target, propertyKeyOrSymbol);\r\n    const prevSet = descriptor === null || descriptor === void 0 ? void 0 : descriptor.set;\r\n    const prevGet = descriptor === null || descriptor === void 0 ? void 0 : descriptor.get;\r\n    const getter = function () {\r\n        var _a, _b;\r\n        let value = prevGet ? prevGet.call(this) : this[valueStoreKey];\r\n        for (const transformFn of (_b = (_a = config[propertyKey]) === null || _a === void 0 ? void 0 : _a.getters) !== null && _b !== void 0 ? _b : []) {\r\n            value = transformFn(this, propertyKeyOrSymbol, value);\r\n            if (value === BREAK_TRANSFORM_CHAIN) {\r\n                return undefined;\r\n            }\r\n        }\r\n        return value;\r\n    };\r\n    const setter = function (value) {\r\n        var _a, _b;\r\n        const setters = (_b = (_a = config[propertyKey]) === null || _a === void 0 ? void 0 : _a.setters) !== null && _b !== void 0 ? _b : [];\r\n        let oldValue;\r\n        if (setters.some((f) => f.length > 2)) {\r\n            // Lazily retrieve old value.\r\n            oldValue = prevGet ? prevGet.call(this) : this[valueStoreKey];\r\n        }\r\n        for (const transformFn of setters) {\r\n            value = transformFn(this, propertyKeyOrSymbol, value, oldValue);\r\n            if (value === BREAK_TRANSFORM_CHAIN) {\r\n                return;\r\n            }\r\n        }\r\n        if (prevSet) {\r\n            prevSet.call(this, value);\r\n        }\r\n        else {\r\n            this[valueStoreKey] = value;\r\n        }\r\n    };\r\n    Object.defineProperty(target, propertyKeyOrSymbol, {\r\n        set: setter,\r\n        get: getter,\r\n        enumerable: true,\r\n        configurable: false,\r\n    });\r\n    return config[propertyKey];\r\n}\r\nfunction addTransformToInstanceProperty(setTransform, getTransform) {\r\n    return (target, propertyKeyOrSymbol) => {\r\n        const propertyKey = propertyKeyOrSymbol.toString();\r\n        const valueStoreKey = `__${propertyKey}`;\r\n        const { getters, setters } = initialiseConfig(target, propertyKeyOrSymbol, propertyKey, valueStoreKey);\r\n        setters.push(setTransform);\r\n        if (getTransform) {\r\n            getters.unshift(getTransform);\r\n        }\r\n    };\r\n}\r\nfunction isDecoratedObject(target) {\r\n    return typeof target !== 'undefined' && CONFIG_KEY in target;\r\n}\r\nfunction listDecoratedProperties(target) {\r\n    const targets = new Set();\r\n    while (isDecoratedObject(target)) {\r\n        targets.add(target === null || target === void 0 ? void 0 : target[CONFIG_KEY]);\r\n        target = Object.getPrototypeOf(target);\r\n    }\r\n    return Array.from(targets).flatMap((configMap) => Object.keys(configMap));\r\n}\r\nfunction extractDecoratedProperties(target) {\r\n    return listDecoratedProperties(target).reduce((result, key) => {\r\n        var _a;\r\n        result[key] = (_a = target[key]) !== null && _a !== void 0 ? _a : null;\r\n        return result;\r\n    }, {});\r\n}\n\nfunction createDeprecationWarning() {\r\n    return (key, message) => {\r\n        const msg = [`Property [${key}] is deprecated.`, message].filter((v) => v != null).join(' ');\r\n        Logger.warnOnce(msg);\r\n    };\r\n}\n\nconst CLASS_INSTANCE_TYPE = 'class-instance';\r\n/**\r\n * Performs a JSON-diff between a source and target JSON structure.\r\n *\r\n * On a per property basis, takes the target property value where:\r\n * - types are different.\r\n * - type is primitive.\r\n * - type is array and length or content have changed.\r\n *\r\n * Recurses for object types.\r\n *\r\n * @param source starting point for diff\r\n * @param target target for diff vs. source\r\n *\r\n * @returns `null` if no differences, or an object with the subset of properties that have changed.\r\n */\r\nfunction jsonDiff(source, target) {\r\n    const sourceType = classify(source);\r\n    const targetType = classify(target);\r\n    if (targetType === 'array') {\r\n        const targetArray = target;\r\n        if (sourceType !== 'array' || source.length !== targetArray.length) {\r\n            return [...targetArray];\r\n        }\r\n        if (targetArray.some((targetElement, i) => jsonDiff(source === null || source === void 0 ? void 0 : source[i], targetElement) != null)) {\r\n            return [...targetArray];\r\n        }\r\n        return null;\r\n    }\r\n    if (targetType === 'primitive') {\r\n        if (sourceType !== 'primitive') {\r\n            return Object.assign({}, target);\r\n        }\r\n        if (source !== target) {\r\n            return target;\r\n        }\r\n        return null;\r\n    }\r\n    const lhs = source || {};\r\n    const rhs = target || {};\r\n    const allProps = new Set([...Object.keys(lhs), ...Object.keys(rhs)]);\r\n    let propsChangedCount = 0;\r\n    const result = {};\r\n    for (const prop of allProps) {\r\n        // Cheap-and-easy equality check.\r\n        if (lhs[prop] === rhs[prop]) {\r\n            continue;\r\n        }\r\n        const take = (v) => {\r\n            result[prop] = v;\r\n            propsChangedCount++;\r\n        };\r\n        const lhsType = classify(lhs[prop]);\r\n        const rhsType = classify(rhs[prop]);\r\n        if (lhsType !== rhsType) {\r\n            // Types changed, just take RHS.\r\n            take(rhs[prop]);\r\n            continue;\r\n        }\r\n        if (rhsType === 'primitive' || rhsType === null) {\r\n            take(rhs[prop]);\r\n            continue;\r\n        }\r\n        if (rhsType === 'array' && lhs[prop].length !== rhs[prop].length) {\r\n            // Arrays are different sizes, so just take target array.\r\n            take(rhs[prop]);\r\n            continue;\r\n        }\r\n        if (rhsType === CLASS_INSTANCE_TYPE) {\r\n            // Don't try to do anything tricky with array diffs!\r\n            take(rhs[prop]);\r\n            continue;\r\n        }\r\n        if (rhsType === 'function' && lhs[prop] !== rhs[prop]) {\r\n            take(rhs[prop]);\r\n            continue;\r\n        }\r\n        const diff = jsonDiff(lhs[prop], rhs[prop]);\r\n        if (diff !== null) {\r\n            take(diff);\r\n        }\r\n    }\r\n    return propsChangedCount === 0 ? null : result;\r\n}\r\n/**\r\n * Special value used by `jsonMerge` to signal that a property should be removed from the merged\r\n * output.\r\n */\r\nconst DELETE = Symbol('<delete-property>');\r\nconst NOT_SPECIFIED = Symbol('<unspecified-property>');\r\n/**\r\n * Merge together the provide JSON object structures, with the precedence of application running\r\n * from higher indexes to lower indexes.\r\n *\r\n * Deep-clones all objects to avoid mutation of the inputs changing the output object. For arrays,\r\n * just performs a deep-clone of the entire array, no merging of elements attempted.\r\n *\r\n * @param json all json objects to merge\r\n * @param opts merge options\r\n * @param opts.avoidDeepClone contains a list of properties where deep clones should be avoided\r\n *\r\n * @returns the combination of all the json inputs\r\n */\r\nfunction jsonMerge(json, opts) {\r\n    var _a;\r\n    const avoidDeepClone = (_a = opts === null || opts === void 0 ? void 0 : opts.avoidDeepClone) !== null && _a !== void 0 ? _a : [];\r\n    const jsonTypes = json.map((v) => classify(v));\r\n    if (jsonTypes.some((v) => v === 'array')) {\r\n        // Clone final array.\r\n        const finalValue = json[json.length - 1];\r\n        if (Array.isArray(finalValue)) {\r\n            return finalValue.map((v) => {\r\n                const type = classify(v);\r\n                if (type === 'array')\r\n                    return jsonMerge([[], v], opts);\r\n                if (type === 'object')\r\n                    return jsonMerge([{}, v], opts);\r\n                return v;\r\n            });\r\n        }\r\n        return finalValue;\r\n    }\r\n    const result = {};\r\n    const props = new Set(json.map((v) => (v != null ? Object.keys(v) : [])).reduce((r, n) => r.concat(n), []));\r\n    for (const nextProp of props) {\r\n        const values = json\r\n            .map((j) => {\r\n            if (j != null && typeof j === 'object' && nextProp in j) {\r\n                return j[nextProp];\r\n            }\r\n            return NOT_SPECIFIED;\r\n        })\r\n            .filter((v) => v !== NOT_SPECIFIED);\r\n        if (values.length === 0) {\r\n            continue;\r\n        }\r\n        const lastValue = values[values.length - 1];\r\n        if (lastValue === DELETE) {\r\n            continue;\r\n        }\r\n        const types = values.map((v) => classify(v));\r\n        const type = types[0];\r\n        if (types.some((t) => t !== type)) {\r\n            // Short-circuit if mismatching types.\r\n            result[nextProp] = lastValue;\r\n            continue;\r\n        }\r\n        if ((type === 'array' || type === 'object') && !avoidDeepClone.includes(nextProp)) {\r\n            result[nextProp] = jsonMerge(values, opts);\r\n        }\r\n        else if (type === 'array') {\r\n            // Arrays need to be shallow copied to avoid external mutation and allow jsonDiff to\r\n            // detect changes.\r\n            result[nextProp] = [...lastValue];\r\n        }\r\n        else {\r\n            // Just directly assign/overwrite.\r\n            result[nextProp] = lastValue;\r\n        }\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Recursively apply a JSON object into a class-hierarchy, optionally instantiating certain classes\r\n * by property name.\r\n *\r\n * @param target to apply source JSON properties into\r\n * @param source to be applied\r\n * @param params\r\n * @param params.path path for logging/error purposes, to aid with pinpointing problems\r\n * @param params.matcherPath path for pattern matching, to lookup allowedTypes override.\r\n * @param params.skip property names to skip from the source\r\n * @param params.constructors dictionary of property name to class constructors for properties that\r\n *                            require object construction\r\n * @param params.constructedArrays map stores arrays which items should be initialised\r\n *                                 using a class constructor\r\n * @param params.allowedTypes overrides by path for allowed property types\r\n */\r\nfunction jsonApply(target, source, params = {}) {\r\n    var _a, _b, _c;\r\n    const { path = undefined, matcherPath = path ? path.replace(/(\\[[0-9+]+])/i, '[]') : undefined, skip = [], constructors = {}, constructedArrays = new WeakMap(), allowedTypes = {}, idx, } = params;\r\n    if (target == null) {\r\n        throw new Error(`AG Charts - target is uninitialised: ${path !== null && path !== void 0 ? path : '<root>'}`);\r\n    }\r\n    if (source == null) {\r\n        return target;\r\n    }\r\n    const targetAny = target;\r\n    if (idx != null && '_declarationOrder' in targetAny) {\r\n        targetAny['_declarationOrder'] = idx;\r\n    }\r\n    const targetType = classify(target);\r\n    for (const property in source) {\r\n        const propertyMatcherPath = `${matcherPath ? matcherPath + '.' : ''}${property}`;\r\n        if (skip.indexOf(propertyMatcherPath) >= 0) {\r\n            continue;\r\n        }\r\n        const newValue = source[property];\r\n        const propertyPath = `${path ? path + '.' : ''}${property}`;\r\n        const targetClass = targetAny.constructor;\r\n        const currentValue = targetAny[property];\r\n        let ctr = (_a = constructors[propertyMatcherPath]) !== null && _a !== void 0 ? _a : constructors[property];\r\n        try {\r\n            const currentValueType = classify(currentValue);\r\n            const newValueType = classify(newValue);\r\n            if (targetType === CLASS_INSTANCE_TYPE &&\r\n                !(property in target || Object.prototype.hasOwnProperty.call(targetAny, property))) {\r\n                Logger.warn(`unable to set [${propertyPath}] in ${targetClass === null || targetClass === void 0 ? void 0 : targetClass.name} - property is unknown`);\r\n                continue;\r\n            }\r\n            const allowableTypes = (_b = allowedTypes[propertyMatcherPath]) !== null && _b !== void 0 ? _b : [currentValueType];\r\n            if (currentValueType === CLASS_INSTANCE_TYPE && newValueType === 'object') {\r\n                // Allowed, this is the common case! - do not error.\r\n            }\r\n            else if (currentValueType != null && newValueType != null && !allowableTypes.includes(newValueType)) {\r\n                Logger.warn(`unable to set [${propertyPath}] in ${targetClass === null || targetClass === void 0 ? void 0 : targetClass.name} - can't apply type of [${newValueType}], allowed types are: [${allowableTypes}]`);\r\n                continue;\r\n            }\r\n            if (newValueType === 'array') {\r\n                ctr = (_c = ctr !== null && ctr !== void 0 ? ctr : constructedArrays.get(currentValue)) !== null && _c !== void 0 ? _c : constructors[`${propertyMatcherPath}[]`];\r\n                if (ctr != null) {\r\n                    const newValueArray = newValue;\r\n                    targetAny[property] = newValueArray.map((v, idx) => jsonApply(new ctr(), v, Object.assign(Object.assign({}, params), { path: propertyPath, matcherPath: propertyMatcherPath + '[]', idx })));\r\n                }\r\n                else {\r\n                    targetAny[property] = newValue;\r\n                }\r\n            }\r\n            else if (newValueType === CLASS_INSTANCE_TYPE) {\r\n                targetAny[property] = newValue;\r\n            }\r\n            else if (newValueType === 'object') {\r\n                if (currentValue != null) {\r\n                    jsonApply(currentValue, newValue, Object.assign(Object.assign({}, params), { path: propertyPath, matcherPath: propertyMatcherPath, idx: undefined }));\r\n                }\r\n                else if (ctr != null) {\r\n                    targetAny[property] = jsonApply(new ctr(), newValue, Object.assign(Object.assign({}, params), { path: propertyPath, matcherPath: propertyMatcherPath, idx: undefined }));\r\n                }\r\n                else {\r\n                    targetAny[property] = newValue;\r\n                }\r\n            }\r\n            else {\r\n                targetAny[property] = newValue;\r\n            }\r\n        }\r\n        catch (error) {\r\n            Logger.warn(`unable to set [${propertyPath}] in [${targetClass === null || targetClass === void 0 ? void 0 : targetClass.name}]; nested error is: ${error.message}`);\r\n        }\r\n    }\r\n    return target;\r\n}\r\n/**\r\n * Walk the given JSON object graphs, invoking the visit() callback for every object encountered.\r\n * Arrays are descended into without a callback, however their elements will have the visit()\r\n * callback invoked if they are objects.\r\n *\r\n * @param json to traverse\r\n * @param visit callback for each non-primitive and non-array object found\r\n * @param opts\r\n * @param opts.skip property names to skip when walking\r\n * @param jsons to traverse in parallel\r\n */\r\nfunction jsonWalk(json, visit, opts, ...jsons) {\r\n    const jsonType = classify(json);\r\n    const { skip = [] } = opts !== null && opts !== void 0 ? opts : {};\r\n    if (jsonType === 'array') {\r\n        visit(jsonType, json, ...jsons);\r\n        json.forEach((element, index) => {\r\n            jsonWalk(element, visit, opts, ...(jsons !== null && jsons !== void 0 ? jsons : []).map((o) => o === null || o === void 0 ? void 0 : o[index]));\r\n        });\r\n        return;\r\n    }\r\n    if (jsonType !== 'object') {\r\n        return;\r\n    }\r\n    visit(jsonType, json, ...jsons);\r\n    for (const property in json) {\r\n        if (skip.includes(property)) {\r\n            continue;\r\n        }\r\n        const value = json[property];\r\n        const otherValues = jsons === null || jsons === void 0 ? void 0 : jsons.map((o) => o === null || o === void 0 ? void 0 : o[property]);\r\n        const valueType = classify(value);\r\n        if (valueType === 'object' || valueType === 'array') {\r\n            jsonWalk(value, visit, opts, ...otherValues);\r\n        }\r\n    }\r\n}\r\nconst isBrowser = typeof window !== 'undefined';\r\n/**\r\n * Classify the type of value to assist with handling for merge purposes.\r\n */\r\nfunction classify(value) {\r\n    if (value == null) {\r\n        return null;\r\n    }\r\n    if (isBrowser && value instanceof HTMLElement) {\r\n        return 'primitive';\r\n    }\r\n    if (Array.isArray(value)) {\r\n        return 'array';\r\n    }\r\n    if (value instanceof Date) {\r\n        return 'primitive';\r\n    }\r\n    if (typeof value === 'object' && value.constructor === Object) {\r\n        return 'object';\r\n    }\r\n    if (typeof value === 'function') {\r\n        return 'function';\r\n    }\r\n    if (typeof value === 'object' && value.constructor != null) {\r\n        return CLASS_INSTANCE_TYPE;\r\n    }\r\n    return 'primitive';\r\n}\n\nconst twoPi = Math.PI * 2;\r\n/**\r\n * Normalize the given angle to be in the [0, 2π) interval.\r\n * @param radians Angle in radians.\r\n */\r\nfunction normalizeAngle360(radians) {\r\n    radians %= twoPi;\r\n    radians += twoPi;\r\n    radians %= twoPi;\r\n    return radians;\r\n}\r\nfunction normalizeAngle360Inclusive(radians) {\r\n    radians %= twoPi;\r\n    radians += twoPi;\r\n    if (radians !== twoPi) {\r\n        radians %= twoPi;\r\n    }\r\n    return radians;\r\n}\r\n/**\r\n * Normalize the given angle to be in the [-π, π) interval.\r\n * @param radians Angle in radians.\r\n */\r\nfunction normalizeAngle180(radians) {\r\n    radians %= twoPi;\r\n    if (radians < -Math.PI) {\r\n        radians += twoPi;\r\n    }\r\n    else if (radians >= Math.PI) {\r\n        radians -= twoPi;\r\n    }\r\n    return radians;\r\n}\r\nfunction toRadians(degrees) {\r\n    return (degrees / 180) * Math.PI;\r\n}\r\nfunction toDegrees(radians) {\r\n    return (radians / Math.PI) * 180;\r\n}\r\n/**\r\n * Returns a rotation angle between two other angles.\r\n * @param angle0 Angle in radians.\r\n * @param angle1 Angle in radians.\r\n * @returns Angle in radians.\r\n */\r\nfunction angleBetween(angle0, angle1) {\r\n    angle0 = normalizeAngle360(angle0);\r\n    angle1 = normalizeAngle360(angle1);\r\n    return angle1 - angle0 + (angle0 > angle1 ? 2 * Math.PI : 0);\r\n}\n\nfunction clamp$1(x, min, max) {\r\n    return Math.max(min, Math.min(max, x));\r\n}\r\n/**\r\n * Maps a discrete domain to a continuous numeric range.\r\n */\r\nclass BandScale {\r\n    constructor() {\r\n        this.type = 'band';\r\n        this.cache = null;\r\n        this.cacheProps = ['_domain', 'range', '_paddingInner', '_paddingOuter', 'round', 'interval'];\r\n        /**\r\n         * Maps datum to its index in the {@link domain} array.\r\n         * Used to check for duplicate datums (not allowed).\r\n         */\r\n        this.index = new Map();\r\n        /**\r\n         * The output range values for datum at each index.\r\n         */\r\n        this.ordinalRange = [];\r\n        /**\r\n         * Contains unique datums only. Since `{}` is used in place of `Map`\r\n         * for IE11 compatibility, the datums are converted `toString` before\r\n         * the uniqueness check.\r\n         */\r\n        this._domain = [];\r\n        this.range = [0, 1];\r\n        this._bandwidth = 1;\r\n        this._rawBandwidth = 1;\r\n        /**\r\n         * The ratio of the range that is reserved for space between bands.\r\n         */\r\n        this._paddingInner = 0;\r\n        /**\r\n         * The ratio of the range that is reserved for space before the first\r\n         * and after the last band.\r\n         */\r\n        this._paddingOuter = 0;\r\n        this.round = false;\r\n    }\r\n    didChange() {\r\n        const { cache } = this;\r\n        const didChange = !cache || this.cacheProps.some((p) => this[p] !== cache[p]);\r\n        if (didChange) {\r\n            this.cache = {};\r\n            this.cacheProps.forEach((p) => (this.cache[p] = this[p]));\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    refresh() {\r\n        if (this.didChange()) {\r\n            this.update();\r\n        }\r\n    }\r\n    set domain(values) {\r\n        const domain = [];\r\n        this.index = new Map();\r\n        const index = this.index;\r\n        // In case one wants to have duplicate domain values, for example, two 'Italy' categories,\r\n        // one should use objects rather than strings for domain values like so:\r\n        // { toString: () => 'Italy' }\r\n        // { toString: () => 'Italy' }\r\n        values.forEach((value) => {\r\n            if (index.get(value) === undefined) {\r\n                index.set(value, domain.push(value) - 1);\r\n            }\r\n        });\r\n        this._domain = domain;\r\n    }\r\n    get domain() {\r\n        return this._domain;\r\n    }\r\n    ticks() {\r\n        this.refresh();\r\n        const { interval = 1 } = this;\r\n        const step = Math.abs(Math.round(interval));\r\n        return this._domain.filter((_, i) => i % step === 0);\r\n    }\r\n    convert(d) {\r\n        this.refresh();\r\n        const i = this.index.get(d);\r\n        if (i === undefined) {\r\n            return NaN;\r\n        }\r\n        const r = this.ordinalRange[i];\r\n        if (r === undefined) {\r\n            return NaN;\r\n        }\r\n        return r;\r\n    }\r\n    invert(position) {\r\n        this.refresh();\r\n        const index = this.ordinalRange.findIndex((p) => p === position);\r\n        return this.domain[index];\r\n    }\r\n    get bandwidth() {\r\n        this.refresh();\r\n        return this._bandwidth;\r\n    }\r\n    get rawBandwidth() {\r\n        this.refresh();\r\n        return this._rawBandwidth;\r\n    }\r\n    set padding(value) {\r\n        value = clamp$1(value, 0, 1);\r\n        this._paddingInner = value;\r\n        this._paddingOuter = value;\r\n    }\r\n    get padding() {\r\n        return this._paddingInner;\r\n    }\r\n    set paddingInner(value) {\r\n        this._paddingInner = clamp$1(value, 0, 1);\r\n    }\r\n    get paddingInner() {\r\n        return this._paddingInner;\r\n    }\r\n    set paddingOuter(value) {\r\n        this._paddingOuter = clamp$1(value, 0, 1);\r\n    }\r\n    get paddingOuter() {\r\n        return this._paddingOuter;\r\n    }\r\n    update() {\r\n        const count = this._domain.length;\r\n        if (count === 0) {\r\n            return;\r\n        }\r\n        const round = this.round;\r\n        const paddingInner = this._paddingInner;\r\n        const paddingOuter = this._paddingOuter;\r\n        const [r0, r1] = this.range;\r\n        const width = r1 - r0;\r\n        const rawStep = width / Math.max(1, count + 2 * paddingOuter - paddingInner);\r\n        const step = round ? Math.floor(rawStep) : rawStep;\r\n        const fullBandWidth = step * (count - paddingInner);\r\n        const x0 = r0 + (width - fullBandWidth) / 2;\r\n        const start = round ? Math.round(x0) : x0;\r\n        const bw = step * (1 - paddingInner);\r\n        const bandwidth = round ? Math.round(bw) : bw;\r\n        const rawBandwidth = rawStep * (1 - paddingInner);\r\n        const values = [];\r\n        for (let i = 0; i < count; i++) {\r\n            values.push(start + step * i);\r\n        }\r\n        this._bandwidth = bandwidth;\r\n        this._rawBandwidth = rawBandwidth;\r\n        this.ordinalRange = values;\r\n    }\r\n}\n\nfunction clamp(min, value, max) {\r\n    return Math.min(max, Math.max(min, value));\r\n}\r\nfunction isEqual(a, b, epsilon = 1e-10) {\r\n    return Math.abs(a - b) < epsilon;\r\n}\r\nfunction isNegative(a) {\r\n    return Math.sign(a) < 0 || Object.is(a, -0);\r\n}\r\nfunction round$1(value, decimals = 2) {\r\n    const pow = Math.pow(10, decimals);\r\n    return Math.round(value * pow) / pow;\r\n}\r\n/**\r\n * `Number.toFixed(n)` always formats a number so that it has `n` digits after the decimal point.\r\n * For example, `Number(0.00003427).toFixed(2)` returns `0.00`.\r\n * That's not very helpful, because all the meaningful information is lost.\r\n * In this case we would want the formatted value to have at least two significant digits: `0.000034`,\r\n * not two fraction digits.\r\n * @param value\r\n * @param fractionOrSignificantDigits\r\n */\r\nfunction toFixed(value, fractionOrSignificantDigits = 2) {\r\n    const power = Math.floor(Math.log(Math.abs(value)) / Math.LN10);\r\n    if (power >= 0 || !isFinite(power)) {\r\n        return value.toFixed(fractionOrSignificantDigits); // fraction digits\r\n    }\r\n    return value.toFixed(Math.abs(power) - 1 + fractionOrSignificantDigits); // significant digits\r\n}\r\n/**\r\n * Returns the mathematically correct n modulus of m. For context, the JS % operator is remainder\r\n * NOT modulus, which is why this is needed.\r\n */\r\nfunction mod(n, m) {\r\n    if (n >= 0) {\r\n        return Math.floor(n % m);\r\n    }\r\n    return Math.floor((n % m) + m);\r\n}\n\nclass Color {\r\n    /**\r\n     * Every color component should be in the [0, 1] range.\r\n     * Some easing functions (such as elastic easing) can overshoot the target value by some amount.\r\n     * So, when animating colors, if the source or target color components are already near\r\n     * or at the edge of the allowed [0, 1] range, it is possible for the intermediate color\r\n     * component value to end up outside of that range mid-animation. For this reason the constructor\r\n     * performs range checking/constraining.\r\n     * @param r Red component.\r\n     * @param g Green component.\r\n     * @param b Blue component.\r\n     * @param a Alpha (opacity) component.\r\n     */\r\n    constructor(r, g, b, a = 1) {\r\n        // NaN is treated as 0\r\n        this.r = clamp(0, r || 0, 1);\r\n        this.g = clamp(0, g || 0, 1);\r\n        this.b = clamp(0, b || 0, 1);\r\n        this.a = clamp(0, a || 0, 1);\r\n    }\r\n    /**\r\n     * A color string can be in one of the following formats to be valid:\r\n     * - #rgb\r\n     * - #rrggbb\r\n     * - rgb(r, g, b)\r\n     * - rgba(r, g, b, a)\r\n     * - CSS color name such as 'white', 'orange', 'cyan', etc.\r\n     */\r\n    static validColorString(str) {\r\n        if (str.indexOf('#') >= 0) {\r\n            return !!Color.parseHex(str);\r\n        }\r\n        if (str.indexOf('rgb') >= 0) {\r\n            return !!Color.stringToRgba(str);\r\n        }\r\n        return !!Color.nameToHex[str.toLowerCase()];\r\n    }\r\n    /**\r\n     * The given string can be in one of the following formats:\r\n     * - #rgb\r\n     * - #rrggbb\r\n     * - rgb(r, g, b)\r\n     * - rgba(r, g, b, a)\r\n     * - CSS color name such as 'white', 'orange', 'cyan', etc.\r\n     * @param str\r\n     */\r\n    static fromString(str) {\r\n        // hexadecimal notation\r\n        if (str.indexOf('#') >= 0) {\r\n            // there can be some leading whitespace\r\n            return Color.fromHexString(str);\r\n        }\r\n        // color name\r\n        const hex = Color.nameToHex[str.toLowerCase()];\r\n        if (hex) {\r\n            return Color.fromHexString(hex);\r\n        }\r\n        // rgb(a) notation\r\n        if (str.indexOf('rgb') >= 0) {\r\n            return Color.fromRgbaString(str);\r\n        }\r\n        throw new Error(`Invalid color string: '${str}'`);\r\n    }\r\n    static tryParseFromString(str) {\r\n        try {\r\n            return Color.fromString(str);\r\n        }\r\n        catch (e) {\r\n            Logger.warnOnce(`invalid color string: '${str}'.`);\r\n            return Color.fromArray([0, 0, 0]);\r\n        }\r\n    }\r\n    // See https://drafts.csswg.org/css-color/#hex-notation\r\n    static parseHex(input) {\r\n        input = input.replace(/ /g, '').slice(1);\r\n        let parts;\r\n        switch (input.length) {\r\n            case 6:\r\n            case 8:\r\n                parts = [];\r\n                for (let i = 0; i < input.length; i += 2) {\r\n                    parts.push(parseInt(`${input[i]}${input[i + 1]}`, 16));\r\n                }\r\n                break;\r\n            case 3:\r\n            case 4:\r\n                parts = input\r\n                    .split('')\r\n                    .map((p) => parseInt(p, 16))\r\n                    .map((p) => p + p * 16);\r\n                break;\r\n        }\r\n        if ((parts === null || parts === void 0 ? void 0 : parts.length) >= 3 && parts.every((p) => p >= 0)) {\r\n            if (parts.length === 3) {\r\n                parts.push(255);\r\n            }\r\n            return parts;\r\n        }\r\n    }\r\n    static fromHexString(str) {\r\n        const values = Color.parseHex(str);\r\n        if (values) {\r\n            const [r, g, b, a] = values;\r\n            return new Color(r / 255, g / 255, b / 255, a / 255);\r\n        }\r\n        throw new Error(`Malformed hexadecimal color string: '${str}'`);\r\n    }\r\n    static stringToRgba(str) {\r\n        // Find positions of opening and closing parentheses.\r\n        let [po, pc] = [NaN, NaN];\r\n        for (let i = 0; i < str.length; i++) {\r\n            const c = str[i];\r\n            if (!po && c === '(') {\r\n                po = i;\r\n            }\r\n            else if (c === ')') {\r\n                pc = i;\r\n                break;\r\n            }\r\n        }\r\n        const contents = po && pc && str.substring(po + 1, pc);\r\n        if (!contents) {\r\n            return;\r\n        }\r\n        const parts = contents.split(',');\r\n        const rgba = [];\r\n        for (let i = 0; i < parts.length; i++) {\r\n            const part = parts[i];\r\n            let value = parseFloat(part);\r\n            if (isNaN(value)) {\r\n                return;\r\n            }\r\n            if (part.indexOf('%') >= 0) {\r\n                // percentage r, g, or b value\r\n                value = Math.max(0, Math.min(100, value));\r\n                value /= 100;\r\n            }\r\n            else {\r\n                if (i === 3) {\r\n                    // alpha component\r\n                    value = Math.max(0, Math.min(1, value));\r\n                }\r\n                else {\r\n                    // absolute r, g, or b value\r\n                    value = Math.max(0, Math.min(255, value));\r\n                    value /= 255;\r\n                }\r\n            }\r\n            rgba.push(value);\r\n        }\r\n        return rgba;\r\n    }\r\n    static fromRgbaString(str) {\r\n        const rgba = Color.stringToRgba(str);\r\n        if (rgba) {\r\n            if (rgba.length === 3) {\r\n                return new Color(rgba[0], rgba[1], rgba[2]);\r\n            }\r\n            else if (rgba.length === 4) {\r\n                return new Color(rgba[0], rgba[1], rgba[2], rgba[3]);\r\n            }\r\n        }\r\n        throw new Error(`Malformed rgb/rgba color string: '${str}'`);\r\n    }\r\n    static fromArray(arr) {\r\n        if (arr.length === 4) {\r\n            return new Color(arr[0], arr[1], arr[2], arr[3]);\r\n        }\r\n        if (arr.length === 3) {\r\n            return new Color(arr[0], arr[1], arr[2]);\r\n        }\r\n        throw new Error('The given array should contain 3 or 4 color components (numbers).');\r\n    }\r\n    static fromHSB(h, s, b, alpha = 1) {\r\n        const rgb = Color.HSBtoRGB(h, s, b);\r\n        return new Color(rgb[0], rgb[1], rgb[2], alpha);\r\n    }\r\n    static fromHSL(h, s, l, alpha = 1) {\r\n        const rgb = Color.HSLtoRGB(h, s, l);\r\n        return new Color(rgb[0], rgb[1], rgb[2], alpha);\r\n    }\r\n    static padHex(str) {\r\n        // Can't use `padStart(2, '0')` here because of IE.\r\n        return str.length === 1 ? '0' + str : str;\r\n    }\r\n    toHexString() {\r\n        let hex = '#' +\r\n            Color.padHex(Math.round(this.r * 255).toString(16)) +\r\n            Color.padHex(Math.round(this.g * 255).toString(16)) +\r\n            Color.padHex(Math.round(this.b * 255).toString(16));\r\n        if (this.a < 1) {\r\n            hex += Color.padHex(Math.round(this.a * 255).toString(16));\r\n        }\r\n        return hex;\r\n    }\r\n    toRgbaString(fractionDigits = 3) {\r\n        const components = [Math.round(this.r * 255), Math.round(this.g * 255), Math.round(this.b * 255)];\r\n        const k = Math.pow(10, fractionDigits);\r\n        if (this.a !== 1) {\r\n            components.push(Math.round(this.a * k) / k);\r\n            return `rgba(${components.join(', ')})`;\r\n        }\r\n        return `rgb(${components.join(', ')})`;\r\n    }\r\n    toString() {\r\n        if (this.a === 1) {\r\n            return this.toHexString();\r\n        }\r\n        return this.toRgbaString();\r\n    }\r\n    toHSB() {\r\n        return Color.RGBtoHSB(this.r, this.g, this.b);\r\n    }\r\n    static RGBtoHSL(r, g, b) {\r\n        const min = Math.min(r, g, b);\r\n        const max = Math.max(r, g, b);\r\n        const l = (max + min) / 2;\r\n        let h;\r\n        let s;\r\n        if (max === min) {\r\n            // Achromatic\r\n            h = NaN;\r\n            s = 0;\r\n        }\r\n        else {\r\n            const delta = max - min;\r\n            s = l > 0.5 ? delta / (2 - max - min) : delta / (max + min);\r\n            if (max === r) {\r\n                h = (g - b) / delta + (g < b ? 6 : 0);\r\n            }\r\n            else if (max === g) {\r\n                h = (b - r) / delta + 2;\r\n            }\r\n            else {\r\n                h = (r - g) / delta + 4;\r\n            }\r\n            h *= 360 / 6;\r\n        }\r\n        return [h, s, l];\r\n    }\r\n    static HSLtoRGB(h, s, l) {\r\n        if (s === 0) {\r\n            // Achromatic\r\n            return [l, l, l];\r\n        }\r\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\r\n        const p = 2 * l - q;\r\n        function hueToRgb(t) {\r\n            if (t < 0)\r\n                t += 1;\r\n            if (t > 1)\r\n                t -= 1;\r\n            if (t < 1 / 6)\r\n                return p + (q - p) * 6 * t;\r\n            if (t < 1 / 2)\r\n                return q;\r\n            if (t < 2 / 3)\r\n                return p + (q - p) * (2 / 3 - t) * 6;\r\n            return p;\r\n        }\r\n        const r = hueToRgb(h / 360 + 1 / 3);\r\n        const g = hueToRgb(h / 360);\r\n        const b = hueToRgb(h / 360 - 1 / 3);\r\n        return [r, g, b];\r\n    }\r\n    /**\r\n     * Converts the given RGB triple to an array of HSB (HSV) components.\r\n     * The hue component will be `NaN` for achromatic colors.\r\n     */\r\n    static RGBtoHSB(r, g, b) {\r\n        const min = Math.min(r, g, b);\r\n        const max = Math.max(r, g, b);\r\n        const S = max !== 0 ? (max - min) / max : 0;\r\n        let H = NaN;\r\n        // min == max, means all components are the same\r\n        // and the color is a shade of gray with no hue (H is NaN)\r\n        if (min !== max) {\r\n            const delta = max - min;\r\n            const rc = (max - r) / delta;\r\n            const gc = (max - g) / delta;\r\n            const bc = (max - b) / delta;\r\n            if (r === max) {\r\n                H = bc - gc;\r\n            }\r\n            else if (g === max) {\r\n                H = 2.0 + rc - bc;\r\n            }\r\n            else {\r\n                H = 4.0 + gc - rc;\r\n            }\r\n            H /= 6.0;\r\n            if (H < 0) {\r\n                H = H + 1.0;\r\n            }\r\n        }\r\n        return [H * 360, S, max];\r\n    }\r\n    /**\r\n     * Converts the given HSB (HSV) triple to an array of RGB components.\r\n     */\r\n    static HSBtoRGB(H, S, B) {\r\n        if (isNaN(H)) {\r\n            H = 0;\r\n        }\r\n        H = (((H % 360) + 360) % 360) / 360; // normalize hue to [0, 360] interval, then scale to [0, 1]\r\n        let r = 0;\r\n        let g = 0;\r\n        let b = 0;\r\n        if (S === 0) {\r\n            r = g = b = B;\r\n        }\r\n        else {\r\n            const h = (H - Math.floor(H)) * 6;\r\n            const f = h - Math.floor(h);\r\n            const p = B * (1 - S);\r\n            const q = B * (1 - S * f);\r\n            const t = B * (1 - S * (1 - f));\r\n            switch (h >> 0 // discard the floating point part of the number\r\n            ) {\r\n                case 0:\r\n                    r = B;\r\n                    g = t;\r\n                    b = p;\r\n                    break;\r\n                case 1:\r\n                    r = q;\r\n                    g = B;\r\n                    b = p;\r\n                    break;\r\n                case 2:\r\n                    r = p;\r\n                    g = B;\r\n                    b = t;\r\n                    break;\r\n                case 3:\r\n                    r = p;\r\n                    g = q;\r\n                    b = B;\r\n                    break;\r\n                case 4:\r\n                    r = t;\r\n                    g = p;\r\n                    b = B;\r\n                    break;\r\n                case 5:\r\n                    r = B;\r\n                    g = p;\r\n                    b = q;\r\n                    break;\r\n            }\r\n        }\r\n        return [r, g, b];\r\n    }\r\n    derive(hueShift, saturationFactor, brightnessFactor, opacityFactor) {\r\n        const hsb = Color.RGBtoHSB(this.r, this.g, this.b);\r\n        let b = hsb[2];\r\n        if (b == 0 && brightnessFactor > 1.0) {\r\n            b = 0.05;\r\n        }\r\n        const h = (((hsb[0] + hueShift) % 360) + 360) % 360;\r\n        const s = Math.max(Math.min(hsb[1] * saturationFactor, 1.0), 0.0);\r\n        b = Math.max(Math.min(b * brightnessFactor, 1.0), 0.0);\r\n        const a = Math.max(Math.min(this.a * opacityFactor, 1.0), 0.0);\r\n        const rgba = Color.HSBtoRGB(h, s, b);\r\n        rgba.push(a);\r\n        return Color.fromArray(rgba);\r\n    }\r\n    brighter() {\r\n        return this.derive(0, 1.0, 1.0 / 0.7, 1.0);\r\n    }\r\n    darker() {\r\n        return this.derive(0, 1.0, 0.7, 1.0);\r\n    }\r\n    static interpolate(color, other) {\r\n        const c0 = Color.tryParseFromString(color);\r\n        const c1 = Color.tryParseFromString(other);\r\n        return (t) => {\r\n            const i = (x, y) => x * (1 - t) + y * t;\r\n            const c = new Color(i(c0.r, c1.r), i(c0.g, c1.g), i(c0.b, c1.b), i(c0.a, c1.a));\r\n            return c.toString();\r\n        };\r\n    }\r\n}\r\n/**\r\n * CSS Color Module Level 4:\r\n * https://drafts.csswg.org/css-color/#named-colors\r\n */\r\nColor.nameToHex = Object.freeze({\r\n    aliceblue: '#F0F8FF',\r\n    antiquewhite: '#FAEBD7',\r\n    aqua: '#00FFFF',\r\n    aquamarine: '#7FFFD4',\r\n    azure: '#F0FFFF',\r\n    beige: '#F5F5DC',\r\n    bisque: '#FFE4C4',\r\n    black: '#000000',\r\n    blanchedalmond: '#FFEBCD',\r\n    blue: '#0000FF',\r\n    blueviolet: '#8A2BE2',\r\n    brown: '#A52A2A',\r\n    burlywood: '#DEB887',\r\n    cadetblue: '#5F9EA0',\r\n    chartreuse: '#7FFF00',\r\n    chocolate: '#D2691E',\r\n    coral: '#FF7F50',\r\n    cornflowerblue: '#6495ED',\r\n    cornsilk: '#FFF8DC',\r\n    crimson: '#DC143C',\r\n    cyan: '#00FFFF',\r\n    darkblue: '#00008B',\r\n    darkcyan: '#008B8B',\r\n    darkgoldenrod: '#B8860B',\r\n    darkgray: '#A9A9A9',\r\n    darkgreen: '#006400',\r\n    darkgrey: '#A9A9A9',\r\n    darkkhaki: '#BDB76B',\r\n    darkmagenta: '#8B008B',\r\n    darkolivegreen: '#556B2F',\r\n    darkorange: '#FF8C00',\r\n    darkorchid: '#9932CC',\r\n    darkred: '#8B0000',\r\n    darksalmon: '#E9967A',\r\n    darkseagreen: '#8FBC8F',\r\n    darkslateblue: '#483D8B',\r\n    darkslategray: '#2F4F4F',\r\n    darkslategrey: '#2F4F4F',\r\n    darkturquoise: '#00CED1',\r\n    darkviolet: '#9400D3',\r\n    deeppink: '#FF1493',\r\n    deepskyblue: '#00BFFF',\r\n    dimgray: '#696969',\r\n    dimgrey: '#696969',\r\n    dodgerblue: '#1E90FF',\r\n    firebrick: '#B22222',\r\n    floralwhite: '#FFFAF0',\r\n    forestgreen: '#228B22',\r\n    fuchsia: '#FF00FF',\r\n    gainsboro: '#DCDCDC',\r\n    ghostwhite: '#F8F8FF',\r\n    gold: '#FFD700',\r\n    goldenrod: '#DAA520',\r\n    gray: '#808080',\r\n    green: '#008000',\r\n    greenyellow: '#ADFF2F',\r\n    grey: '#808080',\r\n    honeydew: '#F0FFF0',\r\n    hotpink: '#FF69B4',\r\n    indianred: '#CD5C5C',\r\n    indigo: '#4B0082',\r\n    ivory: '#FFFFF0',\r\n    khaki: '#F0E68C',\r\n    lavender: '#E6E6FA',\r\n    lavenderblush: '#FFF0F5',\r\n    lawngreen: '#7CFC00',\r\n    lemonchiffon: '#FFFACD',\r\n    lightblue: '#ADD8E6',\r\n    lightcoral: '#F08080',\r\n    lightcyan: '#E0FFFF',\r\n    lightgoldenrodyellow: '#FAFAD2',\r\n    lightgray: '#D3D3D3',\r\n    lightgreen: '#90EE90',\r\n    lightgrey: '#D3D3D3',\r\n    lightpink: '#FFB6C1',\r\n    lightsalmon: '#FFA07A',\r\n    lightseagreen: '#20B2AA',\r\n    lightskyblue: '#87CEFA',\r\n    lightslategray: '#778899',\r\n    lightslategrey: '#778899',\r\n    lightsteelblue: '#B0C4DE',\r\n    lightyellow: '#FFFFE0',\r\n    lime: '#00FF00',\r\n    limegreen: '#32CD32',\r\n    linen: '#FAF0E6',\r\n    magenta: '#FF00FF',\r\n    maroon: '#800000',\r\n    mediumaquamarine: '#66CDAA',\r\n    mediumblue: '#0000CD',\r\n    mediumorchid: '#BA55D3',\r\n    mediumpurple: '#9370DB',\r\n    mediumseagreen: '#3CB371',\r\n    mediumslateblue: '#7B68EE',\r\n    mediumspringgreen: '#00FA9A',\r\n    mediumturquoise: '#48D1CC',\r\n    mediumvioletred: '#C71585',\r\n    midnightblue: '#191970',\r\n    mintcream: '#F5FFFA',\r\n    mistyrose: '#FFE4E1',\r\n    moccasin: '#FFE4B5',\r\n    navajowhite: '#FFDEAD',\r\n    navy: '#000080',\r\n    oldlace: '#FDF5E6',\r\n    olive: '#808000',\r\n    olivedrab: '#6B8E23',\r\n    orange: '#FFA500',\r\n    orangered: '#FF4500',\r\n    orchid: '#DA70D6',\r\n    palegoldenrod: '#EEE8AA',\r\n    palegreen: '#98FB98',\r\n    paleturquoise: '#AFEEEE',\r\n    palevioletred: '#DB7093',\r\n    papayawhip: '#FFEFD5',\r\n    peachpuff: '#FFDAB9',\r\n    peru: '#CD853F',\r\n    pink: '#FFC0CB',\r\n    plum: '#DDA0DD',\r\n    powderblue: '#B0E0E6',\r\n    purple: '#800080',\r\n    rebeccapurple: '#663399',\r\n    red: '#FF0000',\r\n    rosybrown: '#BC8F8F',\r\n    royalblue: '#4169E1',\r\n    saddlebrown: '#8B4513',\r\n    salmon: '#FA8072',\r\n    sandybrown: '#F4A460',\r\n    seagreen: '#2E8B57',\r\n    seashell: '#FFF5EE',\r\n    sienna: '#A0522D',\r\n    silver: '#C0C0C0',\r\n    skyblue: '#87CEEB',\r\n    slateblue: '#6A5ACD',\r\n    slategray: '#708090',\r\n    slategrey: '#708090',\r\n    snow: '#FFFAFA',\r\n    springgreen: '#00FF7F',\r\n    steelblue: '#4682B4',\r\n    tan: '#D2B48C',\r\n    teal: '#008080',\r\n    thistle: '#D8BFD8',\r\n    tomato: '#FF6347',\r\n    transparent: '#00000000',\r\n    turquoise: '#40E0D0',\r\n    violet: '#EE82EE',\r\n    wheat: '#F5DEB3',\r\n    white: '#FFFFFF',\r\n    whitesmoke: '#F5F5F5',\r\n    yellow: '#FFFF00',\r\n    yellowgreen: '#9ACD32',\r\n});\n\n/* eslint-disable sonarjs/no-duplicate-string */\r\nfunction Validate(predicate) {\r\n    return addTransformToInstanceProperty((target, prop, v) => {\r\n        var _a, _b, _c;\r\n        if (predicate(v, { target })) {\r\n            return v;\r\n        }\r\n        const cleanKey = prop.toString().replace(/^_*/, '');\r\n        let targetClass = (_b = (_a = target.constructor) === null || _a === void 0 ? void 0 : _a.className) !== null && _b !== void 0 ? _b : (_c = target.constructor) === null || _c === void 0 ? void 0 : _c.name;\r\n        if ((targetClass === null || targetClass === void 0 ? void 0 : targetClass.length) < 3) {\r\n            targetClass = null;\r\n        }\r\n        const targetClassName = targetClass ? `of [${targetClass}] ` : '';\r\n        if (predicate.message) {\r\n            Logger.warn(`Property [${cleanKey}] ${targetClassName}cannot be set to [${stringify(v)}]; ${predicate.message}, ignoring.`);\r\n        }\r\n        else {\r\n            Logger.warn(`Property [${cleanKey}] ${targetClassName}cannot be set to [${stringify(v)}], ignoring.`);\r\n        }\r\n        return BREAK_TRANSFORM_CHAIN;\r\n    });\r\n}\r\nfunction stringify(value) {\r\n    if (typeof value === 'number' && isNaN(value))\r\n        return 'NaN';\r\n    if (value === Infinity)\r\n        return 'Infinity';\r\n    if (value === -Infinity)\r\n        return '-Infinity';\r\n    return JSON.stringify(value);\r\n}\r\nfunction predicateWithMessage(predicate, message) {\r\n    predicate.message = message;\r\n    return predicate;\r\n}\r\nconst OPTIONAL = (v, ctx, predicate) => v === undefined || predicate(v, ctx);\r\nconst ARRAY = (length, predicate) => {\r\n    return predicateWithMessage((v, ctx) => Array.isArray(v) &&\r\n        (length ? v.length === length : true) &&\r\n        (predicate ? v.every((e) => predicate(e, ctx)) : true), `expecting an Array`);\r\n};\r\nconst OPT_ARRAY = (length) => {\r\n    return predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, ARRAY(length)), 'expecting an optional Array');\r\n};\r\nconst NON_EMPTY_ARRAY = predicateWithMessage((v) => Array.isArray(v) && v.length > 0, `expecting a non-empty Array`);\r\nconst OPT_NON_EMPTY_ARRAY = () => {\r\n    return predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, NON_EMPTY_ARRAY), 'expecting an optional non-empty Array');\r\n};\r\nconst AND = (...predicates) => {\r\n    return predicateWithMessage((v, ctx) => predicates.every((p) => p(v, ctx)), predicates\r\n        .map((p) => p.message)\r\n        .filter((m) => m != null)\r\n        .join(' AND '));\r\n};\r\nconst OR = (...predicates) => {\r\n    return predicateWithMessage((v, ctx) => predicates.some((p) => p(v, ctx)), predicates\r\n        .map((p) => p.message)\r\n        .filter((m) => m != null)\r\n        .join(' OR '));\r\n};\r\nconst isComparable = (v) => {\r\n    return v != null && !isNaN(v);\r\n};\r\nconst LESS_THAN = (otherField) => predicateWithMessage((v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v < ctx.target[otherField], `expected to be less than ${otherField}`);\r\nconst GREATER_THAN = (otherField) => predicateWithMessage((v, ctx) => !isComparable(v) || !isComparable(ctx.target[otherField]) || v > ctx.target[otherField], `expected to be greater than ${otherField}`);\r\nconst FUNCTION = predicateWithMessage((v) => typeof v === 'function', 'expecting a Function');\r\nconst OPT_FUNCTION = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, FUNCTION), `expecting an optional Function`);\r\nconst BOOLEAN = predicateWithMessage((v) => v === true || v === false, 'expecting a Boolean');\r\nconst OPT_BOOLEAN = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, BOOLEAN), 'expecting an optional Boolean');\r\nconst STRING = predicateWithMessage((v) => typeof v === 'string', 'expecting a String');\r\nconst OPT_STRING = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, STRING), 'expecting an optional String');\r\nconst DATE = predicateWithMessage((v) => v instanceof Date && !isNaN(+v), 'expecting a Date object');\r\nconst OPT_DATE = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, DATE), 'expecting an optional Date');\r\nconst DATE_ARRAY = predicateWithMessage(ARRAY(undefined, DATE), 'expecting an Array of Date objects');\r\nconst DATETIME_MS = NUMBER$1(0);\r\nconst OPT_DATETIME_MS = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, DATETIME_MS), 'expecting an optional number');\r\nconst OPT_DATE_OR_DATETIME_MS = OR(OPT_DATE, OPT_DATETIME_MS);\r\nconst colorMessage = `A color string can be in one of the following formats to be valid: #rgb, #rrggbb, rgb(r, g, b), rgba(r, g, b, a) or a CSS color name such as 'white', 'orange', 'cyan', etc`;\r\nconst COLOR_STRING = predicateWithMessage((v) => {\r\n    if (typeof v !== 'string') {\r\n        return false;\r\n    }\r\n    return Color.validColorString(v);\r\n}, `expecting a color String. ${colorMessage}`);\r\nconst OPT_COLOR_STRING = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, COLOR_STRING), `expecting an optional color String. ${colorMessage}`);\r\nconst COLOR_STRING_ARRAY = predicateWithMessage(ARRAY(undefined, COLOR_STRING), `expecting an Array of color strings. ${colorMessage}`);\r\nconst OPT_COLOR_STRING_ARRAY = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, COLOR_STRING_ARRAY), `expecting an optional Array of color strings. ${colorMessage}`);\r\nfunction numberMessage(prefix = `expecting a finite Number`, min, max) {\r\n    let message = prefix;\r\n    if (min !== undefined && max !== undefined) {\r\n        message += ` between ${min} and ${max} inclusive`;\r\n    }\r\n    else if (min !== undefined) {\r\n        message += ` greater than or equal to ${min}`;\r\n    }\r\n    else if (max !== undefined) {\r\n        message += ` less than or equal to ${max}`;\r\n    }\r\n    return message;\r\n}\r\nfunction NUMBER$1(min, max) {\r\n    const message = numberMessage(undefined, min, max);\r\n    return predicateWithMessage((v) => typeof v === 'number' &&\r\n        Number.isFinite(v) &&\r\n        (min !== undefined ? v >= min : true) &&\r\n        (max !== undefined ? v <= max : true), message);\r\n}\r\nfunction OPT_NUMBER(min, max) {\r\n    const message = numberMessage('expecting an optional finite Number', min, max);\r\n    return predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, NUMBER$1(min, max)), message);\r\n}\r\nfunction NUMBER_OR_NAN(min, max) {\r\n    // Can be NaN or finite number\r\n    const message = numberMessage(undefined, min, max);\r\n    return predicateWithMessage((v) => typeof v === 'number' &&\r\n        (isNaN(v) ||\r\n            (Number.isFinite(v) && (min !== undefined ? v >= min : true) && (max !== undefined ? v <= max : true))), message);\r\n}\r\nconst NUMBER_ARRAY = predicateWithMessage(ARRAY(undefined, NUMBER$1()), 'expecting an Array of numbers');\r\nconst OPT_NUMBER_ARRAY = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, NUMBER_ARRAY), 'expecting an optional Array of numbers');\r\nconst STRING_ARRAY = predicateWithMessage(ARRAY(undefined, STRING), 'expecting an Array of strings');\r\nconst OPT_STRING_ARRAY = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, STRING_ARRAY), 'expecting an optional Array of strings');\r\nfunction STRING_UNION(...values) {\r\n    const message = `expecting one of: ${values.join(', ')}`;\r\n    return predicateWithMessage((v) => typeof v === 'string' && values.indexOf(v) >= 0, message);\r\n}\r\nconst BOOLEAN_ARRAY = predicateWithMessage(ARRAY(undefined, BOOLEAN), 'expecting an Array of boolean values');\r\nconst OPT_BOOLEAN_ARRAY = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, BOOLEAN_ARRAY), 'expecting an optional Array of boolean values');\r\nconst FONT_WEIGHTS = ['normal', 'bold', 'bolder', 'lighter'];\r\nconst FONT_STYLE = predicateWithMessage((v) => v === 'normal' || v === 'italic' || v === 'oblique', `expecting a font style keyword such as 'normal', 'italic' or 'oblique'`);\r\nconst OPT_FONT_STYLE = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, FONT_STYLE), `expecting an optional font style keyword such as 'normal', 'italic' or 'oblique'`);\r\nconst FONT_WEIGHT = predicateWithMessage((v) => FONT_WEIGHTS.includes(v) || (typeof v === 'number' && isFinite(v)), `expecting a font weight keyword such as 'normal', 'bold' or 'bolder' or a numeric value such as 100, 300 or 600`);\r\nconst OPT_FONT_WEIGHT = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, FONT_WEIGHT), `expecting an optional font weight keyword such as 'normal', 'bold' or 'bolder' or a numeric value such as 100, 300 or 600`);\r\nconst LINE_DASH = predicateWithMessage(ARRAY(undefined, NUMBER$1(0)), 'expecting an Array of numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels.');\r\nconst OPT_LINE_DASH = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, LINE_DASH), 'expecting an optional Array of numbers specifying the length in pixels of alternating dashes and gaps, for example, [6, 3] means dashes with a length of 6 pixels with gaps between of 3 pixels.');\r\nconst LINE_CAPS = ['butt', 'round', 'square'];\r\nconst LINE_CAP = predicateWithMessage((v) => LINE_CAPS.includes(v), `expecting a line cap keyword such as 'butt', 'round' or 'square'`);\r\nconst OPT_LINE_CAP = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, LINE_CAP), `expecting an optional line cap keyword such as 'butt', 'round' or 'square'`);\r\nconst LINE_JOINS = ['round', 'bevel', 'miter'];\r\nconst LINE_JOIN = predicateWithMessage((v) => LINE_JOINS.includes(v), `expecting a line join keyword such as 'round', 'bevel' or 'miter'`);\r\nconst OPT_LINE_JOIN = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, LINE_JOIN), `expecting an optional line join keyword such as 'round', 'bevel' or 'miter'`);\r\nconst POSITIONS = ['top', 'right', 'bottom', 'left'];\r\nconst POSITION = predicateWithMessage((v) => POSITIONS.includes(v), `expecting a position keyword such as 'top', 'right', 'bottom' or 'left`);\r\nconst INTERACTION_RANGES = ['exact', 'nearest'];\r\nconst INTERACTION_RANGE = predicateWithMessage((v) => (typeof v === 'number' && Number.isFinite(v)) || INTERACTION_RANGES.includes(v), `expecting an interaction range of 'exact', 'nearest' or a number`);\r\nconst TEXT_WRAPS = ['never', 'always', 'hyphenate', 'on-space'];\r\nconst TEXT_WRAP = predicateWithMessage((v) => TEXT_WRAPS.includes(v), `expecting a text wrap strategy keyword such as 'never', 'always', 'hyphenate', or 'on-space'`);\r\nconst OVERFLOW_STRAGEGIES = ['ellipsis', 'hide'];\r\nconst OVERFLOW_STRATEGY = predicateWithMessage((v) => OVERFLOW_STRAGEGIES.includes(v), `expecting an overflow strategy keyword such as 'ellipsis', or 'hide'`);\r\nconst TEXT_ALIGNS = ['left', 'center', 'right'];\r\nconst TEXT_ALIGN = predicateWithMessage((v) => TEXT_ALIGNS.includes(v), `expecting a text align keyword such as 'left', 'center', or 'right'`);\r\nconst VERTICAL_ALIGNS = ['top', 'middle', 'bottom'];\r\nconst VERTICAL_ALIGN = predicateWithMessage((v) => VERTICAL_ALIGNS.includes(v), `expecting a text align keyword such as 'top', 'middle', or 'bottom'`);\r\nconst DIRECTIONS = ['horizontal', 'vertical'];\r\nconst DIRECTION = predicateWithMessage((v) => DIRECTIONS.includes(v), `expecting a direction keyword such as 'horizontal' or 'vertical'`);\r\nconst OPT_DIRECTION = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, DIRECTION), `expecting an optional direction keyword such as 'horizontal' or 'vertical'`);\n\nvar ChartAxisDirection;\r\n(function (ChartAxisDirection) {\r\n    ChartAxisDirection[\"X\"] = \"x\";\r\n    ChartAxisDirection[\"Y\"] = \"y\";\r\n})(ChartAxisDirection || (ChartAxisDirection = {}));\n\nvar RedrawType;\r\n(function (RedrawType) {\r\n    RedrawType[RedrawType[\"NONE\"] = 0] = \"NONE\";\r\n    // Canvas doesn't need clearing, an incremental re-rerender is sufficient.\r\n    RedrawType[RedrawType[\"TRIVIAL\"] = 1] = \"TRIVIAL\";\r\n    // Group needs clearing, a semi-incremental re-render is sufficient.\r\n    RedrawType[RedrawType[\"MINOR\"] = 2] = \"MINOR\";\r\n    // Canvas needs to be cleared for these redraw types.\r\n    RedrawType[RedrawType[\"MAJOR\"] = 3] = \"MAJOR\";\r\n})(RedrawType || (RedrawType = {}));\r\n/** @returns true if new Function() is disabled in the current execution context. */\r\nfunction functionConstructorAvailable() {\r\n    try {\r\n        new Function('return true');\r\n        return true;\r\n    }\r\n    catch (e) {\r\n        return false;\r\n    }\r\n}\r\nconst STRING_FUNCTION_USEABLE = functionConstructorAvailable();\r\nfunction SceneChangeDetection(opts) {\r\n    const { changeCb, convertor } = opts !== null && opts !== void 0 ? opts : {};\r\n    return function (target, key) {\r\n        // `target` is either a constructor (static member) or prototype (instance member)\r\n        const privateKey = `__${key}`;\r\n        if (target[key]) {\r\n            return;\r\n        }\r\n        if (STRING_FUNCTION_USEABLE && changeCb == null && convertor == null) {\r\n            prepareFastGetSet(target, key, privateKey, opts);\r\n        }\r\n        else {\r\n            prepareSlowGetSet(target, key, privateKey, opts);\r\n        }\r\n    };\r\n}\r\nfunction prepareFastGetSet(target, key, privateKey, opts) {\r\n    const { redraw = RedrawType.TRIVIAL, type = 'normal', checkDirtyOnAssignment = false } = opts !== null && opts !== void 0 ? opts : {};\r\n    // Optimised code-path.\r\n    // Remove all conditional logic from runtime - generate a setter with the exact necessary\r\n    // steps, as these setters are called a LOT during update cycles.\r\n    const setterJs = new Function('value', `\n        const oldValue = this.${privateKey};\n        if (value !== oldValue) {\n            this.${privateKey} = value;\n            ${type === 'normal' ? `this.markDirty(this, ${redraw});` : ''}\n            ${type === 'transform' ? `this.markDirtyTransform(${redraw});` : ''}\n            ${type === 'path'\r\n        ? `if (!this._dirtyPath) { this._dirtyPath = true; this.markDirty(this, ${redraw}); }`\r\n        : ''}\n            ${type === 'font'\r\n        ? `if (!this._dirtyFont) { this._dirtyFont = true; this.markDirty(this, ${redraw}); }`\r\n        : ''}\n        }\n        ${checkDirtyOnAssignment\r\n        ? `if (value != null && value._dirty > ${RedrawType.NONE}) { this.markDirty(value, value._dirty); }`\r\n        : ''}\n`);\r\n    const getterJs = new Function(`return this.${privateKey};`);\r\n    Object.defineProperty(target, key, {\r\n        set: setterJs,\r\n        get: getterJs,\r\n        enumerable: true,\r\n        configurable: true,\r\n    });\r\n}\r\nfunction prepareSlowGetSet(target, key, privateKey, opts) {\r\n    const { redraw = RedrawType.TRIVIAL, type = 'normal', changeCb, convertor, checkDirtyOnAssignment = false, } = opts !== null && opts !== void 0 ? opts : {};\r\n    // Unoptimised but 'safe' code-path, for environments with CSP headers and no 'unsafe-eval'.\r\n    // We deliberately do not support debug branches found in the optimised path above, since\r\n    // for large data-set series performance deteriorates with every extra branch here.\r\n    const setter = function (value) {\r\n        const oldValue = this[privateKey];\r\n        value = convertor ? convertor(value) : value;\r\n        if (value !== oldValue) {\r\n            this[privateKey] = value;\r\n            if (type === 'normal')\r\n                this.markDirty(this, redraw);\r\n            if (type === 'transform')\r\n                this.markDirtyTransform(redraw);\r\n            if (type === 'path' && !this._dirtyPath) {\r\n                this._dirtyPath = true;\r\n                this.markDirty(this, redraw);\r\n            }\r\n            if (type === 'font' && !this._dirtyFont) {\r\n                this._dirtyFont = true;\r\n                this.markDirty(this, redraw);\r\n            }\r\n            if (changeCb)\r\n                changeCb(this);\r\n        }\r\n        if (checkDirtyOnAssignment && value != null && value._dirty > RedrawType.NONE)\r\n            this.markDirty(value, value._dirty);\r\n    };\r\n    const getter = function () {\r\n        return this[privateKey];\r\n    };\r\n    Object.defineProperty(target, key, {\r\n        set: setter,\r\n        get: getter,\r\n        enumerable: true,\r\n        configurable: true,\r\n    });\r\n}\r\nclass ChangeDetectable {\r\n    constructor() {\r\n        this._dirty = RedrawType.MAJOR;\r\n    }\r\n    markDirty(_source, type = RedrawType.TRIVIAL) {\r\n        if (this._dirty > type) {\r\n            return;\r\n        }\r\n        this._dirty = type;\r\n    }\r\n    markClean(_opts) {\r\n        this._dirty = RedrawType.NONE;\r\n    }\r\n    isDirty() {\r\n        return this._dirty > RedrawType.NONE;\r\n    }\r\n}\n\nconst ID_MAP = {};\r\nfunction resetIds() {\r\n    for (const key in ID_MAP) {\r\n        delete ID_MAP[key];\r\n    }\r\n}\r\nfunction createId(instance) {\r\n    var _a;\r\n    const constructor = instance.constructor;\r\n    const className = Object.prototype.hasOwnProperty.call(constructor, 'className')\r\n        ? constructor.className\r\n        : constructor.name;\r\n    if (!className) {\r\n        throw new Error(`The ${constructor} is missing the 'className' property.`);\r\n    }\r\n    const nextId = ((_a = ID_MAP[className]) !== null && _a !== void 0 ? _a : 0) + 1;\r\n    ID_MAP[className] = nextId;\r\n    return className + '-' + nextId;\r\n}\n\nfunction nearestSquared(point, objects, maxDistanceSquared = Infinity) {\r\n    const result = { nearest: undefined, distanceSquared: maxDistanceSquared };\r\n    for (const obj of objects) {\r\n        const thisDistance = obj.distanceSquared(point);\r\n        if (thisDistance === 0) {\r\n            return { nearest: obj, distanceSquared: 0 };\r\n        }\r\n        else if (thisDistance < result.distanceSquared) {\r\n            result.nearest = obj;\r\n            result.distanceSquared = thisDistance;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction nearestSquaredInContainer(point, container, maxDistanceSquared = Infinity) {\r\n    const tpoint = container.transformPoint(point.x, point.y);\r\n    const result = { nearest: undefined, distanceSquared: maxDistanceSquared };\r\n    for (const child of container.children) {\r\n        const { nearest, distanceSquared } = child.nearestSquared(tpoint, result.distanceSquared);\r\n        if (distanceSquared === 0) {\r\n            return { nearest, distanceSquared };\r\n        }\r\n        else if (distanceSquared < result.distanceSquared) {\r\n            result.nearest = nearest;\r\n            result.distanceSquared = distanceSquared;\r\n        }\r\n    }\r\n    return result;\r\n}\n\nclass BBox {\r\n    constructor(x, y, width, height) {\r\n        this.x = x;\r\n        this.y = y;\r\n        this.width = width;\r\n        this.height = height;\r\n    }\r\n    clone() {\r\n        const { x, y, width, height } = this;\r\n        return new BBox(x, y, width, height);\r\n    }\r\n    equals(other) {\r\n        return this.x === other.x && this.y === other.y && this.width === other.width && this.height === other.height;\r\n    }\r\n    containsPoint(x, y) {\r\n        return x >= this.x && x <= this.x + this.width && y >= this.y && y <= this.y + this.height;\r\n    }\r\n    collidesBBox(other) {\r\n        return (this.x < other.x + other.width &&\r\n            this.x + this.width > other.x &&\r\n            this.y < other.y + other.height &&\r\n            this.y + this.height > other.y);\r\n    }\r\n    isInfinite() {\r\n        return (Math.abs(this.x) === Infinity ||\r\n            Math.abs(this.y) === Infinity ||\r\n            Math.abs(this.width) === Infinity ||\r\n            Math.abs(this.height) === Infinity);\r\n    }\r\n    distanceSquared(point) {\r\n        if (this.containsPoint(point.x, point.y)) {\r\n            return 0;\r\n        }\r\n        const dx = point.x - Math.max(this.x, Math.min(point.x, this.x + this.width));\r\n        const dy = point.y - Math.max(this.y, Math.min(point.y, this.y + this.height));\r\n        return dx * dx + dy * dy;\r\n    }\r\n    static nearestBox(point, boxes) {\r\n        return nearestSquared(point, boxes);\r\n    }\r\n    shrink(amount, position) {\r\n        const apply = (pos, amt) => {\r\n            switch (pos) {\r\n                case 'top':\r\n                    this.y += amt;\r\n                // eslint-disable-next-line no-fallthrough\r\n                case 'bottom':\r\n                    this.height -= amt;\r\n                    break;\r\n                case 'left':\r\n                    this.x += amt;\r\n                // eslint-disable-next-line no-fallthrough\r\n                case 'right':\r\n                    this.width -= amt;\r\n                    break;\r\n                case 'vertical':\r\n                    this.y += amt;\r\n                    this.height -= amt * 2;\r\n                    break;\r\n                case 'horizontal':\r\n                    this.x += amt;\r\n                    this.width -= amt * 2;\r\n                    break;\r\n                case undefined:\r\n                    this.x += amt;\r\n                    this.width -= amt * 2;\r\n                    this.y += amt;\r\n                    this.height -= amt * 2;\r\n                    break;\r\n                // Unknown position - do nothing.\r\n            }\r\n        };\r\n        if (typeof amount === 'number') {\r\n            apply(position, amount);\r\n        }\r\n        else {\r\n            Object.entries(amount).forEach(([pos, amt]) => apply(pos, amt));\r\n        }\r\n        return this;\r\n    }\r\n    grow(amount, position) {\r\n        if (typeof amount === 'number') {\r\n            this.shrink(-amount, position);\r\n        }\r\n        else {\r\n            const paddingCopy = Object.assign({}, amount);\r\n            for (const key in paddingCopy) {\r\n                paddingCopy[key] *= -1;\r\n            }\r\n            this.shrink(paddingCopy);\r\n        }\r\n        return this;\r\n    }\r\n    static merge(boxes) {\r\n        let left = Infinity;\r\n        let top = Infinity;\r\n        let right = -Infinity;\r\n        let bottom = -Infinity;\r\n        boxes.forEach((box) => {\r\n            if (box.x < left) {\r\n                left = box.x;\r\n            }\r\n            if (box.y < top) {\r\n                top = box.y;\r\n            }\r\n            if (box.x + box.width > right) {\r\n                right = box.x + box.width;\r\n            }\r\n            if (box.y + box.height > bottom) {\r\n                bottom = box.y + box.height;\r\n            }\r\n        });\r\n        return new BBox(left, top, right - left, bottom - top);\r\n    }\r\n}\r\nBBox.zero = new BBox(0, 0, 0, 0);\n\n/**\r\n * As of Jan 8, 2019, Firefox still doesn't implement\r\n * `getTransform(): DOMMatrix;`\r\n * `setTransform(transform?: DOMMatrix2DInit)`\r\n * in the `CanvasRenderingContext2D`.\r\n * Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=928150\r\n * IE11 and Edge 44 also don't have the support.\r\n * Thus this class, to keep track of the current transform and\r\n * combine transformations.\r\n * Standards:\r\n * https://html.spec.whatwg.org/dev/canvas.html\r\n * https://www.w3.org/TR/geometry-1/\r\n */\r\nclass Matrix {\r\n    get e() {\r\n        return [...this.elements];\r\n    }\r\n    constructor(elements = [1, 0, 0, 1, 0, 0]) {\r\n        this.elements = elements;\r\n    }\r\n    setElements(elements) {\r\n        const e = this.elements;\r\n        // `this.elements = elements.slice()` is 4-5 times slower\r\n        // (in Chrome 71 and FF 64) than manually copying elements,\r\n        // since slicing allocates new memory.\r\n        // The performance of passing parameters individually\r\n        // vs as an array is about the same in both browsers, so we\r\n        // go with a single (array of elements) parameter, because\r\n        // `setElements(elements)` and `setElements([a, b, c, d, e, f])`\r\n        // calls give us roughly the same performance, versus\r\n        // `setElements(...elements)` and `setElements(a, b, c, d, e, f)`,\r\n        // where the spread operator causes a 20-30x performance drop\r\n        // (30x when compiled to ES5's `.apply(this, elements)`\r\n        //  20x when used natively).\r\n        e[0] = elements[0];\r\n        e[1] = elements[1];\r\n        e[2] = elements[2];\r\n        e[3] = elements[3];\r\n        e[4] = elements[4];\r\n        e[5] = elements[5];\r\n        return this;\r\n    }\r\n    get identity() {\r\n        const e = this.elements;\r\n        return e[0] === 1 && e[1] === 0 && e[2] === 0 && e[3] === 1 && e[4] === 0 && e[5] === 0;\r\n    }\r\n    /**\r\n     * Performs the AxB matrix multiplication and saves the result\r\n     * to `C`, if given, or to `A` otherwise.\r\n     */\r\n    AxB(A, B, C) {\r\n        const a = A[0] * B[0] + A[2] * B[1], b = A[1] * B[0] + A[3] * B[1], c = A[0] * B[2] + A[2] * B[3], d = A[1] * B[2] + A[3] * B[3], e = A[0] * B[4] + A[2] * B[5] + A[4], f = A[1] * B[4] + A[3] * B[5] + A[5];\r\n        C = C !== null && C !== void 0 ? C : A;\r\n        C[0] = a;\r\n        C[1] = b;\r\n        C[2] = c;\r\n        C[3] = d;\r\n        C[4] = e;\r\n        C[5] = f;\r\n    }\r\n    /**\r\n     * The `other` matrix gets post-multiplied to the current matrix.\r\n     * Returns the current matrix.\r\n     * @param other\r\n     */\r\n    multiplySelf(other) {\r\n        this.AxB(this.elements, other.elements);\r\n        return this;\r\n    }\r\n    /**\r\n     * The `other` matrix gets post-multiplied to the current matrix.\r\n     * Returns a new matrix.\r\n     * @param other\r\n     */\r\n    multiply(other) {\r\n        const elements = new Array(6);\r\n        this.AxB(this.elements, other.elements, elements);\r\n        return new Matrix(elements);\r\n    }\r\n    preMultiplySelf(other) {\r\n        this.AxB(other.elements, this.elements, this.elements);\r\n        return this;\r\n    }\r\n    /**\r\n     * Returns the inverse of this matrix as a new matrix.\r\n     */\r\n    inverse() {\r\n        const el = this.elements;\r\n        let a = el[0], b = el[1], c = el[2], d = el[3];\r\n        const e = el[4], f = el[5];\r\n        const rD = 1 / (a * d - b * c); // reciprocal of determinant\r\n        a *= rD;\r\n        b *= rD;\r\n        c *= rD;\r\n        d *= rD;\r\n        return new Matrix([d, -b, -c, a, c * f - d * e, b * e - a * f]);\r\n    }\r\n    /**\r\n     * Save the inverse of this matrix to the given matrix.\r\n     */\r\n    inverseTo(other) {\r\n        const el = this.elements;\r\n        let a = el[0], b = el[1], c = el[2], d = el[3];\r\n        const e = el[4], f = el[5];\r\n        const rD = 1 / (a * d - b * c); // reciprocal of determinant\r\n        a *= rD;\r\n        b *= rD;\r\n        c *= rD;\r\n        d *= rD;\r\n        other.setElements([d, -b, -c, a, c * f - d * e, b * e - a * f]);\r\n        return this;\r\n    }\r\n    invertSelf() {\r\n        const el = this.elements;\r\n        let a = el[0], b = el[1], c = el[2], d = el[3];\r\n        const e = el[4], f = el[5];\r\n        const rD = 1 / (a * d - b * c); // reciprocal of determinant\r\n        a *= rD;\r\n        b *= rD;\r\n        c *= rD;\r\n        d *= rD;\r\n        el[0] = d;\r\n        el[1] = -b;\r\n        el[2] = -c;\r\n        el[3] = a;\r\n        el[4] = c * f - d * e;\r\n        el[5] = b * e - a * f;\r\n        return this;\r\n    }\r\n    transformPoint(x, y) {\r\n        const e = this.elements;\r\n        return {\r\n            x: x * e[0] + y * e[2] + e[4],\r\n            y: x * e[1] + y * e[3] + e[5],\r\n        };\r\n    }\r\n    transformBBox(bbox, target) {\r\n        const elements = this.elements;\r\n        const xx = elements[0];\r\n        const xy = elements[1];\r\n        const yx = elements[2];\r\n        const yy = elements[3];\r\n        const h_w = bbox.width * 0.5;\r\n        const h_h = bbox.height * 0.5;\r\n        const cx = bbox.x + h_w;\r\n        const cy = bbox.y + h_h;\r\n        const w = Math.abs(h_w * xx) + Math.abs(h_h * yx);\r\n        const h = Math.abs(h_w * xy) + Math.abs(h_h * yy);\r\n        if (!target) {\r\n            target = new BBox(0, 0, 0, 0);\r\n        }\r\n        target.x = cx * xx + cy * yx + elements[4] - w;\r\n        target.y = cx * xy + cy * yy + elements[5] - h;\r\n        target.width = w + w;\r\n        target.height = h + h;\r\n        return target;\r\n    }\r\n    toContext(ctx) {\r\n        // It's fair to say that matrix multiplications are not cheap.\r\n        // However, updating path definitions on every frame isn't either, so\r\n        // it may be cheaper to just translate paths. It's also fair to\r\n        // say, that most paths will have to be re-rendered anyway, say\r\n        // rectangle paths in a bar chart, where an animation would happen when\r\n        // the data set changes and existing bars are morphed into new ones.\r\n        // Or a pie chart, where old sectors are also morphed into new ones.\r\n        // Same for the line chart. The only plausible case where translating\r\n        // existing paths would be enough, is the scatter chart, where marker\r\n        // icons, typically circles, stay the same size. But if circle radii\r\n        // are bound to some data points, even circle paths would have to be\r\n        // updated. And thus it makes sense to optimize for fewer matrix\r\n        // transforms, where transform matrices of paths are mostly identity\r\n        // matrices and `x`/`y`, `centerX`/`centerY` and similar properties\r\n        // are used to define a path at specific coordinates. And only groups\r\n        // are used to collectively apply a transform to a set of nodes.\r\n        // If the matrix is mostly identity (95% of the time),\r\n        // the `if (this.isIdentity)` check can make this call 3-4 times\r\n        // faster on average: https://jsperf.com/matrix-check-first-vs-always-set\r\n        if (this.identity) {\r\n            return;\r\n        }\r\n        const e = this.elements;\r\n        ctx.transform(e[0], e[1], e[2], e[3], e[4], e[5]);\r\n    }\r\n    static flyweight(sourceMatrix) {\r\n        return Matrix.instance.setElements(sourceMatrix.elements);\r\n    }\r\n    static updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, opts) {\r\n        // Assume that centers of scaling and rotation are at the origin.\r\n        const [bbcx, bbcy] = [0, 0];\r\n        const sx = scalingX;\r\n        const sy = scalingY;\r\n        let scx;\r\n        let scy;\r\n        if (sx === 1 && sy === 1) {\r\n            scx = 0;\r\n            scy = 0;\r\n        }\r\n        else {\r\n            scx = (opts === null || opts === void 0 ? void 0 : opts.scalingCenterX) == null ? bbcx : opts === null || opts === void 0 ? void 0 : opts.scalingCenterX;\r\n            scy = (opts === null || opts === void 0 ? void 0 : opts.scalingCenterY) == null ? bbcy : opts === null || opts === void 0 ? void 0 : opts.scalingCenterY;\r\n        }\r\n        const r = rotation;\r\n        const cos = Math.cos(r);\r\n        const sin = Math.sin(r);\r\n        let rcx;\r\n        let rcy;\r\n        if (r === 0) {\r\n            rcx = 0;\r\n            rcy = 0;\r\n        }\r\n        else {\r\n            rcx = (opts === null || opts === void 0 ? void 0 : opts.rotationCenterX) == null ? bbcx : opts === null || opts === void 0 ? void 0 : opts.rotationCenterX;\r\n            rcy = (opts === null || opts === void 0 ? void 0 : opts.rotationCenterY) == null ? bbcy : opts === null || opts === void 0 ? void 0 : opts.rotationCenterY;\r\n        }\r\n        const tx = translationX;\r\n        const ty = translationY;\r\n        // The transform matrix `M` is a result of the following transformations:\r\n        // 1) translate the center of scaling to the origin\r\n        // 2) scale\r\n        // 3) translate back\r\n        // 4) translate the center of rotation to the origin\r\n        // 5) rotate\r\n        // 6) translate back\r\n        // 7) translate\r\n        //         (7)          (6)             (5)             (4)           (3)           (2)           (1)\r\n        //     | 1 0 tx |   | 1 0 rcx |   | cos -sin 0 |   | 1 0 -rcx |   | 1 0 scx |   | sx 0 0 |   | 1 0 -scx |\r\n        // M = | 0 1 ty | * | 0 1 rcy | * | sin  cos 0 | * | 0 1 -rcy | * | 0 1 scy | * | 0 sy 0 | * | 0 1 -scy |\r\n        //     | 0 0  1 |   | 0 0  1  |   |  0    0  1 |   | 0 0  1   |   | 0 0  1  |   | 0  0 0 |   | 0 0  1   |\r\n        // Translation after steps 1-4 above:\r\n        const tx4 = scx * (1 - sx) - rcx;\r\n        const ty4 = scy * (1 - sy) - rcy;\r\n        matrix.setElements([\r\n            cos * sx,\r\n            sin * sx,\r\n            -sin * sy,\r\n            cos * sy,\r\n            cos * tx4 - sin * ty4 + rcx + tx,\r\n            sin * tx4 + cos * ty4 + rcy + ty,\r\n        ]);\r\n        return matrix;\r\n    }\r\n    static fromContext(ctx) {\r\n        const domMatrix = ctx.getTransform();\r\n        return new Matrix([domMatrix.a, domMatrix.b, domMatrix.c, domMatrix.d, domMatrix.e, domMatrix.f]);\r\n    }\r\n}\r\nMatrix.instance = new Matrix();\n\nvar PointerEvents;\r\n(function (PointerEvents) {\r\n    PointerEvents[PointerEvents[\"All\"] = 0] = \"All\";\r\n    PointerEvents[PointerEvents[\"None\"] = 1] = \"None\";\r\n})(PointerEvents || (PointerEvents = {}));\r\nconst zIndexChangedCallback = (o) => {\r\n    if (o.parent) {\r\n        o.parent.dirtyZIndex = true;\r\n    }\r\n    o.zIndexChanged();\r\n};\r\n/**\r\n * Abstract scene graph node.\r\n * Each node can have zero or one parent and belong to zero or one scene.\r\n */\r\nclass Node extends ChangeDetectable {\r\n    /**\r\n     * Some arbitrary data bound to the node.\r\n     */\r\n    get datum() {\r\n        var _a, _b;\r\n        return (_a = this._datum) !== null && _a !== void 0 ? _a : (_b = this._parent) === null || _b === void 0 ? void 0 : _b.datum;\r\n    }\r\n    get previousDatum() {\r\n        return this._previousDatum;\r\n    }\r\n    set datum(datum) {\r\n        if (this._datum !== datum)\r\n            this._previousDatum = this._datum;\r\n        this._datum = datum;\r\n    }\r\n    _setLayerManager(value) {\r\n        this._layerManager = value;\r\n        this._debug = value === null || value === void 0 ? void 0 : value.debug;\r\n        for (const child of this._children) {\r\n            child._setLayerManager(value);\r\n        }\r\n        for (const child of this._virtualChildren) {\r\n            child._setLayerManager(value);\r\n        }\r\n    }\r\n    get layerManager() {\r\n        return this._layerManager;\r\n    }\r\n    get parent() {\r\n        return this._parent;\r\n    }\r\n    get children() {\r\n        if (this._virtualChildren.length === 0)\r\n            return this._children;\r\n        const result = [...this._children];\r\n        for (const next of this._virtualChildren) {\r\n            result.push(...next.children);\r\n        }\r\n        return result;\r\n    }\r\n    get virtualChildren() {\r\n        return this._virtualChildren;\r\n    }\r\n    hasVirtualChildren() {\r\n        return this._virtualChildren.length > 0;\r\n    }\r\n    setProperties(styles, pickKeys) {\r\n        const keys = pickKeys !== null && pickKeys !== void 0 ? pickKeys : Object.keys(styles);\r\n        for (const key of keys) {\r\n            this[key] = styles[key];\r\n        }\r\n        return this;\r\n    }\r\n    /**\r\n     * Appends one or more new node instances to this parent.\r\n     * If one needs to:\r\n     * - move a child to the end of the list of children\r\n     * - move a child from one parent to another (including parents in other scenes)\r\n     * one should use the {@link insertBefore} method instead.\r\n     * @param nodes A node or nodes to append.\r\n     */\r\n    append(nodes) {\r\n        // Passing a single parameter to an open-ended version of `append`\r\n        // would be 30-35% slower than this.\r\n        if (!Array.isArray(nodes)) {\r\n            nodes = [nodes];\r\n        }\r\n        for (const node of nodes) {\r\n            if (node.parent) {\r\n                throw new Error(`${node} already belongs to another parent: ${node.parent}.`);\r\n            }\r\n            if (node.layerManager) {\r\n                throw new Error(`${node} already belongs to a scene: ${node.layerManager}.`);\r\n            }\r\n            if (this.childSet[node.id]) {\r\n                // Cast to `any` to avoid `Property 'name' does not exist on type 'Function'`.\r\n                throw new Error(`Duplicate ${node.constructor.name} node: ${node}`);\r\n            }\r\n            if (node.isVirtual) {\r\n                this._virtualChildren.push(node);\r\n            }\r\n            else {\r\n                this._children.push(node);\r\n            }\r\n            this.childSet[node.id] = true;\r\n            node._parent = this;\r\n            node._setLayerManager(this.layerManager);\r\n        }\r\n        this.dirtyZIndex = true;\r\n        this.markDirty(this, RedrawType.MAJOR);\r\n    }\r\n    appendChild(node) {\r\n        this.append(node);\r\n        return node;\r\n    }\r\n    removeChild(node) {\r\n        const error = () => {\r\n            throw new Error(`The node to be removed is not a child of this node.`);\r\n        };\r\n        if (node.parent !== this) {\r\n            error();\r\n        }\r\n        if (node.isVirtual) {\r\n            const i = this._virtualChildren.indexOf(node);\r\n            if (i < 0)\r\n                error();\r\n            this._virtualChildren.splice(i, 1);\r\n        }\r\n        else {\r\n            const i = this._children.indexOf(node);\r\n            if (i < 0)\r\n                error();\r\n            this._children.splice(i, 1);\r\n        }\r\n        delete this.childSet[node.id];\r\n        node._parent = undefined;\r\n        node._setLayerManager();\r\n        this.dirtyZIndex = true;\r\n        this.markDirty(node, RedrawType.MAJOR);\r\n        return node;\r\n    }\r\n    calculateCumulativeMatrix() {\r\n        this.computeTransformMatrix();\r\n        const matrix = Matrix.flyweight(this.matrix);\r\n        let parent = this.parent;\r\n        while (parent) {\r\n            parent.computeTransformMatrix();\r\n            matrix.preMultiplySelf(parent.matrix);\r\n            parent = parent.parent;\r\n        }\r\n        return matrix;\r\n    }\r\n    transformPoint(x, y) {\r\n        const matrix = this.calculateCumulativeMatrix();\r\n        return matrix.invertSelf().transformPoint(x, y);\r\n    }\r\n    inverseTransformPoint(x, y) {\r\n        const matrix = this.calculateCumulativeMatrix();\r\n        return matrix.transformPoint(x, y);\r\n    }\r\n    transformBBox(bbox) {\r\n        const matrix = this.calculateCumulativeMatrix();\r\n        return matrix.invertSelf().transformBBox(bbox);\r\n    }\r\n    inverseTransformBBox(bbox) {\r\n        const matrix = this.calculateCumulativeMatrix();\r\n        return matrix.transformBBox(bbox);\r\n    }\r\n    markDirtyTransform() {\r\n        this.dirtyTransform = true;\r\n        this.markDirty(this, RedrawType.MAJOR);\r\n    }\r\n    constructor({ isVirtual, tag } = {}) {\r\n        super();\r\n        /** Unique number to allow creation order to be easily determined. */\r\n        this.serialNumber = Node._nextSerialNumber++;\r\n        /**\r\n         * Unique node ID in the form `ClassName-NaturalNumber`.\r\n         */\r\n        this.id = createId(this);\r\n        /**\r\n         * To simplify the type system (especially in Selections) we don't have the `Parent` node\r\n         * (one that has children). Instead, we mimic HTML DOM, where any node can have children.\r\n         * But we still need to distinguish regular leaf nodes from container leafs somehow.\r\n         */\r\n        this.isContainerNode = false;\r\n        this._virtualChildren = [];\r\n        this._children = [];\r\n        // Used to check for duplicate nodes.\r\n        this.childSet = {}; // new Set<Node>()\r\n        // These matrices may need to have package level visibility\r\n        // for performance optimization purposes.\r\n        this.matrix = new Matrix();\r\n        this.inverseMatrix = new Matrix();\r\n        this.dirtyTransform = false;\r\n        this.scalingX = 1;\r\n        this.scalingY = 1;\r\n        /**\r\n         * The center of scaling.\r\n         * The default value of `null` means the scaling center will be\r\n         * determined automatically, as the center of the bounding box\r\n         * of a node.\r\n         */\r\n        this.scalingCenterX = null;\r\n        this.scalingCenterY = null;\r\n        this.rotationCenterX = null;\r\n        this.rotationCenterY = null;\r\n        /**\r\n         * Rotation angle in radians.\r\n         * The value is set as is. No normalization to the [-180, 180) or [0, 360)\r\n         * interval is performed.\r\n         */\r\n        this.rotation = 0;\r\n        this.translationX = 0;\r\n        this.translationY = 0;\r\n        this.visible = true;\r\n        this.dirtyZIndex = false;\r\n        this.zIndex = 0;\r\n        /** Discriminators for render order within a zIndex. */\r\n        this.zIndexSubOrder = undefined;\r\n        this.pointerEvents = PointerEvents.All;\r\n        this.isVirtual = isVirtual !== null && isVirtual !== void 0 ? isVirtual : false;\r\n        this.tag = tag !== null && tag !== void 0 ? tag : NaN;\r\n    }\r\n    containsPoint(_x, _y) {\r\n        return false;\r\n    }\r\n    /**\r\n     * Hit testing method.\r\n     * Recursively checks if the given point is inside this node or any of its children.\r\n     * Returns the first matching node or `undefined`.\r\n     * Nodes that render later (show on top) are hit tested first.\r\n     */\r\n    pickNode(x, y) {\r\n        var _a;\r\n        if (!this.visible || this.pointerEvents === PointerEvents.None || !this.containsPoint(x, y)) {\r\n            return;\r\n        }\r\n        const children = this.children;\r\n        if (children.length > 1000) {\r\n            // Try to optimise which children to interrogate; BBox calculation is an approximation\r\n            // for more complex shapes, so discarding items based on this will save a lot of\r\n            // processing when the point is nowhere near the child.\r\n            for (let i = children.length - 1; i >= 0; i--) {\r\n                const child = children[i];\r\n                const containsPoint = (_a = child.computeTransformedBBox()) === null || _a === void 0 ? void 0 : _a.containsPoint(x, y);\r\n                const hit = containsPoint ? child.pickNode(x, y) : undefined;\r\n                if (hit) {\r\n                    return hit;\r\n                }\r\n            }\r\n        }\r\n        else if (children.length) {\r\n            // Nodes added later should be hit-tested first,\r\n            // as they are rendered on top of the previously added nodes.\r\n            for (let i = children.length - 1; i >= 0; i--) {\r\n                const hit = children[i].pickNode(x, y);\r\n                if (hit) {\r\n                    return hit;\r\n                }\r\n            }\r\n        }\r\n        else if (!this.isContainerNode) {\r\n            // a leaf node, but not a container leaf\r\n            return this;\r\n        }\r\n    }\r\n    findNodes(predicate) {\r\n        const result = predicate(this) ? [this] : [];\r\n        for (const child of this.children) {\r\n            const childResult = child.findNodes(predicate);\r\n            if (childResult) {\r\n                result.push(...childResult);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    computeBBox() {\r\n        return;\r\n    }\r\n    computeTransformedBBox() {\r\n        const bbox = this.computeBBox();\r\n        if (!bbox) {\r\n            return undefined;\r\n        }\r\n        this.computeTransformMatrix();\r\n        const matrix = Matrix.flyweight(this.matrix);\r\n        let parent = this.parent;\r\n        while (parent) {\r\n            parent.computeTransformMatrix();\r\n            matrix.preMultiplySelf(parent.matrix);\r\n            parent = parent.parent;\r\n        }\r\n        matrix.transformBBox(bbox, bbox);\r\n        return bbox;\r\n    }\r\n    computeTransformMatrix() {\r\n        if (!this.dirtyTransform) {\r\n            return;\r\n        }\r\n        const { matrix, scalingX, scalingY, rotation, translationX, translationY, scalingCenterX, scalingCenterY, rotationCenterX, rotationCenterY, } = this;\r\n        Matrix.updateTransformMatrix(matrix, scalingX, scalingY, rotation, translationX, translationY, {\r\n            scalingCenterX,\r\n            scalingCenterY,\r\n            rotationCenterX,\r\n            rotationCenterY,\r\n        });\r\n        matrix.inverseTo(this.inverseMatrix);\r\n        this.dirtyTransform = false;\r\n    }\r\n    render(renderCtx) {\r\n        const { stats } = renderCtx;\r\n        this._dirty = RedrawType.NONE;\r\n        if (stats)\r\n            stats.nodesRendered++;\r\n    }\r\n    clearBBox(ctx) {\r\n        const bbox = this.computeBBox();\r\n        if (bbox == null) {\r\n            return;\r\n        }\r\n        const { x, y, width, height } = bbox;\r\n        const topLeft = this.transformPoint(x, y);\r\n        const bottomRight = this.transformPoint(x + width, y + height);\r\n        ctx.clearRect(topLeft.x, topLeft.y, bottomRight.x - topLeft.x, bottomRight.y - topLeft.y);\r\n    }\r\n    markDirty(_source, type = RedrawType.TRIVIAL, parentType = type) {\r\n        if (this._dirty > type) {\r\n            return;\r\n        }\r\n        if (this._dirty === type && type === parentType) {\r\n            return;\r\n        }\r\n        this._dirty = type;\r\n        if (this.parent) {\r\n            this.parent.markDirty(this, parentType);\r\n        }\r\n        else if (this.layerManager) {\r\n            this.layerManager.markDirty();\r\n        }\r\n    }\r\n    get dirty() {\r\n        return this._dirty;\r\n    }\r\n    markClean(opts) {\r\n        const { force = false, recursive = true } = opts !== null && opts !== void 0 ? opts : {};\r\n        if (this._dirty === RedrawType.NONE && !force) {\r\n            return;\r\n        }\r\n        this._dirty = RedrawType.NONE;\r\n        if (recursive !== false) {\r\n            for (const child of this._virtualChildren) {\r\n                child.markClean({ force });\r\n            }\r\n        }\r\n        if (recursive === true) {\r\n            for (const child of this._children) {\r\n                child.markClean({ force });\r\n            }\r\n        }\r\n    }\r\n    visibilityChanged() {\r\n        // Override point for sub-classes to react to visibility changes.\r\n    }\r\n    get nodeCount() {\r\n        let count = 1;\r\n        let dirtyCount = this._dirty >= RedrawType.NONE || this.dirtyTransform ? 1 : 0;\r\n        let visibleCount = this.visible ? 1 : 0;\r\n        const countChild = (child) => {\r\n            const { count: childCount, visibleCount: childVisibleCount, dirtyCount: childDirtyCount } = child.nodeCount;\r\n            count += childCount;\r\n            visibleCount += childVisibleCount;\r\n            dirtyCount += childDirtyCount;\r\n        };\r\n        for (const child of this._children) {\r\n            countChild(child);\r\n        }\r\n        for (const child of this._virtualChildren) {\r\n            countChild(child);\r\n        }\r\n        return { count, visibleCount, dirtyCount };\r\n    }\r\n    zIndexChanged() {\r\n        // Override point for sub-classes.\r\n    }\r\n}\r\nNode._nextSerialNumber = 0;\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Number)\r\n], Node.prototype, \"scalingX\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Number)\r\n], Node.prototype, \"scalingY\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Object)\r\n], Node.prototype, \"scalingCenterX\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Object)\r\n], Node.prototype, \"scalingCenterY\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Object)\r\n], Node.prototype, \"rotationCenterX\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Object)\r\n], Node.prototype, \"rotationCenterY\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Number)\r\n], Node.prototype, \"rotation\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Number)\r\n], Node.prototype, \"translationX\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ type: 'transform' }),\r\n    __metadata(\"design:type\", Number)\r\n], Node.prototype, \"translationY\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR, changeCb: (o) => o.visibilityChanged() }),\r\n    __metadata(\"design:type\", Boolean)\r\n], Node.prototype, \"visible\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({\r\n        redraw: RedrawType.TRIVIAL,\r\n        changeCb: zIndexChangedCallback,\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Node.prototype, \"zIndex\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({\r\n        redraw: RedrawType.TRIVIAL,\r\n        changeCb: zIndexChangedCallback,\r\n    })\r\n    /** Discriminators for render order within a zIndex. */\r\n    ,\r\n    __metadata(\"design:type\", Array)\r\n], Node.prototype, \"zIndexSubOrder\", void 0);\n\nclass DropShadow extends ChangeDetectable {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.enabled = true;\r\n        this.color = 'rgba(0, 0, 0, 0.5)';\r\n        this.xOffset = 0;\r\n        this.yOffset = 0;\r\n        this.blur = 5;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Object)\r\n], DropShadow.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Object)\r\n], DropShadow.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Object)\r\n], DropShadow.prototype, \"xOffset\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Object)\r\n], DropShadow.prototype, \"yOffset\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Object)\r\n], DropShadow.prototype, \"blur\", void 0);\n\nconst MOBILE = [/Android/i, /webOS/i, /iPhone/i, /iPad/i, /iPod/i, /BlackBerry/i, /Windows Phone/i];\r\nfunction isDesktop() {\r\n    if (typeof navigator === 'undefined') {\r\n        return true;\r\n    }\r\n    const userAgent = navigator.userAgent;\r\n    return !MOBILE.some((r) => r.test(userAgent));\r\n}\n\n/**\r\n * Wraps the native Canvas element and overrides its CanvasRenderingContext2D to\r\n * provide resolution independent rendering based on `window.devicePixelRatio`.\r\n */\r\nclass HdpiCanvas {\r\n    // The width/height attributes of the Canvas element default to\r\n    // 300/150 according to w3.org.\r\n    constructor(opts) {\r\n        this._enabled = true;\r\n        // `NaN` is deliberate here, so that overrides are always applied\r\n        // and the `resetTransform` inside the `resize` method works in IE11.\r\n        this._pixelRatio = NaN;\r\n        this._width = 0;\r\n        this._height = 0;\r\n        const { document, window, width = 600, height = 300, domLayer = false, zIndex = 0, name = undefined, overrideDevicePixelRatio = undefined, } = opts;\r\n        this.document = document;\r\n        this.window = window;\r\n        HdpiCanvas.document = document;\r\n        // Create canvas and immediately apply width + height to avoid out-of-memory\r\n        // errors on iOS/iPadOS Safari.\r\n        this.element = document.createElement('canvas');\r\n        this.element.width = width;\r\n        this.element.height = height;\r\n        this.realContext = this.element.getContext('2d');\r\n        this.imageSource = this.realContext.canvas;\r\n        const { style } = this.element;\r\n        style.userSelect = 'none';\r\n        style.display = 'block';\r\n        if (domLayer) {\r\n            style.position = 'absolute';\r\n            style.zIndex = String(zIndex);\r\n            style.top = '0';\r\n            style.left = '0';\r\n            style.pointerEvents = 'none';\r\n            style.opacity = `1`;\r\n            if (name) {\r\n                this.element.id = name;\r\n            }\r\n        }\r\n        this.context = this.setPixelRatio(overrideDevicePixelRatio);\r\n        this.resize(width, height);\r\n    }\r\n    set container(value) {\r\n        if (this._container !== value) {\r\n            this.remove();\r\n            if (value) {\r\n                value.appendChild(this.element);\r\n            }\r\n            this._container = value;\r\n        }\r\n    }\r\n    get container() {\r\n        return this._container;\r\n    }\r\n    set enabled(value) {\r\n        this.element.style.display = value ? 'block' : 'none';\r\n        this._enabled = !!value;\r\n    }\r\n    get enabled() {\r\n        return this._enabled;\r\n    }\r\n    remove() {\r\n        const { parentNode } = this.element;\r\n        if (parentNode != null) {\r\n            parentNode.removeChild(this.element);\r\n        }\r\n    }\r\n    destroy() {\r\n        this.element.remove();\r\n        // Workaround memory allocation quirks in iOS Safari by resizing to 0x0 and clearing.\r\n        // See https://bugs.webkit.org/show_bug.cgi?id=195325.\r\n        this.element.width = 0;\r\n        this.element.height = 0;\r\n        this.context.clearRect(0, 0, 0, 0);\r\n        Object.freeze(this);\r\n    }\r\n    snapshot() {\r\n        // No-op for compatibility with HdpiOffscreenCanvas.\r\n    }\r\n    clear() {\r\n        this.context.save();\r\n        this.context.resetTransform();\r\n        this.context.clearRect(0, 0, this.width, this.height);\r\n        this.context.restore();\r\n    }\r\n    toImage() {\r\n        const img = this.document.createElement('img');\r\n        img.src = this.getDataURL();\r\n        return img;\r\n    }\r\n    getDataURL(type) {\r\n        return this.element.toDataURL(type);\r\n    }\r\n    /**\r\n     * @param fileName The name of the downloaded file.\r\n     * @param fileFormat The file format, the default is `image/png`\r\n     */\r\n    download(fileName, fileFormat = 'image/png') {\r\n        fileName = (fileName !== null && fileName !== void 0 ? fileName : '').trim() || 'image';\r\n        const dataUrl = this.getDataURL(fileFormat);\r\n        const document = this.document;\r\n        const a = document.createElement('a');\r\n        a.href = dataUrl;\r\n        a.download = fileName;\r\n        a.style.display = 'none';\r\n        document.body.appendChild(a); // required for the `click` to work in Firefox\r\n        a.click();\r\n        document.body.removeChild(a);\r\n    }\r\n    get pixelRatio() {\r\n        return this._pixelRatio;\r\n    }\r\n    /**\r\n     * Changes the pixel ratio of the Canvas element to the given value,\r\n     * or uses the window.devicePixelRatio (default), then resizes the Canvas\r\n     * element accordingly (default).\r\n     */\r\n    setPixelRatio(ratio) {\r\n        let pixelRatio = ratio !== null && ratio !== void 0 ? ratio : this.window.devicePixelRatio;\r\n        if (!isDesktop()) {\r\n            // Mobile browsers have stricter memory limits, we reduce rendering resolution to\r\n            // improve stability on mobile browsers. iOS Safari 12->16 are pain-points since they\r\n            // have memory allocation quirks - see https://bugs.webkit.org/show_bug.cgi?id=195325.\r\n            pixelRatio = 1;\r\n        }\r\n        this._pixelRatio = pixelRatio;\r\n        return HdpiCanvas.overrideScale(this.realContext, pixelRatio);\r\n    }\r\n    set pixelated(value) {\r\n        this.element.style.imageRendering = value ? 'pixelated' : 'auto';\r\n    }\r\n    get pixelated() {\r\n        return this.element.style.imageRendering === 'pixelated';\r\n    }\r\n    get width() {\r\n        return this._width;\r\n    }\r\n    get height() {\r\n        return this._height;\r\n    }\r\n    resize(width, height) {\r\n        if (!(width > 0 && height > 0)) {\r\n            return;\r\n        }\r\n        const { element, context, pixelRatio } = this;\r\n        element.width = Math.round(width * pixelRatio);\r\n        element.height = Math.round(height * pixelRatio);\r\n        element.style.width = width + 'px';\r\n        element.style.height = height + 'px';\r\n        context.resetTransform();\r\n        this._width = width;\r\n        this._height = height;\r\n    }\r\n    static get textMeasuringContext() {\r\n        if (this._textMeasuringContext) {\r\n            return this._textMeasuringContext;\r\n        }\r\n        const canvas = this.document.createElement('canvas');\r\n        this._textMeasuringContext = canvas.getContext('2d');\r\n        return this._textMeasuringContext;\r\n    }\r\n    static get svgText() {\r\n        if (this._svgText) {\r\n            return this._svgText;\r\n        }\r\n        const xmlns = 'http://www.w3.org/2000/svg';\r\n        const svg = document.createElementNS(xmlns, 'svg');\r\n        svg.setAttribute('width', '100');\r\n        svg.setAttribute('height', '100');\r\n        // Add a descriptive class name in case someone sees this SVG element\r\n        // in devtools and wonders about its purpose:\r\n        if (svg.classList) {\r\n            svg.classList.add('text-measuring-svg');\r\n        }\r\n        else {\r\n            svg.setAttribute('class', 'text-measuring-svg');\r\n        }\r\n        svg.style.position = 'absolute';\r\n        svg.style.top = '-1000px';\r\n        svg.style.visibility = 'hidden';\r\n        const svgText = document.createElementNS(xmlns, 'text');\r\n        svgText.setAttribute('x', '0');\r\n        svgText.setAttribute('y', '30');\r\n        svgText.setAttribute('text', 'black');\r\n        svg.appendChild(svgText);\r\n        document.body.appendChild(svg);\r\n        this._svgText = svgText;\r\n        return svgText;\r\n    }\r\n    static get has() {\r\n        if (this._has) {\r\n            return this._has;\r\n        }\r\n        const isChrome = typeof navigator === 'undefined' || navigator.userAgent.indexOf('Chrome') > -1;\r\n        const isFirefox = typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Firefox') > -1;\r\n        const isSafari = !isChrome && typeof navigator !== 'undefined' && navigator.userAgent.indexOf('Safari') > -1;\r\n        this._has = Object.freeze({\r\n            textMetrics: this.textMeasuringContext.measureText('test').actualBoundingBoxDescent !== undefined &&\r\n                // Firefox implemented advanced TextMetrics object in v74:\r\n                // https://bugzilla.mozilla.org/show_bug.cgi?id=1102584\r\n                // but it's buggy, so we'll keep using the SVG for text measurement in Firefox for now.\r\n                !isFirefox &&\r\n                !isSafari,\r\n            getTransform: this.textMeasuringContext.getTransform !== undefined,\r\n        });\r\n        return this._has;\r\n    }\r\n    static measureText(text, font, textBaseline, textAlign) {\r\n        const ctx = this.textMeasuringContext;\r\n        ctx.font = font;\r\n        ctx.textBaseline = textBaseline;\r\n        ctx.textAlign = textAlign;\r\n        return ctx.measureText(text);\r\n    }\r\n    /**\r\n     * Returns the width and height of the measured text.\r\n     * @param text The single-line text to measure.\r\n     * @param font The font shorthand string.\r\n     */\r\n    static getTextSize(text, font) {\r\n        if (this.has.textMetrics) {\r\n            const ctx = this.textMeasuringContext;\r\n            ctx.font = font;\r\n            const metrics = ctx.measureText(text);\r\n            return {\r\n                width: metrics.width,\r\n                height: metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent,\r\n            };\r\n        }\r\n        else {\r\n            return this.measureSvgText(text, font);\r\n        }\r\n    }\r\n    static measureSvgText(text, font) {\r\n        const cache = this.textSizeCache;\r\n        const fontCache = cache[font];\r\n        // Note: consider not caching the size of numeric strings.\r\n        // For example: if (isNaN(+text)) { // skip\r\n        if (fontCache) {\r\n            const size = fontCache[text];\r\n            if (size) {\r\n                return size;\r\n            }\r\n        }\r\n        else {\r\n            cache[font] = {};\r\n        }\r\n        const svgText = this.svgText;\r\n        svgText.style.font = font;\r\n        svgText.textContent = text;\r\n        // `getBBox` returns an instance of `SVGRect` with the same `width` and `height`\r\n        // measurements as `DOMRect` instance returned by the `getBoundingClientRect`.\r\n        // But the `SVGRect` instance has half the properties of the `DOMRect`,\r\n        // so we use the `getBBox` method.\r\n        const bbox = svgText.getBBox();\r\n        const size = {\r\n            width: bbox.width,\r\n            height: bbox.height,\r\n        };\r\n        cache[font][text] = size;\r\n        return size;\r\n    }\r\n    static overrideScale(ctx, scale) {\r\n        let depth = 0;\r\n        const overrides = {\r\n            save() {\r\n                this.$save();\r\n                depth++;\r\n            },\r\n            restore() {\r\n                if (depth > 0) {\r\n                    this.$restore();\r\n                    depth--;\r\n                }\r\n                else {\r\n                    throw new Error('AG Charts - Unable to restore() past depth 0');\r\n                }\r\n            },\r\n            setTransform(a, b, c, d, e, f) {\r\n                if (typeof a === 'object') {\r\n                    this.$setTransform(a);\r\n                }\r\n                else {\r\n                    this.$setTransform(a * scale, b * scale, c * scale, d * scale, e * scale, f * scale);\r\n                }\r\n            },\r\n            resetTransform() {\r\n                // As of Jan 8, 2019, `resetTransform` is still an \"experimental technology\",\r\n                // and doesn't work in IE11 and Edge 44.\r\n                this.$setTransform(scale, 0, 0, scale, 0, 0);\r\n            },\r\n            verifyDepthZero() {\r\n                if (depth !== 0) {\r\n                    throw new Error('AG Charts - Save/restore depth is non-zero: ' + depth);\r\n                }\r\n            },\r\n        };\r\n        for (const name in overrides) {\r\n            if (Object.prototype.hasOwnProperty.call(overrides, name)) {\r\n                // Save native methods under prefixed names,\r\n                // if this hasn't been done by the previous overrides already.\r\n                if (!ctx['$' + name]) {\r\n                    ctx['$' + name] = ctx[name];\r\n                }\r\n                // Replace native methods with overrides,\r\n                // or previous overrides with the new ones.\r\n                ctx[name] = overrides[name];\r\n            }\r\n        }\r\n        return ctx;\r\n    }\r\n}\r\nHdpiCanvas.document = globalThis.document;\r\nHdpiCanvas.textSizeCache = {};\n\nclass Gradient {\r\n    constructor() {\r\n        this.stops = [];\r\n    }\r\n}\n\nclass LinearGradient extends Gradient {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.angle = 0;\r\n    }\r\n    createGradient(ctx, bbox) {\r\n        // Gradient 0° angle starts at top according to CSS spec\r\n        const angleOffset = 90;\r\n        const { stops, angle } = this;\r\n        const radians = normalizeAngle360(toRadians(angle + angleOffset));\r\n        const cos = Math.cos(radians);\r\n        const sin = Math.sin(radians);\r\n        const w = bbox.width;\r\n        const h = bbox.height;\r\n        const cx = bbox.x + w * 0.5;\r\n        const cy = bbox.y + h * 0.5;\r\n        if (w > 0 && h > 0) {\r\n            const diagonal = Math.sqrt(h * h + w * w) / 2;\r\n            const diagonalAngle = Math.atan2(h, w);\r\n            let quarteredAngle;\r\n            if (radians < Math.PI / 2) {\r\n                quarteredAngle = radians;\r\n            }\r\n            else if (radians < Math.PI) {\r\n                quarteredAngle = Math.PI - radians;\r\n            }\r\n            else if (radians < (3 * Math.PI) / 2) {\r\n                quarteredAngle = radians - Math.PI;\r\n            }\r\n            else {\r\n                quarteredAngle = 2 * Math.PI - radians;\r\n            }\r\n            const l = diagonal * Math.abs(Math.cos(quarteredAngle - diagonalAngle));\r\n            const gradient = ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);\r\n            stops.forEach((stop) => {\r\n                gradient.addColorStop(stop.offset, stop.color);\r\n            });\r\n            return gradient;\r\n        }\r\n        return 'black';\r\n    }\r\n}\n\nconst LINEAR_GRADIENT_REGEXP = /^linear-gradient\\((.*?)deg,\\s*(.*?)\\s*\\)$/i;\r\nclass Shape extends Node {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.fillOpacity = 1;\r\n        this.strokeOpacity = 1;\r\n        this.fill = Shape.defaultStyles.fill;\r\n        /**\r\n         * Note that `strokeStyle = null` means invisible stroke,\r\n         * while `lineWidth = 0` means no stroke, and sometimes this can mean different things.\r\n         * For example, a rect shape with an invisible stroke may not align to the pixel grid\r\n         * properly because the stroke affects the rules of alignment, and arc shapes forming\r\n         * a pie chart will have a gap between them if they have an invisible stroke, whereas\r\n         * there would be not gap if there was no stroke at all.\r\n         * The preferred way of making the stroke invisible is setting the `lineWidth` to zero,\r\n         * unless specific looks that is achieved by having an invisible stroke is desired.\r\n         */\r\n        this.stroke = Shape.defaultStyles.stroke;\r\n        this.strokeWidth = Shape.defaultStyles.strokeWidth;\r\n        this.lineDash = Shape.defaultStyles.lineDash;\r\n        this.lineDashOffset = Shape.defaultStyles.lineDashOffset;\r\n        this.lineCap = Shape.defaultStyles.lineCap;\r\n        this.lineJoin = Shape.defaultStyles.lineJoin;\r\n        this.opacity = Shape.defaultStyles.opacity;\r\n        this.fillShadow = Shape.defaultStyles.fillShadow;\r\n    }\r\n    /**\r\n     * Restores the default styles introduced by this subclass.\r\n     */\r\n    restoreOwnStyles() {\r\n        const styles = this.constructor.defaultStyles;\r\n        const keys = Object.getOwnPropertyNames(styles);\r\n        // getOwnPropertyNames is about 2.5 times faster than\r\n        // for..in with the hasOwnProperty check and in this\r\n        // case, where most properties are inherited, can be\r\n        // more than an order of magnitude faster.\r\n        for (let i = 0, n = keys.length; i < n; i++) {\r\n            const key = keys[i];\r\n            this[key] = styles[key];\r\n        }\r\n    }\r\n    updateGradient() {\r\n        const { fill } = this;\r\n        let linearGradientMatch;\r\n        if ((fill === null || fill === void 0 ? void 0 : fill.startsWith('linear-gradient')) && (linearGradientMatch = LINEAR_GRADIENT_REGEXP.exec(fill))) {\r\n            const angle = parseFloat(linearGradientMatch[1]);\r\n            const colors = [];\r\n            const colorsPart = linearGradientMatch[2];\r\n            const colorRegex = /(#[0-9a-f]+)|(rgba?\\(.+?\\))|([a-z]+)/gi;\r\n            let c;\r\n            while ((c = colorRegex.exec(colorsPart))) {\r\n                colors.push(c[0]);\r\n            }\r\n            this.gradient = new LinearGradient();\r\n            this.gradient.angle = angle;\r\n            this.gradient.stops = colors.map((color, index) => {\r\n                const offset = index / (colors.length - 1);\r\n                return { offset, color };\r\n            });\r\n        }\r\n        else {\r\n            this.gradient = undefined;\r\n        }\r\n    }\r\n    /**\r\n     * Returns a device-pixel aligned coordinate (or length if length is supplied).\r\n     *\r\n     * NOTE: Not suitable for strokes, since the stroke needs to be offset to the middle\r\n     * of a device pixel.\r\n     */\r\n    align(start, length) {\r\n        var _a, _b, _c;\r\n        const pixelRatio = (_c = (_b = (_a = this.layerManager) === null || _a === void 0 ? void 0 : _a.canvas) === null || _b === void 0 ? void 0 : _b.pixelRatio) !== null && _c !== void 0 ? _c : 1;\r\n        const alignedStart = Math.round(start * pixelRatio) / pixelRatio;\r\n        if (length == undefined) {\r\n            return alignedStart;\r\n        }\r\n        if (length === 0) {\r\n            return 0;\r\n        }\r\n        if (length < 1) {\r\n            // Avoid hiding crisp shapes\r\n            return Math.ceil(length * pixelRatio) / pixelRatio;\r\n        }\r\n        // Account for the rounding of alignedStart by increasing length to compensate before\r\n        // alignment.\r\n        return Math.round((length + start) * pixelRatio) / pixelRatio - alignedStart;\r\n    }\r\n    fillStroke(ctx) {\r\n        this.renderFill(ctx);\r\n        this.renderStroke(ctx);\r\n    }\r\n    renderFill(ctx) {\r\n        if (this.fill) {\r\n            const { globalAlpha } = ctx;\r\n            this.applyFill(ctx);\r\n            this.applyFillAlpha(ctx);\r\n            this.applyShadow(ctx);\r\n            ctx.fill();\r\n            ctx.globalAlpha = globalAlpha;\r\n        }\r\n        ctx.shadowColor = 'rgba(0, 0, 0, 0)';\r\n    }\r\n    applyFill(ctx) {\r\n        if (this.gradient) {\r\n            ctx.fillStyle = this.gradient.createGradient(ctx, this.computeBBox());\r\n        }\r\n        else {\r\n            ctx.fillStyle = this.fill;\r\n        }\r\n    }\r\n    applyFillAlpha(ctx) {\r\n        const { globalAlpha } = ctx;\r\n        ctx.globalAlpha = globalAlpha * this.opacity * this.fillOpacity;\r\n    }\r\n    applyShadow(ctx) {\r\n        var _a, _b;\r\n        // The canvas context scaling (depends on the device's pixel ratio)\r\n        // has no effect on shadows, so we have to account for the pixel ratio\r\n        // manually here.\r\n        const pixelRatio = (_b = (_a = this.layerManager) === null || _a === void 0 ? void 0 : _a.canvas.pixelRatio) !== null && _b !== void 0 ? _b : 1;\r\n        const fillShadow = this.fillShadow;\r\n        if (fillShadow === null || fillShadow === void 0 ? void 0 : fillShadow.enabled) {\r\n            ctx.shadowColor = fillShadow.color;\r\n            ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\r\n            ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\r\n            ctx.shadowBlur = fillShadow.blur * pixelRatio;\r\n        }\r\n    }\r\n    renderStroke(ctx) {\r\n        if (this.stroke && this.strokeWidth) {\r\n            const { globalAlpha } = ctx;\r\n            ctx.strokeStyle = this.stroke;\r\n            ctx.globalAlpha = globalAlpha * this.opacity * this.strokeOpacity;\r\n            ctx.lineWidth = this.strokeWidth;\r\n            if (this.lineDash) {\r\n                ctx.setLineDash(this.lineDash);\r\n            }\r\n            if (this.lineDashOffset) {\r\n                ctx.lineDashOffset = this.lineDashOffset;\r\n            }\r\n            if (this.lineCap) {\r\n                ctx.lineCap = this.lineCap;\r\n            }\r\n            if (this.lineJoin) {\r\n                ctx.lineJoin = this.lineJoin;\r\n            }\r\n            ctx.stroke();\r\n            ctx.globalAlpha = globalAlpha;\r\n        }\r\n    }\r\n    containsPoint(x, y) {\r\n        return this.isPointInPath(x, y);\r\n    }\r\n}\r\n/**\r\n * Defaults for style properties. Note that properties that affect the position\r\n * and shape of the node are not considered style properties, for example:\r\n * `x`, `y`, `width`, `height`, `radius`, `rotation`, etc.\r\n * Can be used to reset to the original styling after some custom styling\r\n * has been applied (using the `restoreOwnStyles` method).\r\n * These static defaults are meant to be inherited by subclasses.\r\n */\r\nShape.defaultStyles = Object.assign({}, {\r\n    fill: 'black',\r\n    stroke: undefined,\r\n    strokeWidth: 0,\r\n    lineDash: undefined,\r\n    lineDashOffset: 0,\r\n    lineCap: undefined,\r\n    lineJoin: undefined,\r\n    opacity: 1,\r\n    fillShadow: undefined,\r\n});\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Shape.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Shape.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR, changeCb: (s) => s.updateGradient() }),\r\n    __metadata(\"design:type\", Object)\r\n], Shape.prototype, \"fill\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Object)\r\n], Shape.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Shape.prototype, \"strokeWidth\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Object)\r\n], Shape.prototype, \"lineDash\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Shape.prototype, \"lineDashOffset\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", String)\r\n], Shape.prototype, \"lineCap\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", String)\r\n], Shape.prototype, \"lineJoin\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({\r\n        redraw: RedrawType.MINOR,\r\n        convertor: (v) => Math.min(1, Math.max(0, v)),\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Shape.prototype, \"opacity\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR, checkDirtyOnAssignment: true }),\r\n    __metadata(\"design:type\", Object)\r\n], Shape.prototype, \"fillShadow\", void 0);\n\nconst ellipsis = '\\u2026';\r\nfunction SceneFontChangeDetection(opts) {\r\n    const { redraw = RedrawType.MAJOR, changeCb } = opts !== null && opts !== void 0 ? opts : {};\r\n    return SceneChangeDetection({ redraw, type: 'font', changeCb });\r\n}\r\nclass Text extends Shape {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.lines = [];\r\n        this.text = undefined;\r\n        this._dirtyFont = true;\r\n        this.fontSize = 10;\r\n        this.fontFamily = 'sans-serif';\r\n        this.textAlign = Text.defaultStyles.textAlign;\r\n        this.textBaseline = Text.defaultStyles.textBaseline;\r\n        // TextMetrics are used if lineHeight is not defined.\r\n        this.lineHeight = undefined;\r\n    }\r\n    _setLines() {\r\n        this.lines = splitText(this.text);\r\n    }\r\n    get font() {\r\n        if (this._font == null || this._dirtyFont) {\r\n            this._dirtyFont = false;\r\n            this._font = getFont(this);\r\n        }\r\n        return this._font;\r\n    }\r\n    computeBBox() {\r\n        return HdpiCanvas.has.textMetrics\r\n            ? getPreciseBBox(this.lines, this.x, this.y, this)\r\n            : getApproximateBBox(this.lines, this.x, this.y, this);\r\n    }\r\n    getLineHeight(line) {\r\n        var _a, _b;\r\n        if (this.lineHeight)\r\n            return this.lineHeight;\r\n        if (HdpiCanvas.has.textMetrics) {\r\n            const metrics = HdpiCanvas.measureText(line, this.font, this.textBaseline, this.textAlign);\r\n            return (((_a = metrics.fontBoundingBoxAscent) !== null && _a !== void 0 ? _a : metrics.emHeightAscent) +\r\n                ((_b = metrics.fontBoundingBoxDescent) !== null && _b !== void 0 ? _b : metrics.emHeightDescent));\r\n        }\r\n        return HdpiCanvas.getTextSize(line, this.font).height;\r\n    }\r\n    isPointInPath(x, y) {\r\n        const point = this.transformPoint(x, y);\r\n        const bbox = this.computeBBox();\r\n        return bbox ? bbox.containsPoint(point.x, point.y) : false;\r\n    }\r\n    render(renderCtx) {\r\n        const { ctx, forceRender, stats } = renderCtx;\r\n        if (this.dirty === RedrawType.NONE && !forceRender) {\r\n            if (stats)\r\n                stats.nodesSkipped += this.nodeCount.count;\r\n            return;\r\n        }\r\n        if (!this.lines.length || !this.layerManager) {\r\n            if (stats)\r\n                stats.nodesSkipped += this.nodeCount.count;\r\n            return;\r\n        }\r\n        this.computeTransformMatrix();\r\n        this.matrix.toContext(ctx);\r\n        const { fill, stroke, strokeWidth } = this;\r\n        ctx.font = this.font;\r\n        ctx.textAlign = this.textAlign;\r\n        ctx.textBaseline = this.textBaseline;\r\n        const pixelRatio = this.layerManager.canvas.pixelRatio || 1;\r\n        const { globalAlpha } = ctx;\r\n        if (fill) {\r\n            ctx.fillStyle = fill;\r\n            ctx.globalAlpha = globalAlpha * this.opacity * this.fillOpacity;\r\n            const { fillShadow } = this;\r\n            if (fillShadow === null || fillShadow === void 0 ? void 0 : fillShadow.enabled) {\r\n                ctx.shadowColor = fillShadow.color;\r\n                ctx.shadowOffsetX = fillShadow.xOffset * pixelRatio;\r\n                ctx.shadowOffsetY = fillShadow.yOffset * pixelRatio;\r\n                ctx.shadowBlur = fillShadow.blur * pixelRatio;\r\n            }\r\n            this.renderLines((line, x, y) => ctx.fillText(line, x, y));\r\n        }\r\n        if (stroke && strokeWidth) {\r\n            ctx.strokeStyle = stroke;\r\n            ctx.lineWidth = strokeWidth;\r\n            ctx.globalAlpha = globalAlpha * this.opacity * this.strokeOpacity;\r\n            const { lineDash, lineDashOffset, lineCap, lineJoin } = this;\r\n            if (lineDash) {\r\n                ctx.setLineDash(lineDash);\r\n            }\r\n            if (lineDashOffset) {\r\n                ctx.lineDashOffset = lineDashOffset;\r\n            }\r\n            if (lineCap) {\r\n                ctx.lineCap = lineCap;\r\n            }\r\n            if (lineJoin) {\r\n                ctx.lineJoin = lineJoin;\r\n            }\r\n            this.renderLines((line, x, y) => ctx.strokeText(line, x, y));\r\n        }\r\n        super.render(renderCtx);\r\n    }\r\n    renderLines(renderCallback) {\r\n        const { lines, x, y } = this;\r\n        const lineHeights = this.lines.map((line) => this.getLineHeight(line));\r\n        const totalHeight = lineHeights.reduce((a, b) => a + b, 0);\r\n        let offsetY = -(totalHeight - lineHeights[0]) * getVerticalOffset(this.textBaseline);\r\n        for (let i = 0; i < lines.length; i++) {\r\n            renderCallback(lines[i], x, y + offsetY);\r\n            offsetY += lineHeights[i];\r\n        }\r\n    }\r\n    static wrap(text, maxWidth, maxHeight, textProps, wrapping, overflow = 'ellipsis') {\r\n        var _a;\r\n        const canOverflow = overflow !== 'hide';\r\n        const font = getFont(textProps);\r\n        const measurer = createTextMeasurer(font);\r\n        const lines = text.split(/\\r?\\n/g);\r\n        if (lines.length === 0) {\r\n            return '';\r\n        }\r\n        if (wrapping === 'never') {\r\n            return (_a = Text.truncateLine(lines[0], maxWidth, measurer, canOverflow ? 'auto' : 'never')) !== null && _a !== void 0 ? _a : '';\r\n        }\r\n        const result = [];\r\n        let cumulativeHeight = 0;\r\n        for (const line of lines) {\r\n            const wrappedLine = Text.wrapLine(line, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight, canOverflow);\r\n            if (wrappedLine == null) {\r\n                return '';\r\n            }\r\n            result.push(wrappedLine.result);\r\n            cumulativeHeight = wrappedLine.cumulativeHeight;\r\n            if (wrappedLine.truncated) {\r\n                break;\r\n            }\r\n        }\r\n        return result.join('\\n').trim();\r\n    }\r\n    static wrapLine(text, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight, canOverflow) {\r\n        text = text.trim();\r\n        if (!text) {\r\n            return { result: '', truncated: false, cumulativeHeight };\r\n        }\r\n        const initialSize = measurer.size(text);\r\n        if (initialSize.width <= maxWidth) {\r\n            // Text fits into a single line\r\n            return {\r\n                result: text,\r\n                truncated: false,\r\n                cumulativeHeight: cumulativeHeight + initialSize.height,\r\n            };\r\n        }\r\n        if (initialSize.height > maxHeight || measurer.width('W') > maxWidth) {\r\n            // Not enough space for a single line or character\r\n            return canOverflow ? { result: '', truncated: true, cumulativeHeight } : undefined;\r\n        }\r\n        const words = text.split(/\\s+/g);\r\n        const wrapResult = Text.wrapLineSequentially(words, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight, canOverflow);\r\n        if (wrapResult == null) {\r\n            return undefined;\r\n        }\r\n        cumulativeHeight = wrapResult.cumulativeHeight;\r\n        let { lines } = wrapResult;\r\n        if (!(wrapResult.wordsBrokenOrTruncated || wrapResult.linesTruncated)) {\r\n            // If no word breaks or truncations, try the balanced wrapping\r\n            const linesCount = wrapResult.lines.length;\r\n            const balanced = Text.wrapLineBalanced(words, maxWidth, measurer, linesCount);\r\n            if (balanced.length === lines.length) {\r\n                // Some lines can't be balanced properly because of unusually long words\r\n                lines = balanced;\r\n            }\r\n        }\r\n        const wrappedText = lines.map((ln) => ln.join(' ')).join('\\n');\r\n        return { result: wrappedText, truncated: wrapResult.linesTruncated, cumulativeHeight };\r\n    }\r\n    static breakWord(word, firstLineWidth, maxWidth, hyphens, measurer) {\r\n        const isPunctuationAt = (index) => Text.punctuationMarks.includes(word[index]);\r\n        const h = hyphens ? measurer.width('-') : 0;\r\n        const breaks = [];\r\n        let partWidth = 0;\r\n        let p = 0;\r\n        for (let i = 0; i < word.length; i++) {\r\n            const c = word[i];\r\n            const w = measurer.width(c);\r\n            const limit = p === 0 ? firstLineWidth : maxWidth;\r\n            if (partWidth + w + h > limit) {\r\n                breaks.push(i);\r\n                partWidth = 0;\r\n                p++;\r\n            }\r\n            partWidth += w;\r\n        }\r\n        const parts = [];\r\n        let start = 0;\r\n        for (const index of breaks) {\r\n            let part = word.substring(start, index);\r\n            if (hyphens && part.length > 0 && !isPunctuationAt(index - 1) && !isPunctuationAt(index)) {\r\n                part += '-';\r\n            }\r\n            parts.push(part);\r\n            start = index;\r\n        }\r\n        parts.push(word.substring(start));\r\n        return parts;\r\n    }\r\n    static truncateLine(text, maxWidth, measurer, ellipsisMode) {\r\n        text = text.trimEnd();\r\n        const lineWidth = measurer.width(text);\r\n        if (lineWidth > maxWidth && ellipsisMode === 'never') {\r\n            return undefined;\r\n        }\r\n        else if (lineWidth <= maxWidth && ellipsisMode !== 'force') {\r\n            return text;\r\n        }\r\n        const ellipsisWidth = measurer.width(ellipsis);\r\n        let trunc = text;\r\n        let truncWidth = lineWidth;\r\n        while (trunc.length > 0 && truncWidth + ellipsisWidth > maxWidth) {\r\n            // Ensure there is no space between the ellipsis and last letter\r\n            trunc = trunc.slice(0, -1).trimEnd();\r\n            truncWidth = measurer.width(trunc);\r\n        }\r\n        if (truncWidth + ellipsisWidth <= maxWidth) {\r\n            return `${trunc}${ellipsis}`;\r\n        }\r\n        else {\r\n            return undefined;\r\n        }\r\n    }\r\n    static wrapLineSequentially(words, maxWidth, maxHeight, measurer, textProps, wrapping, cumulativeHeight, canOverflow) {\r\n        const { fontSize = 0, lineHeight = fontSize * Text.defaultLineHeightRatio } = textProps;\r\n        const breakWord = wrapping === 'always' || wrapping === 'hyphenate';\r\n        const hyphenate = wrapping === 'hyphenate';\r\n        const spaceWidth = measurer.width(' ');\r\n        let wordsBrokenOrTruncated = false;\r\n        let linesTruncated = false;\r\n        const lines = [];\r\n        let currentLine = [];\r\n        let lineWidth = 0;\r\n        const getReturnValue = () => ({\r\n            lines,\r\n            linesTruncated,\r\n            wordsBrokenOrTruncated,\r\n            cumulativeHeight,\r\n        });\r\n        const truncateLastLine = () => {\r\n            if (!canOverflow) {\r\n                return undefined;\r\n            }\r\n            const lastLine = currentLine.join(' ');\r\n            const trunc = Text.truncateLine(lastLine, maxWidth, measurer, 'force');\r\n            if (trunc == null) {\r\n                return undefined;\r\n            }\r\n            currentLine.splice(0, currentLine.length, trunc);\r\n            linesTruncated = true;\r\n            return getReturnValue();\r\n        };\r\n        const addNewLine = () => {\r\n            const expectedHeight = cumulativeHeight + lineHeight;\r\n            if (expectedHeight >= maxHeight) {\r\n                return false;\r\n            }\r\n            // Add new line\r\n            currentLine = [];\r\n            lineWidth = 0;\r\n            cumulativeHeight = expectedHeight;\r\n            lines.push(currentLine);\r\n            return true;\r\n        };\r\n        if (!addNewLine()) {\r\n            return truncateLastLine();\r\n        }\r\n        for (let i = 0; i < words.length; i++) {\r\n            const word = words[i];\r\n            const wordWidth = measurer.width(word);\r\n            const expectedSpaceWidth = currentLine.length === 0 ? 0 : spaceWidth;\r\n            const expectedLineWidth = lineWidth + expectedSpaceWidth + wordWidth;\r\n            if (expectedLineWidth <= maxWidth) {\r\n                // If the word fits, add it to the current line\r\n                currentLine.push(word);\r\n                lineWidth = expectedLineWidth;\r\n                continue;\r\n            }\r\n            if (wordWidth <= maxWidth) {\r\n                // If the word is not too long, put it onto new line\r\n                if (!addNewLine()) {\r\n                    return truncateLastLine();\r\n                }\r\n                currentLine.push(word);\r\n                lineWidth = wordWidth;\r\n                continue;\r\n            }\r\n            // Handle a long word\r\n            wordsBrokenOrTruncated = true;\r\n            if (breakWord) {\r\n                // Break the word into parts\r\n                const availWidth = maxWidth - lineWidth - expectedSpaceWidth;\r\n                const parts = Text.breakWord(word, availWidth, maxWidth, hyphenate, measurer);\r\n                for (let p = 0; p < parts.length; p++) {\r\n                    const part = parts[p];\r\n                    part && currentLine.push(part);\r\n                    if (p === parts.length - 1) {\r\n                        lineWidth = measurer.width(part);\r\n                    }\r\n                    else if (!addNewLine()) {\r\n                        return truncateLastLine();\r\n                    }\r\n                }\r\n            }\r\n            else if (canOverflow) {\r\n                // Truncate the word\r\n                if (!addNewLine()) {\r\n                    return truncateLastLine();\r\n                }\r\n                const trunc = Text.truncateLine(word, maxWidth, measurer, 'force');\r\n                if (trunc == null) {\r\n                    return undefined;\r\n                }\r\n                currentLine.push(trunc);\r\n                if (i < words.length - 1) {\r\n                    linesTruncated = true;\r\n                }\r\n                break;\r\n            }\r\n            else {\r\n                return undefined;\r\n            }\r\n        }\r\n        return getReturnValue();\r\n    }\r\n    static wrapLineBalanced(words, maxWidth, measurer, linesCount) {\r\n        const totalWordsWidth = words.reduce((sum, w) => sum + measurer.width(w), 0);\r\n        const spaceWidth = measurer.width(' ');\r\n        const totalSpaceWidth = spaceWidth * (words.length - linesCount - 2);\r\n        const averageLineWidth = (totalWordsWidth + totalSpaceWidth) / linesCount;\r\n        const lines = [];\r\n        let currentLine = [];\r\n        let lineWidth = measurer.width(words[0]);\r\n        let newLine = true;\r\n        for (const word of words) {\r\n            const width = measurer.width(word);\r\n            if (newLine) {\r\n                // New line\r\n                currentLine = [];\r\n                currentLine.push(word);\r\n                lineWidth = width;\r\n                newLine = false;\r\n                lines.push(currentLine);\r\n                continue;\r\n            }\r\n            const expectedLineWidth = lineWidth + spaceWidth + width;\r\n            if (expectedLineWidth <= averageLineWidth) {\r\n                // Keep adding words to the line\r\n                currentLine.push(word);\r\n                lineWidth = expectedLineWidth;\r\n            }\r\n            else if (expectedLineWidth <= maxWidth) {\r\n                // Add the last word to the line\r\n                currentLine.push(word);\r\n                newLine = true;\r\n            }\r\n            else {\r\n                // Put the word onto the next line\r\n                currentLine = [word];\r\n                lineWidth = width;\r\n                lines.push(currentLine);\r\n            }\r\n        }\r\n        return lines;\r\n    }\r\n    setFont(props) {\r\n        this.fontFamily = props.fontFamily;\r\n        this.fontSize = props.fontSize;\r\n        this.fontStyle = props.fontStyle;\r\n        this.fontWeight = props.fontWeight;\r\n    }\r\n    setAlign(props) {\r\n        this.textAlign = props.textAlign;\r\n        this.textBaseline = props.textBaseline;\r\n    }\r\n}\r\nText.className = 'Text';\r\n// The default line spacing for document editors is usually 1.15\r\nText.defaultLineHeightRatio = 1.15;\r\nText.defaultStyles = Object.assign({}, Shape.defaultStyles, {\r\n    textAlign: 'start',\r\n    fontStyle: undefined,\r\n    fontWeight: undefined,\r\n    fontSize: 10,\r\n    fontFamily: 'sans-serif',\r\n    textBaseline: 'alphabetic',\r\n});\r\nText.ellipsis = ellipsis;\r\nText.punctuationMarks = ['.', ',', '-', ':', ';', '!', '?', `'`, '\"', '(', ')'];\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Text.prototype, \"x\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Text.prototype, \"y\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR, changeCb: (o) => o._setLines() }),\r\n    __metadata(\"design:type\", String)\r\n], Text.prototype, \"text\", void 0);\r\n__decorate([\r\n    SceneFontChangeDetection(),\r\n    __metadata(\"design:type\", String)\r\n], Text.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    SceneFontChangeDetection(),\r\n    __metadata(\"design:type\", String)\r\n], Text.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    SceneFontChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Text.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    SceneFontChangeDetection(),\r\n    __metadata(\"design:type\", String)\r\n], Text.prototype, \"fontFamily\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", String)\r\n], Text.prototype, \"textAlign\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", String)\r\n], Text.prototype, \"textBaseline\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Text.prototype, \"lineHeight\", void 0);\r\nfunction createTextMeasurer(font) {\r\n    const cache = new Map();\r\n    const getTextSize = (text) => HdpiCanvas.getTextSize(text, font);\r\n    const getLineWidth = (text) => {\r\n        if (cache.has(text)) {\r\n            return cache.get(text);\r\n        }\r\n        const { width } = getTextSize(text);\r\n        cache.set(text, width);\r\n        return width;\r\n    };\r\n    return { size: getTextSize, width: getLineWidth };\r\n}\r\nfunction getFont(fontProps) {\r\n    const { fontFamily, fontSize, fontStyle, fontWeight } = fontProps;\r\n    return [fontStyle !== null && fontStyle !== void 0 ? fontStyle : '', fontWeight !== null && fontWeight !== void 0 ? fontWeight : '', fontSize + 'px', fontFamily].join(' ').trim();\r\n}\r\nfunction measureText(lines, x, y, textProps) {\r\n    return HdpiCanvas.has.textMetrics\r\n        ? getPreciseBBox(lines, x, y, textProps)\r\n        : getApproximateBBox(lines, x, y, textProps);\r\n}\r\nfunction getPreciseBBox(lines, x, y, textProps) {\r\n    var _a, _b;\r\n    let left = 0;\r\n    let top = 0;\r\n    let width = 0;\r\n    let height = 0;\r\n    // Distance between first and last base lines.\r\n    let baselineDistance = 0;\r\n    const font = getFont(textProps);\r\n    const { lineHeight, textBaseline = Text.defaultStyles.textBaseline, textAlign = Text.defaultStyles.textAlign, } = textProps;\r\n    for (let i = 0; i < lines.length; i++) {\r\n        const metrics = HdpiCanvas.measureText(lines[i], font, textBaseline, textAlign);\r\n        left = Math.max(left, metrics.actualBoundingBoxLeft);\r\n        width = Math.max(width, metrics.width);\r\n        if (i == 0) {\r\n            top += metrics.actualBoundingBoxAscent;\r\n            height += metrics.actualBoundingBoxAscent;\r\n        }\r\n        else {\r\n            baselineDistance += (_a = metrics.fontBoundingBoxAscent) !== null && _a !== void 0 ? _a : metrics.emHeightAscent;\r\n        }\r\n        if (i == lines.length - 1) {\r\n            height += metrics.actualBoundingBoxDescent;\r\n        }\r\n        else {\r\n            baselineDistance += (_b = metrics.fontBoundingBoxDescent) !== null && _b !== void 0 ? _b : metrics.emHeightDescent;\r\n        }\r\n    }\r\n    if (lineHeight !== undefined) {\r\n        baselineDistance = (lines.length - 1) * lineHeight;\r\n    }\r\n    height += baselineDistance;\r\n    top += baselineDistance * getVerticalOffset(textBaseline);\r\n    return new BBox(x - left, y - top, width, height);\r\n}\r\nfunction getApproximateBBox(lines, x, y, textProps) {\r\n    let width = 0;\r\n    let firstLineHeight = 0;\r\n    // Distance between first and last base lines.\r\n    let baselineDistance = 0;\r\n    const font = getFont(textProps);\r\n    const { lineHeight, textBaseline = Text.defaultStyles.textBaseline, textAlign = Text.defaultStyles.textAlign, } = textProps;\r\n    if (lines.length > 0) {\r\n        const lineSize = HdpiCanvas.getTextSize(lines[0], font);\r\n        width = lineSize.width;\r\n        firstLineHeight = lineSize.height;\r\n    }\r\n    for (let i = 1; i < lines.length; i++) {\r\n        const lineSize = HdpiCanvas.getTextSize(lines[i], font);\r\n        width = Math.max(width, lineSize.width);\r\n        baselineDistance += lineHeight !== null && lineHeight !== void 0 ? lineHeight : lineSize.height;\r\n    }\r\n    switch (textAlign) {\r\n        case 'end':\r\n        case 'right':\r\n            x -= width;\r\n            break;\r\n        case 'center':\r\n            x -= width / 2;\r\n    }\r\n    switch (textBaseline) {\r\n        case 'alphabetic':\r\n            y -= firstLineHeight * 0.7 + baselineDistance * 0.5;\r\n            break;\r\n        case 'middle':\r\n            y -= firstLineHeight * 0.45 + baselineDistance * 0.5;\r\n            break;\r\n        case 'ideographic':\r\n            y -= firstLineHeight + baselineDistance;\r\n            break;\r\n        case 'hanging':\r\n            y -= firstLineHeight * 0.2 + baselineDistance * 0.5;\r\n            break;\r\n        case 'bottom':\r\n            y -= firstLineHeight + baselineDistance;\r\n            break;\r\n    }\r\n    return new BBox(x, y, width, firstLineHeight + baselineDistance);\r\n}\r\nfunction getVerticalOffset(textBaseline) {\r\n    switch (textBaseline) {\r\n        case 'top':\r\n        case 'hanging':\r\n            return 0;\r\n        case 'bottom':\r\n        case 'alphabetic':\r\n        case 'ideographic':\r\n            return 1;\r\n        case 'middle':\r\n            return 0.5;\r\n    }\r\n}\r\nfunction splitText(text) {\r\n    return typeof text === 'string' ? text.split(/\\r?\\n/g) : [];\r\n}\n\nfunction ProxyOnWrite(proxyProperty) {\r\n    return addTransformToInstanceProperty((target, _, value) => {\r\n        target[proxyProperty] = value;\r\n        return value;\r\n    });\r\n}\r\nfunction ProxyPropertyOnWrite(childName, childProperty) {\r\n    return addTransformToInstanceProperty((target, key, value) => {\r\n        target[childName][childProperty !== null && childProperty !== void 0 ? childProperty : key] = value;\r\n        return value;\r\n    });\r\n}\r\n/**\r\n * Allows side-effects to be triggered on property write.\r\n *\r\n * @param opts.newValue called when a new value is set - never called for undefined values.\r\n * @param opts.oldValue called with the old value before a new value is set - never called for\r\n *                      undefined values.\r\n * @param opts.changeValue called on any change to the value - always called.\r\n */\r\nfunction ActionOnSet(opts) {\r\n    const { newValue: newValueFn, oldValue: oldValueFn, changeValue: changeValueFn } = opts;\r\n    return addTransformToInstanceProperty((target, _, newValue, oldValue) => {\r\n        if (newValue !== oldValue) {\r\n            if (oldValue !== undefined) {\r\n                oldValueFn === null || oldValueFn === void 0 ? void 0 : oldValueFn.call(target, oldValue);\r\n            }\r\n            if (newValue !== undefined) {\r\n                newValueFn === null || newValueFn === void 0 ? void 0 : newValueFn.call(target, newValue);\r\n            }\r\n            changeValueFn === null || changeValueFn === void 0 ? void 0 : changeValueFn.call(target, newValue, oldValue);\r\n        }\r\n        return newValue;\r\n    });\r\n}\n\nclass Caption {\r\n    constructor() {\r\n        this.node = new Text();\r\n        this.enabled = false;\r\n        this.text = undefined;\r\n        this.fontSize = 10;\r\n        this.fontFamily = 'sans-serif';\r\n        this.maxWidth = undefined;\r\n        this.maxHeight = undefined;\r\n        this.wrapping = 'always';\r\n        const node = this.node;\r\n        node.textAlign = 'center';\r\n        node.pointerEvents = PointerEvents.None;\r\n    }\r\n    computeTextWrap(containerWidth, containerHeight) {\r\n        var _a, _b;\r\n        const { text, wrapping } = this;\r\n        const maxWidth = Math.min((_a = this.maxWidth) !== null && _a !== void 0 ? _a : Infinity, containerWidth);\r\n        const maxHeight = (_b = this.maxHeight) !== null && _b !== void 0 ? _b : containerHeight;\r\n        if (!isFinite(maxWidth) && !isFinite(maxHeight)) {\r\n            this.node.text = text;\r\n            return;\r\n        }\r\n        const wrapped = Text.wrap(text !== null && text !== void 0 ? text : '', maxWidth, maxHeight, this, wrapping);\r\n        this.node.text = wrapped;\r\n    }\r\n}\r\nCaption.SMALL_PADDING = 10;\r\nCaption.LARGE_PADDING = 20;\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], Caption.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    ProxyPropertyOnWrite('node'),\r\n    __metadata(\"design:type\", String)\r\n], Caption.prototype, \"text\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_STYLE),\r\n    ProxyPropertyOnWrite('node'),\r\n    __metadata(\"design:type\", Object)\r\n], Caption.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_WEIGHT),\r\n    ProxyPropertyOnWrite('node'),\r\n    __metadata(\"design:type\", Object)\r\n], Caption.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    ProxyPropertyOnWrite('node'),\r\n    __metadata(\"design:type\", Number)\r\n], Caption.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    ProxyPropertyOnWrite('node'),\r\n    __metadata(\"design:type\", String)\r\n], Caption.prototype, \"fontFamily\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    ProxyPropertyOnWrite('node', 'fill'),\r\n    __metadata(\"design:type\", Object)\r\n], Caption.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Caption.prototype, \"spacing\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Caption.prototype, \"lineHeight\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Caption.prototype, \"maxWidth\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Caption.prototype, \"maxHeight\", void 0);\r\n__decorate([\r\n    Validate(TEXT_WRAP),\r\n    __metadata(\"design:type\", String)\r\n], Caption.prototype, \"wrapping\", void 0);\n\nclass AxisTitle {\r\n    constructor() {\r\n        this.enabled = false;\r\n        this.text = undefined;\r\n        this.spacing = Caption.SMALL_PADDING;\r\n        this.fontStyle = undefined;\r\n        this.fontWeight = undefined;\r\n        this.fontSize = 10;\r\n        this.fontFamily = 'sans-serif';\r\n        this.wrapping = 'always';\r\n        this.formatter = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], AxisTitle.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AxisTitle.prototype, \"text\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisTitle.prototype, \"spacing\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_STYLE),\r\n    __metadata(\"design:type\", String)\r\n], AxisTitle.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_WEIGHT),\r\n    __metadata(\"design:type\", String)\r\n], AxisTitle.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisTitle.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", String)\r\n], AxisTitle.prototype, \"fontFamily\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AxisTitle.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(TEXT_WRAP),\r\n    __metadata(\"design:type\", String)\r\n], AxisTitle.prototype, \"wrapping\", void 0);\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    __metadata(\"design:type\", Function)\r\n], AxisTitle.prototype, \"formatter\", void 0);\n\n/**\r\n * Zip two arrays into an object of keys and values, or an object of keys with a single value.\r\n */\r\nfunction zipObject(keys, values) {\r\n    const zipped = {};\r\n    if (Array.isArray(values)) {\r\n        for (let i = 0; i < keys.length; i++) {\r\n            zipped[`${keys[i]}`] = values[i];\r\n        }\r\n    }\r\n    else {\r\n        for (let i = 0; i < keys.length; i++) {\r\n            zipped[`${keys[i]}`] = values;\r\n        }\r\n    }\r\n    return zipped;\r\n}\n\nfunction interpolateNumber(a, b) {\r\n    return (d) => Number(a) * (1 - d) + Number(b) * d;\r\n}\r\nfunction interpolateColor(a, b) {\r\n    if (typeof a === 'string') {\r\n        try {\r\n            a = Color.fromString(a);\r\n        }\r\n        catch (e) {\r\n            a = Color.fromArray([0, 0, 0]);\r\n        }\r\n    }\r\n    if (typeof b === 'string') {\r\n        try {\r\n            b = Color.fromString(b);\r\n        }\r\n        catch (e) {\r\n            b = Color.fromArray([0, 0, 0]);\r\n        }\r\n    }\r\n    const red = interpolateNumber(a.r, b.r);\r\n    const green = interpolateNumber(a.g, b.g);\r\n    const blue = interpolateNumber(a.b, b.b);\r\n    const alpha = interpolateNumber(a.a, b.a);\r\n    return (d) => Color.fromArray([red(d), green(d), blue(d), alpha(d)]).toRgbaString();\r\n}\n\nconst linear = (n) => n;\r\nconst easeIn = (n) => 1 - Math.cos((n * Math.PI) / 2);\r\nconst easeOut = (n) => Math.sin((n * Math.PI) / 2);\r\nconst easeInOut = (n) => -(Math.cos(n * Math.PI) - 1) / 2;\r\nconst easeInQuad = (n) => n * n;\r\nconst easeOutQuad = (n) => 1 - Math.pow((1 - n), 2);\r\nconst easeInOutQuad = (n) => (n < 0.5 ? 2 * n * n : 1 - Math.pow((-2 * n + 2), 2) / 2);\n\nvar easing = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    linear: linear,\n    easeIn: easeIn,\n    easeOut: easeOut,\n    easeInOut: easeInOut,\n    easeInQuad: easeInQuad,\n    easeOutQuad: easeOutQuad,\n    easeInOutQuad: easeInOutQuad\n});\n\nconst QUICK_TRANSITION = 0.2;\r\nconst INITIAL_LOAD = {\r\n    animationDuration: 1,\r\n    animationDelay: 0,\r\n};\r\nconst REMOVE_PHASE = {\r\n    animationDuration: 0.25,\r\n    animationDelay: 0,\r\n};\r\nconst UPDATE_PHASE = {\r\n    animationDuration: 0.5,\r\n    animationDelay: 0.25,\r\n};\r\nconst ADD_PHASE = {\r\n    animationDuration: 0.25,\r\n    animationDelay: 0.75,\r\n};\r\nconst LABEL_PHASE = {\r\n    animationDuration: QUICK_TRANSITION,\r\n    animationDelay: 1,\r\n};\r\nvar RepeatType;\r\n(function (RepeatType) {\r\n    RepeatType[\"Loop\"] = \"loop\";\r\n    RepeatType[\"Reverse\"] = \"reverse\";\r\n})(RepeatType || (RepeatType = {}));\r\nfunction isNodeArray(array) {\r\n    return array.every((n) => n instanceof Node);\r\n}\r\nclass Animation {\r\n    constructor(opts) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\r\n        this.elapsed = 0;\r\n        this.iteration = 0;\r\n        this.isPlaying = false;\r\n        this.isReverse = false;\r\n        // animation configuration\r\n        this.id = opts.id;\r\n        this.groupId = opts.groupId;\r\n        this.autoplay = (_a = opts.autoplay) !== null && _a !== void 0 ? _a : true;\r\n        this.delay = (_b = opts.delay) !== null && _b !== void 0 ? _b : 0;\r\n        this.duration = (_c = opts.duration) !== null && _c !== void 0 ? _c : 1000;\r\n        this.ease = (_d = opts.ease) !== null && _d !== void 0 ? _d : linear;\r\n        this.repeat = (_e = opts.repeat) !== null && _e !== void 0 ? _e : 0;\r\n        this.repeatType = (_f = opts.repeatType) !== null && _f !== void 0 ? _f : RepeatType.Loop;\r\n        // user defined event listeners\r\n        this.onComplete = opts.onComplete;\r\n        this.onPlay = opts.onPlay;\r\n        this.onStop = opts.onStop;\r\n        this.onRepeat = opts.onRepeat;\r\n        this.onUpdate = opts.onUpdate;\r\n        // animation interpolator based on `from` & `to` types\r\n        this.interpolate = this.createInterpolator(opts.from, opts.to);\r\n        if (opts.skip === true) {\r\n            (_g = this.onUpdate) === null || _g === void 0 ? void 0 : _g.call(this, opts.to, false, this);\r\n            (_h = this.onStop) === null || _h === void 0 ? void 0 : _h.call(this, this);\r\n            (_j = this.onComplete) === null || _j === void 0 ? void 0 : _j.call(this, this);\r\n        }\r\n        else if (this.autoplay) {\r\n            this.play();\r\n            // Initialise the animation immediately without requesting a frame to prevent flashes\r\n            (_k = this.onUpdate) === null || _k === void 0 ? void 0 : _k.call(this, opts.from, true, this);\r\n        }\r\n    }\r\n    play() {\r\n        var _a;\r\n        if (!this.isPlaying) {\r\n            this.isPlaying = true;\r\n            (_a = this.onPlay) === null || _a === void 0 ? void 0 : _a.call(this, this);\r\n        }\r\n        return this;\r\n    }\r\n    pause() {\r\n        if (this.isPlaying) {\r\n            this.isPlaying = false;\r\n        }\r\n        return this;\r\n    }\r\n    stop() {\r\n        var _a;\r\n        if (this.isPlaying) {\r\n            this.isPlaying = false;\r\n            (_a = this.onStop) === null || _a === void 0 ? void 0 : _a.call(this, this);\r\n        }\r\n        return this;\r\n    }\r\n    reset(opts) {\r\n        const deltaState = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);\r\n        this.interpolate = this.createInterpolator(deltaState, opts.to);\r\n        this.elapsed = 0;\r\n        this.iteration = 0;\r\n        if (typeof opts.delay === 'number') {\r\n            this.delay = opts.delay;\r\n        }\r\n        if (typeof opts.duration === 'number') {\r\n            this.duration = opts.duration;\r\n        }\r\n        if (typeof opts.ease === 'function') {\r\n            this.ease = opts.ease;\r\n        }\r\n        return this;\r\n    }\r\n    update(time) {\r\n        var _a, _b, _c;\r\n        this.elapsed += time;\r\n        if (this.elapsed <= this.delay) {\r\n            return this;\r\n        }\r\n        const value = this.interpolate(this.isReverse ? 1 - this.delta : this.delta);\r\n        (_a = this.onUpdate) === null || _a === void 0 ? void 0 : _a.call(this, value, false, this);\r\n        if (this.elapsed - this.delay >= this.duration) {\r\n            if (this.iteration < this.repeat) {\r\n                this.iteration++;\r\n                this.elapsed = ((this.elapsed - this.delay) % this.duration) + this.delay;\r\n                if (this.repeatType === RepeatType.Reverse) {\r\n                    this.isReverse = !this.isReverse;\r\n                }\r\n                (_b = this.onRepeat) === null || _b === void 0 ? void 0 : _b.call(this, this);\r\n            }\r\n            else {\r\n                this.stop();\r\n                (_c = this.onComplete) === null || _c === void 0 ? void 0 : _c.call(this, this);\r\n            }\r\n        }\r\n        return this;\r\n    }\r\n    get delta() {\r\n        return this.ease(clamp(0, (this.elapsed - this.delay) / this.duration, 1));\r\n    }\r\n    createInterpolator(from, to) {\r\n        if (typeof to !== 'object') {\r\n            return this.interpolateValue(from, to);\r\n        }\r\n        const interpolatorEntries = Object.keys(to).map((key) => [\r\n            key,\r\n            this.interpolateValue(from[key], to[key]),\r\n        ]);\r\n        return (d) => {\r\n            const result = {};\r\n            for (const [key, interpolator] of interpolatorEntries) {\r\n                result[key] = interpolator(d);\r\n            }\r\n            return result;\r\n        };\r\n    }\r\n    interpolateValue(a, b) {\r\n        try {\r\n            switch (typeof a) {\r\n                case 'number':\r\n                    return interpolateNumber(a, b);\r\n                case 'string':\r\n                    return interpolateColor(a, b);\r\n            }\r\n        }\r\n        catch (e) {\r\n            // Error-case handled below.\r\n        }\r\n        throw new Error(`Unable to interpolate values: ${a}, ${b}`);\r\n    }\r\n}\n\nconst NODE_UPDATE_PHASES = ['removed', 'updated', 'added'];\r\nconst FROM_TO_MIXINS = {\r\n    added: ADD_PHASE,\r\n    updated: UPDATE_PHASE,\r\n    removed: REMOVE_PHASE,\r\n    unknown: INITIAL_LOAD,\r\n};\r\n/**\r\n * Implements a per-node \"to/from\" animation, with support for detection of added/moved/removed\r\n * nodes.\r\n *\r\n * @param id prefix for all animation ids generated by this call\r\n * @param animationManager used to schedule generated animations\r\n * @param selections contains nodes to be animated\r\n * @param fromFn callback to determine per-node starting properties\r\n * @param toFn callback to determine per-node final properties\r\n * @param extraOpts optional additional animation properties to pass to AnimationManager#animate.\r\n * @param getDatumId optional per-datum 'id' generation function for diff calculation - must be\r\n *                   specified iff diff is specified\r\n * @param diff optional diff from a DataModel to use to detect added/moved/removed cases\r\n */\r\nfunction fromToMotion(groupId, subId, animationManager, selectionsOrNodes, fns, getDatumId, diff) {\r\n    const { defaultDuration } = animationManager;\r\n    const { fromFn, toFn, intermediateFn } = fns;\r\n    const isNodes = isNodeArray(selectionsOrNodes);\r\n    const nodes = isNodes ? selectionsOrNodes : [];\r\n    const selections = !isNodes ? selectionsOrNodes : [];\r\n    // Dynamic case with varying add/update/remove behavior.\r\n    const ids = { added: {}, removed: {} };\r\n    if (getDatumId && diff) {\r\n        ids.added = zipObject(diff.added, true);\r\n        ids.removed = zipObject(diff.removed, true);\r\n    }\r\n    const processNodes = (liveNodes, nodes) => {\r\n        var _a, _b;\r\n        let prevFromProps;\r\n        let liveNodeIndex = 0;\r\n        let nodeIndex = 0;\r\n        for (const node of nodes) {\r\n            const isLive = liveNodes[liveNodeIndex] === node;\r\n            const ctx = {\r\n                last: nodeIndex >= nodes.length - 1,\r\n                lastLive: liveNodeIndex >= liveNodes.length - 1,\r\n                prev: nodes[nodeIndex - 1],\r\n                prevFromProps,\r\n                prevLive: liveNodes[liveNodeIndex - 1],\r\n                next: nodes[nodeIndex + 1],\r\n                nextLive: liveNodes[liveNodeIndex + (isLive ? 1 : 0)],\r\n            };\r\n            const animationId = `${groupId}_${subId}_${node.id}`;\r\n            animationManager.stopByAnimationId(animationId);\r\n            let status = 'unknown';\r\n            if (!isLive) {\r\n                status = 'removed';\r\n            }\r\n            else if (getDatumId && diff) {\r\n                status = calculateStatus(node, node.datum, getDatumId, ids);\r\n            }\r\n            const _c = fromFn(node, node.datum, status, ctx), { animationDelay: delay, animationDuration: duration, start = {}, finish = {} } = _c, from = __rest(_c, [\"animationDelay\", \"animationDuration\", \"start\", \"finish\"]);\r\n            const _d = toFn(node, node.datum, status, ctx), { animationDelay: toDelay, animationDuration: toDuration, start: toStart = {}, finish: toFinish = {} } = _d, to = __rest(_d, [\"animationDelay\", \"animationDuration\", \"start\", \"finish\"]);\r\n            animationManager.animate({\r\n                id: animationId,\r\n                groupId,\r\n                from: from,\r\n                to: to,\r\n                ease: easeOut,\r\n                onPlay: () => {\r\n                    node.setProperties(Object.assign(Object.assign({}, start), toStart));\r\n                },\r\n                onUpdate(props) {\r\n                    node.setProperties(props);\r\n                    if (intermediateFn) {\r\n                        node.setProperties(intermediateFn(node, node.datum, status, ctx));\r\n                    }\r\n                },\r\n                onStop: () => {\r\n                    node.setProperties(Object.assign(Object.assign(Object.assign({}, to), finish), toFinish));\r\n                },\r\n                duration: ((_a = duration !== null && duration !== void 0 ? duration : toDuration) !== null && _a !== void 0 ? _a : 1) * defaultDuration,\r\n                delay: ((_b = delay !== null && delay !== void 0 ? delay : toDelay) !== null && _b !== void 0 ? _b : 0) * defaultDuration,\r\n            });\r\n            if (isLive) {\r\n                liveNodeIndex++;\r\n            }\r\n            nodeIndex++;\r\n            prevFromProps = from;\r\n        }\r\n    };\r\n    let selectionIndex = 0;\r\n    for (const selection of selections) {\r\n        const nodes = selection.nodes();\r\n        const liveNodes = nodes.filter((n) => !selection.isGarbage(n));\r\n        processNodes(liveNodes, nodes);\r\n        // Only perform selection cleanup once.\r\n        animationManager.animate({\r\n            id: `${groupId}_${subId}_selection_${selectionIndex}`,\r\n            groupId,\r\n            from: 0,\r\n            to: 1,\r\n            ease: easeOut,\r\n            onStop() {\r\n                selection.cleanup();\r\n            },\r\n        });\r\n        selectionIndex++;\r\n    }\r\n    processNodes(nodes, nodes);\r\n}\r\n/**\r\n * Implements a batch \"to/from\" animation.\r\n *\r\n * @param id prefix for all animation ids generated by this call\r\n * @param animationManager used to schedule generated animations\r\n * @param selectionsOrNodes contains nodes to be animated\r\n * @param from node starting properties\r\n * @param to node final properties\r\n * @param extraOpts optional additional animation properties to pass to AnimationManager#animate.\r\n */\r\nfunction staticFromToMotion(groupId, subId, animationManager, selectionsOrNodes, from, to, extraOpts = {}) {\r\n    const isNodes = isNodeArray(selectionsOrNodes);\r\n    const nodes = isNodes ? selectionsOrNodes : [];\r\n    const selections = !isNodes ? selectionsOrNodes : [];\r\n    const { animationDelay = 0, animationDuration = 1, start = {}, finish = {} } = extraOpts;\r\n    const { defaultDuration } = animationManager;\r\n    // Simple static to/from case, we can batch updates.\r\n    animationManager.animate({\r\n        id: `${groupId}_${subId}`,\r\n        groupId,\r\n        from,\r\n        to,\r\n        ease: easeOut,\r\n        onPlay: () => {\r\n            for (const node of nodes) {\r\n                node.setProperties(start);\r\n            }\r\n            for (const selection of selections) {\r\n                for (const node of selection.nodes()) {\r\n                    node.setProperties(start);\r\n                }\r\n            }\r\n        },\r\n        onUpdate(props) {\r\n            for (const node of nodes) {\r\n                node.setProperties(props);\r\n            }\r\n            for (const selection of selections) {\r\n                for (const node of selection.nodes()) {\r\n                    node.setProperties(props);\r\n                }\r\n            }\r\n        },\r\n        onStop: () => {\r\n            for (const node of nodes) {\r\n                node.setProperties(Object.assign(Object.assign({}, to), finish));\r\n            }\r\n            for (const selection of selections) {\r\n                for (const node of selection.nodes()) {\r\n                    node.setProperties(Object.assign(Object.assign({}, to), finish));\r\n                }\r\n            }\r\n        },\r\n        duration: animationDuration * defaultDuration,\r\n        delay: animationDelay * defaultDuration,\r\n    });\r\n}\r\nfunction calculateStatus(node, datum, getDatumId, ids) {\r\n    const id = getDatumId(node, datum);\r\n    if (ids.added[id]) {\r\n        return 'added';\r\n    }\r\n    else if (ids.removed[id]) {\r\n        return 'removed';\r\n    }\r\n    return 'updated';\r\n}\n\nvar fromToMotion$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    NODE_UPDATE_PHASES: NODE_UPDATE_PHASES,\n    FROM_TO_MIXINS: FROM_TO_MIXINS,\n    fromToMotion: fromToMotion,\n    staticFromToMotion: staticFromToMotion\n});\n\nconst group = (content) => `(${content})`;\r\nconst optionalGroup = (content) => `${group(content)}?`;\r\nconst nonCapturingGroup = (content) => optionalGroup(`?:${content}`);\r\nconst formatRegEx = (() => {\r\n    const fill = '.';\r\n    const align = '[<>=^]';\r\n    const sign = '[+\\\\-( ]';\r\n    const symbol = '[$€£¥₣₹#]';\r\n    const zero = '0';\r\n    const width = '\\\\d+';\r\n    const comma = ',';\r\n    const precision = '\\\\d+';\r\n    const tilde = '~';\r\n    const type = '[%a-z]';\r\n    return new RegExp([\r\n        '^',\r\n        nonCapturingGroup(`${optionalGroup(fill)}${group(align)}`),\r\n        optionalGroup(sign),\r\n        optionalGroup(symbol),\r\n        optionalGroup(zero),\r\n        optionalGroup(width),\r\n        optionalGroup(comma),\r\n        nonCapturingGroup(`\\\\.${group(precision)}`),\r\n        optionalGroup(tilde),\r\n        optionalGroup(type),\r\n        '$',\r\n    ].join(''), 'i');\r\n})();\r\nconst surroundedRegEx = (() => {\r\n    const prefix = '.*?';\r\n    const content = '.+?';\r\n    const suffix = '.*?';\r\n    return new RegExp(['^', group(prefix), `#\\\\{${group(content)}\\\\}`, group(suffix), '$'].join(''));\r\n})();\r\nfunction parseFormatter(formatter) {\r\n    let prefix;\r\n    let suffix;\r\n    const surrounded = surroundedRegEx.exec(formatter);\r\n    if (surrounded) {\r\n        [, prefix, formatter, suffix] = surrounded;\r\n    }\r\n    const match = formatRegEx.exec(formatter);\r\n    if (!match) {\r\n        throw new Error(`The number formatter is invalid: ${formatter}`);\r\n    }\r\n    const [, fill, align, sign, symbol, zero, width, comma, precision, trim, type] = match;\r\n    return {\r\n        fill,\r\n        align,\r\n        sign,\r\n        symbol,\r\n        zero,\r\n        width: parseInt(width),\r\n        comma,\r\n        precision: parseInt(precision),\r\n        trim: Boolean(trim),\r\n        type,\r\n        prefix,\r\n        suffix,\r\n    };\r\n}\r\nfunction format(formatter) {\r\n    const options = typeof formatter === 'string' ? parseFormatter(formatter) : formatter;\r\n    const { fill, align, sign = '-', symbol, zero, width, comma, type, prefix = '', suffix = '', precision } = options;\r\n    let { trim } = options;\r\n    const precisionIsNaN = precision === undefined || isNaN(precision);\r\n    let formatBody;\r\n    if (!type) {\r\n        formatBody = decimalTypes['g'];\r\n        trim = true;\r\n    }\r\n    else if (type in decimalTypes && type in integerTypes) {\r\n        formatBody = precisionIsNaN ? integerTypes[type] : decimalTypes[type];\r\n    }\r\n    else if (type in decimalTypes) {\r\n        formatBody = decimalTypes[type];\r\n    }\r\n    else if (type in integerTypes) {\r\n        formatBody = integerTypes[type];\r\n    }\r\n    else {\r\n        throw new Error(`The number formatter type is invalid: ${type}`);\r\n    }\r\n    let formatterPrecision;\r\n    if (precision == null || precisionIsNaN) {\r\n        formatterPrecision = type ? 6 : 12;\r\n    }\r\n    else {\r\n        formatterPrecision = precision;\r\n    }\r\n    return (n) => {\r\n        let result = formatBody(n, formatterPrecision);\r\n        if (trim) {\r\n            result = removeTrailingZeros(result);\r\n        }\r\n        if (comma) {\r\n            result = insertSeparator(result, comma);\r\n        }\r\n        result = addSign(n, result, sign);\r\n        if (symbol && symbol !== '#') {\r\n            result = `${symbol}${result}`;\r\n        }\r\n        if (symbol === '#' && type === 'x') {\r\n            result = `0x${result}`;\r\n        }\r\n        if (type === 's') {\r\n            result = `${result}${getSIPrefix(n)}`;\r\n        }\r\n        if (type === '%' || type === 'p') {\r\n            result = `${result}%`;\r\n        }\r\n        if (width != null && !isNaN(width)) {\r\n            result = addPadding(result, width, fill !== null && fill !== void 0 ? fill : zero, align);\r\n        }\r\n        result = `${prefix}${result}${suffix}`;\r\n        return result;\r\n    };\r\n}\r\nconst absFloor = (n) => Math.floor(Math.abs(n));\r\nconst integerTypes = {\r\n    b: (n) => absFloor(n).toString(2),\r\n    c: (n) => String.fromCharCode(n),\r\n    d: (n) => Math.round(Math.abs(n)).toFixed(0),\r\n    o: (n) => absFloor(n).toString(8),\r\n    x: (n) => absFloor(n).toString(16),\r\n    X: (n) => integerTypes.x(n).toUpperCase(),\r\n    n: (n) => integerTypes.d(n),\r\n    '%': (n) => `${absFloor(n * 100).toFixed(0)}`,\r\n};\r\nconst decimalTypes = {\r\n    e: (n, f) => Math.abs(n).toExponential(f),\r\n    E: (n, f) => decimalTypes.e(n, f).toUpperCase(),\r\n    f: (n, f) => Math.abs(n).toFixed(f),\r\n    F: (n, f) => decimalTypes.f(n, f).toUpperCase(),\r\n    g: (n, f) => {\r\n        if (n === 0) {\r\n            return '0';\r\n        }\r\n        const a = Math.abs(n);\r\n        const p = Math.floor(Math.log10(a));\r\n        if (p >= -4 && p < f) {\r\n            return a.toFixed(f - 1 - p);\r\n        }\r\n        return a.toExponential(f - 1);\r\n    },\r\n    G: (n, f) => decimalTypes.g(n, f).toUpperCase(),\r\n    n: (n, f) => decimalTypes.g(n, f),\r\n    p: (n, f) => decimalTypes.r(n * 100, f),\r\n    r: (n, f) => {\r\n        if (n === 0) {\r\n            return '0';\r\n        }\r\n        const a = Math.abs(n);\r\n        const p = Math.floor(Math.log10(a));\r\n        const q = p - (f - 1);\r\n        if (q <= 0) {\r\n            return a.toFixed(-q);\r\n        }\r\n        const x = Math.pow(10, q);\r\n        return (Math.round(a / x) * x).toFixed();\r\n    },\r\n    s: (n, f) => {\r\n        const p = getSIPrefixPower(n);\r\n        return decimalTypes.r(n / Math.pow(10, p), f);\r\n    },\r\n    '%': (n, f) => decimalTypes.f(n * 100, f),\r\n};\r\nfunction removeTrailingZeros(numString) {\r\n    return numString.replace(/\\.0+$/, '').replace(/(\\.[1-9])0+$/, '$1');\r\n}\r\nfunction insertSeparator(numString, separator) {\r\n    let dotIndex = numString.indexOf('.');\r\n    if (dotIndex < 0) {\r\n        dotIndex = numString.length;\r\n    }\r\n    const integerChars = numString.substring(0, dotIndex).split('');\r\n    const fractionalPart = numString.substring(dotIndex);\r\n    for (let i = integerChars.length - 3; i > 0; i -= 3) {\r\n        integerChars.splice(i, 0, separator);\r\n    }\r\n    return `${integerChars.join('')}${fractionalPart}`;\r\n}\r\nfunction getSIPrefix(n) {\r\n    return siPrefixes[getSIPrefixPower(n)];\r\n}\r\nfunction getSIPrefixPower(n) {\r\n    const power = Math.log10(Math.abs(n));\r\n    const p = Math.floor(power / 3) * 3;\r\n    return Math.max(minSIPrefix, Math.min(maxSIPrefix, p));\r\n}\r\nconst minSIPrefix = -24;\r\nconst maxSIPrefix = 24;\r\nconst siPrefixes = {\r\n    [minSIPrefix]: 'y',\r\n    [-21]: 'z',\r\n    [-18]: 'a',\r\n    [-15]: 'f',\r\n    [-12]: 'p',\r\n    [-9]: 'n',\r\n    [-6]: 'µ',\r\n    [-3]: 'm',\r\n    [0]: '',\r\n    [3]: 'k',\r\n    [6]: 'M',\r\n    [9]: 'G',\r\n    [12]: 'T',\r\n    [15]: 'P',\r\n    [18]: 'E',\r\n    [21]: 'Z',\r\n    [maxSIPrefix]: 'Y',\r\n};\r\nconst minusSign = '\\u2212';\r\nfunction addSign(num, numString, signType = '') {\r\n    if (signType === '(') {\r\n        return num >= 0 ? numString : `(${numString})`;\r\n    }\r\n    const plusSign = signType === '+' ? '+' : '';\r\n    return `${num >= 0 ? plusSign : minusSign}${numString}`;\r\n}\r\nfunction addPadding(numString, width, fill = ' ', align = '>') {\r\n    let result = numString;\r\n    if (align === '>' || !align) {\r\n        result = result.padStart(width, fill);\r\n    }\r\n    else if (align === '<') {\r\n        result = result.padEnd(width, fill);\r\n    }\r\n    else if (align === '^') {\r\n        const padWidth = Math.max(0, width - result.length);\r\n        const padLeft = Math.ceil(padWidth / 2);\r\n        const padRight = Math.floor(padWidth / 2);\r\n        result = result.padStart(padLeft + result.length, fill);\r\n        result = result.padEnd(padRight + result.length, fill);\r\n    }\r\n    return result;\r\n}\r\nfunction tickFormat(ticks, formatter) {\r\n    const options = parseFormatter(formatter !== null && formatter !== void 0 ? formatter : ',f');\r\n    const { precision } = options;\r\n    if (precision == null || isNaN(precision)) {\r\n        if (options.type === 'f' || options.type === '%') {\r\n            options.precision = Math.max(...ticks.map((x) => {\r\n                if (typeof x !== 'number' || x === 0) {\r\n                    return 0;\r\n                }\r\n                const l = Math.floor(Math.log10(Math.abs(x)));\r\n                const digits = options.type ? 6 : 12;\r\n                const exp = x.toExponential(digits - 1).replace(/\\.?0+e/, 'e');\r\n                const dotIndex = exp.indexOf('.');\r\n                if (dotIndex < 0) {\r\n                    return l >= 0 ? 0 : -l;\r\n                }\r\n                const s = exp.indexOf('e') - dotIndex;\r\n                return Math.max(0, s - l - 1);\r\n            }));\r\n        }\r\n        else if (!options.type || options.type in decimalTypes) {\r\n            options.precision = Math.max(...ticks.map((x) => {\r\n                if (typeof x !== 'number') {\r\n                    return 0;\r\n                }\r\n                const exp = x.toExponential((options.type ? 6 : 12) - 1).replace(/\\.?0+e/, 'e');\r\n                return exp.substring(0, exp.indexOf('e')).replace('.', '').length;\r\n            }));\r\n        }\r\n    }\r\n    const f = format(options);\r\n    return (n) => f(Number(n));\r\n}\n\nfunction ticks (start, stop, count, minCount, maxCount) {\r\n    if (count < 2) {\r\n        return range$1(start, stop, stop - start);\r\n    }\r\n    const step = tickStep(start, stop, count, minCount, maxCount);\r\n    if (isNaN(step)) {\r\n        return new NumericTicks(0);\r\n    }\r\n    start = Math.ceil(start / step) * step;\r\n    stop = Math.floor(stop / step) * step;\r\n    return range$1(start, stop, step);\r\n}\r\nconst tickMultipliers = [1, 2, 5, 10];\r\nfunction tickStep(a, b, count, minCount = 0, maxCount = Infinity) {\r\n    const rawStep = (b - a) / count;\r\n    const power = Math.floor(Math.log10(rawStep));\r\n    const step = Math.pow(10, power);\r\n    const m = tickMultipliers\r\n        .map((multiplier) => {\r\n        const s = multiplier * step;\r\n        const c = Math.ceil((b - a) / s);\r\n        const isWithinBounds = c >= minCount && c <= maxCount;\r\n        const diffCount = Math.abs(c - count);\r\n        return { multiplier, isWithinBounds, diffCount };\r\n    })\r\n        .sort((a, b) => {\r\n        if (a.isWithinBounds !== b.isWithinBounds) {\r\n            return a.isWithinBounds ? -1 : 1;\r\n        }\r\n        return a.diffCount - b.diffCount;\r\n    })[0].multiplier;\r\n    if (!m || isNaN(m)) {\r\n        return NaN;\r\n    }\r\n    return m * step;\r\n}\r\nfunction singleTickDomain(a, b) {\r\n    const power = Math.floor(Math.log10(b - a));\r\n    const step = Math.pow(10, power);\r\n    return tickMultipliers\r\n        .map((multiplier) => {\r\n        const s = multiplier * step;\r\n        const start = Math.floor(a / s) * s;\r\n        const end = Math.ceil(b / s) * s;\r\n        const error = 1 - (b - a) / (end - start);\r\n        const domain = [start, end];\r\n        return { error, domain };\r\n    })\r\n        .sort((a, b) => a.error - b.error)[0].domain;\r\n}\r\nclass NumericTicks extends Array {\r\n    constructor(fractionDigits, elements) {\r\n        super();\r\n        if (elements) {\r\n            for (let i = 0, n = elements.length; i < n; i++) {\r\n                this[i] = elements[i];\r\n            }\r\n        }\r\n        this.fractionDigits = fractionDigits;\r\n    }\r\n}\r\nfunction range$1(start, stop, step) {\r\n    const countDigits = (expNo) => {\r\n        var _a, _b;\r\n        const parts = expNo.split('e');\r\n        return Math.max(((_b = (_a = parts[0].split('.')[1]) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) - Number(parts[1]), 0);\r\n    };\r\n    const fractionalDigits = countDigits((step % 1).toExponential());\r\n    const f = Math.pow(10, fractionalDigits);\r\n    const n = Math.ceil((stop - start) / step);\r\n    const values = new NumericTicks(fractionalDigits);\r\n    for (let i = 0; i <= n; i++) {\r\n        const value = start + step * i;\r\n        values.push(Math.round(value * f) / f);\r\n    }\r\n    return values;\r\n}\n\nclass ContinuousScale {\r\n    static is(value) {\r\n        return value instanceof ContinuousScale;\r\n    }\r\n    constructor(domain, range) {\r\n        this.domain = domain;\r\n        this.range = range;\r\n        this.nice = false;\r\n        this.tickCount = ContinuousScale.defaultTickCount;\r\n        this.minTickCount = 0;\r\n        this.maxTickCount = Infinity;\r\n        this.niceDomain = [];\r\n        this.defaultClampMode = 'raw';\r\n        this.cache = null;\r\n        this.cacheProps = ['domain', 'range', 'nice', 'tickCount', 'minTickCount', 'maxTickCount'];\r\n    }\r\n    transform(x) {\r\n        return x;\r\n    }\r\n    transformInvert(x) {\r\n        return x;\r\n    }\r\n    calcBandwidth(smallestInterval = 1) {\r\n        const domain = this.getDomain();\r\n        const maxRange = Math.max(...this.range);\r\n        const intervals = (domain[1] - domain[0]) / smallestInterval + 1;\r\n        // The number of intervals/bands is used to determine the width of individual bands by dividing the available range.\r\n        // Allow a maximum number of bands to ensure the step does not fall below 1 pixel.\r\n        // This means there could be some overlap of the bands in the chart.\r\n        const maxBands = Math.floor(maxRange); // A minimum of 1px per bar/column means the maximum number of bands will equal the available range\r\n        const bands = Math.min(intervals, maxBands);\r\n        return maxRange / Math.max(1, bands);\r\n    }\r\n    fromDomain(d) {\r\n        if (typeof d === 'number') {\r\n            return d;\r\n        }\r\n        else if (d instanceof Date) {\r\n            return d.getTime();\r\n        }\r\n        return NaN;\r\n    }\r\n    getDomain() {\r\n        if (this.nice) {\r\n            this.refresh();\r\n            if (this.niceDomain.length) {\r\n                return this.niceDomain;\r\n            }\r\n        }\r\n        return this.domain;\r\n    }\r\n    convert(x, opts) {\r\n        var _a;\r\n        const clampMode = (_a = opts === null || opts === void 0 ? void 0 : opts.clampMode) !== null && _a !== void 0 ? _a : this.defaultClampMode;\r\n        if (!this.domain || this.domain.length < 2) {\r\n            return NaN;\r\n        }\r\n        this.refresh();\r\n        const domain = this.getDomain().map((d) => this.transform(d));\r\n        const [d0, d1] = domain;\r\n        const { range } = this;\r\n        const [r0, r1] = range;\r\n        x = this.transform(x);\r\n        if (clampMode === 'clamped') {\r\n            if (x < d0) {\r\n                return r0;\r\n            }\r\n            else if (x > d1) {\r\n                return r1;\r\n            }\r\n        }\r\n        if (d0 === d1) {\r\n            return (r0 + r1) / 2;\r\n        }\r\n        else if (x === d0) {\r\n            return r0;\r\n        }\r\n        else if (x === d1) {\r\n            return r1;\r\n        }\r\n        return (r0 + ((this.fromDomain(x) - this.fromDomain(d0)) / (this.fromDomain(d1) - this.fromDomain(d0))) * (r1 - r0));\r\n    }\r\n    invert(x) {\r\n        this.refresh();\r\n        const domain = this.getDomain().map((d) => this.transform(d));\r\n        const [d0, d1] = domain;\r\n        const { range } = this;\r\n        const [r0, r1] = range;\r\n        const isReversed = r0 > r1;\r\n        const rMin = isReversed ? r1 : r0;\r\n        const rMax = isReversed ? r0 : r1;\r\n        let d;\r\n        if (x < rMin) {\r\n            return isReversed ? d1 : d0;\r\n        }\r\n        else if (x > rMax) {\r\n            return isReversed ? d0 : d1;\r\n        }\r\n        else if (r0 === r1) {\r\n            d = this.toDomain((this.fromDomain(d0) + this.fromDomain(d1)) / 2);\r\n        }\r\n        else {\r\n            d = this.toDomain(this.fromDomain(d0) + ((x - r0) / (r1 - r0)) * (this.fromDomain(d1) - this.fromDomain(d0)));\r\n        }\r\n        return this.transformInvert(d);\r\n    }\r\n    didChange() {\r\n        const { cache } = this;\r\n        const didChange = !cache || this.cacheProps.some((p) => this[p] !== cache[p]);\r\n        if (didChange) {\r\n            this.cache = {};\r\n            this.cacheProps.forEach((p) => (this.cache[p] = this[p]));\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    refresh() {\r\n        if (this.didChange()) {\r\n            this.update();\r\n        }\r\n    }\r\n    getPixelRange() {\r\n        const range = this.range.slice().sort((a, b) => a - b);\r\n        return range[1] - range[0];\r\n    }\r\n    isDenseInterval({ start, stop, interval, count, }) {\r\n        const domain = stop - start;\r\n        const availableRange = this.getPixelRange();\r\n        const step = typeof interval === 'number' ? interval : 1;\r\n        count !== null && count !== void 0 ? count : (count = domain / step);\r\n        if (count >= availableRange) {\r\n            Logger.warn(`the configured tick interval results in more than 1 tick per pixel, ignoring. Supply a larger tick interval or omit this configuration.`);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\nContinuousScale.defaultTickCount = 5;\r\nContinuousScale.defaultMaxTickCount = 6;\n\n/**\r\n * Maps continuous domain to a continuous range.\r\n */\r\nclass LinearScale extends ContinuousScale {\r\n    constructor() {\r\n        super([0, 1], [0, 1]);\r\n        this.type = 'linear';\r\n    }\r\n    toDomain(d) {\r\n        return d;\r\n    }\r\n    ticks() {\r\n        var _a;\r\n        const count = (_a = this.tickCount) !== null && _a !== void 0 ? _a : ContinuousScale.defaultTickCount;\r\n        if (!this.domain || this.domain.length < 2 || count < 1 || this.domain.some((d) => !isFinite(d))) {\r\n            return [];\r\n        }\r\n        this.refresh();\r\n        const [d0, d1] = this.getDomain();\r\n        const { interval } = this;\r\n        if (interval) {\r\n            const step = Math.abs(interval);\r\n            if (!this.isDenseInterval({ start: d0, stop: d1, interval: step })) {\r\n                return range$1(d0, d1, step);\r\n            }\r\n        }\r\n        return ticks(d0, d1, count, this.minTickCount, this.maxTickCount);\r\n    }\r\n    update() {\r\n        if (!this.domain || this.domain.length < 2) {\r\n            return;\r\n        }\r\n        if (this.nice) {\r\n            this.updateNiceDomain();\r\n        }\r\n    }\r\n    getTickStep(start, stop) {\r\n        var _a, _b;\r\n        const count = (_a = this.tickCount) !== null && _a !== void 0 ? _a : ContinuousScale.defaultTickCount;\r\n        return (_b = this.interval) !== null && _b !== void 0 ? _b : tickStep(start, stop, count, this.minTickCount, this.maxTickCount);\r\n    }\r\n    /**\r\n     * Extends the domain so that it starts and ends on nice round values.\r\n     */\r\n    updateNiceDomain() {\r\n        var _a;\r\n        const count = (_a = this.tickCount) !== null && _a !== void 0 ? _a : ContinuousScale.defaultTickCount;\r\n        let [start, stop] = this.domain;\r\n        if (count < 1) {\r\n            this.niceDomain = [start, stop];\r\n            return;\r\n        }\r\n        if (count === 1) {\r\n            this.niceDomain = singleTickDomain(start, stop);\r\n            return;\r\n        }\r\n        const maxAttempts = 4;\r\n        let prev0 = start;\r\n        let prev1 = stop;\r\n        for (let i = 0; i < maxAttempts; i++) {\r\n            const step = this.getTickStep(start, stop);\r\n            const [d0, d1] = this.domain;\r\n            if (step >= 1) {\r\n                start = Math.floor(d0 / step) * step;\r\n                stop = Math.ceil(d1 / step) * step;\r\n            }\r\n            else {\r\n                // Prevent floating point error\r\n                const s = 1 / step;\r\n                start = Math.floor(d0 * s) / s;\r\n                stop = Math.ceil(d1 * s) / s;\r\n            }\r\n            if (start === prev0 && stop === prev1) {\r\n                break;\r\n            }\r\n            prev0 = start;\r\n            prev1 = stop;\r\n        }\r\n        this.niceDomain = [start, stop];\r\n    }\r\n    tickFormat({ ticks, specifier }) {\r\n        return tickFormat(ticks !== null && ticks !== void 0 ? ticks : this.ticks(), specifier);\r\n    }\r\n}\n\nfunction ascendingStringNumberUndefined(a, b) {\r\n    let diff = 0;\r\n    if (typeof a === 'number' && typeof b === 'number') {\r\n        diff = a - b;\r\n    }\r\n    else if (typeof a === 'string' && typeof b === 'string') {\r\n        diff = a.localeCompare(b);\r\n    }\r\n    else if (a == null && b == null) ;\r\n    else if (a == null) {\r\n        diff = -1;\r\n    }\r\n    else if (b == null) {\r\n        diff = 1;\r\n    }\r\n    else {\r\n        diff = String(a).localeCompare(String(b));\r\n    }\r\n    return diff;\r\n}\r\nfunction compoundAscending(a, b, comparator) {\r\n    const toLiteral = (v) => {\r\n        if (typeof v === 'function') {\r\n            return v();\r\n        }\r\n        return v;\r\n    };\r\n    for (const idx in a) {\r\n        const diff = comparator(toLiteral(a[idx]), toLiteral(b[idx]));\r\n        if (diff !== 0) {\r\n            return diff;\r\n        }\r\n    }\r\n    return 0;\r\n}\n\nclass Group extends Node {\r\n    zIndexChanged() {\r\n        var _a;\r\n        if (this.layer) {\r\n            (_a = this._layerManager) === null || _a === void 0 ? void 0 : _a.moveLayer(this.layer, this.zIndex, this.zIndexSubOrder);\r\n        }\r\n    }\r\n    isLayer() {\r\n        return this.layer != null;\r\n    }\r\n    constructor(opts) {\r\n        var _a;\r\n        super({ isVirtual: opts === null || opts === void 0 ? void 0 : opts.isVirtual });\r\n        this.opts = opts;\r\n        this.opacity = 1;\r\n        this.lastBBox = undefined;\r\n        const { zIndex, zIndexSubOrder } = opts !== null && opts !== void 0 ? opts : {};\r\n        this.isContainerNode = true;\r\n        if (zIndex !== undefined) {\r\n            this.zIndex = zIndex;\r\n        }\r\n        if (zIndexSubOrder !== undefined) {\r\n            this.zIndexSubOrder = zIndexSubOrder;\r\n        }\r\n        this.name = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.name;\r\n    }\r\n    _setLayerManager(scene) {\r\n        var _a, _b;\r\n        if (this._layerManager && this.layer) {\r\n            this._layerManager.removeLayer(this.layer);\r\n            this.layer = undefined;\r\n        }\r\n        if (this.layer) {\r\n            throw new Error('AG Charts - unable to deregister scene rendering layer!');\r\n        }\r\n        super._setLayerManager(scene);\r\n        if (scene && ((_a = this.opts) === null || _a === void 0 ? void 0 : _a.layer)) {\r\n            const { zIndex, zIndexSubOrder, name } = (_b = this.opts) !== null && _b !== void 0 ? _b : {};\r\n            const getComputedOpacity = () => this.getComputedOpacity();\r\n            const getVisibility = () => this.getVisibility();\r\n            this.layer = scene.addLayer({\r\n                zIndex,\r\n                zIndexSubOrder,\r\n                name,\r\n                getComputedOpacity,\r\n                getVisibility,\r\n            });\r\n        }\r\n    }\r\n    getComputedOpacity() {\r\n        let opacity = 1;\r\n        let node = this;\r\n        do {\r\n            if (node instanceof Group) {\r\n                opacity *= node.opacity;\r\n            }\r\n        } while ((node = node.parent));\r\n        return opacity;\r\n    }\r\n    getVisibility() {\r\n        let node = this;\r\n        let visible = this.visible;\r\n        while ((node = node.parent)) {\r\n            if (node.visible) {\r\n                continue;\r\n            }\r\n            visible = node.visible;\r\n        }\r\n        return visible;\r\n    }\r\n    visibilityChanged() {\r\n        if (this.layer) {\r\n            this.layer.enabled = this.visible;\r\n        }\r\n    }\r\n    markDirty(source, type = RedrawType.TRIVIAL) {\r\n        if (this.isVirtual) {\r\n            // Always percolate directly for virtual nodes - they don't exist for rendering purposes.\r\n            super.markDirty(source, type);\r\n            return;\r\n        }\r\n        // Downgrade dirty-ness percolated to parent in special cases.\r\n        let parentType = type;\r\n        if (type < RedrawType.MINOR || this.layer != null) {\r\n            parentType = RedrawType.TRIVIAL;\r\n        }\r\n        super.markDirty(source, type, parentType);\r\n    }\r\n    // We consider a group to be boundless, thus any point belongs to it.\r\n    containsPoint(_x, _y) {\r\n        return true;\r\n    }\r\n    computeBBox() {\r\n        this.computeTransformMatrix();\r\n        return Group.computeBBox(this.children);\r\n    }\r\n    computeTransformedBBox() {\r\n        return this.computeBBox();\r\n    }\r\n    render(renderCtx) {\r\n        var _a, _b;\r\n        const { opts: { name = undefined } = {}, _debug: debug = () => { } } = this;\r\n        const { dirty, dirtyZIndex, layer, children, clipRect, dirtyTransform } = this;\r\n        let { ctx, forceRender, clipBBox } = renderCtx;\r\n        const { resized, stats } = renderCtx;\r\n        const canvasCtxTransform = ctx.getTransform();\r\n        const isDirty = dirty >= RedrawType.MINOR || dirtyZIndex || resized;\r\n        let isChildDirty = isDirty;\r\n        let isChildLayerDirty = false;\r\n        for (const child of children) {\r\n            isChildDirty || (isChildDirty = child.layerManager == null && child.dirty >= RedrawType.TRIVIAL);\r\n            isChildLayerDirty || (isChildLayerDirty = child.layerManager != null && child.dirty >= RedrawType.TRIVIAL);\r\n            if (isChildDirty) {\r\n                break;\r\n            }\r\n        }\r\n        if (name) {\r\n            debug({ name, group: this, isDirty, isChildDirty, dirtyTransform, renderCtx, forceRender });\r\n        }\r\n        if (dirtyTransform) {\r\n            forceRender = 'dirtyTransform';\r\n        }\r\n        else if (layer) {\r\n            // If bounding-box of a layer changes, force re-render.\r\n            const currentBBox = this.computeBBox();\r\n            if (this.lastBBox === undefined || !this.lastBBox.equals(currentBBox)) {\r\n                forceRender = 'dirtyTransform';\r\n                this.lastBBox = currentBBox;\r\n            }\r\n        }\r\n        if (!isDirty && !isChildDirty && !isChildLayerDirty && !forceRender) {\r\n            if (name && stats) {\r\n                debug({ name, result: 'skipping', renderCtx, counts: this.nodeCount, group: this });\r\n            }\r\n            if (layer && stats) {\r\n                stats.layersSkipped++;\r\n                stats.nodesSkipped += this.nodeCount.count;\r\n            }\r\n            this.markClean({ recursive: false });\r\n            // Nothing to do.\r\n            return;\r\n        }\r\n        const groupVisible = this.visible;\r\n        if (layer) {\r\n            // Switch context to the canvas layer we use for this group.\r\n            ctx = layer.context;\r\n            ctx.save();\r\n            ctx.resetTransform();\r\n            if (forceRender !== 'dirtyTransform') {\r\n                forceRender = isChildDirty || dirtyZIndex;\r\n            }\r\n            if (forceRender)\r\n                layer.clear();\r\n            if (clipBBox) {\r\n                // clipBBox is in the canvas coordinate space, when we hit a layer we apply the new clipping at which point there are no transforms in play\r\n                const { width, height, x, y } = clipBBox;\r\n                debug(() => ({\r\n                    name,\r\n                    clipBBox,\r\n                    ctxTransform: ctx.getTransform(),\r\n                    renderCtx,\r\n                    group: this,\r\n                }));\r\n                this.clipCtx(ctx, x, y, width, height);\r\n            }\r\n            ctx.setTransform(canvasCtxTransform);\r\n        }\r\n        else {\r\n            // Only apply opacity if this isn't a distinct layer - opacity will be applied\r\n            // at composition time.\r\n            ctx.globalAlpha *= this.opacity;\r\n        }\r\n        // A group can have `scaling`, `rotation`, `translation` properties\r\n        // that are applied to the canvas context before children are rendered,\r\n        // so all children can be transformed at once.\r\n        this.computeTransformMatrix();\r\n        this.matrix.toContext(ctx);\r\n        if (clipRect) {\r\n            // clipRect is in the group's coordinate space\r\n            const { x, y, width, height } = clipRect;\r\n            ctx.save();\r\n            debug(() => ({ name, clipRect, ctxTransform: ctx.getTransform(), renderCtx, group: this }));\r\n            this.clipCtx(ctx, x, y, width, height);\r\n            // clipBBox is in the canvas coordinate space, when we hit a layer we apply the new clipping at which point there are no transforms in play\r\n            clipBBox = this.matrix.transformBBox(clipRect);\r\n        }\r\n        const hasVirtualChildren = this.hasVirtualChildren();\r\n        if (dirtyZIndex) {\r\n            this.sortChildren(children);\r\n            if (forceRender !== 'dirtyTransform')\r\n                forceRender = true;\r\n        }\r\n        else if (hasVirtualChildren) {\r\n            this.sortChildren(children);\r\n        }\r\n        // Reduce churn if renderCtx is identical.\r\n        const renderContextChanged = forceRender !== renderCtx.forceRender || clipBBox !== renderCtx.clipBBox || ctx !== renderCtx.ctx;\r\n        const childRenderContext = renderContextChanged ? Object.assign(Object.assign({}, renderCtx), { ctx, forceRender, clipBBox }) : renderCtx;\r\n        // Render visible children.\r\n        let skipped = 0;\r\n        for (const child of children) {\r\n            if (!child.visible || !groupVisible) {\r\n                // Skip invisible children, but make sure their dirty flag is reset.\r\n                child.markClean();\r\n                if (stats)\r\n                    skipped += child.nodeCount.count;\r\n                continue;\r\n            }\r\n            if (!forceRender && child.dirty === RedrawType.NONE) {\r\n                // Skip children that don't need to be redrawn.\r\n                if (stats)\r\n                    skipped += child.nodeCount.count;\r\n                continue;\r\n            }\r\n            // Render marks this node (and children) as clean - no need to explicitly markClean().\r\n            ctx.save();\r\n            child.render(childRenderContext);\r\n            ctx.restore();\r\n        }\r\n        if (stats)\r\n            stats.nodesSkipped += skipped;\r\n        // Render marks this node as clean - no need to explicitly markClean().\r\n        super.render(renderCtx);\r\n        if (clipRect) {\r\n            ctx.restore();\r\n        }\r\n        if (hasVirtualChildren) {\r\n            // Mark virtual nodes as clean and their virtual children - all other nodes have already\r\n            // been visited and marked clean.\r\n            for (const child of this.virtualChildren) {\r\n                child.markClean({ recursive: 'virtual' });\r\n            }\r\n        }\r\n        if (layer) {\r\n            if (stats)\r\n                stats.layersRendered++;\r\n            ctx.restore();\r\n            if (forceRender)\r\n                layer.snapshot();\r\n            // Check for save/restore depth of zero!\r\n            (_b = (_a = layer.context).verifyDepthZero) === null || _b === void 0 ? void 0 : _b.call(_a);\r\n        }\r\n        if (name && stats) {\r\n            debug({ name, result: 'rendered', skipped, renderCtx, counts: this.nodeCount, group: this });\r\n        }\r\n    }\r\n    sortChildren(children) {\r\n        this.dirtyZIndex = false;\r\n        children.sort((a, b) => {\r\n            var _a, _b;\r\n            return compoundAscending([a.zIndex, ...((_a = a.zIndexSubOrder) !== null && _a !== void 0 ? _a : [undefined, undefined]), a.serialNumber], [b.zIndex, ...((_b = b.zIndexSubOrder) !== null && _b !== void 0 ? _b : [undefined, undefined]), b.serialNumber], ascendingStringNumberUndefined);\r\n        });\r\n    }\r\n    clipCtx(ctx, x, y, width, height) {\r\n        ctx.beginPath();\r\n        ctx.moveTo(x, y);\r\n        ctx.lineTo(x + width, y);\r\n        ctx.lineTo(x + width, y + height);\r\n        ctx.lineTo(x, y + height);\r\n        ctx.closePath();\r\n        ctx.clip();\r\n    }\r\n    static computeBBox(nodes) {\r\n        let left = Infinity;\r\n        let right = -Infinity;\r\n        let top = Infinity;\r\n        let bottom = -Infinity;\r\n        nodes.forEach((n) => {\r\n            if (!n.visible) {\r\n                return;\r\n            }\r\n            const bbox = n.computeTransformedBBox();\r\n            if (!bbox) {\r\n                return;\r\n            }\r\n            const x = bbox.x;\r\n            const y = bbox.y;\r\n            if (x < left) {\r\n                left = x;\r\n            }\r\n            if (y < top) {\r\n                top = y;\r\n            }\r\n            if (x + bbox.width > right) {\r\n                right = x + bbox.width;\r\n            }\r\n            if (y + bbox.height > bottom) {\r\n                bottom = y + bbox.height;\r\n            }\r\n        });\r\n        return new BBox(left, top, right - left, bottom - top);\r\n    }\r\n    /**\r\n     * Transforms bbox given in the canvas coordinate space to bbox in this group's coordinate space and\r\n     * sets this group's clipRect to the transformed bbox.\r\n     * @param bbox clipRect bbox in the canvas coordinate space.\r\n     */\r\n    setClipRectInGroupCoordinateSpace(bbox) {\r\n        this.clipRect = bbox ? this.transformBBox(bbox) : undefined;\r\n    }\r\n}\r\nGroup.className = 'Group';\r\n__decorate([\r\n    SceneChangeDetection({\r\n        redraw: RedrawType.MAJOR,\r\n        convertor: (v) => Math.min(1, Math.max(0, v)),\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Group.prototype, \"opacity\", void 0);\n\nclass Selection {\r\n    static select(parent, classOrFactory, garbageCollection = true) {\r\n        return new Selection(parent, classOrFactory, garbageCollection);\r\n    }\r\n    static selectAll(parent, predicate) {\r\n        const results = [];\r\n        const traverse = (node) => {\r\n            if (predicate(node)) {\r\n                results.push(node);\r\n            }\r\n            node.children.forEach(traverse);\r\n        };\r\n        traverse(parent);\r\n        return results;\r\n    }\r\n    static selectByClass(node, Class) {\r\n        return Selection.selectAll(node, (node) => node instanceof Class);\r\n    }\r\n    static selectByTag(node, tag) {\r\n        return Selection.selectAll(node, (node) => node.tag === tag);\r\n    }\r\n    constructor(parentNode, classOrFactory, autoCleanup = true) {\r\n        this.parentNode = parentNode;\r\n        this.autoCleanup = autoCleanup;\r\n        this.garbageBin = new Set();\r\n        this._nodesMap = new Map();\r\n        this._nodes = [];\r\n        this.data = [];\r\n        this.debug = Debug.create(true, 'scene', 'scene:selections');\r\n        this.nodeFactory = Object.prototype.isPrototypeOf.call(Node, classOrFactory)\r\n            ? () => new classOrFactory()\r\n            : classOrFactory;\r\n    }\r\n    createNode(datum, initializer, idx) {\r\n        const node = this.nodeFactory(datum);\r\n        node.datum = datum;\r\n        initializer === null || initializer === void 0 ? void 0 : initializer(node);\r\n        if (idx != null) {\r\n            this._nodes.splice(idx, 0, node);\r\n        }\r\n        else {\r\n            this._nodes.push(node);\r\n        }\r\n        this.parentNode.appendChild(node);\r\n        return node;\r\n    }\r\n    /**\r\n     * Update the data in a selection. If an `getDatumId()` function is provided, maintain a list of ids related to\r\n     * the nodes. Otherwise, take the more efficient route of simply creating and destroying nodes at the end\r\n     * of the array.\r\n     */\r\n    update(data, initializer, getDatumId) {\r\n        if (this.garbageBin.size > 0) {\r\n            this.debug(`Selection - update() called with pending garbage: ${data}`);\r\n        }\r\n        if (getDatumId) {\r\n            const dataMap = new Map(data.map((datum, idx) => [getDatumId(datum), [datum, idx]]));\r\n            for (const [node, datumId] of this._nodesMap.entries()) {\r\n                if (dataMap.has(datumId)) {\r\n                    const [newDatum] = dataMap.get(datumId);\r\n                    node.datum = newDatum;\r\n                    this.garbageBin.delete(node);\r\n                    dataMap.delete(datumId);\r\n                }\r\n                else {\r\n                    this.garbageBin.add(node);\r\n                }\r\n            }\r\n            for (const [datumId, [datum, idx]] of dataMap.entries()) {\r\n                this._nodesMap.set(this.createNode(datum, initializer, idx), datumId);\r\n            }\r\n        }\r\n        else {\r\n            const maxLength = Math.max(data.length, this.data.length);\r\n            for (let i = 0; i < maxLength; i++) {\r\n                if (i >= data.length) {\r\n                    this.garbageBin.add(this._nodes[i]);\r\n                }\r\n                else if (i >= this._nodes.length) {\r\n                    this.createNode(data[i], initializer);\r\n                }\r\n                else {\r\n                    this._nodes[i].datum = data[i];\r\n                    this.garbageBin.delete(this._nodes[i]);\r\n                }\r\n            }\r\n        }\r\n        this.data = data.slice();\r\n        if (this.autoCleanup) {\r\n            this.cleanup();\r\n        }\r\n        return this;\r\n    }\r\n    cleanup() {\r\n        if (this.garbageBin.size === 0) {\r\n            return this;\r\n        }\r\n        this._nodes = this._nodes.filter((node) => {\r\n            if (this.garbageBin.has(node)) {\r\n                this._nodesMap.delete(node);\r\n                this.garbageBin.delete(node);\r\n                this.parentNode.removeChild(node);\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n        return this;\r\n    }\r\n    clear() {\r\n        this.update([]);\r\n        return this;\r\n    }\r\n    isGarbage(node) {\r\n        return this.garbageBin.has(node);\r\n    }\r\n    hasGarbage() {\r\n        return this.garbageBin.size > 0;\r\n    }\r\n    each(iterate) {\r\n        this._nodes.forEach((node, i) => iterate(node, node.datum, i));\r\n        return this;\r\n    }\r\n    *[Symbol.iterator]() {\r\n        for (let index = 0; index < this._nodes.length; index++) {\r\n            const node = this._nodes[index];\r\n            const datum = this._nodes[index].datum;\r\n            yield { node, datum, index };\r\n        }\r\n    }\r\n    select(predicate) {\r\n        return Selection.selectAll(this.parentNode, predicate);\r\n    }\r\n    selectByClass(Class) {\r\n        return Selection.selectByClass(this.parentNode, Class);\r\n    }\r\n    selectByTag(tag) {\r\n        return Selection.selectByTag(this.parentNode, tag);\r\n    }\r\n    nodes() {\r\n        return this._nodes;\r\n    }\r\n}\n\nclass Line extends Shape {\r\n    constructor(opts = {}) {\r\n        super(opts);\r\n        this.x1 = 0;\r\n        this.y1 = 0;\r\n        this.x2 = 0;\r\n        this.y2 = 0;\r\n        this.restoreOwnStyles();\r\n    }\r\n    set x(value) {\r\n        this.x1 = value;\r\n        this.x2 = value;\r\n    }\r\n    set y(value) {\r\n        this.y1 = value;\r\n        this.y2 = value;\r\n    }\r\n    computeBBox() {\r\n        return new BBox(Math.min(this.x1, this.x2), Math.min(this.y1, this.y2), Math.abs(this.x2 - this.x1), Math.abs(this.y2 - this.y1));\r\n    }\r\n    isPointInPath(px, py) {\r\n        if (this.x1 === this.x2 || this.y1 === this.y2) {\r\n            const { x, y } = this.transformPoint(px, py);\r\n            return this.computeBBox()\r\n                .grow(this.strokeWidth / 2)\r\n                .containsPoint(x, y);\r\n        }\r\n        return false;\r\n    }\r\n    render(renderCtx) {\r\n        var _a;\r\n        const { ctx, forceRender, stats } = renderCtx;\r\n        if (this.dirty === RedrawType.NONE && !forceRender) {\r\n            if (stats)\r\n                stats.nodesSkipped += this.nodeCount.count;\r\n            return;\r\n        }\r\n        this.computeTransformMatrix();\r\n        this.matrix.toContext(ctx);\r\n        let { x1, y1, x2, y2 } = this;\r\n        // Align to the pixel grid if the line is strictly vertical\r\n        // or horizontal (but not both, i.e. a dot).\r\n        if (x1 === x2) {\r\n            const x = Math.round(x1) + (Math.floor(this.strokeWidth) % 2) / 2;\r\n            x1 = x;\r\n            x2 = x;\r\n        }\r\n        else if (y1 === y2) {\r\n            const y = Math.round(y1) + (Math.floor(this.strokeWidth) % 2) / 2;\r\n            y1 = y;\r\n            y2 = y;\r\n        }\r\n        ctx.beginPath();\r\n        ctx.moveTo(x1, y1);\r\n        ctx.lineTo(x2, y2);\r\n        this.fillStroke(ctx);\r\n        (_a = this.fillShadow) === null || _a === void 0 ? void 0 : _a.markClean();\r\n        super.render(renderCtx);\r\n    }\r\n}\r\nLine.className = 'Line';\r\nLine.defaultStyles = Object.assign({}, Shape.defaultStyles, {\r\n    fill: undefined,\r\n    strokeWidth: 1,\r\n});\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Line.prototype, \"x1\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Line.prototype, \"y1\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Line.prototype, \"x2\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Line.prototype, \"y2\", void 0);\n\n/**\r\n * Finds the roots of a parametric linear equation in `t`,\r\n * where `t` lies in the interval of `[0,1]`.\r\n */\r\nfunction linearRoot(a, b) {\r\n    const t = -b / a;\r\n    return a !== 0 && t >= 0 && t <= 1 ? [t] : [];\r\n}\r\n/**\r\n * Finds the roots of a parametric quadratic equation in `t`,\r\n * where `t` lies in the interval of `[0,1]`.\r\n */\r\nfunction quadraticRoots(a, b, c) {\r\n    if (a === 0) {\r\n        return linearRoot(b, c);\r\n    }\r\n    const D = b * b - 4 * a * c; // The polynomial's discriminant.\r\n    const roots = [];\r\n    if (D === 0) {\r\n        // A single real root.\r\n        const t = -b / (2 * a);\r\n        if (t >= 0 && t <= 1) {\r\n            roots.push(t);\r\n        }\r\n    }\r\n    else if (D > 0) {\r\n        // A pair of distinct real roots.\r\n        const rD = Math.sqrt(D);\r\n        const t1 = (-b - rD) / (2 * a);\r\n        const t2 = (-b + rD) / (2 * a);\r\n        if (t1 >= 0 && t1 <= 1) {\r\n            roots.push(t1);\r\n        }\r\n        if (t2 >= 0 && t2 <= 1) {\r\n            roots.push(t2);\r\n        }\r\n    }\r\n    // else -> Complex roots.\r\n    return roots;\r\n}\r\n/**\r\n * Finds the roots of a parametric cubic equation in `t`,\r\n * where `t` lies in the interval of `[0,1]`.\r\n * Returns an array of parametric intersection locations along the cubic,\r\n * excluding out-of-bounds intersections (before or after the end point\r\n * or in the imaginary plane).\r\n * An adaptation of http://www.particleincell.com/blog/2013/cubic-line-intersection/\r\n */\r\nfunction cubicRoots(a, b, c, d) {\r\n    if (a === 0) {\r\n        return quadraticRoots(b, c, d);\r\n    }\r\n    const A = b / a;\r\n    const B = c / a;\r\n    const C = d / a;\r\n    const Q = (3 * B - A * A) / 9;\r\n    const R = (9 * A * B - 27 * C - 2 * A * A * A) / 54;\r\n    const D = Q * Q * Q + R * R; // The polynomial's discriminant.\r\n    const third = 1 / 3;\r\n    const roots = [];\r\n    if (D >= 0) {\r\n        // Complex or duplicate roots.\r\n        const rD = Math.sqrt(D);\r\n        const S = Math.sign(R + rD) * Math.pow(Math.abs(R + rD), third);\r\n        const T = Math.sign(R - rD) * Math.pow(Math.abs(R - rD), third);\r\n        const Im = Math.abs((Math.sqrt(3) * (S - T)) / 2); // Complex part of the root pair.\r\n        const t = -third * A + (S + T); // A real root.\r\n        if (t >= 0 && t <= 1) {\r\n            roots.push(t);\r\n        }\r\n        if (Im === 0) {\r\n            const t = -third * A - (S + T) / 2; // The real part of a complex root.\r\n            if (t >= 0 && t <= 1) {\r\n                roots.push(t);\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        // Distinct real roots.\r\n        const theta = Math.acos(R / Math.sqrt(-Q * Q * Q));\r\n        const thirdA = third * A;\r\n        const twoSqrtQ = 2 * Math.sqrt(-Q);\r\n        const t1 = twoSqrtQ * Math.cos(third * theta) - thirdA;\r\n        const t2 = twoSqrtQ * Math.cos(third * (theta + 2 * Math.PI)) - thirdA;\r\n        const t3 = twoSqrtQ * Math.cos(third * (theta + 4 * Math.PI)) - thirdA;\r\n        if (t1 >= 0 && t1 <= 1) {\r\n            roots.push(t1);\r\n        }\r\n        if (t2 >= 0 && t2 <= 1) {\r\n            roots.push(t2);\r\n        }\r\n        if (t3 >= 0 && t3 <= 1) {\r\n            roots.push(t3);\r\n        }\r\n    }\r\n    return roots;\r\n}\n\n/**\r\n * Returns the intersection point for the given pair of line segments, or null,\r\n * if the segments are parallel or don't intersect.\r\n * Based on http://paulbourke.net/geometry/pointlineplane/\r\n */\r\nfunction segmentIntersection(ax1, ay1, ax2, ay2, bx1, by1, bx2, by2) {\r\n    const d = (ax2 - ax1) * (by2 - by1) - (ay2 - ay1) * (bx2 - bx1);\r\n    if (d === 0) {\r\n        // The lines are parallel.\r\n        return null;\r\n    }\r\n    const ua = ((bx2 - bx1) * (ay1 - by1) - (ax1 - bx1) * (by2 - by1)) / d;\r\n    const ub = ((ax2 - ax1) * (ay1 - by1) - (ay2 - ay1) * (ax1 - bx1)) / d;\r\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\r\n        return {\r\n            x: ax1 + ua * (ax2 - ax1),\r\n            y: ay1 + ua * (ay2 - ay1),\r\n        };\r\n    }\r\n    return null; // The intersection point is outside either or both segments.\r\n}\r\n/**\r\n * Returns intersection points of the given cubic curve and the line segment.\r\n * Takes in x/y components of cubic control points and line segment start/end points\r\n * as parameters.\r\n */\r\nfunction cubicSegmentIntersections(px1, py1, px2, py2, px3, py3, px4, py4, x1, y1, x2, y2) {\r\n    const intersections = [];\r\n    // Find line equation coefficients.\r\n    const A = y1 - y2;\r\n    const B = x2 - x1;\r\n    const C = x1 * (y2 - y1) - y1 * (x2 - x1);\r\n    // Find cubic Bezier curve equation coefficients from control points.\r\n    const bx = bezierCoefficients(px1, px2, px3, px4);\r\n    const by = bezierCoefficients(py1, py2, py3, py4);\r\n    const a = A * bx[0] + B * by[0]; // t^3\r\n    const b = A * bx[1] + B * by[1]; // t^2\r\n    const c = A * bx[2] + B * by[2]; // t\r\n    const d = A * bx[3] + B * by[3] + C; // 1\r\n    const roots = cubicRoots(a, b, c, d);\r\n    // Verify that the roots are within bounds of the linear segment.\r\n    for (const t of roots) {\r\n        const tt = t * t;\r\n        const ttt = t * tt;\r\n        // Find the cartesian plane coordinates for the parametric root `t`.\r\n        const x = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];\r\n        const y = by[0] * ttt + by[1] * tt + by[2] * t + by[3];\r\n        // The parametric cubic roots we found are intersection points\r\n        // with an infinite line, and so the x/y coordinates above are as well.\r\n        // Make sure the x/y is also within the bounds of the given segment.\r\n        let s;\r\n        if (x1 !== x2) {\r\n            s = (x - x1) / (x2 - x1);\r\n        }\r\n        else {\r\n            // the line is vertical\r\n            s = (y - y1) / (y2 - y1);\r\n        }\r\n        if (s >= 0 && s <= 1) {\r\n            intersections.push({ x, y });\r\n        }\r\n    }\r\n    return intersections;\r\n}\r\n/**\r\n * Returns the given coordinates vector multiplied by the coefficient matrix\r\n * of the parametric cubic Bézier equation.\r\n */\r\nfunction bezierCoefficients(P1, P2, P3, P4) {\r\n    return [\r\n        // Bézier expressed as matrix operations:\r\n        -P1 + 3 * P2 - 3 * P3 + P4,\r\n        3 * P1 - 6 * P2 + 3 * P3,\r\n        -3 * P1 + 3 * P2,\r\n        P1, //                 | 1  0  0  0| |P4|\r\n    ];\r\n}\r\n/**\r\n * Returns intersection points of the arc and the line segment.\r\n * Takes in arc parameters and line segment start/end points.\r\n */\r\nfunction arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, x1, y1, x2, y2) {\r\n    // Solving the quadratic equation:\r\n    // 1. y = k * x + y0\r\n    // 2. (x - cx)^2 + (y - cy)^2 = r^2\r\n    const k = (y2 - y1) / (x2 - x1);\r\n    const y0 = y1 - k * x1;\r\n    const a = Math.pow(k, 2) + 1;\r\n    const b = 2 * (k * (y0 - cy) - cx);\r\n    const c = Math.pow(cx, 2) + Math.pow(y0 - cy, 2) - Math.pow(r, 2);\r\n    const d = Math.pow(b, 2) - 4 * a * c;\r\n    if (d < 0) {\r\n        return [];\r\n    }\r\n    const i1x = (-b + Math.sqrt(d)) / 2 / a;\r\n    const i2x = (-b - Math.sqrt(d)) / 2 / a;\r\n    const intersections = [];\r\n    [i1x, i2x].forEach((x) => {\r\n        const isXInsideLine = x >= Math.min(x1, x2) && x <= Math.max(x1, x2);\r\n        if (!isXInsideLine) {\r\n            return;\r\n        }\r\n        const y = k * x + y0;\r\n        const a1 = normalizeAngle360(startAngle);\r\n        let a2 = normalizeAngle360(endAngle);\r\n        let a = normalizeAngle360(Math.atan2(y, x));\r\n        // Order angles clockwise after the start angle\r\n        if (a2 <= a1) {\r\n            a2 += 2 * Math.PI;\r\n        }\r\n        if (a < a1) {\r\n            a += 2 * Math.PI;\r\n        }\r\n        if (counterClockwise !== (a >= a1 && a <= a2)) {\r\n            intersections.push({ x, y });\r\n        }\r\n    });\r\n    return intersections;\r\n}\n\nfunction isPointInSector(x, y, sector) {\r\n    const radius = Math.sqrt(Math.pow(x, 2) + Math.pow(y, 2));\r\n    const { innerRadius, outerRadius } = sector;\r\n    if (sector.startAngle === sector.endAngle ||\r\n        radius < Math.min(innerRadius, outerRadius) ||\r\n        radius > Math.max(innerRadius, outerRadius)) {\r\n        return false;\r\n    }\r\n    const startAngle = normalizeAngle180(sector.startAngle);\r\n    const endAngle = normalizeAngle180(sector.endAngle);\r\n    const angle = Math.atan2(y, x);\r\n    // Sector can cross axis start\r\n    return startAngle < endAngle\r\n        ? angle <= endAngle && angle >= startAngle\r\n        : (angle <= endAngle && angle >= -Math.PI) || (angle >= startAngle && angle <= Math.PI);\r\n}\r\nfunction lineCollidesSector(line, sector) {\r\n    const { startAngle, endAngle, innerRadius, outerRadius } = sector;\r\n    const outerStart = { x: outerRadius * Math.cos(startAngle), y: outerRadius * Math.sin(startAngle) };\r\n    const outerEnd = { x: outerRadius * Math.cos(endAngle), y: outerRadius * Math.sin(endAngle) };\r\n    const innerStart = innerRadius === 0\r\n        ? { x: 0, y: 0 }\r\n        : { x: innerRadius * Math.cos(startAngle), y: innerRadius * Math.sin(startAngle) };\r\n    const innerEnd = innerRadius === 0\r\n        ? { x: 0, y: 0 }\r\n        : { x: innerRadius * Math.cos(endAngle), y: innerRadius * Math.sin(endAngle) };\r\n    return (segmentIntersection(line.start.x, line.start.y, line.end.x, line.end.y, outerStart.x, outerStart.y, innerStart.x, innerStart.y) != null ||\r\n        segmentIntersection(line.start.x, line.start.y, line.end.x, line.end.y, outerEnd.x, outerEnd.y, innerEnd.x, innerEnd.y) != null ||\r\n        arcIntersections(0, 0, outerRadius, startAngle, endAngle, true, line.start.x, line.start.y, line.end.x, line.end.y).length > 0);\r\n}\r\nfunction boxCollidesSector(box, sector) {\r\n    const topLeft = { x: box.x, y: box.y };\r\n    const topRight = { x: box.x + box.width, y: box.y };\r\n    const bottomLeft = { x: box.x, y: box.y + box.height };\r\n    const bottomRight = { x: box.x + box.width, y: box.y + box.height };\r\n    return (lineCollidesSector({ start: topLeft, end: topRight }, sector) ||\r\n        lineCollidesSector({ start: bottomLeft, end: bottomRight }, sector));\r\n}\n\nvar Command;\r\n(function (Command) {\r\n    Command[Command[\"Move\"] = 0] = \"Move\";\r\n    Command[Command[\"Line\"] = 1] = \"Line\";\r\n    Command[Command[\"Arc\"] = 2] = \"Arc\";\r\n    Command[Command[\"Curve\"] = 3] = \"Curve\";\r\n    Command[Command[\"ClosePath\"] = 4] = \"ClosePath\";\r\n})(Command || (Command = {}));\r\nclass Path2D {\r\n    constructor() {\r\n        // The methods of this class will likely be called many times per animation frame,\r\n        // and any allocation can trigger a GC cycle during animation, so we attempt\r\n        // to minimize the number of allocations.\r\n        this.previousCommands = [];\r\n        this.previousParams = [];\r\n        this.previousClosedPath = false;\r\n        this.commands = [];\r\n        this.params = [];\r\n        this._closedPath = false;\r\n    }\r\n    isDirty() {\r\n        if (this._closedPath !== this.previousClosedPath) {\r\n            return true;\r\n        }\r\n        if (this.previousCommands.length !== this.commands.length) {\r\n            return true;\r\n        }\r\n        if (this.previousParams.length !== this.params.length) {\r\n            return true;\r\n        }\r\n        for (let i = 0; i < this.commands.length; i++) {\r\n            if (this.commands[i] !== this.previousCommands[i]) {\r\n                return true;\r\n            }\r\n        }\r\n        for (let i = 0; i < this.params.length; i++) {\r\n            if (this.params[i] !== this.previousParams[i]) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n    draw(ctx) {\r\n        const commands = this.commands;\r\n        const params = this.params;\r\n        let j = 0;\r\n        ctx.beginPath();\r\n        for (const command of commands) {\r\n            switch (command) {\r\n                case Command.Move:\r\n                    ctx.moveTo(params[j++], params[j++]);\r\n                    break;\r\n                case Command.Line:\r\n                    ctx.lineTo(params[j++], params[j++]);\r\n                    break;\r\n                case Command.Curve:\r\n                    ctx.bezierCurveTo(params[j++], params[j++], params[j++], params[j++], params[j++], params[j++]);\r\n                    break;\r\n                case Command.Arc:\r\n                    ctx.arc(params[j++], params[j++], params[j++], params[j++], params[j++], params[j++] === 1);\r\n                    break;\r\n                case Command.ClosePath:\r\n                    ctx.closePath();\r\n                    break;\r\n            }\r\n        }\r\n        if (commands.length === 0) {\r\n            ctx.closePath();\r\n        }\r\n    }\r\n    moveTo(x, y) {\r\n        if (this.xy) {\r\n            this.xy[0] = x;\r\n            this.xy[1] = y;\r\n        }\r\n        else {\r\n            this.xy = [x, y];\r\n        }\r\n        this.commands.push(Command.Move);\r\n        this.params.push(x, y);\r\n    }\r\n    lineTo(x, y) {\r\n        if (this.xy) {\r\n            this.commands.push(Command.Line);\r\n            this.params.push(x, y);\r\n            this.xy[0] = x;\r\n            this.xy[1] = y;\r\n        }\r\n        else {\r\n            this.moveTo(x, y);\r\n        }\r\n    }\r\n    rect(x, y, width, height) {\r\n        this.moveTo(x, y);\r\n        this.lineTo(x + width, y);\r\n        this.lineTo(x + width, y + height);\r\n        this.lineTo(x, y + height);\r\n        this.closePath();\r\n    }\r\n    arc(x, y, r, sAngle, eAngle, antiClockwise = false) {\r\n        const endX = x + r * Math.cos(eAngle);\r\n        const endY = y + r * Math.sin(eAngle);\r\n        if (this.xy) {\r\n            this.xy[0] = endX;\r\n            this.xy[1] = endY;\r\n        }\r\n        else {\r\n            this.xy = [endX, endY];\r\n        }\r\n        this.commands.push(Command.Arc);\r\n        this.params.push(x, y, r, sAngle, eAngle, antiClockwise ? 1 : 0);\r\n    }\r\n    cubicCurveTo(cx1, cy1, cx2, cy2, x, y) {\r\n        if (!this.xy) {\r\n            this.moveTo(cx1, cy1);\r\n        }\r\n        this.commands.push(Command.Curve);\r\n        this.params.push(cx1, cy1, cx2, cy2, x, y);\r\n        if (this.xy) {\r\n            this.xy[0] = x;\r\n            this.xy[1] = y;\r\n        }\r\n    }\r\n    get closedPath() {\r\n        return this._closedPath;\r\n    }\r\n    closePath() {\r\n        if (this.xy) {\r\n            this.xy = undefined;\r\n            this.commands.push(Command.ClosePath);\r\n            this._closedPath = true;\r\n        }\r\n    }\r\n    clear({ trackChanges } = { trackChanges: false }) {\r\n        if (trackChanges) {\r\n            this.previousCommands = this.commands;\r\n            this.previousParams = this.params;\r\n            this.previousClosedPath = this._closedPath;\r\n            this.commands = [];\r\n            this.params = [];\r\n        }\r\n        else {\r\n            this.commands.length = 0;\r\n            this.params.length = 0;\r\n        }\r\n        this.xy = undefined;\r\n        this._closedPath = false;\r\n    }\r\n    isPointInPath(x, y) {\r\n        const commands = this.commands;\r\n        const params = this.params;\r\n        const cn = commands.length;\r\n        // Hit testing using ray casting method, where the ray's origin is some point\r\n        // outside the path. In this case, an offscreen point that is remote enough, so that\r\n        // even if the path itself is large and is partially offscreen, the ray's origin\r\n        // will likely be outside the path anyway. To test if the given point is inside the\r\n        // path or not, we cast a ray from the origin to the given point and check the number\r\n        // of intersections of this segment with the path. If the number of intersections is\r\n        // even, then the ray both entered and exited the path an equal number of times,\r\n        // therefore the point is outside the path, and inside the path, if the number of\r\n        // intersections is odd. Since the path is compound, we check if the ray segment\r\n        // intersects with each of the path's segments, which can be either a line segment\r\n        // (one or no intersection points) or a Bézier curve segment (up to 3 intersection\r\n        // points).\r\n        const ox = -10000;\r\n        const oy = -10000;\r\n        // the starting point of the  current path\r\n        let sx = NaN;\r\n        let sy = NaN;\r\n        // the previous point of the current path\r\n        let px = 0;\r\n        let py = 0;\r\n        let intersectionCount = 0;\r\n        for (let ci = 0, pi = 0; ci < cn; ci++) {\r\n            switch (commands[ci]) {\r\n                case Command.Move:\r\n                    if (!isNaN(sx) && segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\r\n                        intersectionCount++;\r\n                    }\r\n                    px = params[pi++];\r\n                    sx = px;\r\n                    py = params[pi++];\r\n                    sy = py;\r\n                    break;\r\n                case Command.Line:\r\n                    if (segmentIntersection(px, py, params[pi++], params[pi++], ox, oy, x, y)) {\r\n                        intersectionCount++;\r\n                    }\r\n                    px = params[pi - 2];\r\n                    py = params[pi - 1];\r\n                    break;\r\n                case Command.Curve:\r\n                    intersectionCount += cubicSegmentIntersections(px, py, params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], params[pi++], ox, oy, x, y).length;\r\n                    px = params[pi - 2];\r\n                    py = params[pi - 1];\r\n                    break;\r\n                case Command.Arc:\r\n                    const cx = params[pi++];\r\n                    const cy = params[pi++];\r\n                    const r = params[pi++];\r\n                    const startAngle = params[pi++];\r\n                    const endAngle = params[pi++];\r\n                    const counterClockwise = Boolean(params[pi++]);\r\n                    intersectionCount += arcIntersections(cx, cy, r, startAngle, endAngle, counterClockwise, ox, oy, x, y).length;\r\n                    px = cx + Math.cos(endAngle) * r;\r\n                    py = cy + Math.sin(endAngle) * r;\r\n                    break;\r\n                case Command.ClosePath:\r\n                    if (!isNaN(sx) && segmentIntersection(sx, sy, px, py, ox, oy, x, y)) {\r\n                        intersectionCount++;\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        return intersectionCount % 2 === 1;\r\n    }\r\n    getPoints() {\r\n        const { commands, params } = this;\r\n        const coords = [];\r\n        let pi = 0;\r\n        for (let ci = 0; ci < commands.length; ci++) {\r\n            switch (commands[ci]) {\r\n                case Command.Move:\r\n                case Command.Line:\r\n                    coords.push({ x: params[pi++], y: params[pi++] });\r\n                    break;\r\n                case Command.Curve:\r\n                    pi += 4;\r\n                    coords.push({ x: params[pi++], y: params[pi++] });\r\n                    break;\r\n                case Command.Arc:\r\n                    coords.push({ x: params[pi++], y: params[pi++] });\r\n                    pi += 4;\r\n                    break;\r\n                case Command.ClosePath:\r\n                    break;\r\n            }\r\n        }\r\n        return coords;\r\n    }\r\n}\n\nfunction ScenePathChangeDetection(opts) {\r\n    const { redraw = RedrawType.MAJOR, changeCb, convertor } = opts !== null && opts !== void 0 ? opts : {};\r\n    return SceneChangeDetection({ redraw, type: 'path', convertor, changeCb });\r\n}\r\nclass Path extends Shape {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * Declare a path to retain for later rendering and hit testing\r\n         * using custom Path2D class. Think of it as a TypeScript version\r\n         * of the native Path2D (with some differences) that works in all browsers.\r\n         */\r\n        this.path = new Path2D();\r\n        this.clipScalingX = 1;\r\n        this.clipScalingY = 1;\r\n        /**\r\n         * The path only has to be updated when certain attributes change.\r\n         * For example, if transform attributes (such as `translationX`)\r\n         * are changed, we don't have to update the path. The `dirtyPath` flag\r\n         * is how we keep track if the path has to be updated or not.\r\n         */\r\n        this._dirtyPath = true;\r\n    }\r\n    set dirtyPath(value) {\r\n        if (this._dirtyPath !== value) {\r\n            this._dirtyPath = value;\r\n            if (value) {\r\n                this.markDirty(this, RedrawType.MAJOR);\r\n            }\r\n        }\r\n    }\r\n    get dirtyPath() {\r\n        return this._dirtyPath;\r\n    }\r\n    checkPathDirty() {\r\n        var _a, _b, _c, _d;\r\n        if (this._dirtyPath) {\r\n            return;\r\n        }\r\n        this.dirtyPath =\r\n            this.path.isDirty() || ((_b = (_a = this.fillShadow) === null || _a === void 0 ? void 0 : _a.isDirty()) !== null && _b !== void 0 ? _b : false) || ((_d = (_c = this.clipPath) === null || _c === void 0 ? void 0 : _c.isDirty()) !== null && _d !== void 0 ? _d : false);\r\n    }\r\n    isPointInPath(x, y) {\r\n        const point = this.transformPoint(x, y);\r\n        return this.path.closedPath && this.path.isPointInPath(point.x, point.y);\r\n    }\r\n    isDirtyPath() {\r\n        // Override point for more expensive dirty checks.\r\n        return false;\r\n    }\r\n    updatePath() {\r\n        // Override point for subclasses.\r\n    }\r\n    clip(ctx, op) {\r\n        const transform = ctx.getTransform();\r\n        const clipScale = this.clipScalingX !== 1 || this.clipScalingY !== 1;\r\n        if (clipScale) {\r\n            ctx.scale(this.clipScalingX, this.clipScalingY);\r\n        }\r\n        op();\r\n        if (clipScale) {\r\n            ctx.setTransform(transform);\r\n        }\r\n    }\r\n    render(renderCtx) {\r\n        var _a;\r\n        const { ctx, forceRender, stats } = renderCtx;\r\n        if (this.dirty === RedrawType.NONE && !forceRender) {\r\n            if (stats)\r\n                stats.nodesSkipped += this.nodeCount.count;\r\n            return;\r\n        }\r\n        this.computeTransformMatrix();\r\n        this.matrix.toContext(ctx);\r\n        if (this.dirtyPath || this.isDirtyPath()) {\r\n            this.updatePath();\r\n            this.dirtyPath = false;\r\n        }\r\n        if (this.clipPath && this.clipMode != null) {\r\n            ctx.save();\r\n            if (this.clipMode === 'normal') {\r\n                this.clip(ctx, () => {\r\n                    var _a;\r\n                    // Bound the shape rendered to the clipping path.\r\n                    (_a = this.clipPath) === null || _a === void 0 ? void 0 : _a.draw(ctx);\r\n                    ctx.clip();\r\n                });\r\n            }\r\n            if (this.clipScalingX > 0 && this.clipScalingY > 0) {\r\n                this.path.draw(ctx);\r\n                this.fillStroke(ctx);\r\n            }\r\n            if (this.clipMode === 'punch-out') {\r\n                this.clip(ctx, () => {\r\n                    var _a, _b;\r\n                    // Bound the shape rendered to the clipping path.\r\n                    (_a = this.clipPath) === null || _a === void 0 ? void 0 : _a.draw(ctx);\r\n                    ctx.clip();\r\n                    // Fallback values, but practically these should never be used.\r\n                    const { x = -10000, y = -10000, width = 20000, height = 20000 } = (_b = this.computeBBox()) !== null && _b !== void 0 ? _b : {};\r\n                    ctx.clearRect(x, y, width, height);\r\n                });\r\n            }\r\n            ctx.restore();\r\n        }\r\n        else {\r\n            this.path.draw(ctx);\r\n            this.fillStroke(ctx);\r\n        }\r\n        (_a = this.fillShadow) === null || _a === void 0 ? void 0 : _a.markClean();\r\n        super.render(renderCtx);\r\n    }\r\n}\r\nPath.className = 'Path';\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Path2D)\r\n], Path.prototype, \"clipPath\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", String)\r\n], Path.prototype, \"clipMode\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Object)\r\n], Path.prototype, \"clipScalingX\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Object)\r\n], Path.prototype, \"clipScalingY\", void 0);\n\nclass Sector extends Path {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.centerX = 0;\r\n        this.centerY = 0;\r\n        this.innerRadius = 10;\r\n        this.outerRadius = 20;\r\n        this.startAngle = 0;\r\n        this.endAngle = Math.PI * 2;\r\n        this.angleOffset = 0;\r\n        this.inset = 0;\r\n    }\r\n    computeBBox() {\r\n        const radius = this.outerRadius;\r\n        return new BBox(this.centerX - radius, this.centerY - radius, radius * 2, radius * 2);\r\n    }\r\n    updatePath() {\r\n        const path = this.path;\r\n        const { angleOffset, inset } = this;\r\n        const startAngle = this.startAngle + angleOffset;\r\n        const endAngle = this.endAngle + angleOffset;\r\n        const fullPie = Math.abs(this.endAngle - this.startAngle) >= 2 * Math.PI;\r\n        const centerX = this.centerX;\r\n        const centerY = this.centerY;\r\n        path.clear();\r\n        if (fullPie) {\r\n            const baseInnerRadius = this.innerRadius <= 0 ? 0 : this.innerRadius + inset;\r\n            const innerRadius = Math.min(baseInnerRadius, this.outerRadius - inset);\r\n            const outerRadius = Math.max(baseInnerRadius, this.outerRadius - inset);\r\n            path.arc(centerX, centerY, outerRadius, startAngle, endAngle);\r\n            if (innerRadius > 0) {\r\n                path.moveTo(centerX + innerRadius * Math.cos(endAngle), centerY + innerRadius * Math.sin(endAngle));\r\n                path.arc(centerX, centerY, innerRadius, endAngle, startAngle, true);\r\n            }\r\n        }\r\n        else {\r\n            const innerRadius = Math.min(this.innerRadius + inset, this.outerRadius - inset);\r\n            const outerRadius = Math.max(this.innerRadius + inset, this.outerRadius - inset);\r\n            const innerAngleOffset = innerRadius > 0 ? inset / innerRadius : 0;\r\n            const outerAngleOffset = outerRadius > 0 ? inset / outerRadius : 0;\r\n            const sweep = Math.abs(endAngle - startAngle);\r\n            const outerAngleExceeded = sweep < 2 * outerAngleOffset;\r\n            if (outerAngleExceeded)\r\n                return;\r\n            const innerAngleExceeded = innerRadius <= inset || sweep < 2 * innerAngleOffset;\r\n            if (innerAngleExceeded) {\r\n                // Draw a wedge on a cartesian co-ordinate with radius `sweep`\r\n                // Inset from bottom - i.e. y = innerRadius\r\n                // Inset the top - i.e. y = (x - x0) * tan(sweep)\r\n                // Form a right angle from the wedge with hypotenuse x0 and an opposite side of innerRadius\r\n                // Gives x0 = inset * sin(sweep)\r\n                // y = inset = (x - inset * sin(sweep)) * tan(sweep) - solve for x\r\n                // This formula has limits (i.e. sweep being >= a quarter turn),\r\n                // but the bounds for x should be [innerRadius, outerRadius)\r\n                const x = Math.abs(sweep) < Math.PI * 0.5 ? (inset * (1 + Math.cos(sweep))) / Math.sin(sweep) : NaN;\r\n                // r = sqrt(x**2 + y**2)\r\n                let r;\r\n                if (x > 0 && x < outerRadius) {\r\n                    // Even within the formula limits, floating point precision isn't always enough,\r\n                    // so ensure we never go less than the inner radius\r\n                    r = Math.max(Math.hypot(inset, x), innerRadius);\r\n                }\r\n                else {\r\n                    // Formula limits exceeded - just use the inner radius\r\n                    r = innerRadius;\r\n                }\r\n                const midAngle = (startAngle + endAngle) * 0.5;\r\n                path.moveTo(centerX + r * Math.cos(midAngle), centerY + r * Math.sin(midAngle));\r\n            }\r\n            else {\r\n                path.moveTo(centerX + innerRadius * Math.cos(startAngle + innerAngleOffset), centerY + innerRadius * Math.sin(startAngle + innerAngleOffset));\r\n            }\r\n            path.arc(centerX, centerY, outerRadius, startAngle + outerAngleOffset, endAngle - outerAngleOffset);\r\n            if (innerAngleExceeded) ;\r\n            else if (innerRadius > 0) {\r\n                path.arc(centerX, centerY, innerRadius, endAngle - innerAngleOffset, startAngle + innerAngleOffset, true);\r\n            }\r\n            else {\r\n                path.lineTo(centerX, centerY);\r\n            }\r\n        }\r\n        path.closePath();\r\n        this.dirtyPath = false;\r\n    }\r\n    isPointInPath(x, y) {\r\n        const { angleOffset } = this;\r\n        const startAngle = this.startAngle + angleOffset;\r\n        const endAngle = this.endAngle + angleOffset;\r\n        const innerRadius = Math.min(this.innerRadius, this.outerRadius);\r\n        const outerRadius = Math.max(this.innerRadius, this.outerRadius);\r\n        const point = this.transformPoint(x, y);\r\n        return isPointInSector(point.x, point.y, { startAngle, endAngle, innerRadius, outerRadius });\r\n    }\r\n}\r\nSector.className = 'Sector';\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Sector.prototype, \"centerX\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Sector.prototype, \"centerY\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Sector.prototype, \"innerRadius\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Sector.prototype, \"outerRadius\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Sector.prototype, \"startAngle\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Sector.prototype, \"endAngle\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Sector.prototype, \"angleOffset\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Sector.prototype, \"inset\", void 0);\n\nfunction deepMerge(target, source) {\r\n    if (isPlainObject(target) && isPlainObject(source)) {\r\n        const result = {};\r\n        Object.keys(target).forEach((key) => {\r\n            if (key in source) {\r\n                result[key] = deepMerge(target[key], source[key]);\r\n            }\r\n            else {\r\n                result[key] = target[key];\r\n            }\r\n        });\r\n        Object.keys(source).forEach((key) => {\r\n            if (!(key in target)) {\r\n                result[key] = source[key];\r\n            }\r\n        });\r\n        return result;\r\n    }\r\n    if ((Array.isArray(target) && !Array.isArray(source)) || (isObjectLike(target) && !isObjectLike(source))) {\r\n        return target;\r\n    }\r\n    return source;\r\n}\r\nfunction isObjectLike(value) {\r\n    return typeof value === 'object' && value !== null;\r\n}\r\nfunction isObject(value) {\r\n    return isObjectLike(value) && !Array.isArray(value);\r\n}\r\nfunction isPlainObject(x) {\r\n    return isObject(x) && x.constructor === Object;\r\n}\r\nfunction mergeDefaults(...sources) {\r\n    var _a;\r\n    const target = {};\r\n    for (const source of sources) {\r\n        if (!source)\r\n            continue;\r\n        const keys = isDecoratedObject(source) ? listDecoratedProperties(source) : Object.keys(source);\r\n        for (const key of keys) {\r\n            if (isObject(target[key]) && isObject(source[key])) {\r\n                target[key] = mergeDefaults(target[key], source[key]);\r\n            }\r\n            else {\r\n                (_a = target[key]) !== null && _a !== void 0 ? _a : (target[key] = source[key]);\r\n            }\r\n        }\r\n    }\r\n    return target;\r\n}\r\n// Similar to Object.assign, but only copy an explicit set of keys.\r\nfunction partialAssign(keysToCopy, target, source) {\r\n    if (source === undefined) {\r\n        return target;\r\n    }\r\n    for (const key of keysToCopy) {\r\n        const value = source[key];\r\n        if (value !== undefined) {\r\n            target[key] = value;\r\n        }\r\n    }\r\n    return target;\r\n}\n\nlet element = null;\r\nfunction sanitizeHtml(text) {\r\n    if (text == null) {\r\n        return undefined;\r\n    }\r\n    else if (text === '') {\r\n        return '';\r\n    }\r\n    element !== null && element !== void 0 ? element : (element = document.createElement('div'));\r\n    element.textContent = String(text);\r\n    return element.innerHTML;\r\n}\n\nconst isString = (v) => typeof v === 'string';\r\nconst isStringObject = (v) => !!v && Object.prototype.hasOwnProperty.call(v, 'toString') && isString(v.toString());\r\nconst isDate = (v) => v instanceof Date && !isNaN(+v);\r\nfunction isDiscrete(value) {\r\n    return isString(value) || isStringObject(value);\r\n}\r\nfunction isContinuous(value) {\r\n    const isNumberObject = (v) => !!v && Object.prototype.hasOwnProperty.call(v, 'valueOf') && isNumber(v.valueOf());\r\n    const isDate = (v) => v instanceof Date && !isNaN(+v);\r\n    return isNumber(value) || isNumberObject(value) || isDate(value);\r\n}\r\nfunction checkDatum(value, isContinuousScale) {\r\n    if (isContinuousScale && isContinuous(value)) {\r\n        return value;\r\n    }\r\n    else if (!isContinuousScale) {\r\n        if (!isDiscrete(value)) {\r\n            return String(value);\r\n        }\r\n        return value;\r\n    }\r\n    return undefined;\r\n}\r\nconst isNumber = (v) => typeof v === 'number' && Number.isFinite(v);\n\nconst memorizedFns = new Map();\r\nfunction memo(params, fnGenerator) {\r\n    var _a, _b, _c;\r\n    const serialisedParams = JSON.stringify(params, null, 0);\r\n    if (!memorizedFns.has(fnGenerator)) {\r\n        memorizedFns.set(fnGenerator, new Map());\r\n    }\r\n    if (!((_a = memorizedFns.get(fnGenerator)) === null || _a === void 0 ? void 0 : _a.has(serialisedParams))) {\r\n        (_b = memorizedFns.get(fnGenerator)) === null || _b === void 0 ? void 0 : _b.set(serialisedParams, fnGenerator(params));\r\n    }\r\n    return (_c = memorizedFns.get(fnGenerator)) === null || _c === void 0 ? void 0 : _c.get(serialisedParams);\r\n}\n\nconst SMALLEST_KEY_INTERVAL = {\r\n    type: 'reducer',\r\n    property: 'smallestKeyInterval',\r\n    initialValue: Infinity,\r\n    reducer: () => {\r\n        let prevX = NaN;\r\n        return (smallestSoFar = Infinity, next) => {\r\n            const nextX = next.keys[0];\r\n            const interval = Math.abs(nextX - prevX);\r\n            prevX = nextX;\r\n            if (!isNaN(interval) && interval > 0 && interval < smallestSoFar) {\r\n                return interval;\r\n            }\r\n            return smallestSoFar;\r\n        };\r\n    },\r\n};\r\nconst AGG_VALUES_EXTENT = {\r\n    type: 'processor',\r\n    property: 'aggValuesExtent',\r\n    calculate: (processedData) => {\r\n        var _a, _b, _c, _d;\r\n        const result = [...((_b = (_a = processedData.domain.aggValues) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : [0, 0])];\r\n        for (const [min, max] of (_d = (_c = processedData.domain.aggValues) === null || _c === void 0 ? void 0 : _c.slice(1)) !== null && _d !== void 0 ? _d : []) {\r\n            if (min < result[0]) {\r\n                result[0] = min;\r\n            }\r\n            if (max > result[1]) {\r\n                result[1] = max;\r\n            }\r\n        }\r\n        return result;\r\n    },\r\n};\r\nconst SORT_DOMAIN_GROUPS = {\r\n    type: 'processor',\r\n    property: 'sortedGroupDomain',\r\n    calculate: ({ domain: { groups } }) => {\r\n        if (groups == null)\r\n            return undefined;\r\n        return [...groups].sort((a, b) => {\r\n            for (let i = 0; i < a.length; i++) {\r\n                const result = a[i] - b[i];\r\n                if (result !== 0) {\r\n                    return result;\r\n                }\r\n            }\r\n            return 0;\r\n        });\r\n    },\r\n};\r\nfunction normaliseFnBuilder({ normaliseTo, mode }) {\r\n    const normalise = (val, extent) => {\r\n        const result = (val * normaliseTo) / extent;\r\n        if (result >= 0) {\r\n            return Math.min(normaliseTo, result);\r\n        }\r\n        return Math.max(-normaliseTo, result);\r\n    };\r\n    return () => () => (values, valueIndexes) => {\r\n        const valuesExtent = [0, 0];\r\n        for (const valueIdx of valueIndexes) {\r\n            const value = values[valueIdx];\r\n            const valIdx = value < 0 ? 0 : 1;\r\n            if (mode === 'sum') {\r\n                valuesExtent[valIdx] += value;\r\n            }\r\n            else if (valIdx === 0) {\r\n                valuesExtent[valIdx] = Math.min(valuesExtent[valIdx], value);\r\n            }\r\n            else {\r\n                valuesExtent[valIdx] = Math.max(valuesExtent[valIdx], value);\r\n            }\r\n        }\r\n        const extent = Math.max(Math.abs(valuesExtent[0]), valuesExtent[1]);\r\n        for (const valueIdx of valueIndexes) {\r\n            values[valueIdx] = normalise(values[valueIdx], extent);\r\n        }\r\n    };\r\n}\r\nfunction normaliseGroupTo(scope, matchGroupIds, normaliseTo, mode = 'sum') {\r\n    return {\r\n        scopes: [scope.id],\r\n        type: 'group-value-processor',\r\n        matchGroupIds,\r\n        adjust: memo({ normaliseTo, mode }, normaliseFnBuilder),\r\n    };\r\n}\r\nfunction normalisePropertyFnBuilder({ normaliseTo, zeroDomain, rangeMin, rangeMax, }) {\r\n    const normaliseSpan = normaliseTo[1] - normaliseTo[0];\r\n    const normalise = (val, start, span) => {\r\n        const result = normaliseTo[0] + ((val - start) / span) * normaliseSpan;\r\n        if (span === 0)\r\n            return zeroDomain;\r\n        if (result >= normaliseTo[1])\r\n            return normaliseTo[1];\r\n        if (result < normaliseTo[0])\r\n            return normaliseTo[0];\r\n        return result;\r\n    };\r\n    return () => (pData, pIdx) => {\r\n        let [start, end] = pData.domain.values[pIdx];\r\n        if (rangeMin != null)\r\n            start = rangeMin;\r\n        if (rangeMax != null)\r\n            end = rangeMax;\r\n        const span = end - start;\r\n        pData.domain.values[pIdx] = [normaliseTo[0], normaliseTo[1]];\r\n        for (const group of pData.data) {\r\n            let groupValues = group.values;\r\n            if (pData.type === 'ungrouped') {\r\n                groupValues = [groupValues];\r\n            }\r\n            for (const values of groupValues) {\r\n                values[pIdx] = normalise(values[pIdx], start, span);\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction normalisePropertyTo(scope, property, normaliseTo, zeroDomain, rangeMin, rangeMax) {\r\n    return {\r\n        scopes: [scope.id],\r\n        type: 'property-value-processor',\r\n        property,\r\n        adjust: memo({ normaliseTo, rangeMin, rangeMax, zeroDomain }, normalisePropertyFnBuilder),\r\n    };\r\n}\r\nfunction animationValidation(scope, valueKeyIds = []) {\r\n    return {\r\n        type: 'processor',\r\n        scopes: [scope.id],\r\n        property: 'animationValidation',\r\n        calculate(result) {\r\n            var _a;\r\n            const { keys, values } = result.defs;\r\n            const { input, data } = result;\r\n            let uniqueKeys = true;\r\n            let orderedKeys = true;\r\n            const valueKeys = [];\r\n            for (let k = 0; k < values.length; k++) {\r\n                if (!((_a = values[k].scopes) === null || _a === void 0 ? void 0 : _a.some((s) => s === scope.id)))\r\n                    continue;\r\n                if (!valueKeyIds.some((v) => values[k].id === v))\r\n                    continue;\r\n                valueKeys.push([k, values[k]]);\r\n            }\r\n            const processKey = (idx, def, type) => {\r\n                var _a;\r\n                if (def.valueType === 'category') {\r\n                    const keyValues = result.domain[type][idx];\r\n                    uniqueKeys && (uniqueKeys = keyValues.length === input.count);\r\n                    return;\r\n                }\r\n                let lastValue = (_a = data[0]) === null || _a === void 0 ? void 0 : _a[type][idx];\r\n                for (let d = 1; (uniqueKeys || orderedKeys) && d < data.length; d++) {\r\n                    const keyValue = data[d][type][idx];\r\n                    orderedKeys && (orderedKeys = lastValue <= keyValue);\r\n                    uniqueKeys && (uniqueKeys = lastValue !== keyValue);\r\n                    lastValue = keyValue;\r\n                }\r\n            };\r\n            for (let k = 0; (uniqueKeys || orderedKeys) && k < keys.length; k++) {\r\n                processKey(k, keys[k], 'keys');\r\n            }\r\n            for (let k = 0; (uniqueKeys || orderedKeys) && k < valueKeys.length; k++) {\r\n                const [idx, key] = valueKeys[k];\r\n                processKey(idx, key, 'values');\r\n            }\r\n            return { uniqueKeys, orderedKeys };\r\n        },\r\n    };\r\n}\r\nfunction buildGroupAccFn({ mode, separateNegative }) {\r\n    return () => () => (values, valueIndexes) => {\r\n        // Datum scope.\r\n        const acc = [0, 0];\r\n        for (const valueIdx of valueIndexes) {\r\n            const currentVal = values[valueIdx];\r\n            const accIndex = isNegative(currentVal) && separateNegative ? 0 : 1;\r\n            if (typeof currentVal !== 'number' || isNaN(currentVal))\r\n                continue;\r\n            if (mode === 'normal')\r\n                acc[accIndex] += currentVal;\r\n            values[valueIdx] = acc[accIndex];\r\n            if (mode === 'trailing')\r\n                acc[accIndex] += currentVal;\r\n        }\r\n    };\r\n}\r\nfunction buildGroupWindowAccFn({ mode, sum }) {\r\n    return () => {\r\n        // Entire data-set scope.\r\n        const lastValues = [];\r\n        let firstRow = true;\r\n        return () => {\r\n            // Group scope.\r\n            return (values, valueIndexes) => {\r\n                // Datum scope.\r\n                let acc = 0;\r\n                for (const valueIdx of valueIndexes) {\r\n                    const currentVal = values[valueIdx];\r\n                    const lastValue = firstRow && sum === 'current' ? 0 : lastValues[valueIdx];\r\n                    lastValues[valueIdx] = currentVal;\r\n                    const sumValue = sum === 'current' ? currentVal : lastValue;\r\n                    if (typeof currentVal !== 'number' || isNaN(currentVal)) {\r\n                        values[valueIdx] = acc;\r\n                        continue;\r\n                    }\r\n                    if (typeof lastValue !== 'number' || isNaN(lastValue)) {\r\n                        values[valueIdx] = acc;\r\n                        continue;\r\n                    }\r\n                    if (mode === 'normal')\r\n                        acc += sumValue;\r\n                    values[valueIdx] = acc;\r\n                    if (mode === 'trailing')\r\n                        acc += sumValue;\r\n                }\r\n                firstRow = false;\r\n            };\r\n        };\r\n    };\r\n}\r\nfunction accumulateGroup(scope, matchGroupId, mode, sum, separateNegative = false) {\r\n    let adjust;\r\n    if (mode.startsWith('window')) {\r\n        const modeParam = mode.endsWith('-trailing') ? 'trailing' : 'normal';\r\n        adjust = memo({ mode: modeParam, sum }, buildGroupWindowAccFn);\r\n    }\r\n    else {\r\n        adjust = memo({ mode: mode, separateNegative }, buildGroupAccFn);\r\n    }\r\n    return {\r\n        scopes: [scope.id],\r\n        type: 'group-value-processor',\r\n        matchGroupIds: [matchGroupId],\r\n        adjust,\r\n    };\r\n}\r\nfunction diff(previousData, updateMovedDatums = true) {\r\n    return {\r\n        type: 'processor',\r\n        property: 'diff',\r\n        calculate: (processedData) => {\r\n            const diff = {\r\n                changed: false,\r\n                moved: [],\r\n                added: [],\r\n                updated: [],\r\n                removed: [],\r\n                addedIndices: [],\r\n                updatedIndices: [],\r\n                removedIndices: [],\r\n            };\r\n            const moved = new Map();\r\n            const added = new Map();\r\n            const updated = new Map();\r\n            const removed = new Map();\r\n            const addedIndices = new Map();\r\n            const updatedIndices = new Map();\r\n            const removedIndices = new Map();\r\n            for (let i = 0; i < Math.max(previousData.data.length, processedData.data.length); i++) {\r\n                const prev = previousData.data[i];\r\n                const datum = processedData.data[i];\r\n                const prevId = prev ? createDatumId(prev.keys) : '';\r\n                const datumId = datum ? createDatumId(datum.keys) : '';\r\n                if (prevId === datumId) {\r\n                    if (!arraysEqual(prev.values, datum.values)) {\r\n                        updated.set(datumId, datum);\r\n                        updatedIndices.set(datumId, i);\r\n                    }\r\n                    continue;\r\n                }\r\n                if (removed.has(datumId)) {\r\n                    if (updateMovedDatums || !arraysEqual(removed.get(datumId).values, datum.values)) {\r\n                        updated.set(datumId, datum);\r\n                        updatedIndices.set(datumId, i);\r\n                        moved.set(datumId, datum);\r\n                    }\r\n                    removed.delete(datumId);\r\n                    removedIndices.delete(datumId);\r\n                }\r\n                else if (datum) {\r\n                    added.set(datumId, datum);\r\n                    addedIndices.set(datumId, i);\r\n                }\r\n                if (added.has(prevId)) {\r\n                    if (updateMovedDatums || !arraysEqual(added.get(prevId).values, prev.values)) {\r\n                        updated.set(prevId, prev);\r\n                        updatedIndices.set(prevId, i);\r\n                        moved.set(prevId, prev);\r\n                    }\r\n                    added.delete(prevId);\r\n                    addedIndices.delete(prevId);\r\n                }\r\n                else if (prev) {\r\n                    updated.delete(prevId);\r\n                    updatedIndices.delete(prevId);\r\n                    removed.set(prevId, prev);\r\n                    removedIndices.set(prevId, i);\r\n                }\r\n            }\r\n            diff.added = Array.from(added.keys());\r\n            diff.updated = Array.from(updated.keys());\r\n            diff.removed = Array.from(removed.keys());\r\n            diff.moved = Array.from(moved.keys());\r\n            diff.addedIndices = Array.from(addedIndices.values());\r\n            diff.updatedIndices = Array.from(updatedIndices.values());\r\n            diff.removedIndices = Array.from(removedIndices.values());\r\n            diff.changed = diff.added.length > 0 || diff.updated.length > 0 || diff.removed.length > 0;\r\n            return diff;\r\n        },\r\n    };\r\n}\r\nfunction createDatumId(keys) {\r\n    return keys.join('___');\r\n}\n\nclass Label {\r\n    constructor() {\r\n        this.enabled = true;\r\n        this.color = '#464646';\r\n        this.fontSize = 12;\r\n        this.fontFamily = 'Verdana, sans-serif';\r\n    }\r\n    getFont() {\r\n        return getFont(this);\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], Label.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    __metadata(\"design:type\", Object)\r\n], Label.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_STYLE),\r\n    __metadata(\"design:type\", String)\r\n], Label.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_WEIGHT),\r\n    __metadata(\"design:type\", String)\r\n], Label.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], Label.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", Object)\r\n], Label.prototype, \"fontFamily\", void 0);\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    __metadata(\"design:type\", Function)\r\n], Label.prototype, \"formatter\", void 0);\r\nfunction calculateLabelRotation(opts) {\r\n    const { parallelFlipRotation = 0, regularFlipRotation = 0 } = opts;\r\n    const configuredRotation = opts.rotation ? normalizeAngle360(toRadians(opts.rotation)) : 0;\r\n    const parallelFlipFlag = !configuredRotation && parallelFlipRotation >= 0 && parallelFlipRotation <= Math.PI ? -1 : 1;\r\n    // Flip if the axis rotation angle is in the top hemisphere.\r\n    const regularFlipFlag = !configuredRotation && regularFlipRotation >= 0 && regularFlipRotation <= Math.PI ? -1 : 1;\r\n    let defaultRotation = 0;\r\n    if (opts.parallel) {\r\n        defaultRotation = (parallelFlipFlag * Math.PI) / 2;\r\n    }\r\n    else if (regularFlipFlag === -1) {\r\n        defaultRotation = Math.PI;\r\n    }\r\n    return { configuredRotation, defaultRotation, parallelFlipFlag, regularFlipFlag };\r\n}\r\nfunction getLabelSpacing(minSpacing, rotated) {\r\n    if (!isNaN(minSpacing)) {\r\n        return minSpacing;\r\n    }\r\n    return rotated ? 0 : 10;\r\n}\r\nfunction getTextBaseline(parallel, labelRotation, sideFlag, parallelFlipFlag) {\r\n    if (parallel && !labelRotation) {\r\n        return sideFlag * parallelFlipFlag === -1 ? 'hanging' : 'bottom';\r\n    }\r\n    return 'middle';\r\n}\r\nfunction getTextAlign(parallel, labelRotation, labelAutoRotation, sideFlag, regularFlipFlag) {\r\n    const labelRotated = labelRotation > 0 && labelRotation <= Math.PI;\r\n    const labelAutoRotated = labelAutoRotation > 0 && labelAutoRotation <= Math.PI;\r\n    const alignFlag = labelRotated || labelAutoRotated ? -1 : 1;\r\n    if (parallel) {\r\n        if (labelRotation || labelAutoRotation) {\r\n            if (sideFlag * alignFlag === -1) {\r\n                return 'end';\r\n            }\r\n        }\r\n        else {\r\n            return 'center';\r\n        }\r\n    }\r\n    else if (sideFlag * regularFlipFlag === -1) {\r\n        return 'end';\r\n    }\r\n    return 'start';\r\n}\r\nfunction calculateLabelBBox(text, bbox, labelX, labelY, labelMatrix) {\r\n    // Text.computeBBox() does not take into account any of the transformations that have been applied to the label nodes, only the width and height are useful.\r\n    // Rather than taking into account all transformations including those of parent nodes which would be the result of `computeTransformedBBox()`, giving the x and y in the entire axis coordinate space,\r\n    // take into account only the rotation and translation applied to individual label nodes to get the x y coordinates of the labels relative to each other\r\n    // this makes label collision detection a lot simpler\r\n    const { width, height } = bbox;\r\n    const translatedBBox = new BBox(labelX, labelY, 0, 0);\r\n    labelMatrix.transformBBox(translatedBBox, bbox);\r\n    const { x = 0, y = 0 } = bbox;\r\n    bbox.width = width;\r\n    bbox.height = height;\r\n    return {\r\n        point: { x, y, size: 0 },\r\n        label: { width, height, text },\r\n    };\r\n}\n\n/**\r\n * Constants to declare the expected nominal zIndex for all types of layer in chart rendering.\r\n */\r\nvar Layers;\r\n(function (Layers) {\r\n    Layers[Layers[\"SERIES_BACKGROUND_ZINDEX\"] = -10] = \"SERIES_BACKGROUND_ZINDEX\";\r\n    Layers[Layers[\"AXIS_GRID_ZINDEX\"] = 0] = \"AXIS_GRID_ZINDEX\";\r\n    Layers[Layers[\"AXIS_ZINDEX\"] = 20] = \"AXIS_ZINDEX\";\r\n    Layers[Layers[\"SERIES_CROSSLINE_RANGE_ZINDEX\"] = 30] = \"SERIES_CROSSLINE_RANGE_ZINDEX\";\r\n    Layers[Layers[\"SERIES_LAYER_ZINDEX\"] = 500] = \"SERIES_LAYER_ZINDEX\";\r\n    Layers[Layers[\"AXIS_FOREGROUND_ZINDEX\"] = 750] = \"AXIS_FOREGROUND_ZINDEX\";\r\n    Layers[Layers[\"SERIES_CROSSHAIR_ZINDEX\"] = 1000] = \"SERIES_CROSSHAIR_ZINDEX\";\r\n    Layers[Layers[\"SERIES_LABEL_ZINDEX\"] = 1500] = \"SERIES_LABEL_ZINDEX\";\r\n    Layers[Layers[\"SERIES_CROSSLINE_LINE_ZINDEX\"] = 2500] = \"SERIES_CROSSLINE_LINE_ZINDEX\";\r\n    Layers[Layers[\"LEGEND_ZINDEX\"] = 3000] = \"LEGEND_ZINDEX\";\r\n})(Layers || (Layers = {}));\n\nclass Marker extends Path {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.size = 12;\r\n    }\r\n    computeBBox() {\r\n        const { x, y, size } = this;\r\n        const half = size / 2;\r\n        return new BBox(x - half, y - half, size, size);\r\n    }\r\n    applyPath(s, moves) {\r\n        const { path } = this;\r\n        let { x, y } = this;\r\n        path.clear();\r\n        for (const { x: mx, y: my, t } of moves) {\r\n            x += mx * s;\r\n            y += my * s;\r\n            if (t === 'move') {\r\n                path.moveTo(x, y);\r\n            }\r\n            else {\r\n                path.lineTo(x, y);\r\n            }\r\n        }\r\n        path.closePath();\r\n    }\r\n}\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Marker.prototype, \"x\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Marker.prototype, \"y\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection({ convertor: Math.abs }),\r\n    __metadata(\"design:type\", Number)\r\n], Marker.prototype, \"size\", void 0);\n\nclass Circle extends Marker {\r\n    updatePath() {\r\n        const { x, y, path, size } = this;\r\n        const r = size / 2;\r\n        path.clear();\r\n        path.arc(x, y, r, 0, Math.PI * 2);\r\n        path.closePath();\r\n    }\r\n}\r\nCircle.className = 'Circle';\n\nconst DEFAULT_FILLS = {\r\n    BLUE: '#5090dc',\r\n    ORANGE: '#ffa03a',\r\n    GREEN: '#459d55',\r\n    CYAN: '#34bfe1',\r\n    YELLOW: '#e1cc00',\r\n    VIOLET: '#9669cb',\r\n    GRAY: '#b5b5b5',\r\n    MAGENTA: '#bd5aa7',\r\n    BROWN: '#8a6224',\r\n    RED: '#ef5452',\r\n};\r\nconst DEFAULT_STROKES = {\r\n    BLUE: '#2b5c95',\r\n    ORANGE: '#cc6f10',\r\n    GREEN: '#1e652e',\r\n    CYAN: '#18859e',\r\n    YELLOW: '#a69400',\r\n    VIOLET: '#603c88',\r\n    GRAY: '#575757',\r\n    MAGENTA: '#7d2f6d',\r\n    BROWN: '#4f3508',\r\n    RED: '#a82529',\r\n};\n\nclass ModuleMap {\r\n    constructor(parent) {\r\n        this.modules = {};\r\n        this.parent = parent;\r\n    }\r\n    destroy() {\r\n        for (const [key, module] of Object.entries(this.modules)) {\r\n            module.instance.destroy();\r\n            delete this.modules[key];\r\n            delete this.parent[key];\r\n        }\r\n    }\r\n    addModule(module) {\r\n        if (this.modules[module.optionsKey] != null) {\r\n            throw new Error('AG Charts - module already initialised: ' + module.optionsKey);\r\n        }\r\n        if (module.optionsKey in this.parent) {\r\n            throw new Error(`AG Charts - class already has option key '${module.optionsKey}'`);\r\n        }\r\n        if (this.moduleContext == null) {\r\n            this.moduleContext = this.parent.createModuleContext();\r\n        }\r\n        const moduleInstance = new module.instanceConstructor(Object.assign({}, this.moduleContext));\r\n        this.modules[module.optionsKey] = { instance: moduleInstance };\r\n        this.parent[module.optionsKey] = moduleInstance;\r\n    }\r\n    removeModule(module) {\r\n        var _a, _b;\r\n        (_b = (_a = this.modules[module.optionsKey]) === null || _a === void 0 ? void 0 : _a.instance) === null || _b === void 0 ? void 0 : _b.destroy();\r\n        delete this.modules[module.optionsKey];\r\n        delete this.parent[module.optionsKey];\r\n    }\r\n    isModuleEnabled(module) {\r\n        return this.modules[module.optionsKey] != null;\r\n    }\r\n    *[Symbol.iterator]() {\r\n        for (const { instance } of Object.values(this.modules)) {\r\n            yield instance;\r\n        }\r\n    }\r\n}\n\nclass Listeners {\r\n    constructor() {\r\n        this.registeredListeners = new Map();\r\n    }\r\n    addListener(eventType, handler, meta) {\r\n        const record = { symbol: Symbol(eventType), handler, meta };\r\n        if (this.registeredListeners.has(eventType)) {\r\n            this.registeredListeners.get(eventType).push(record);\r\n        }\r\n        else {\r\n            this.registeredListeners.set(eventType, [record]);\r\n        }\r\n        return () => this.removeListener(record.symbol);\r\n    }\r\n    removeListener(eventSymbol) {\r\n        for (const [type, listeners] of this.registeredListeners.entries()) {\r\n            const matchIndex = listeners.findIndex((listener) => listener.symbol === eventSymbol);\r\n            if (matchIndex >= 0) {\r\n                listeners.splice(matchIndex, 1);\r\n                if (listeners.length === 0) {\r\n                    this.registeredListeners.delete(type);\r\n                }\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    dispatch(eventType, ...params) {\r\n        // This is a utility class to store all the results of Listeners (or do nothing\r\n        // if R = void).\r\n        class ResultArray {\r\n            constructor() {\r\n                this.results = undefined;\r\n            }\r\n            push(result) {\r\n                var _a;\r\n                if (result === undefined)\r\n                    return;\r\n                (_a = this.results) !== null && _a !== void 0 ? _a : (this.results = []);\r\n                this.results.push(result);\r\n            }\r\n        }\r\n        const results = new ResultArray();\r\n        for (const listener of this.getListenersByType(eventType)) {\r\n            try {\r\n                results.push(listener.handler(...params));\r\n            }\r\n            catch (e) {\r\n                Logger.errorOnce(e);\r\n            }\r\n        }\r\n        return results.results;\r\n    }\r\n    dispatchWrapHandlers(eventType, wrapFn, ...params) {\r\n        for (const listener of this.getListenersByType(eventType)) {\r\n            try {\r\n                wrapFn(listener.handler, listener.meta, ...params);\r\n            }\r\n            catch (e) {\r\n                Logger.errorOnce(e);\r\n            }\r\n        }\r\n    }\r\n    getListenersByType(eventType) {\r\n        var _a;\r\n        return (_a = this.registeredListeners.get(eventType)) !== null && _a !== void 0 ? _a : [];\r\n    }\r\n}\n\nclass Observable {\r\n    constructor() {\r\n        this.eventListeners = new Map();\r\n    }\r\n    addEventListener(eventType, listener) {\r\n        if (typeof listener !== 'function') {\r\n            throw new Error('AG Charts - listener must be a Function');\r\n        }\r\n        const eventTypeListeners = this.eventListeners.get(eventType);\r\n        if (eventTypeListeners) {\r\n            eventTypeListeners.add(listener);\r\n        }\r\n        else {\r\n            this.eventListeners.set(eventType, new Set([listener]));\r\n        }\r\n    }\r\n    removeEventListener(type, listener) {\r\n        var _a;\r\n        (_a = this.eventListeners.get(type)) === null || _a === void 0 ? void 0 : _a.delete(listener);\r\n        if (this.eventListeners.size === 0) {\r\n            this.eventListeners.delete(type);\r\n        }\r\n    }\r\n    hasEventListener(type) {\r\n        return this.eventListeners.has(type);\r\n    }\r\n    clearEventListeners() {\r\n        this.eventListeners.clear();\r\n    }\r\n    fireEvent(event) {\r\n        var _a;\r\n        (_a = this.eventListeners.get(event.type)) === null || _a === void 0 ? void 0 : _a.forEach((listener) => listener(event));\r\n    }\r\n}\n\nfunction extendDomain(values, domain = [Infinity, -Infinity]) {\r\n    for (const value of values) {\r\n        if (typeof value !== 'number') {\r\n            continue;\r\n        }\r\n        if (value < domain[0]) {\r\n            domain[0] = value;\r\n        }\r\n        if (value > domain[1]) {\r\n            domain[1] = value;\r\n        }\r\n    }\r\n    return domain;\r\n}\n\nfunction sumValues(values, accumulator = [0, 0]) {\r\n    for (const value of values) {\r\n        if (typeof value !== 'number') {\r\n            continue;\r\n        }\r\n        if (value < 0) {\r\n            accumulator[0] += value;\r\n        }\r\n        if (value > 0) {\r\n            accumulator[1] += value;\r\n        }\r\n    }\r\n    return accumulator;\r\n}\r\nfunction sum(scope, id, matchGroupId) {\r\n    const result = {\r\n        id,\r\n        scopes: [scope.id],\r\n        matchGroupIds: [matchGroupId],\r\n        type: 'aggregate',\r\n        aggregateFunction: (values) => sumValues(values),\r\n    };\r\n    return result;\r\n}\r\nfunction groupSum(scope, id, matchGroupId) {\r\n    return {\r\n        id,\r\n        scopes: [scope.id],\r\n        type: 'aggregate',\r\n        matchGroupIds: matchGroupId ? [matchGroupId] : undefined,\r\n        aggregateFunction: (values) => sumValues(values),\r\n        groupAggregateFunction: (next, acc = [0, 0]) => {\r\n            var _a, _b;\r\n            acc[0] += (_a = next === null || next === void 0 ? void 0 : next[0]) !== null && _a !== void 0 ? _a : 0;\r\n            acc[1] += (_b = next === null || next === void 0 ? void 0 : next[1]) !== null && _b !== void 0 ? _b : 0;\r\n            return acc;\r\n        },\r\n    };\r\n}\r\nfunction range(scope, id, matchGroupId) {\r\n    const result = {\r\n        id,\r\n        scopes: [scope.id],\r\n        matchGroupIds: [matchGroupId],\r\n        type: 'aggregate',\r\n        aggregateFunction: (values) => extendDomain(values),\r\n    };\r\n    return result;\r\n}\r\nfunction count(scope, id) {\r\n    const result = {\r\n        id,\r\n        scopes: [scope.id],\r\n        type: 'aggregate',\r\n        aggregateFunction: () => [0, 1],\r\n    };\r\n    return result;\r\n}\r\nfunction groupCount(scope, id) {\r\n    return {\r\n        id,\r\n        scopes: [scope.id],\r\n        type: 'aggregate',\r\n        aggregateFunction: () => [0, 1],\r\n        groupAggregateFunction: (next, acc = [0, 0]) => {\r\n            var _a, _b;\r\n            acc[0] += (_a = next === null || next === void 0 ? void 0 : next[0]) !== null && _a !== void 0 ? _a : 0;\r\n            acc[1] += (_b = next === null || next === void 0 ? void 0 : next[1]) !== null && _b !== void 0 ? _b : 0;\r\n            return acc;\r\n        },\r\n    };\r\n}\r\nfunction average(scope, id, matchGroupId) {\r\n    const result = {\r\n        id,\r\n        scopes: [scope.id],\r\n        matchGroupIds: [matchGroupId],\r\n        type: 'aggregate',\r\n        aggregateFunction: (values) => sumValues(values).map((v) => v / values.length),\r\n    };\r\n    return result;\r\n}\r\nfunction groupAverage(scope, id, matchGroupId) {\r\n    const result = {\r\n        id,\r\n        scopes: [scope.id],\r\n        matchGroupIds: matchGroupId ? [matchGroupId] : undefined,\r\n        type: 'aggregate',\r\n        aggregateFunction: (values) => sumValues(values),\r\n        groupAggregateFunction: (next, acc = [0, 0, -1]) => {\r\n            var _a, _b;\r\n            acc[0] += (_a = next === null || next === void 0 ? void 0 : next[0]) !== null && _a !== void 0 ? _a : 0;\r\n            acc[1] += (_b = next === null || next === void 0 ? void 0 : next[1]) !== null && _b !== void 0 ? _b : 0;\r\n            acc[2]++;\r\n            return acc;\r\n        },\r\n        finalFunction: (acc = [0, 0, 0]) => {\r\n            const result = acc[0] + acc[1];\r\n            if (result >= 0) {\r\n                return [0, result / acc[2]];\r\n            }\r\n            return [result / acc[2], 0];\r\n        },\r\n    };\r\n    return result;\r\n}\r\nfunction area(scope, id, aggFn, matchGroupId) {\r\n    const result = {\r\n        id,\r\n        scopes: [scope.id],\r\n        matchGroupIds: matchGroupId ? [matchGroupId] : undefined,\r\n        type: 'aggregate',\r\n        aggregateFunction: (values, keyRange = []) => {\r\n            const keyWidth = keyRange[1] - keyRange[0];\r\n            return aggFn.aggregateFunction(values).map((v) => v / keyWidth);\r\n        },\r\n    };\r\n    if (aggFn.groupAggregateFunction) {\r\n        result.groupAggregateFunction = aggFn.groupAggregateFunction;\r\n    }\r\n    return result;\r\n}\r\nfunction accumulatedValue(onlyPositive) {\r\n    return () => {\r\n        let value = 0;\r\n        return (datum) => {\r\n            if (typeof datum !== 'number')\r\n                return datum;\r\n            if (isNaN(datum))\r\n                return datum;\r\n            value += onlyPositive ? Math.max(0, datum) : datum;\r\n            return value;\r\n        };\r\n    };\r\n}\r\nfunction trailingAccumulatedValue() {\r\n    return () => {\r\n        let value = 0;\r\n        return (datum) => {\r\n            if (typeof datum !== 'number')\r\n                return datum;\r\n            if (isNaN(datum))\r\n                return datum;\r\n            const trailingValue = value;\r\n            value += datum;\r\n            return trailingValue;\r\n        };\r\n    };\r\n}\n\n/** Modes of matching user interactions to rendered nodes (e.g. hover or click) */\r\nvar SeriesNodePickMode;\r\n(function (SeriesNodePickMode) {\r\n    /** Pick matches based upon pick coordinates being inside a matching shape/marker. */\r\n    SeriesNodePickMode[SeriesNodePickMode[\"EXACT_SHAPE_MATCH\"] = 0] = \"EXACT_SHAPE_MATCH\";\r\n    /** Pick matches by nearest category/X-axis value, then distance within that category/X-value. */\r\n    SeriesNodePickMode[SeriesNodePickMode[\"NEAREST_BY_MAIN_AXIS_FIRST\"] = 1] = \"NEAREST_BY_MAIN_AXIS_FIRST\";\r\n    /** Pick matches by nearest category value, then distance within that category. */\r\n    SeriesNodePickMode[SeriesNodePickMode[\"NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST\"] = 2] = \"NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST\";\r\n    /** Pick matches based upon distance to ideal position */\r\n    SeriesNodePickMode[SeriesNodePickMode[\"NEAREST_NODE\"] = 3] = \"NEAREST_NODE\";\r\n})(SeriesNodePickMode || (SeriesNodePickMode = {}));\r\nfunction basicContinuousCheckDatumValidation(v) {\r\n    return checkDatum(v, true) != null;\r\n}\r\nfunction basicDiscreteCheckDatumValidation(v) {\r\n    return checkDatum(v, false) != null;\r\n}\r\nfunction keyProperty(scope, propName, continuous, opts = {}) {\r\n    const result = Object.assign({ scopes: [scope.id], property: propName, type: 'key', valueType: continuous ? 'range' : 'category', validation: continuous ? basicContinuousCheckDatumValidation : basicDiscreteCheckDatumValidation }, opts);\r\n    return result;\r\n}\r\nfunction valueProperty(scope, propName, continuous, opts = {}) {\r\n    const result = Object.assign({ scopes: [scope.id], property: propName, type: 'value', valueType: continuous ? 'range' : 'category', validation: continuous ? basicContinuousCheckDatumValidation : basicDiscreteCheckDatumValidation }, opts);\r\n    return result;\r\n}\r\nfunction rangedValueProperty(scope, propName, opts = {}) {\r\n    const { min = -Infinity, max = Infinity } = opts, defOpts = __rest(opts, [\"min\", \"max\"]);\r\n    return Object.assign({ scopes: [scope.id], type: 'value', property: propName, valueType: 'range', validation: basicContinuousCheckDatumValidation, processor: () => (datum) => {\r\n            if (typeof datum !== 'number')\r\n                return datum;\r\n            if (isNaN(datum))\r\n                return datum;\r\n            return Math.min(Math.max(datum, min), max);\r\n        } }, defOpts);\r\n}\r\nfunction trailingValueProperty(scope, propName, continuous, opts = {}) {\r\n    const result = Object.assign(Object.assign({}, valueProperty(scope, propName, continuous, opts)), { processor: trailingValue() });\r\n    return result;\r\n}\r\nfunction trailingValue() {\r\n    return () => {\r\n        let value = 0;\r\n        return (datum) => {\r\n            const trailingValue = value;\r\n            value = datum;\r\n            return trailingValue;\r\n        };\r\n    };\r\n}\r\nfunction accumulativeValueProperty(scope, propName, continuous, opts = {}) {\r\n    const { onlyPositive } = opts, defOpts = __rest(opts, [\"onlyPositive\"]);\r\n    const result = Object.assign(Object.assign({}, valueProperty(scope, propName, continuous, defOpts)), { processor: accumulatedValue(onlyPositive) });\r\n    return result;\r\n}\r\nfunction trailingAccumulatedValueProperty(scope, propName, continuous, opts = {}) {\r\n    const result = Object.assign(Object.assign({}, valueProperty(scope, propName, continuous, opts)), { processor: trailingAccumulatedValue() });\r\n    return result;\r\n}\r\nfunction groupAccumulativeValueProperty(scope, propName, continuous, mode, sum = 'current', opts) {\r\n    return [\r\n        valueProperty(scope, propName, continuous, opts),\r\n        accumulateGroup(scope, opts.groupId, mode, sum, opts.separateNegative),\r\n    ];\r\n}\r\nclass SeriesNodeClickEvent {\r\n    constructor(type, event, { datum }, series) {\r\n        this.type = type;\r\n        this.event = event;\r\n        this.datum = datum;\r\n        this.seriesId = series.id;\r\n    }\r\n}\r\nclass SeriesItemHighlightStyle {\r\n    constructor() {\r\n        this.fill = 'yellow';\r\n        this.fillOpacity = undefined;\r\n        this.stroke = undefined;\r\n        this.strokeWidth = undefined;\r\n        this.strokeOpacity = undefined;\r\n        this.lineDash = undefined;\r\n        this.lineDashOffset = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], SeriesItemHighlightStyle.prototype, \"fill\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesItemHighlightStyle.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], SeriesItemHighlightStyle.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesItemHighlightStyle.prototype, \"strokeWidth\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesItemHighlightStyle.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_LINE_DASH),\r\n    __metadata(\"design:type\", Array)\r\n], SeriesItemHighlightStyle.prototype, \"lineDash\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesItemHighlightStyle.prototype, \"lineDashOffset\", void 0);\r\nclass SeriesHighlightStyle {\r\n    constructor() {\r\n        this.strokeWidth = undefined;\r\n        this.dimOpacity = undefined;\r\n        this.enabled = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesHighlightStyle.prototype, \"strokeWidth\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesHighlightStyle.prototype, \"dimOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], SeriesHighlightStyle.prototype, \"enabled\", void 0);\r\nclass TextHighlightStyle {\r\n    constructor() {\r\n        this.color = 'black';\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], TextHighlightStyle.prototype, \"color\", void 0);\r\nclass HighlightStyle {\r\n    constructor() {\r\n        this.item = new SeriesItemHighlightStyle();\r\n        this.series = new SeriesHighlightStyle();\r\n        this.text = new TextHighlightStyle();\r\n    }\r\n}\r\nvar SeriesHighlight;\r\n(function (SeriesHighlight) {\r\n    SeriesHighlight[SeriesHighlight[\"None\"] = 0] = \"None\";\r\n    SeriesHighlight[SeriesHighlight[\"This\"] = 1] = \"This\";\r\n    SeriesHighlight[SeriesHighlight[\"Other\"] = 2] = \"Other\";\r\n})(SeriesHighlight || (SeriesHighlight = {}));\r\nclass Series extends Observable {\r\n    get type() {\r\n        var _a;\r\n        return (_a = this.constructor.type) !== null && _a !== void 0 ? _a : '';\r\n    }\r\n    set data(input) {\r\n        this._data = input;\r\n        this.onDataChange();\r\n    }\r\n    get data() {\r\n        var _a;\r\n        return (_a = this._data) !== null && _a !== void 0 ? _a : this._chartData;\r\n    }\r\n    onDataChange() {\r\n        this.nodeDataRefresh = true;\r\n    }\r\n    setChartData(input) {\r\n        this._chartData = input;\r\n        if (this.data === input) {\r\n            this.onDataChange();\r\n        }\r\n    }\r\n    hasData() {\r\n        const { data } = this;\r\n        return data && (!Array.isArray(data) || data.length > 0);\r\n    }\r\n    set visible(value) {\r\n        this._visible = value;\r\n        this.visibleChanged();\r\n    }\r\n    get visible() {\r\n        return this._visible;\r\n    }\r\n    onSeriesGroupingChange(prev, next) {\r\n        const { id, type, visible, rootGroup, highlightGroup, annotationGroup } = this;\r\n        if (prev) {\r\n            this.ctx.seriesStateManager.deregisterSeries({ id, type });\r\n        }\r\n        if (next) {\r\n            this.ctx.seriesStateManager.registerSeries({ id, type, visible, seriesGrouping: next });\r\n        }\r\n        // Short-circuit if series isn't already attached to the scene-graph yet.\r\n        if (this.rootGroup.parent == null)\r\n            return;\r\n        this.ctx.seriesLayerManager.changeGroup({\r\n            id,\r\n            type,\r\n            rootGroup,\r\n            highlightGroup,\r\n            annotationGroup,\r\n            getGroupZIndexSubOrder: (type) => this.getGroupZIndexSubOrder(type),\r\n            seriesGrouping: next,\r\n            oldGrouping: prev,\r\n        });\r\n    }\r\n    getBandScalePadding() {\r\n        return { inner: 1, outer: 0 };\r\n    }\r\n    constructor(seriesOpts) {\r\n        super();\r\n        this.NodeClickEvent = SeriesNodeClickEvent;\r\n        this.id = createId(this);\r\n        // The group node that contains all the nodes used to render this series.\r\n        this.rootGroup = new Group({ name: 'seriesRoot', isVirtual: true });\r\n        this.axes = {\r\n            [ChartAxisDirection.X]: undefined,\r\n            [ChartAxisDirection.Y]: undefined,\r\n        };\r\n        this.directions = [ChartAxisDirection.X, ChartAxisDirection.Y];\r\n        // Flag to determine if we should recalculate node data.\r\n        this.nodeDataRefresh = true;\r\n        this._visible = true;\r\n        this.showInLegend = true;\r\n        this.cursor = 'default';\r\n        this.nodeClickRange = 'exact';\r\n        this.seriesGrouping = undefined;\r\n        this._declarationOrder = -1;\r\n        this.seriesListeners = new Listeners();\r\n        this.highlightStyle = new HighlightStyle();\r\n        this.moduleMap = new ModuleMap(this);\r\n        this.nodeDataDependencies = {};\r\n        this.ctx = seriesOpts.moduleCtx;\r\n        const { useLabelLayer = false, pickModes = [SeriesNodePickMode.NEAREST_BY_MAIN_AXIS_FIRST], directionKeys = {}, directionNames = {}, contentGroupVirtual = true, canHaveAxes = false, } = seriesOpts;\r\n        this.directionKeys = directionKeys;\r\n        this.directionNames = directionNames;\r\n        this.canHaveAxes = canHaveAxes;\r\n        this.contentGroup = this.rootGroup.appendChild(new Group({\r\n            name: `${this.id}-content`,\r\n            layer: !contentGroupVirtual,\r\n            isVirtual: contentGroupVirtual,\r\n            zIndex: Layers.SERIES_LAYER_ZINDEX,\r\n            zIndexSubOrder: this.getGroupZIndexSubOrder('data'),\r\n        }));\r\n        this.highlightGroup = new Group({\r\n            name: `${this.id}-highlight`,\r\n            layer: !contentGroupVirtual,\r\n            isVirtual: contentGroupVirtual,\r\n            zIndex: Layers.SERIES_LAYER_ZINDEX,\r\n            zIndexSubOrder: this.getGroupZIndexSubOrder('highlight'),\r\n        });\r\n        this.highlightNode = this.highlightGroup.appendChild(new Group({ name: 'highlightNode', zIndex: 0 }));\r\n        this.highlightLabel = this.highlightGroup.appendChild(new Group({ name: 'highlightLabel', zIndex: 10 }));\r\n        this.pickModes = pickModes;\r\n        this.labelGroup = this.rootGroup.appendChild(new Group({\r\n            name: `${this.id}-series-labels`,\r\n            layer: useLabelLayer,\r\n            zIndex: Layers.SERIES_LABEL_ZINDEX,\r\n        }));\r\n        this.annotationGroup = new Group({\r\n            name: `${this.id}-annotation`,\r\n            layer: !contentGroupVirtual,\r\n            isVirtual: contentGroupVirtual,\r\n            zIndex: Layers.SERIES_LAYER_ZINDEX,\r\n            zIndexSubOrder: this.getGroupZIndexSubOrder('annotation'),\r\n        });\r\n    }\r\n    getGroupZIndexSubOrder(type, subIndex = 0) {\r\n        let mainAdjust = 0;\r\n        switch (type) {\r\n            case 'data':\r\n            case 'paths':\r\n                break;\r\n            case 'labels':\r\n                mainAdjust += 20000;\r\n                break;\r\n            case 'marker':\r\n                mainAdjust += 10000;\r\n                break;\r\n            // Following cases are in their own layer, so need to be careful to respect declarationOrder.\r\n            case 'highlight':\r\n                subIndex += 15000;\r\n                break;\r\n            case 'annotation':\r\n                mainAdjust += 15000;\r\n                break;\r\n        }\r\n        const main = () => this._declarationOrder + mainAdjust;\r\n        return [main, subIndex];\r\n    }\r\n    addListener(type, listener) {\r\n        return this.seriesListeners.addListener(type, listener);\r\n    }\r\n    dispatch(type, event) {\r\n        return this.seriesListeners.dispatch(type, event);\r\n    }\r\n    addChartEventListeners() {\r\n        return;\r\n    }\r\n    destroy() {\r\n        this.ctx.seriesStateManager.deregisterSeries(this);\r\n        this.ctx.seriesLayerManager.releaseGroup(this);\r\n    }\r\n    getDirectionValues(direction, properties) {\r\n        const resolvedDirection = this.resolveKeyDirection(direction);\r\n        const keys = properties === null || properties === void 0 ? void 0 : properties[resolvedDirection];\r\n        const values = [];\r\n        if (!keys)\r\n            return values;\r\n        const addValues = (...items) => {\r\n            for (const value of items) {\r\n                if (Array.isArray(value)) {\r\n                    addValues(...value);\r\n                }\r\n                else if (typeof value === 'object') {\r\n                    addValues(...Object.values(value));\r\n                }\r\n                else {\r\n                    values.push(value);\r\n                }\r\n            }\r\n        };\r\n        addValues(...keys.map((key) => this[key]));\r\n        return values;\r\n    }\r\n    getKeys(direction) {\r\n        return this.getDirectionValues(direction, this.directionKeys);\r\n    }\r\n    getNames(direction) {\r\n        return this.getDirectionValues(direction, this.directionNames);\r\n    }\r\n    resolveKeyDirection(direction) {\r\n        return direction;\r\n    }\r\n    // The union of the series domain ('community') and series-option domains ('enterprise').\r\n    getDomain(direction) {\r\n        var _a;\r\n        const seriesDomain = this.getSeriesDomain(direction);\r\n        const moduleDomains = (_a = this.dispatch('data-getDomain', { direction })) !== null && _a !== void 0 ? _a : [];\r\n        // Flatten the 2D moduleDomains into a 1D array and concatenate it with seriesDomain\r\n        return moduleDomains.reduce((total, current) => total.concat(current), seriesDomain);\r\n    }\r\n    // Indicate that something external changed and we should recalculate nodeData.\r\n    markNodeDataDirty() {\r\n        this.nodeDataRefresh = true;\r\n    }\r\n    visibleChanged() {\r\n        this.ctx.seriesStateManager.registerSeries(this);\r\n    }\r\n    getOpacity() {\r\n        const defaultOpacity = 1;\r\n        const { dimOpacity = 1, enabled = true } = this.highlightStyle.series;\r\n        if (!enabled || dimOpacity === defaultOpacity) {\r\n            return defaultOpacity;\r\n        }\r\n        switch (this.isItemIdHighlighted()) {\r\n            case SeriesHighlight.None:\r\n            case SeriesHighlight.This:\r\n                return defaultOpacity;\r\n            case SeriesHighlight.Other:\r\n            default:\r\n                return dimOpacity;\r\n        }\r\n    }\r\n    getStrokeWidth(defaultStrokeWidth) {\r\n        const { strokeWidth, enabled = true } = this.highlightStyle.series;\r\n        if (!enabled || strokeWidth === undefined) {\r\n            // No change in styling for highlight cases.\r\n            return defaultStrokeWidth;\r\n        }\r\n        switch (this.isItemIdHighlighted()) {\r\n            case SeriesHighlight.This:\r\n                return strokeWidth;\r\n            case SeriesHighlight.None:\r\n            case SeriesHighlight.Other:\r\n                return defaultStrokeWidth;\r\n        }\r\n    }\r\n    isItemIdHighlighted() {\r\n        var _a, _b;\r\n        const { series } = (_b = (_a = this.ctx.highlightManager) === null || _a === void 0 ? void 0 : _a.getActiveHighlight()) !== null && _b !== void 0 ? _b : {};\r\n        // Highlighting not active.\r\n        if (series == null) {\r\n            return SeriesHighlight.None;\r\n        }\r\n        // Highlighting active, this series not highlighted.\r\n        if (series !== this) {\r\n            return SeriesHighlight.Other;\r\n        }\r\n        return SeriesHighlight.This;\r\n    }\r\n    getModuleTooltipParams(datum) {\r\n        var _a;\r\n        const params = (_a = this.dispatch('tooltip-getParams', { datum })) !== null && _a !== void 0 ? _a : [];\r\n        return params.reduce((total, current) => {\r\n            return Object.assign(Object.assign({}, current), total);\r\n        }, {});\r\n    }\r\n    pickNode(point, limitPickModes) {\r\n        const { pickModes, visible, rootGroup } = this;\r\n        if (!visible || !rootGroup.visible) {\r\n            return;\r\n        }\r\n        for (const pickMode of pickModes) {\r\n            if (limitPickModes && !limitPickModes.includes(pickMode)) {\r\n                continue;\r\n            }\r\n            let match;\r\n            switch (pickMode) {\r\n                case SeriesNodePickMode.EXACT_SHAPE_MATCH:\r\n                    match = this.pickNodeExactShape(point);\r\n                    break;\r\n                case SeriesNodePickMode.NEAREST_BY_MAIN_AXIS_FIRST:\r\n                case SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST:\r\n                    match = this.pickNodeMainAxisFirst(point, pickMode === SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST);\r\n                    break;\r\n                case SeriesNodePickMode.NEAREST_NODE:\r\n                    match = this.pickNodeClosestDatum(point);\r\n                    break;\r\n            }\r\n            if (match) {\r\n                return { pickMode, match: match.datum, distance: match.distance };\r\n            }\r\n        }\r\n    }\r\n    pickNodeExactShape(point) {\r\n        const match = this.contentGroup.pickNode(point.x, point.y);\r\n        return match && { datum: match.datum, distance: 0 };\r\n    }\r\n    pickNodeClosestDatum(_point) {\r\n        // Override point for subclasses - but if this is invoked, the subclass specified it wants\r\n        // to use this feature.\r\n        throw new Error('AG Charts - Series.pickNodeClosestDatum() not implemented');\r\n    }\r\n    pickNodeMainAxisFirst(_point, _requireCategoryAxis) {\r\n        // Override point for subclasses - but if this is invoked, the subclass specified it wants\r\n        // to use this feature.\r\n        throw new Error('AG Charts - Series.pickNodeMainAxisFirst() not implemented');\r\n    }\r\n    fireNodeClickEvent(event, datum) {\r\n        this.fireEvent(new this.NodeClickEvent('nodeClick', event, datum, this));\r\n    }\r\n    fireNodeDoubleClickEvent(event, datum) {\r\n        this.fireEvent(new this.NodeClickEvent('nodeDoubleClick', event, datum, this));\r\n    }\r\n    toggleSeriesItem(itemId, enabled) {\r\n        this.visible = enabled;\r\n        this.nodeDataRefresh = true;\r\n        this.dispatch('visibility-changed', { itemId, enabled });\r\n    }\r\n    isEnabled() {\r\n        return this.visible;\r\n    }\r\n    getModuleMap() {\r\n        return this.moduleMap;\r\n    }\r\n    createModuleContext() {\r\n        return Object.assign(Object.assign({}, this.ctx), { series: this });\r\n    }\r\n    getLabelText(label, params, defaultFormatter = String) {\r\n        var _a;\r\n        if (label.formatter) {\r\n            return ((_a = this.ctx.callbackCache.call(label.formatter, Object.assign({ seriesId: this.id }, params))) !== null && _a !== void 0 ? _a : defaultFormatter(params.value));\r\n        }\r\n        return defaultFormatter(params.value);\r\n    }\r\n    getMarkerStyle(marker, params, defaultStyle = marker.getStyle()) {\r\n        var _a, _b;\r\n        const defaultSize = { size: (_b = (_a = params.datum.point) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0 };\r\n        const markerStyle = mergeDefaults(defaultSize, defaultStyle);\r\n        if (marker.formatter) {\r\n            const style = this.ctx.callbackCache.call(marker.formatter, Object.assign(Object.assign(Object.assign({ seriesId: this.id }, markerStyle), params), { datum: params.datum.datum }));\r\n            return mergeDefaults(style, markerStyle);\r\n        }\r\n        return markerStyle;\r\n    }\r\n    updateMarkerStyle(markerNode, marker, params, defaultStyle = marker.getStyle(), { applyTranslation = true } = {}) {\r\n        const { point } = params.datum;\r\n        const activeStyle = this.getMarkerStyle(marker, params, defaultStyle);\r\n        const visible = this.visible && activeStyle.size > 0 && point && !isNaN(point.x) && !isNaN(point.y);\r\n        if (applyTranslation) {\r\n            markerNode.setProperties(Object.assign(Object.assign({ visible }, activeStyle), { translationX: point === null || point === void 0 ? void 0 : point.x, translationY: point === null || point === void 0 ? void 0 : point.y }));\r\n        }\r\n        else {\r\n            markerNode.setProperties(Object.assign({ visible }, activeStyle));\r\n        }\r\n        // Only for custom marker shapes\r\n        if (typeof marker.shape === 'function' && !markerNode.dirtyPath) {\r\n            markerNode.path.clear({ trackChanges: true });\r\n            markerNode.updatePath();\r\n            markerNode.checkPathDirty();\r\n        }\r\n    }\r\n    getMinRect() {\r\n        return undefined;\r\n    }\r\n    checkResize(newSeriesRect) {\r\n        const newNodeDataDependencies = {\r\n            seriesRectWidth: newSeriesRect === null || newSeriesRect === void 0 ? void 0 : newSeriesRect.width,\r\n            seriesRectHeight: newSeriesRect === null || newSeriesRect === void 0 ? void 0 : newSeriesRect.height,\r\n        };\r\n        const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\r\n        if (resize) {\r\n            this.nodeDataDependencies = newNodeDataDependencies;\r\n            this.markNodeDataDirty();\r\n        }\r\n        return resize;\r\n    }\r\n}\r\nSeries.highlightedZIndex = 1000000000000;\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", Object)\r\n], Series.prototype, \"id\", void 0);\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], Series.prototype, \"_visible\", void 0);\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], Series.prototype, \"showInLegend\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", Object)\r\n], Series.prototype, \"cursor\", void 0);\r\n__decorate([\r\n    Validate(INTERACTION_RANGE),\r\n    __metadata(\"design:type\", Object)\r\n], Series.prototype, \"nodeClickRange\", void 0);\r\n__decorate([\r\n    ActionOnSet({\r\n        changeValue: function (newVal, oldVal) {\r\n            this.onSeriesGroupingChange(oldVal, newVal);\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Object)\r\n], Series.prototype, \"seriesGrouping\", void 0);\n\nfunction seriesLabelFadeInAnimation({ id }, subId, animationManager, labelSelections) {\r\n    staticFromToMotion(id, subId, animationManager, labelSelections, { opacity: 0 }, { opacity: 1 }, LABEL_PHASE);\r\n}\r\nfunction seriesLabelFadeOutAnimation({ id }, subId, animationManager, labelSelections) {\r\n    staticFromToMotion(id, subId, animationManager, labelSelections, { opacity: 1 }, { opacity: 0 }, LABEL_PHASE);\r\n}\r\nfunction resetLabelFn(_node) {\r\n    return { opacity: 1 };\r\n}\n\nconst CONSTANTS = {\r\n    periods: ['AM', 'PM'],\r\n    days: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'],\r\n    shortDays: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],\r\n    months: [\r\n        'January',\r\n        'February',\r\n        'March',\r\n        'April',\r\n        'May',\r\n        'June',\r\n        'July',\r\n        'August',\r\n        'September',\r\n        'October',\r\n        'November',\r\n        'December',\r\n    ],\r\n    shortMonths: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\r\n};\r\nfunction dayOfYear(date, startOfYear = new Date(date.getFullYear(), 0, 1)) {\r\n    const startOffset = date.getTimezoneOffset() - startOfYear.getTimezoneOffset();\r\n    const timeDiff = date.getTime() - startOfYear.getTime() + startOffset * 60000;\r\n    const timeOneDay = 3600000 * 24;\r\n    return Math.floor(timeDiff / timeOneDay);\r\n}\r\nfunction weekOfYear(date, startDay) {\r\n    const startOfYear = new Date(date.getFullYear(), 0, 1);\r\n    const startOfYearDay = startOfYear.getDay();\r\n    const firstWeekStartOffset = (startDay - startOfYearDay + 7) % 7;\r\n    const startOffset = new Date(date.getFullYear(), 0, firstWeekStartOffset + 1);\r\n    if (startOffset <= date) {\r\n        return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\r\n    }\r\n    // Days before week 1 are in week 0.\r\n    return 0;\r\n}\r\nconst SUNDAY = 0;\r\nconst MONDAY = 1;\r\nconst THURSDAY = 4;\r\nfunction isoWeekOfYear(date, year = date.getFullYear()) {\r\n    const firstOfYear = new Date(year, 0, 1);\r\n    const firstOfYearDay = firstOfYear.getDay();\r\n    const firstThursdayOffset = (THURSDAY - firstOfYearDay + 7) % 7;\r\n    const startOffset = new Date(year, 0, firstThursdayOffset - (THURSDAY - MONDAY) + 1);\r\n    if (startOffset <= date) {\r\n        return Math.floor(dayOfYear(date, startOffset) / 7) + 1;\r\n    }\r\n    // Days before week 1 are in week 52/53 of previous year.\r\n    return isoWeekOfYear(date, year - 1);\r\n}\r\nfunction timezone(date) {\r\n    const offset = date.getTimezoneOffset();\r\n    const unsignedOffset = Math.abs(offset);\r\n    const sign = offset > 0 ? '-' : '+';\r\n    return `${sign}${pad(Math.floor(unsignedOffset / 60), 2, '0')}${pad(Math.floor(unsignedOffset % 60), 2, '0')}`;\r\n}\r\nconst FORMATTERS = {\r\n    a: (d) => CONSTANTS.shortDays[d.getDay()],\r\n    A: (d) => CONSTANTS.days[d.getDay()],\r\n    b: (d) => CONSTANTS.shortMonths[d.getMonth()],\r\n    B: (d) => CONSTANTS.months[d.getMonth()],\r\n    c: '%x, %X',\r\n    d: (d, p) => pad(d.getDate(), 2, p !== null && p !== void 0 ? p : '0'),\r\n    e: '%_d',\r\n    f: (d, p) => pad(d.getMilliseconds() * 1000, 6, p !== null && p !== void 0 ? p : '0'),\r\n    H: (d, p) => pad(d.getHours(), 2, p !== null && p !== void 0 ? p : '0'),\r\n    I: (d, p) => {\r\n        const hours = d.getHours() % 12;\r\n        return hours === 0 ? '12' : pad(hours, 2, p !== null && p !== void 0 ? p : '0');\r\n    },\r\n    j: (d, p) => pad(dayOfYear(d) + 1, 3, p !== null && p !== void 0 ? p : '0'),\r\n    m: (d, p) => pad(d.getMonth() + 1, 2, p !== null && p !== void 0 ? p : '0'),\r\n    M: (d, p) => pad(d.getMinutes(), 2, p !== null && p !== void 0 ? p : '0'),\r\n    L: (d, p) => pad(d.getMilliseconds(), 3, p !== null && p !== void 0 ? p : '0'),\r\n    p: (d) => (d.getHours() < 12 ? 'AM' : 'PM'),\r\n    Q: (d) => String(d.getTime()),\r\n    s: (d) => String(Math.floor(d.getTime() / 1000)),\r\n    S: (d, p) => pad(d.getSeconds(), 2, p !== null && p !== void 0 ? p : '0'),\r\n    u: (d) => {\r\n        let day = d.getDay();\r\n        if (day < 1)\r\n            day += 7;\r\n        return String(day % 7);\r\n    },\r\n    U: (d, p) => pad(weekOfYear(d, SUNDAY), 2, p !== null && p !== void 0 ? p : '0'),\r\n    V: (d, p) => pad(isoWeekOfYear(d), 2, p !== null && p !== void 0 ? p : '0'),\r\n    w: (d, p) => pad(d.getDay(), 2, p !== null && p !== void 0 ? p : '0'),\r\n    W: (d, p) => pad(weekOfYear(d, MONDAY), 2, p !== null && p !== void 0 ? p : '0'),\r\n    x: '%-m/%-d/%Y',\r\n    X: '%-I:%M:%S %p',\r\n    y: (d, p) => pad(d.getFullYear() % 100, 2, p !== null && p !== void 0 ? p : '0'),\r\n    Y: (d, p) => pad(d.getFullYear(), 4, p !== null && p !== void 0 ? p : '0'),\r\n    Z: (d) => timezone(d),\r\n    '%': () => '%',\r\n};\r\nconst PADS = {\r\n    _: ' ',\r\n    '0': '0',\r\n    '-': '',\r\n};\r\nfunction pad(value, size, padChar) {\r\n    const output = String(Math.floor(value));\r\n    if (output.length >= size) {\r\n        return output;\r\n    }\r\n    return `${padChar.repeat(size - output.length)}${output}`;\r\n}\r\nfunction buildFormatter(formatString) {\r\n    const formatParts = [];\r\n    while (formatString.length > 0) {\r\n        let nextEscapeIdx = formatString.indexOf('%');\r\n        if (nextEscapeIdx !== 0) {\r\n            const literalPart = nextEscapeIdx > 0 ? formatString.substring(0, nextEscapeIdx) : formatString;\r\n            formatParts.push(literalPart);\r\n        }\r\n        if (nextEscapeIdx < 0)\r\n            break;\r\n        const maybePadSpecifier = formatString[nextEscapeIdx + 1];\r\n        const maybePad = PADS[maybePadSpecifier];\r\n        if (maybePad != null) {\r\n            nextEscapeIdx++;\r\n        }\r\n        const maybeFormatterSpecifier = formatString[nextEscapeIdx + 1];\r\n        const maybeFormatter = FORMATTERS[maybeFormatterSpecifier];\r\n        if (typeof maybeFormatter === 'function') {\r\n            formatParts.push([maybeFormatter, maybePad]);\r\n        }\r\n        else if (typeof maybeFormatter === 'string') {\r\n            const formatter = buildFormatter(maybeFormatter);\r\n            formatParts.push([formatter, maybePad]);\r\n        }\r\n        else {\r\n            formatParts.push(`${maybePad !== null && maybePad !== void 0 ? maybePad : ''}${maybeFormatterSpecifier}`);\r\n        }\r\n        formatString = formatString.substring(nextEscapeIdx + 2);\r\n    }\r\n    return (dateTime) => {\r\n        const dateTimeAsDate = typeof dateTime === 'number' ? new Date(dateTime) : dateTime;\r\n        return formatParts.map((c) => (typeof c === 'string' ? c : c[0](dateTimeAsDate, c[1]))).join('');\r\n    };\r\n}\n\nconst interpolatePattern = /(#\\{(.*?)\\})/g;\r\nfunction interpolate(input, values, formats) {\r\n    return input.replace(interpolatePattern, function (...args) {\r\n        const name = args[2];\r\n        const [valueName, formatName] = name.split(':');\r\n        const value = values[valueName];\r\n        if (typeof value === 'number') {\r\n            const format = formatName && formats && formats[formatName];\r\n            if (format) {\r\n                const { locales, options } = format;\r\n                return value.toLocaleString(locales, options);\r\n            }\r\n            return String(value);\r\n        }\r\n        if (value instanceof Date) {\r\n            const format = formatName && formats && formats[formatName];\r\n            if (typeof format === 'string') {\r\n                const formatter = buildFormatter(format);\r\n                return formatter(value);\r\n            }\r\n            return value.toDateString();\r\n        }\r\n        if (typeof value === 'string' || (value === null || value === void 0 ? void 0 : value.toString)) {\r\n            return String(value);\r\n        }\r\n        return '';\r\n    });\r\n}\n\nfunction injectStyle(document, cssStyle) {\r\n    const styleElement = document.createElement('style');\r\n    styleElement.innerHTML = cssStyle;\r\n    // Make sure these styles are injected before other styles, so it can be overridden.\r\n    document.head.insertBefore(styleElement, document.head.querySelector('style'));\r\n}\n\nconst DEFAULT_TOOLTIP_CLASS = 'ag-chart-tooltip';\r\nconst DEFAULT_TOOLTIP_DARK_CLASS = 'ag-chart-dark-tooltip';\r\nconst defaultTooltipCss = `\n.${DEFAULT_TOOLTIP_CLASS} {\n    transition: transform 0.1s ease;\n    display: table;\n    position: fixed;\n    left: 0px;\n    top: 0px;\n    white-space: nowrap;\n    z-index: 99999;\n    font: 12px Verdana, sans-serif;\n    color: rgb(70, 70, 70);\n    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-no-interaction {\n    pointer-events: none;\n    user-select: none;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-no-animation {\n    transition: none !important;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-hidden {\n    visibility: hidden;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-title {\n    position: relative;\n    padding: 8px 14px;\n    border-top-left-radius: 2px;\n    border-top-right-radius: 2px;\n    color: white;\n    background-color: #888888;\n    z-index: 1;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-title:only-child {\n    border-bottom-left-radius: 2px;\n    border-bottom-right-radius: 2px;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-content {\n    padding: 6px 14px;\n    line-height: 1.7em;\n    background: white;\n    border-bottom-left-radius: 2px;\n    border-bottom-right-radius: 2px;\n    border: 1px solid rgba(0, 0, 0, 0.15);\n    overflow: hidden;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-arrow::before {\n    content: \"\";\n\n    position: absolute;\n    top: 100%;\n    left: 50%;\n    transform: translateX(-50%);\n\n    border: 5px solid #d9d9d9;\n\n    border-left-color: transparent;\n    border-right-color: transparent;\n    border-bottom-color: transparent;\n\n    width: 0;\n    height: 0;\n\n    margin: 0 auto;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}-arrow::after {\n    content: \"\";\n\n    position: absolute;\n    top: calc(100% - 1px);\n    left: 50%;\n    transform: translateX(-50%);\n\n    border: 5px solid white;\n\n    border-left-color: transparent;\n    border-right-color: transparent;\n    border-bottom-color: transparent;\n\n    width: 0;\n    height: 0;\n\n    margin: 0 auto;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}.${DEFAULT_TOOLTIP_DARK_CLASS} {\n    color: white;\n    background: #15181c;\n}\n\n.${DEFAULT_TOOLTIP_CLASS}.${DEFAULT_TOOLTIP_DARK_CLASS} .${DEFAULT_TOOLTIP_CLASS}-content {\n    border-color: rgba(255, 255, 255, 0.15);\n}\n\n.ag-chart-wrapper {\n    box-sizing: border-box;\n    overflow: hidden;\n}\n`;\r\nfunction toTooltipHtml(input, defaults) {\r\n    var _a, _b, _c;\r\n    if (typeof input === 'string') {\r\n        return input;\r\n    }\r\n    const { content = (_a = defaults === null || defaults === void 0 ? void 0 : defaults.content) !== null && _a !== void 0 ? _a : '', title = defaults === null || defaults === void 0 ? void 0 : defaults.title, color = (_b = defaults === null || defaults === void 0 ? void 0 : defaults.color) !== null && _b !== void 0 ? _b : 'white', backgroundColor = (_c = defaults === null || defaults === void 0 ? void 0 : defaults.backgroundColor) !== null && _c !== void 0 ? _c : '#888', } = input;\r\n    const titleHtml = title\r\n        ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-title\"\n        style=\"color: ${color}; background-color: ${backgroundColor}\">${title}</div>`\r\n        : '';\r\n    const contentHtml = content ? `<div class=\"${DEFAULT_TOOLTIP_CLASS}-content\">${content}</div>` : '';\r\n    return `${titleHtml}${contentHtml}`;\r\n}\r\nconst POSITION_TYPES = ['pointer', 'node'];\r\nconst POSITION_TYPE = predicateWithMessage((v) => POSITION_TYPES.includes(v), `expecting a position type keyword such as 'pointer' or 'node'`);\r\nclass TooltipPosition {\r\n    constructor() {\r\n        /** The type of positioning for the tooltip. By default, the tooltip follows the pointer. */\r\n        this.type = 'pointer';\r\n        /** The horizontal offset in pixels for the position of the tooltip. */\r\n        this.xOffset = 0;\r\n        /** The vertical offset in pixels for the position of the tooltip. */\r\n        this.yOffset = 0;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(POSITION_TYPE)\r\n    /** The type of positioning for the tooltip. By default, the tooltip follows the pointer. */\r\n    ,\r\n    __metadata(\"design:type\", String)\r\n], TooltipPosition.prototype, \"type\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1())\r\n    /** The horizontal offset in pixels for the position of the tooltip. */\r\n    ,\r\n    __metadata(\"design:type\", Number)\r\n], TooltipPosition.prototype, \"xOffset\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1())\r\n    /** The vertical offset in pixels for the position of the tooltip. */\r\n    ,\r\n    __metadata(\"design:type\", Number)\r\n], TooltipPosition.prototype, \"yOffset\", void 0);\r\nclass Tooltip {\r\n    constructor(canvasElement, document, window, container) {\r\n        this.enableInteraction = false;\r\n        this.enabled = true;\r\n        this.showArrow = undefined;\r\n        this.class = undefined;\r\n        this.lastClass = undefined;\r\n        this.delay = 0;\r\n        this.range = 'nearest';\r\n        this.lastVisibilityChange = Date.now();\r\n        this.position = new TooltipPosition();\r\n        this.showTimeout = 0;\r\n        this._showArrow = true;\r\n        this.tooltipRoot = container;\r\n        this.window = window;\r\n        const element = document.createElement('div');\r\n        this.element = this.tooltipRoot.appendChild(element);\r\n        this.element.classList.add(DEFAULT_TOOLTIP_CLASS);\r\n        this.canvasElement = canvasElement;\r\n        // Detect when the chart becomes invisible and hide the tooltip as well.\r\n        if (typeof IntersectionObserver !== 'undefined') {\r\n            const observer = new IntersectionObserver((entries) => {\r\n                for (const entry of entries) {\r\n                    if (entry.target === this.canvasElement && entry.intersectionRatio === 0) {\r\n                        this.toggle(false);\r\n                    }\r\n                }\r\n            }, { root: this.tooltipRoot });\r\n            observer.observe(this.canvasElement);\r\n            this.observer = observer;\r\n        }\r\n        if (Tooltip.tooltipDocuments.indexOf(document) < 0) {\r\n            injectStyle(document, defaultTooltipCss);\r\n            Tooltip.tooltipDocuments.push(document);\r\n        }\r\n    }\r\n    destroy() {\r\n        const { parentNode } = this.element;\r\n        if (parentNode) {\r\n            parentNode.removeChild(this.element);\r\n        }\r\n        if (this.observer) {\r\n            this.observer.unobserve(this.canvasElement);\r\n        }\r\n    }\r\n    isVisible() {\r\n        const { element } = this;\r\n        return !element.classList.contains(DEFAULT_TOOLTIP_CLASS + '-hidden');\r\n    }\r\n    updateClass(visible, showArrow) {\r\n        const { element, class: newClass, lastClass, enableInteraction, lastVisibilityChange } = this;\r\n        const wasVisible = this.isVisible();\r\n        const nowVisible = !!visible;\r\n        let timeSinceLastVisibilityChangeMs = Infinity;\r\n        if (wasVisible !== nowVisible) {\r\n            const now = Date.now();\r\n            timeSinceLastVisibilityChangeMs = now - lastVisibilityChange;\r\n            this.lastVisibilityChange = now;\r\n        }\r\n        const toggleClass = (name, include) => {\r\n            const className = `${DEFAULT_TOOLTIP_CLASS}-${name}`;\r\n            if (include) {\r\n                element.classList.add(className);\r\n            }\r\n            else {\r\n                element.classList.remove(className);\r\n            }\r\n        };\r\n        // Time below which an animated move should be used.\r\n        const animatedMoveThresholdMs = 100;\r\n        // Time below which we should treat updates as indistinguishable to users, and we shouldn't\r\n        // adjust the `no-animation` CSS class.\r\n        const thrashingThresholdMs = 5;\r\n        // No animation on first show or if tooltip is disabled for a non-trivial amount of time.\r\n        // Don't change the `no-animation` class on fast update.\r\n        const noAnimation = !wasVisible && nowVisible && timeSinceLastVisibilityChangeMs > animatedMoveThresholdMs;\r\n        if (timeSinceLastVisibilityChangeMs > thrashingThresholdMs) {\r\n            toggleClass('no-animation', noAnimation);\r\n        }\r\n        toggleClass('no-interaction', !enableInteraction); // Prevent interaction.\r\n        toggleClass('hidden', !visible); // Hide if not visible.\r\n        toggleClass('arrow', !!showArrow); // Add arrow if tooltip is constrained.\r\n        if (newClass !== lastClass) {\r\n            if (lastClass) {\r\n                element.classList.remove(lastClass);\r\n            }\r\n            if (newClass) {\r\n                element.classList.add(newClass);\r\n            }\r\n            this.lastClass = newClass;\r\n        }\r\n    }\r\n    /**\r\n     * Shows tooltip at the given event's coordinates.\r\n     * If the `html` parameter is missing, moves the existing tooltip to the new position.\r\n     */\r\n    show(meta, html, instantly = false) {\r\n        var _a, _b, _c, _d, _e, _f, _g;\r\n        const { element, canvasElement } = this;\r\n        if (html !== undefined) {\r\n            element.innerHTML = html;\r\n        }\r\n        else if (!element.innerHTML) {\r\n            this.toggle(false);\r\n            return;\r\n        }\r\n        const limit = (low, actual, high) => {\r\n            return Math.max(Math.min(actual, high), low);\r\n        };\r\n        const xOffset = (_b = (_a = meta.position) === null || _a === void 0 ? void 0 : _a.xOffset) !== null && _b !== void 0 ? _b : 0;\r\n        const yOffset = (_d = (_c = meta.position) === null || _c === void 0 ? void 0 : _c.yOffset) !== null && _d !== void 0 ? _d : 0;\r\n        const canvasRect = canvasElement.getBoundingClientRect();\r\n        const naiveLeft = canvasRect.left + meta.offsetX - element.clientWidth / 2 + xOffset;\r\n        const naiveTop = canvasRect.top + meta.offsetY - element.clientHeight - 8 + yOffset;\r\n        const windowBounds = this.getWindowBoundingBox();\r\n        const maxLeft = windowBounds.x + windowBounds.width - element.clientWidth - 1;\r\n        const maxTop = windowBounds.y + windowBounds.height - element.clientHeight;\r\n        const left = limit(windowBounds.x, naiveLeft, maxLeft);\r\n        const top = limit(windowBounds.y, naiveTop, maxTop);\r\n        const constrained = left !== naiveLeft || top !== naiveTop;\r\n        const defaultShowArrow = !constrained && !xOffset && !yOffset;\r\n        const showArrow = (_f = (_e = meta.showArrow) !== null && _e !== void 0 ? _e : this.showArrow) !== null && _f !== void 0 ? _f : defaultShowArrow;\r\n        this.updateShowArrow(showArrow);\r\n        element.style.transform = `translate(${Math.round(left)}px, ${Math.round(top)}px)`;\r\n        this.enableInteraction = (_g = meta.enableInteraction) !== null && _g !== void 0 ? _g : false;\r\n        if (this.delay > 0 && !instantly) {\r\n            this.toggle(false);\r\n            this.showTimeout = this.window.setTimeout(() => {\r\n                this.toggle(true);\r\n            }, this.delay);\r\n            return;\r\n        }\r\n        this.toggle(true);\r\n    }\r\n    getWindowBoundingBox() {\r\n        return new BBox(0, 0, this.window.innerWidth, this.window.innerHeight);\r\n    }\r\n    toggle(visible) {\r\n        if (!visible) {\r\n            this.window.clearTimeout(this.showTimeout);\r\n        }\r\n        this.updateClass(visible, this._showArrow);\r\n    }\r\n    pointerLeftOntoTooltip(event) {\r\n        var _a;\r\n        if (!this.enableInteraction)\r\n            return false;\r\n        const classList = (_a = event.sourceEvent.relatedTarget) === null || _a === void 0 ? void 0 : _a.classList;\r\n        const classes = ['', '-title', '-content'];\r\n        const classListContains = Boolean(classes.filter((c) => classList === null || classList === void 0 ? void 0 : classList.contains(`${DEFAULT_TOOLTIP_CLASS}${c}`)));\r\n        return classList !== undefined && classListContains;\r\n    }\r\n    updateShowArrow(show) {\r\n        this._showArrow = show;\r\n    }\r\n}\r\nTooltip.tooltipDocuments = [];\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], Tooltip.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], Tooltip.prototype, \"showArrow\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], Tooltip.prototype, \"class\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Tooltip.prototype, \"delay\", void 0);\r\n__decorate([\r\n    Validate(INTERACTION_RANGE),\r\n    __metadata(\"design:type\", Object)\r\n], Tooltip.prototype, \"range\", void 0);\n\nclass SeriesTooltipInteraction {\r\n    constructor() {\r\n        this.enabled = false;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], SeriesTooltipInteraction.prototype, \"enabled\", void 0);\r\nclass SeriesTooltip {\r\n    constructor() {\r\n        this.enabled = true;\r\n        this.showArrow = undefined;\r\n        this.format = undefined;\r\n        this.renderer = undefined;\r\n        this.interaction = new SeriesTooltipInteraction();\r\n        this.position = new TooltipPosition();\r\n    }\r\n    toTooltipHtml(defaults, params, overrides) {\r\n        var _a, _b;\r\n        const formatFn = (_a = overrides === null || overrides === void 0 ? void 0 : overrides.format) !== null && _a !== void 0 ? _a : this.format;\r\n        const rendererFn = (_b = overrides === null || overrides === void 0 ? void 0 : overrides.renderer) !== null && _b !== void 0 ? _b : this.renderer;\r\n        if (formatFn) {\r\n            return toTooltipHtml({ content: interpolate(formatFn, params) }, defaults);\r\n        }\r\n        if (rendererFn) {\r\n            return toTooltipHtml(rendererFn(params), defaults);\r\n        }\r\n        return toTooltipHtml(defaults);\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], SeriesTooltip.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], SeriesTooltip.prototype, \"showArrow\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], SeriesTooltip.prototype, \"format\", void 0);\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    __metadata(\"design:type\", Function)\r\n], SeriesTooltip.prototype, \"renderer\", void 0);\n\nfunction preparePieSeriesAnimationFunctions(initialLoad, rotationDegrees, scaleFn, oldScaleFn) {\r\n    const scale = [scaleFn.convert(0), scaleFn.convert(1)];\r\n    const oldScale = [oldScaleFn.convert(0), oldScaleFn.convert(1)];\r\n    const rotation = Math.PI / -2 + toRadians(rotationDegrees);\r\n    const scaleToNewRadius = ({ radius }) => {\r\n        return { innerRadius: scale[0], outerRadius: scale[0] + (scale[1] - scale[0]) * radius };\r\n    };\r\n    const scaleToOldRadius = ({ radius }) => {\r\n        return { innerRadius: oldScale[0], outerRadius: oldScale[0] + (oldScale[1] - oldScale[0]) * radius };\r\n    };\r\n    const fromFn = (sect, datum, status, { prevFromProps }) => {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        // Default to starting from current state.\r\n        let { startAngle, endAngle, innerRadius, outerRadius } = sect;\r\n        let { fill, stroke } = datum.sectorFormat;\r\n        if (status === 'unknown' || (status === 'added' && !prevFromProps)) {\r\n            // Start of animation (full new data) - sweep in.\r\n            startAngle = rotation;\r\n            endAngle = rotation;\r\n            innerRadius = datum.innerRadius;\r\n            outerRadius = datum.outerRadius;\r\n        }\r\n        else if (status === 'added' && prevFromProps) {\r\n            startAngle = (_a = prevFromProps.endAngle) !== null && _a !== void 0 ? _a : rotation;\r\n            endAngle = (_b = prevFromProps.endAngle) !== null && _b !== void 0 ? _b : rotation;\r\n            innerRadius = (_c = prevFromProps.innerRadius) !== null && _c !== void 0 ? _c : datum.innerRadius;\r\n            outerRadius = (_d = prevFromProps.outerRadius) !== null && _d !== void 0 ? _d : datum.outerRadius;\r\n        }\r\n        if (status === 'added' && !initialLoad) {\r\n            const radii = scaleToOldRadius(datum);\r\n            innerRadius = radii.innerRadius;\r\n            outerRadius = radii.outerRadius;\r\n        }\r\n        if (status === 'updated') {\r\n            fill = (_e = sect.fill) !== null && _e !== void 0 ? _e : fill;\r\n            stroke = (_f = sect.stroke) !== null && _f !== void 0 ? _f : stroke;\r\n        }\r\n        return { startAngle, endAngle, innerRadius, outerRadius, fill, stroke };\r\n    };\r\n    const toFn = (_sect, datum, status, { prevLive }) => {\r\n        var _a, _b;\r\n        // Default to moving to target state.\r\n        let { startAngle, endAngle, innerRadius, outerRadius } = datum;\r\n        const { stroke, fill } = datum.sectorFormat;\r\n        if (status === 'removed' && prevLive) {\r\n            startAngle = (_a = prevLive.datum) === null || _a === void 0 ? void 0 : _a.endAngle;\r\n            endAngle = (_b = prevLive.datum) === null || _b === void 0 ? void 0 : _b.endAngle;\r\n        }\r\n        else if (status === 'removed' && !prevLive) {\r\n            startAngle = rotation;\r\n            endAngle = rotation;\r\n        }\r\n        if (status === 'removed') {\r\n            const radii = scaleToNewRadius(datum);\r\n            innerRadius = radii.innerRadius;\r\n            outerRadius = radii.outerRadius;\r\n        }\r\n        return { startAngle, endAngle, outerRadius, innerRadius, stroke, fill };\r\n    };\r\n    const innerCircle = {\r\n        fromFn: (node, _datum) => {\r\n            var _a, _b, _c;\r\n            return { size: (_c = (_b = (_a = node.previousDatum) === null || _a === void 0 ? void 0 : _a.radius) !== null && _b !== void 0 ? _b : node.size) !== null && _c !== void 0 ? _c : 0 };\r\n        },\r\n        toFn: (_node, datum) => {\r\n            var _a;\r\n            return { size: (_a = datum.radius) !== null && _a !== void 0 ? _a : 0 };\r\n        },\r\n    };\r\n    return { nodes: { toFn, fromFn }, innerCircle };\r\n}\r\nfunction resetPieSelectionsFn(_node, datum) {\r\n    return {\r\n        startAngle: datum.startAngle,\r\n        endAngle: datum.endAngle,\r\n        innerRadius: datum.innerRadius,\r\n        outerRadius: datum.outerRadius,\r\n        fill: datum.sectorFormat.fill,\r\n        stroke: datum.sectorFormat.stroke,\r\n    };\r\n}\n\n/**\r\n * Implements a per-node reset.\r\n *\r\n * @param selections contains nodes to be reset\r\n * @param propsFn callback to determine per-node properties\r\n */\r\nfunction resetMotion(selectionsOrNodes, propsFn) {\r\n    const isNodes = isNodeArray(selectionsOrNodes);\r\n    const nodes = isNodes ? selectionsOrNodes : [];\r\n    const selections = !isNodes ? selectionsOrNodes : [];\r\n    for (const selection of selections) {\r\n        for (const node of selection.nodes()) {\r\n            const from = propsFn(node, node.datum);\r\n            node.setProperties(from);\r\n        }\r\n        selection.cleanup();\r\n    }\r\n    for (const node of nodes) {\r\n        const from = propsFn(node, node.datum);\r\n        node.setProperties(from);\r\n    }\r\n}\n\nvar resetMotion$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    resetMotion: resetMotion\n});\n\nclass StateMachine {\r\n    constructor(initialState, states, preTransitionCb) {\r\n        this.states = states;\r\n        this.preTransitionCb = preTransitionCb;\r\n        this.debug = Debug.create(true, 'animation');\r\n        this.state = initialState;\r\n        this.debug(`%c${this.constructor.name} | init -> ${initialState}`, 'color: green');\r\n    }\r\n    transition(event, data) {\r\n        var _a, _b;\r\n        const currentStateConfig = this.states[this.state];\r\n        const destinationTransition = currentStateConfig === null || currentStateConfig === void 0 ? void 0 : currentStateConfig[event];\r\n        if (!destinationTransition) {\r\n            this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${this.state}`, 'color: grey');\r\n            return;\r\n        }\r\n        let destinationState = this.state;\r\n        if (typeof destinationTransition === 'string') {\r\n            destinationState = destinationTransition;\r\n        }\r\n        else if (typeof destinationTransition === 'object') {\r\n            destinationState = destinationTransition.target;\r\n        }\r\n        this.debug(`%c${this.constructor.name} | ${this.state} -> ${event} -> ${destinationState}`, 'color: green');\r\n        (_a = this.preTransitionCb) === null || _a === void 0 ? void 0 : _a.call(this, this.state, destinationState);\r\n        // Change the state before calling the transition action to allow the action to trigger a subsequent transition\r\n        this.state = destinationState;\r\n        if (typeof destinationTransition === 'function') {\r\n            destinationTransition(data);\r\n        }\r\n        else if (typeof destinationTransition === 'object') {\r\n            (_b = destinationTransition.action) === null || _b === void 0 ? void 0 : _b.call(destinationTransition, data);\r\n        }\r\n        return this.state;\r\n    }\r\n}\n\nclass DataModelSeries extends Series {\r\n    isContinuous() {\r\n        var _a, _b;\r\n        const isContinuousX = ContinuousScale.is((_a = this.axes[ChartAxisDirection.X]) === null || _a === void 0 ? void 0 : _a.scale);\r\n        const isContinuousY = ContinuousScale.is((_b = this.axes[ChartAxisDirection.Y]) === null || _b === void 0 ? void 0 : _b.scale);\r\n        return { isContinuousX, isContinuousY };\r\n    }\r\n    // Request data, but with message dispatching to series-options (modules).\r\n    requestDataModel(dataController, data, opts) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Merge properties of this series with properties of all the attached series-options\r\n            const props = opts.props;\r\n            const listenerProps = (_a = this.dispatch('data-prerequest', this.isContinuous())) !== null && _a !== void 0 ? _a : [];\r\n            for (const moreProps of listenerProps) {\r\n                props.push(...moreProps);\r\n            }\r\n            const { dataModel, processedData } = yield dataController.request(this.id, data !== null && data !== void 0 ? data : [], Object.assign(Object.assign({}, opts), { props }));\r\n            this.dataModel = dataModel;\r\n            this.processedData = processedData;\r\n            this.dispatch('data-processed', { dataModel, processedData });\r\n            return { dataModel, processedData };\r\n        });\r\n    }\r\n    isProcessedDataAnimatable() {\r\n        var _a, _b;\r\n        const validationResults = (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.animationValidation;\r\n        if (!validationResults)\r\n            return true;\r\n        const { orderedKeys, uniqueKeys } = validationResults;\r\n        return !!orderedKeys && !!uniqueKeys;\r\n    }\r\n    checkProcessedDataAnimatable() {\r\n        if (!this.isProcessedDataAnimatable()) {\r\n            this.ctx.animationManager.skipCurrentBatch();\r\n        }\r\n    }\r\n}\n\nclass PolarSeries extends DataModelSeries {\r\n    constructor(_a) {\r\n        var { useLabelLayer = false, pickModes = [SeriesNodePickMode.EXACT_SHAPE_MATCH], canHaveAxes = false, animationResetFns } = _a, opts = __rest(_a, [\"useLabelLayer\", \"pickModes\", \"canHaveAxes\", \"animationResetFns\"]);\r\n        super(Object.assign(Object.assign({}, opts), { useLabelLayer,\r\n            pickModes, contentGroupVirtual: false, directionKeys: {\r\n                [ChartAxisDirection.X]: ['angleKey'],\r\n                [ChartAxisDirection.Y]: ['radiusKey'],\r\n            }, directionNames: {\r\n                [ChartAxisDirection.X]: ['angleName'],\r\n                [ChartAxisDirection.Y]: ['radiusName'],\r\n            }, canHaveAxes }));\r\n        this.sectorGroup = this.contentGroup.appendChild(new Group());\r\n        this.itemSelection = Selection.select(this.sectorGroup, () => this.nodeFactory(), false);\r\n        this.labelSelection = Selection.select(this.labelGroup, Text, false);\r\n        this.highlightSelection = Selection.select(this.highlightGroup, () => this.nodeFactory());\r\n        /**\r\n         * The center of the polar series (for example, the center of a pie).\r\n         * If the polar chart has multiple series, all of them will have their\r\n         * center set to the same value as a result of the polar chart layout.\r\n         * The center coordinates are not supposed to be set by the user.\r\n         */\r\n        this.centerX = 0;\r\n        this.centerY = 0;\r\n        /**\r\n         * The maximum radius the series can use.\r\n         * This value is set automatically as a result of the polar chart layout\r\n         * and is not supposed to be set by the user.\r\n         */\r\n        this.radius = 0;\r\n        this.sectorGroup.zIndexSubOrder = [() => this._declarationOrder, 1];\r\n        this.animationResetFns = animationResetFns;\r\n        this.animationState = new StateMachine('empty', {\r\n            empty: {\r\n                update: {\r\n                    target: 'ready',\r\n                    action: (data) => this.animateEmptyUpdateReady(data),\r\n                },\r\n            },\r\n            ready: {\r\n                updateData: 'waiting',\r\n                clear: 'clearing',\r\n                highlight: (data) => this.animateReadyHighlight(data),\r\n                highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\r\n                resize: (data) => this.animateReadyResize(data),\r\n            },\r\n            waiting: {\r\n                update: {\r\n                    target: 'ready',\r\n                    action: (data) => this.animateWaitingUpdateReady(data),\r\n                },\r\n            },\r\n            clearing: {\r\n                update: {\r\n                    target: 'empty',\r\n                    action: (data) => this.animateClearingUpdateEmpty(data),\r\n                },\r\n            },\r\n        }, () => this.checkProcessedDataAnimatable());\r\n    }\r\n    getLabelData() {\r\n        return [];\r\n    }\r\n    computeLabelsBBox(_options, _seriesRect) {\r\n        return null;\r\n    }\r\n    resetAllAnimation() {\r\n        var _a;\r\n        const { item, label } = (_a = this.animationResetFns) !== null && _a !== void 0 ? _a : {};\r\n        this.ctx.animationManager.stopByAnimationGroupId(this.id);\r\n        if (item) {\r\n            resetMotion([this.itemSelection, this.highlightSelection], item);\r\n        }\r\n        if (label) {\r\n            resetMotion([this.labelSelection], label);\r\n        }\r\n        this.itemSelection.cleanup();\r\n        this.labelSelection.cleanup();\r\n        this.highlightSelection.cleanup();\r\n    }\r\n    animateEmptyUpdateReady(_data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation();\r\n    }\r\n    animateWaitingUpdateReady(_data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation();\r\n    }\r\n    animateReadyHighlight(_data) {\r\n        var _a;\r\n        const { item } = (_a = this.animationResetFns) !== null && _a !== void 0 ? _a : {};\r\n        if (item) {\r\n            resetMotion([this.highlightSelection], item);\r\n        }\r\n    }\r\n    animateReadyHighlightMarkers(_data) {\r\n        // Override point for sub-classes.\r\n    }\r\n    animateReadyResize(_data) {\r\n        this.resetAllAnimation();\r\n    }\r\n    animateClearingUpdateEmpty(_data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation();\r\n    }\r\n    animationTransitionClear() {\r\n        this.animationState.transition('clear', this.getAnimationData());\r\n    }\r\n    getAnimationData(seriesRect) {\r\n        return { seriesRect };\r\n    }\r\n}\n\nclass PieSeriesNodeClickEvent extends SeriesNodeClickEvent {\r\n    constructor(type, nativeEvent, datum, series) {\r\n        super(type, nativeEvent, datum, series);\r\n        this.angleKey = series.angleKey;\r\n        this.radiusKey = series.radiusKey;\r\n        this.calloutLabelKey = series.calloutLabelKey;\r\n        this.sectorLabelKey = series.sectorLabelKey;\r\n    }\r\n}\r\nvar PieNodeTag;\r\n(function (PieNodeTag) {\r\n    PieNodeTag[PieNodeTag[\"Sector\"] = 0] = \"Sector\";\r\n    PieNodeTag[PieNodeTag[\"Callout\"] = 1] = \"Callout\";\r\n    PieNodeTag[PieNodeTag[\"Label\"] = 2] = \"Label\";\r\n})(PieNodeTag || (PieNodeTag = {}));\r\nclass PieSeriesCalloutLabel extends Label {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.offset = 3; // from the callout line\r\n        this.minAngle = 0; // in degrees\r\n        this.minSpacing = 4;\r\n        this.maxCollisionOffset = 50;\r\n        this.avoidCollisions = true;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeriesCalloutLabel.prototype, \"offset\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeriesCalloutLabel.prototype, \"minAngle\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeriesCalloutLabel.prototype, \"minSpacing\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeriesCalloutLabel.prototype, \"maxCollisionOffset\", void 0);\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeriesCalloutLabel.prototype, \"avoidCollisions\", void 0);\r\nclass PieSeriesSectorLabel extends Label {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.positionOffset = 0;\r\n        this.positionRatio = 0.5;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeriesSectorLabel.prototype, \"positionOffset\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeriesSectorLabel.prototype, \"positionRatio\", void 0);\r\nclass PieSeriesCalloutLine {\r\n    constructor() {\r\n        this.length = 10;\r\n        this.strokeWidth = 1;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], PieSeriesCalloutLine.prototype, \"colors\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], PieSeriesCalloutLine.prototype, \"length\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], PieSeriesCalloutLine.prototype, \"strokeWidth\", void 0);\r\nclass PieTitle extends Caption {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.showInLegend = false;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], PieTitle.prototype, \"showInLegend\", void 0);\r\nclass DoughnutInnerLabel extends Label {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.text = '';\r\n        this.margin = 2;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", Object)\r\n], DoughnutInnerLabel.prototype, \"text\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    __metadata(\"design:type\", Object)\r\n], DoughnutInnerLabel.prototype, \"margin\", void 0);\r\nclass DoughnutInnerCircle {\r\n    constructor() {\r\n        this.fill = 'transparent';\r\n        this.fillOpacity = 1;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    __metadata(\"design:type\", Object)\r\n], DoughnutInnerCircle.prototype, \"fill\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], DoughnutInnerCircle.prototype, \"fillOpacity\", void 0);\r\nclass PieSeries extends PolarSeries {\r\n    constructor(moduleCtx) {\r\n        super({\r\n            moduleCtx,\r\n            useLabelLayer: true,\r\n            animationResetFns: { item: resetPieSelectionsFn, label: resetLabelFn },\r\n        });\r\n        this.previousRadiusScale = new LinearScale();\r\n        this.radiusScale = new LinearScale();\r\n        // The group node that contains the background graphics.\r\n        this.backgroundGroup = this.rootGroup.appendChild(new Group({\r\n            name: `${this.id}-background`,\r\n            layer: true,\r\n            zIndex: Layers.SERIES_BACKGROUND_ZINDEX,\r\n        }));\r\n        this.innertCircleGroup = this.backgroundGroup.appendChild(new Group({ name: `${this.id}-innerCircle` }));\r\n        this.nodeData = [];\r\n        // When a user toggles a series item (e.g. from the legend), its boolean state is recorded here.\r\n        this.seriesItemEnabled = [];\r\n        this.title = undefined;\r\n        this.calloutLabel = new PieSeriesCalloutLabel();\r\n        this.sectorLabel = new PieSeriesSectorLabel();\r\n        this.calloutLine = new PieSeriesCalloutLine();\r\n        this.tooltip = new SeriesTooltip();\r\n        /**\r\n         * The key of the numeric field to use to determine the angle (for example,\r\n         * a pie sector angle).\r\n         */\r\n        this.angleKey = '';\r\n        this.angleName = '';\r\n        this.innerLabels = [];\r\n        this.innerCircle = undefined;\r\n        /**\r\n         * The key of the numeric field to use to determine the radii of pie sectors.\r\n         * The largest value will correspond to the full radius and smaller values to\r\n         * proportionally smaller radii.\r\n         */\r\n        this.radiusKey = undefined;\r\n        this.radiusName = undefined;\r\n        this.radiusMin = undefined;\r\n        this.radiusMax = undefined;\r\n        this.calloutLabelKey = undefined;\r\n        this.calloutLabelName = undefined;\r\n        this.sectorLabelKey = undefined;\r\n        this.sectorLabelName = undefined;\r\n        this.legendItemKey = undefined;\r\n        this.fills = Object.values(DEFAULT_FILLS);\r\n        this.strokes = Object.values(DEFAULT_STROKES);\r\n        this.fillOpacity = 1;\r\n        this.strokeOpacity = 1;\r\n        this.lineDash = [0];\r\n        this.lineDashOffset = 0;\r\n        this.formatter = undefined;\r\n        /**\r\n         * The series rotation in degrees.\r\n         */\r\n        this.rotation = 0;\r\n        this.outerRadiusOffset = 0;\r\n        this.outerRadiusRatio = 1;\r\n        this.innerRadiusOffset = 0;\r\n        this.innerRadiusRatio = 1;\r\n        this.strokeWidth = 1;\r\n        this.shadow = undefined;\r\n        this.highlightStyle = new HighlightStyle();\r\n        this.surroundingRadius = undefined;\r\n        this.NodeClickEvent = PieSeriesNodeClickEvent;\r\n        this.angleScale = new LinearScale();\r\n        // Each sector is a ratio of the whole, where all ratios add up to 1.\r\n        this.angleScale.domain = [0, 1];\r\n        // Add 90 deg to start the first pie at 12 o'clock.\r\n        this.angleScale.range = [-Math.PI, Math.PI].map((angle) => angle + Math.PI / 2);\r\n        const pieCalloutLabels = new Group({ name: 'pieCalloutLabels' });\r\n        const pieSectorLabels = new Group({ name: 'pieSectorLabels' });\r\n        const innerLabels = new Group({ name: 'innerLabels' });\r\n        this.labelGroup.append(pieCalloutLabels);\r\n        this.labelGroup.append(pieSectorLabels);\r\n        this.labelGroup.append(innerLabels);\r\n        this.calloutLabelSelection = Selection.select(pieCalloutLabels, Group);\r\n        this.sectorLabelSelection = Selection.select(pieSectorLabels, Text);\r\n        this.innerLabelsSelection = Selection.select(innerLabels, Text);\r\n        this.innerCircleSelection = Selection.select(this.innertCircleGroup, Circle);\r\n    }\r\n    addChartEventListeners() {\r\n        var _a;\r\n        (_a = this.ctx.chartEventManager) === null || _a === void 0 ? void 0 : _a.addListener('legend-item-click', (event) => this.onLegendItemClick(event));\r\n    }\r\n    visibleChanged() {\r\n        this.processSeriesItemEnabled();\r\n    }\r\n    processSeriesItemEnabled() {\r\n        var _a;\r\n        const { data, visible } = this;\r\n        this.seriesItemEnabled = (_a = data === null || data === void 0 ? void 0 : data.map(() => visible)) !== null && _a !== void 0 ? _a : [];\r\n    }\r\n    nodeFactory() {\r\n        return new Sector();\r\n    }\r\n    getSeriesDomain(direction) {\r\n        if (direction === ChartAxisDirection.X) {\r\n            return this.angleScale.domain;\r\n        }\r\n        else {\r\n            return this.radiusScale.domain;\r\n        }\r\n    }\r\n    processData(dataController) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let { data } = this;\r\n            const { angleKey, radiusKey, calloutLabelKey, sectorLabelKey, legendItemKey, seriesItemEnabled } = this;\r\n            if (angleKey == null || data == null)\r\n                return;\r\n            const animationEnabled = !this.ctx.animationManager.isSkipped();\r\n            const extraKeyProps = [];\r\n            const extraProps = [];\r\n            // Order here should match `getDatumIdFromData()`.\r\n            if (legendItemKey) {\r\n                extraKeyProps.push(keyProperty(this, legendItemKey, false, { id: `legendItemKey` }));\r\n            }\r\n            else if (calloutLabelKey) {\r\n                extraKeyProps.push(keyProperty(this, calloutLabelKey, false, { id: `calloutLabelKey` }));\r\n            }\r\n            else if (sectorLabelKey) {\r\n                extraKeyProps.push(keyProperty(this, sectorLabelKey, false, { id: `sectorLabelKey` }));\r\n            }\r\n            if (radiusKey) {\r\n                extraProps.push(rangedValueProperty(this, radiusKey, {\r\n                    id: 'radiusValue',\r\n                    min: (_a = this.radiusMin) !== null && _a !== void 0 ? _a : 0,\r\n                    max: this.radiusMax,\r\n                }), valueProperty(this, radiusKey, true, { id: `radiusRaw` }), // Raw value pass-through.\r\n                normalisePropertyTo(this, { id: 'radiusValue' }, [0, 1], 1, (_b = this.radiusMin) !== null && _b !== void 0 ? _b : 0, this.radiusMax));\r\n            }\r\n            if (calloutLabelKey) {\r\n                extraProps.push(valueProperty(this, calloutLabelKey, false, { id: `calloutLabelValue` }));\r\n            }\r\n            if (sectorLabelKey) {\r\n                extraProps.push(valueProperty(this, sectorLabelKey, false, { id: `sectorLabelValue` }));\r\n            }\r\n            if (legendItemKey) {\r\n                extraProps.push(valueProperty(this, legendItemKey, false, { id: `legendItemValue` }));\r\n            }\r\n            if (animationEnabled && this.processedData && extraKeyProps.length > 0) {\r\n                extraProps.push(diff(this.processedData));\r\n            }\r\n            extraProps.push(animationValidation(this));\r\n            data = data.map((d, idx) => (seriesItemEnabled[idx] ? d : Object.assign(Object.assign({}, d), { [angleKey]: 0 })));\r\n            yield this.requestDataModel(dataController, data, {\r\n                props: [\r\n                    ...extraKeyProps,\r\n                    accumulativeValueProperty(this, angleKey, true, { id: `angleValue`, onlyPositive: true }),\r\n                    valueProperty(this, angleKey, true, { id: `angleRaw` }),\r\n                    normalisePropertyTo(this, { id: 'angleValue' }, [0, 1], 0, 0),\r\n                    ...extraProps,\r\n                ],\r\n            });\r\n            this.animationState.transition('updateData');\r\n        });\r\n    }\r\n    maybeRefreshNodeData() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this.nodeDataRefresh)\r\n                return;\r\n            const [{ nodeData = [] } = {}] = yield this.createNodeData();\r\n            this.nodeData = nodeData;\r\n            this.nodeDataRefresh = false;\r\n        });\r\n    }\r\n    getProcessedDataIndexes(dataModel) {\r\n        const angleIdx = dataModel.resolveProcessedDataIndexById(this, `angleValue`).index;\r\n        const radiusIdx = this.radiusKey ? dataModel.resolveProcessedDataIndexById(this, `radiusValue`).index : -1;\r\n        const calloutLabelIdx = this.calloutLabelKey\r\n            ? dataModel.resolveProcessedDataIndexById(this, `calloutLabelValue`).index\r\n            : -1;\r\n        const sectorLabelIdx = this.sectorLabelKey\r\n            ? dataModel.resolveProcessedDataIndexById(this, `sectorLabelValue`).index\r\n            : -1;\r\n        const legendItemIdx = this.legendItemKey\r\n            ? dataModel.resolveProcessedDataIndexById(this, `legendItemValue`).index\r\n            : -1;\r\n        return { angleIdx, radiusIdx, calloutLabelIdx, sectorLabelIdx, legendItemIdx };\r\n    }\r\n    createNodeData() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { id: seriesId, processedData, dataModel, rotation, angleScale } = this;\r\n            if (!processedData || !dataModel || processedData.type !== 'ungrouped')\r\n                return [];\r\n            const { angleIdx, radiusIdx, calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\r\n            let currentStart = 0;\r\n            const nodeData = processedData.data.map((group, index) => {\r\n                var _a;\r\n                const { datum, values } = group;\r\n                const currentValue = values[angleIdx];\r\n                const startAngle = angleScale.convert(currentStart) + toRadians(rotation);\r\n                currentStart = currentValue;\r\n                const endAngle = angleScale.convert(currentStart) + toRadians(rotation);\r\n                const span = Math.abs(endAngle - startAngle);\r\n                const midAngle = startAngle + span / 2;\r\n                const angleValue = values[angleIdx + 1];\r\n                const radius = radiusIdx >= 0 ? (_a = values[radiusIdx]) !== null && _a !== void 0 ? _a : 1 : 1;\r\n                const radiusValue = radiusIdx >= 0 ? values[radiusIdx + 1] : undefined;\r\n                const legendItemValue = legendItemIdx >= 0 ? values[legendItemIdx] : undefined;\r\n                const labels = this.getLabels(datum, midAngle, span, true, values[calloutLabelIdx], values[sectorLabelIdx], legendItemValue);\r\n                const sectorFormat = this.getSectorFormat(datum, index, false);\r\n                return Object.assign({ itemId: index, series: this, datum,\r\n                    index,\r\n                    angleValue,\r\n                    midAngle, midCos: Math.cos(midAngle), midSin: Math.sin(midAngle), startAngle,\r\n                    endAngle,\r\n                    sectorFormat,\r\n                    radiusValue,\r\n                    radius, innerRadius: Math.max(this.radiusScale.convert(0), 0), outerRadius: Math.max(this.radiusScale.convert(radius), 0), legendItemValue }, labels);\r\n            });\r\n            return [{ itemId: seriesId, nodeData, labelData: nodeData }];\r\n        });\r\n    }\r\n    getLabels(datum, midAngle, span, skipDisabled, calloutLabelValue, sectorLabelValue, legendItemValue) {\r\n        const { calloutLabel, sectorLabel, legendItemKey } = this;\r\n        const calloutLabelKey = !skipDisabled || calloutLabel.enabled ? this.calloutLabelKey : undefined;\r\n        const sectorLabelKey = !skipDisabled || sectorLabel.enabled ? this.sectorLabelKey : undefined;\r\n        if (!calloutLabelKey && !sectorLabelKey && !legendItemKey) {\r\n            return {};\r\n        }\r\n        const labelFormatterParams = {\r\n            datum,\r\n            angleKey: this.angleKey,\r\n            angleName: this.angleName,\r\n            radiusKey: this.radiusKey,\r\n            radiusName: this.radiusName,\r\n            calloutLabelKey: this.calloutLabelKey,\r\n            calloutLabelName: this.calloutLabelName,\r\n            sectorLabelKey: this.sectorLabelKey,\r\n            sectorLabelName: this.sectorLabelName,\r\n            legendItemKey: this.legendItemKey,\r\n        };\r\n        const result = {};\r\n        if (calloutLabelKey && span > toRadians(calloutLabel.minAngle)) {\r\n            result.calloutLabel = Object.assign(Object.assign({}, this.getTextAlignment(midAngle)), { text: this.getLabelText(calloutLabel, Object.assign(Object.assign({}, labelFormatterParams), { value: calloutLabelValue })), hidden: false, collisionTextAlign: undefined, collisionOffsetY: 0, box: undefined });\r\n        }\r\n        if (sectorLabelKey) {\r\n            result.sectorLabel = {\r\n                text: this.getLabelText(sectorLabel, Object.assign(Object.assign({}, labelFormatterParams), { value: sectorLabelValue })),\r\n            };\r\n        }\r\n        if (legendItemKey != null && legendItemValue != null) {\r\n            result.legendItem = { key: legendItemKey, text: legendItemValue };\r\n        }\r\n        return result;\r\n    }\r\n    getTextAlignment(midAngle) {\r\n        const quadrantTextOpts = [\r\n            { textAlign: 'center', textBaseline: 'bottom' },\r\n            { textAlign: 'left', textBaseline: 'middle' },\r\n            { textAlign: 'center', textBaseline: 'hanging' },\r\n            { textAlign: 'right', textBaseline: 'middle' },\r\n        ];\r\n        const midAngle180 = normalizeAngle180(midAngle);\r\n        // Split the circle into quadrants like so: ⊗\r\n        const quadrantStart = (-3 * Math.PI) / 4; // same as `normalizeAngle180(toRadians(-135))`\r\n        const quadrantOffset = midAngle180 - quadrantStart;\r\n        const quadrant = Math.floor(quadrantOffset / (Math.PI / 2));\r\n        const quadrantIndex = mod(quadrant, quadrantTextOpts.length);\r\n        return quadrantTextOpts[quadrantIndex];\r\n    }\r\n    getSectorFormat(datum, formatIndex, highlight) {\r\n        var _a, _b, _c, _d, _e;\r\n        const { angleKey, radiusKey, fills, strokes, formatter, id: seriesId, ctx: { callbackCache, highlightManager }, } = this;\r\n        const highlightedDatum = highlightManager.getActiveHighlight();\r\n        const isDatumHighlighted = highlight && (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.series) === this && formatIndex === highlightedDatum.itemId;\r\n        const { fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = mergeDefaults(isDatumHighlighted && this.highlightStyle.item, {\r\n            fill: fills[formatIndex % fills.length],\r\n            fillOpacity: this.fillOpacity,\r\n            stroke: strokes[formatIndex % strokes.length],\r\n            strokeWidth: this.getStrokeWidth(this.strokeWidth),\r\n            strokeOpacity: this.getOpacity(),\r\n        });\r\n        let format;\r\n        if (formatter) {\r\n            format = callbackCache.call(formatter, {\r\n                datum,\r\n                angleKey,\r\n                radiusKey,\r\n                fill,\r\n                stroke,\r\n                fills,\r\n                strokes,\r\n                strokeWidth,\r\n                highlighted: isDatumHighlighted,\r\n                seriesId,\r\n            });\r\n        }\r\n        return {\r\n            fill: (_a = format === null || format === void 0 ? void 0 : format.fill) !== null && _a !== void 0 ? _a : fill,\r\n            fillOpacity: (_b = format === null || format === void 0 ? void 0 : format.fillOpacity) !== null && _b !== void 0 ? _b : fillOpacity,\r\n            stroke: (_c = format === null || format === void 0 ? void 0 : format.stroke) !== null && _c !== void 0 ? _c : stroke,\r\n            strokeWidth: (_d = format === null || format === void 0 ? void 0 : format.strokeWidth) !== null && _d !== void 0 ? _d : strokeWidth,\r\n            strokeOpacity: (_e = format === null || format === void 0 ? void 0 : format.strokeOpacity) !== null && _e !== void 0 ? _e : strokeOpacity,\r\n        };\r\n    }\r\n    getInnerRadius() {\r\n        const { radius, innerRadiusRatio, innerRadiusOffset } = this;\r\n        const innerRadius = radius * innerRadiusRatio + innerRadiusOffset;\r\n        if (innerRadius === radius || innerRadius < 0) {\r\n            return 0;\r\n        }\r\n        return innerRadius;\r\n    }\r\n    getOuterRadius() {\r\n        return Math.max(this.radius * this.outerRadiusRatio + this.outerRadiusOffset, 0);\r\n    }\r\n    updateRadiusScale(resize) {\r\n        const newRange = [this.getInnerRadius(), this.getOuterRadius()];\r\n        this.radiusScale.range = newRange;\r\n        if (resize) {\r\n            this.previousRadiusScale.range = newRange;\r\n        }\r\n        this.nodeData = this.nodeData.map((_a) => {\r\n            var { radius } = _a, d = __rest(_a, [\"radius\"]);\r\n            return Object.assign(Object.assign({}, d), { radius, innerRadius: Math.max(this.radiusScale.convert(0), 0), outerRadius: Math.max(this.radiusScale.convert(radius), 0) });\r\n        });\r\n    }\r\n    getTitleTranslationY() {\r\n        var _a, _b;\r\n        const outerRadius = Math.max(0, this.radiusScale.range[1]);\r\n        if (outerRadius === 0) {\r\n            return NaN;\r\n        }\r\n        const spacing = (_b = (_a = this.title) === null || _a === void 0 ? void 0 : _a.spacing) !== null && _b !== void 0 ? _b : 0;\r\n        const titleOffset = 2 + spacing;\r\n        const dy = Math.max(0, -outerRadius);\r\n        return -outerRadius - titleOffset - dy;\r\n    }\r\n    update({ seriesRect }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { title } = this;\r\n            const newNodeDataDependencies = {\r\n                seriesRectWidth: seriesRect === null || seriesRect === void 0 ? void 0 : seriesRect.width,\r\n                seriesRectHeight: seriesRect === null || seriesRect === void 0 ? void 0 : seriesRect.height,\r\n            };\r\n            const resize = jsonDiff(this.nodeDataDependencies, newNodeDataDependencies) != null;\r\n            if (resize) {\r\n                this.nodeDataDependencies = newNodeDataDependencies;\r\n            }\r\n            yield this.maybeRefreshNodeData();\r\n            this.updateTitleNodes();\r\n            this.updateRadiusScale(resize);\r\n            this.contentGroup.translationX = this.centerX;\r\n            this.contentGroup.translationY = this.centerY;\r\n            this.highlightGroup.translationX = this.centerX;\r\n            this.highlightGroup.translationY = this.centerY;\r\n            this.backgroundGroup.translationX = this.centerX;\r\n            this.backgroundGroup.translationY = this.centerY;\r\n            if (this.labelGroup) {\r\n                this.labelGroup.translationX = this.centerX;\r\n                this.labelGroup.translationY = this.centerY;\r\n            }\r\n            if (title) {\r\n                const dy = this.getTitleTranslationY();\r\n                const titleBox = title.node.computeBBox();\r\n                title.node.visible =\r\n                    title.enabled && isFinite(dy) && !this.bboxIntersectsSurroundingSeries(titleBox, 0, dy);\r\n                title.node.translationY = isFinite(dy) ? dy : 0;\r\n            }\r\n            this.updateNodeMidPoint();\r\n            yield this.updateSelections();\r\n            yield this.updateNodes(seriesRect);\r\n        });\r\n    }\r\n    updateTitleNodes() {\r\n        var _a, _b;\r\n        const { title, oldTitle } = this;\r\n        if (oldTitle !== title) {\r\n            if (oldTitle) {\r\n                (_a = this.labelGroup) === null || _a === void 0 ? void 0 : _a.removeChild(oldTitle.node);\r\n            }\r\n            if (title) {\r\n                title.node.textBaseline = 'bottom';\r\n                (_b = this.labelGroup) === null || _b === void 0 ? void 0 : _b.appendChild(title.node);\r\n            }\r\n            this.oldTitle = title;\r\n        }\r\n    }\r\n    updateNodeMidPoint() {\r\n        this.nodeData.forEach((d) => {\r\n            const radius = d.innerRadius + (d.outerRadius - d.innerRadius) / 2;\r\n            d.midPoint = {\r\n                x: d.midCos * Math.max(0, radius),\r\n                y: d.midSin * Math.max(0, radius),\r\n            };\r\n        });\r\n    }\r\n    updateSelections() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.updateGroupSelection();\r\n            this.updateInnerCircleSelection();\r\n        });\r\n    }\r\n    updateGroupSelection() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { itemSelection, highlightSelection, calloutLabelSelection, sectorLabelSelection, innerLabelsSelection } = this;\r\n            const update = (selection, clone) => {\r\n                let nodeData = this.nodeData;\r\n                if (clone) {\r\n                    // Allow mutable sectorFormat, so formatted sector styles can be updated and varied\r\n                    // between normal and highlighted cases.\r\n                    nodeData = nodeData.map((datum) => (Object.assign(Object.assign({}, datum), { sectorFormat: Object.assign({}, datum.sectorFormat) })));\r\n                }\r\n                selection.update(nodeData);\r\n                if (this.ctx.animationManager.isSkipped()) {\r\n                    selection.cleanup();\r\n                }\r\n            };\r\n            update(itemSelection, false);\r\n            update(highlightSelection, true);\r\n            calloutLabelSelection.update(this.nodeData, (group) => {\r\n                const line = new Line();\r\n                line.tag = PieNodeTag.Callout;\r\n                line.pointerEvents = PointerEvents.None;\r\n                group.appendChild(line);\r\n                const text = new Text();\r\n                text.tag = PieNodeTag.Label;\r\n                text.pointerEvents = PointerEvents.None;\r\n                group.appendChild(text);\r\n            });\r\n            sectorLabelSelection.update(this.nodeData, (node) => {\r\n                node.pointerEvents = PointerEvents.None;\r\n            });\r\n            innerLabelsSelection.update(this.innerLabels, (node) => {\r\n                node.pointerEvents = PointerEvents.None;\r\n            });\r\n        });\r\n    }\r\n    updateInnerCircleSelection() {\r\n        const { innerCircle } = this;\r\n        let radius = 0;\r\n        const innerRadius = this.getInnerRadius();\r\n        if (innerRadius > 0) {\r\n            const circleRadius = Math.min(innerRadius, this.getOuterRadius());\r\n            const antiAliasingPadding = 1;\r\n            radius = Math.ceil(circleRadius * 2 + antiAliasingPadding);\r\n        }\r\n        const datums = innerCircle ? [{ radius }] : [];\r\n        this.innerCircleSelection.update(datums);\r\n    }\r\n    updateNodes(seriesRect) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const highlightedDatum = this.ctx.highlightManager.getActiveHighlight();\r\n            const isVisible = this.seriesItemEnabled.indexOf(true) >= 0;\r\n            this.rootGroup.visible = isVisible;\r\n            this.backgroundGroup.visible = isVisible;\r\n            this.contentGroup.visible = isVisible;\r\n            this.highlightGroup.visible = isVisible && (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.series) === this;\r\n            if (this.labelGroup) {\r\n                this.labelGroup.visible = isVisible;\r\n            }\r\n            this.contentGroup.opacity = this.getOpacity();\r\n            this.innerCircleSelection.each((node, { radius }) => {\r\n                var _a, _b;\r\n                node.setProperties({\r\n                    fill: (_a = this.innerCircle) === null || _a === void 0 ? void 0 : _a.fill,\r\n                    opacity: (_b = this.innerCircle) === null || _b === void 0 ? void 0 : _b.fillOpacity,\r\n                    size: radius,\r\n                });\r\n            });\r\n            const updateSectorFn = (sector, datum, _index, isDatumHighlighted) => {\r\n                const format = this.getSectorFormat(datum.datum, datum.itemId, isDatumHighlighted);\r\n                datum.sectorFormat.fill = format.fill;\r\n                datum.sectorFormat.stroke = format.stroke;\r\n                const animationDisabled = this.ctx.animationManager.isSkipped();\r\n                if (animationDisabled) {\r\n                    sector.startAngle = datum.startAngle;\r\n                    sector.endAngle = datum.endAngle;\r\n                    sector.innerRadius = datum.innerRadius;\r\n                    sector.outerRadius = datum.outerRadius;\r\n                }\r\n                if (isDatumHighlighted || animationDisabled) {\r\n                    sector.fill = format.fill;\r\n                    sector.stroke = format.stroke;\r\n                }\r\n                sector.strokeWidth = format.strokeWidth;\r\n                sector.fillOpacity = format.fillOpacity;\r\n                sector.strokeOpacity = this.strokeOpacity;\r\n                sector.lineDash = this.lineDash;\r\n                sector.lineDashOffset = this.lineDashOffset;\r\n                sector.fillShadow = this.shadow;\r\n                sector.lineJoin = 'round';\r\n            };\r\n            this.itemSelection.each((node, datum, index) => updateSectorFn(node, datum, index, false));\r\n            this.highlightSelection.each((node, datum, index) => {\r\n                const isDatumHighlighted = (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.series) === this && node.datum.itemId === highlightedDatum.itemId;\r\n                updateSectorFn(node, datum, index, isDatumHighlighted);\r\n                node.visible = isDatumHighlighted;\r\n            });\r\n            this.updateCalloutLineNodes();\r\n            this.updateCalloutLabelNodes(seriesRect);\r\n            this.updateSectorLabelNodes();\r\n            this.updateInnerLabelNodes();\r\n            this.animationState.transition('update');\r\n        });\r\n    }\r\n    updateCalloutLineNodes() {\r\n        var _a;\r\n        const { calloutLine } = this;\r\n        const calloutLength = calloutLine.length;\r\n        const calloutStrokeWidth = calloutLine.strokeWidth;\r\n        const calloutColors = (_a = calloutLine.colors) !== null && _a !== void 0 ? _a : this.strokes;\r\n        const { offset } = this.calloutLabel;\r\n        this.calloutLabelSelection.selectByTag(PieNodeTag.Callout).forEach((line, index) => {\r\n            const datum = line.datum;\r\n            const { calloutLabel: label, outerRadius } = datum;\r\n            if ((label === null || label === void 0 ? void 0 : label.text) && !label.hidden && outerRadius !== 0) {\r\n                line.visible = true;\r\n                line.strokeWidth = calloutStrokeWidth;\r\n                line.stroke = calloutColors[index % calloutColors.length];\r\n                line.fill = undefined;\r\n                const x1 = datum.midCos * outerRadius;\r\n                const y1 = datum.midSin * outerRadius;\r\n                let x2 = datum.midCos * (outerRadius + calloutLength);\r\n                let y2 = datum.midSin * (outerRadius + calloutLength);\r\n                const isMoved = label.collisionTextAlign || label.collisionOffsetY !== 0;\r\n                if (isMoved && label.box != null) {\r\n                    // Get the closest point to the text bounding box\r\n                    const box = label.box;\r\n                    let cx = x2;\r\n                    let cy = y2;\r\n                    if (x2 < box.x) {\r\n                        cx = box.x;\r\n                    }\r\n                    else if (x2 > box.x + box.width) {\r\n                        cx = box.x + box.width;\r\n                    }\r\n                    if (y2 < box.y) {\r\n                        cy = box.y;\r\n                    }\r\n                    else if (y2 > box.y + box.height) {\r\n                        cy = box.y + box.height;\r\n                    }\r\n                    // Apply label offset\r\n                    const dx = cx - x2;\r\n                    const dy = cy - y2;\r\n                    const length = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\r\n                    const paddedLength = length - offset;\r\n                    if (paddedLength > 0) {\r\n                        x2 = x2 + (dx * paddedLength) / length;\r\n                        y2 = y2 + (dy * paddedLength) / length;\r\n                    }\r\n                }\r\n                line.x1 = x1;\r\n                line.y1 = y1;\r\n                line.x2 = x2;\r\n                line.y2 = y2;\r\n            }\r\n            else {\r\n                line.visible = false;\r\n            }\r\n        });\r\n    }\r\n    getLabelOverflow(text, box, seriesRect) {\r\n        const seriesLeft = seriesRect.x - this.centerX;\r\n        const seriesRight = seriesRect.x + seriesRect.width - this.centerX;\r\n        const seriesTop = seriesRect.y - this.centerY;\r\n        const seriesBottom = seriesRect.y + seriesRect.height - this.centerY;\r\n        const errPx = 1; // Prevents errors related to floating point calculations\r\n        let visibleTextPart = 1;\r\n        if (box.x + errPx < seriesLeft) {\r\n            visibleTextPart = (box.x + box.width - seriesLeft) / box.width;\r\n        }\r\n        else if (box.x + box.width - errPx > seriesRight) {\r\n            visibleTextPart = (seriesRight - box.x) / box.width;\r\n        }\r\n        const hasVerticalOverflow = box.y + errPx < seriesTop || box.y + box.height - errPx > seriesBottom;\r\n        const textLength = visibleTextPart === 1 ? text.length : Math.floor(text.length * visibleTextPart) - 1;\r\n        const hasSurroundingSeriesOverflow = this.bboxIntersectsSurroundingSeries(box);\r\n        return { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow };\r\n    }\r\n    bboxIntersectsSurroundingSeries(box, dx = 0, dy = 0) {\r\n        const { surroundingRadius } = this;\r\n        if (surroundingRadius == null) {\r\n            return false;\r\n        }\r\n        const corners = [\r\n            { x: box.x + dx, y: box.y + dy },\r\n            { x: box.x + box.width + dx, y: box.y + dy },\r\n            { x: box.x + box.width + dx, y: box.y + box.height + dy },\r\n            { x: box.x + dx, y: box.y + box.height + dy },\r\n        ];\r\n        const sur2 = Math.pow(surroundingRadius, 2);\r\n        return corners.some((corner) => Math.pow(corner.x, 2) + Math.pow(corner.y, 2) > sur2);\r\n    }\r\n    computeCalloutLabelCollisionOffsets() {\r\n        const { radiusScale, calloutLabel, calloutLine } = this;\r\n        const { offset, minSpacing } = calloutLabel;\r\n        const innerRadius = radiusScale.convert(0);\r\n        const shouldSkip = (datum) => {\r\n            const label = datum.calloutLabel;\r\n            return !label || datum.outerRadius === 0;\r\n        };\r\n        const fullData = this.nodeData;\r\n        const data = this.nodeData.filter((t) => !shouldSkip(t));\r\n        data.forEach((datum) => {\r\n            const label = datum.calloutLabel;\r\n            if (label == null)\r\n                return;\r\n            label.hidden = false;\r\n            label.collisionTextAlign = undefined;\r\n            label.collisionOffsetY = 0;\r\n        });\r\n        if (data.length <= 1) {\r\n            return;\r\n        }\r\n        const leftLabels = data.filter((d) => d.midCos < 0).sort((a, b) => a.midSin - b.midSin);\r\n        const rightLabels = data.filter((d) => d.midCos >= 0).sort((a, b) => a.midSin - b.midSin);\r\n        const topLabels = data\r\n            .filter((d) => { var _a; return d.midSin < 0 && ((_a = d.calloutLabel) === null || _a === void 0 ? void 0 : _a.textAlign) === 'center'; })\r\n            .sort((a, b) => a.midCos - b.midCos);\r\n        const bottomLabels = data\r\n            .filter((d) => { var _a; return d.midSin >= 0 && ((_a = d.calloutLabel) === null || _a === void 0 ? void 0 : _a.textAlign) === 'center'; })\r\n            .sort((a, b) => a.midCos - b.midCos);\r\n        const tempTextNode = new Text();\r\n        const getTextBBox = (datum) => {\r\n            var _a;\r\n            const label = datum.calloutLabel;\r\n            if (label == null)\r\n                return new BBox(0, 0, 0, 0);\r\n            const labelRadius = datum.outerRadius + calloutLine.length + offset;\r\n            const x = datum.midCos * labelRadius;\r\n            const y = datum.midSin * labelRadius + label.collisionOffsetY;\r\n            tempTextNode.text = label.text;\r\n            tempTextNode.x = x;\r\n            tempTextNode.y = y;\r\n            tempTextNode.setFont(this.calloutLabel);\r\n            tempTextNode.setAlign({\r\n                textAlign: (_a = label.collisionTextAlign) !== null && _a !== void 0 ? _a : label.textAlign,\r\n                textBaseline: label.textBaseline,\r\n            });\r\n            return tempTextNode.computeBBox();\r\n        };\r\n        const avoidNeighbourYCollision = (label, next, direction) => {\r\n            const box = getTextBBox(label).grow(minSpacing / 2);\r\n            const other = getTextBBox(next).grow(minSpacing / 2);\r\n            // The full collision is not detected, because sometimes\r\n            // the next label can appear behind the label with offset\r\n            const collidesOrBehind = box.x < other.x + other.width &&\r\n                box.x + box.width > other.x &&\r\n                (direction === 'to-top' ? box.y < other.y + other.height : box.y + box.height > other.y);\r\n            if (collidesOrBehind) {\r\n                const dy = direction === 'to-top' ? box.y - other.y - other.height : box.y + box.height - other.y;\r\n                next.calloutLabel.collisionOffsetY = dy;\r\n            }\r\n        };\r\n        const avoidYCollisions = (labels) => {\r\n            const midLabel = labels.slice().sort((a, b) => Math.abs(a.midSin) - Math.abs(b.midSin))[0];\r\n            const midIndex = labels.indexOf(midLabel);\r\n            for (let i = midIndex - 1; i >= 0; i--) {\r\n                const prev = labels[i + 1];\r\n                const next = labels[i];\r\n                avoidNeighbourYCollision(prev, next, 'to-top');\r\n            }\r\n            for (let i = midIndex + 1; i < labels.length; i++) {\r\n                const prev = labels[i - 1];\r\n                const next = labels[i];\r\n                avoidNeighbourYCollision(prev, next, 'to-bottom');\r\n            }\r\n        };\r\n        const avoidXCollisions = (labels) => {\r\n            const labelsCollideLabelsByY = data.some((datum) => datum.calloutLabel.collisionOffsetY !== 0);\r\n            const boxes = labels.map((label) => getTextBBox(label));\r\n            const paddedBoxes = boxes.map((box) => box.clone().grow(minSpacing / 2));\r\n            let labelsCollideLabelsByX = false;\r\n            for (let i = 0; i < paddedBoxes.length && !labelsCollideLabelsByX; i++) {\r\n                const box = paddedBoxes[i];\r\n                for (let j = i + 1; j < labels.length; j++) {\r\n                    const other = paddedBoxes[j];\r\n                    if (box.collidesBBox(other)) {\r\n                        labelsCollideLabelsByX = true;\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            const sectors = fullData.map((datum) => {\r\n                const { startAngle, endAngle, outerRadius } = datum;\r\n                return { startAngle, endAngle, innerRadius, outerRadius };\r\n            });\r\n            const labelsCollideSectors = boxes.some((box) => {\r\n                return sectors.some((sector) => boxCollidesSector(box, sector));\r\n            });\r\n            if (!labelsCollideLabelsByX && !labelsCollideLabelsByY && !labelsCollideSectors) {\r\n                return;\r\n            }\r\n            labels\r\n                .filter((d) => d.calloutLabel.textAlign === 'center')\r\n                .forEach((d) => {\r\n                const label = d.calloutLabel;\r\n                if (d.midCos < 0) {\r\n                    label.collisionTextAlign = 'right';\r\n                }\r\n                else if (d.midCos > 0) {\r\n                    label.collisionTextAlign = 'left';\r\n                }\r\n                else {\r\n                    label.collisionTextAlign = 'center';\r\n                }\r\n            });\r\n        };\r\n        avoidYCollisions(leftLabels);\r\n        avoidYCollisions(rightLabels);\r\n        avoidXCollisions(topLabels);\r\n        avoidXCollisions(bottomLabels);\r\n    }\r\n    updateCalloutLabelNodes(seriesRect) {\r\n        const { radiusScale, calloutLabel, calloutLine } = this;\r\n        const calloutLength = calloutLine.length;\r\n        const { offset, color } = calloutLabel;\r\n        const tempTextNode = new Text();\r\n        this.calloutLabelSelection.selectByTag(PieNodeTag.Label).forEach((text) => {\r\n            var _a;\r\n            const { datum } = text;\r\n            const label = datum.calloutLabel;\r\n            const radius = radiusScale.convert(datum.radius);\r\n            const outerRadius = Math.max(0, radius);\r\n            if (!(label === null || label === void 0 ? void 0 : label.text) || outerRadius === 0 || label.hidden) {\r\n                text.visible = false;\r\n                return;\r\n            }\r\n            const labelRadius = outerRadius + calloutLength + offset;\r\n            const x = datum.midCos * labelRadius;\r\n            const y = datum.midSin * labelRadius + label.collisionOffsetY;\r\n            // Detect text overflow\r\n            const align = {\r\n                textAlign: (_a = label.collisionTextAlign) !== null && _a !== void 0 ? _a : label.textAlign,\r\n                textBaseline: label.textBaseline,\r\n            };\r\n            tempTextNode.text = label.text;\r\n            tempTextNode.x = x;\r\n            tempTextNode.y = y;\r\n            tempTextNode.setFont(this.calloutLabel);\r\n            tempTextNode.setAlign(align);\r\n            const box = tempTextNode.computeBBox();\r\n            let displayText = label.text;\r\n            let visible = true;\r\n            if (calloutLabel.avoidCollisions) {\r\n                const { textLength, hasVerticalOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\r\n                displayText = label.text.length === textLength ? label.text : `${label.text.substring(0, textLength)}…`;\r\n                visible = !hasVerticalOverflow;\r\n            }\r\n            text.text = displayText;\r\n            text.x = x;\r\n            text.y = y;\r\n            text.setFont(this.calloutLabel);\r\n            text.setAlign(align);\r\n            text.fill = color;\r\n            text.visible = visible;\r\n        });\r\n    }\r\n    computeLabelsBBox(options, seriesRect) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { calloutLabel, calloutLine } = this;\r\n            const calloutLength = calloutLine.length;\r\n            const { offset, maxCollisionOffset, minSpacing } = calloutLabel;\r\n            if (!calloutLabel.avoidCollisions) {\r\n                return null;\r\n            }\r\n            yield this.maybeRefreshNodeData();\r\n            this.updateRadiusScale(false);\r\n            this.computeCalloutLabelCollisionOffsets();\r\n            const textBoxes = [];\r\n            const text = new Text();\r\n            let titleBox;\r\n            if (((_a = this.title) === null || _a === void 0 ? void 0 : _a.text) && this.title.enabled) {\r\n                const dy = this.getTitleTranslationY();\r\n                if (isFinite(dy)) {\r\n                    text.text = this.title.text;\r\n                    text.x = 0;\r\n                    text.y = dy;\r\n                    text.setFont(this.title);\r\n                    text.setAlign({\r\n                        textBaseline: 'bottom',\r\n                        textAlign: 'center',\r\n                    });\r\n                    titleBox = text.computeBBox();\r\n                    textBoxes.push(titleBox);\r\n                }\r\n            }\r\n            this.nodeData.forEach((datum) => {\r\n                var _a;\r\n                const label = datum.calloutLabel;\r\n                if (!label || datum.outerRadius === 0) {\r\n                    return null;\r\n                }\r\n                const labelRadius = datum.outerRadius + calloutLength + offset;\r\n                const x = datum.midCos * labelRadius;\r\n                const y = datum.midSin * labelRadius + label.collisionOffsetY;\r\n                text.text = label.text;\r\n                text.x = x;\r\n                text.y = y;\r\n                text.setFont(this.calloutLabel);\r\n                text.setAlign({\r\n                    textAlign: (_a = label.collisionTextAlign) !== null && _a !== void 0 ? _a : label.textAlign,\r\n                    textBaseline: label.textBaseline,\r\n                });\r\n                const box = text.computeBBox();\r\n                label.box = box;\r\n                // Hide labels that where pushed too far by the collision avoidance algorithm\r\n                if (Math.abs(label.collisionOffsetY) > maxCollisionOffset) {\r\n                    label.hidden = true;\r\n                    return;\r\n                }\r\n                // Hide labels intersecting or above the title\r\n                if (titleBox) {\r\n                    const seriesTop = seriesRect.y - this.centerY;\r\n                    const titleCleanArea = new BBox(titleBox.x - minSpacing, seriesTop, titleBox.width + 2 * minSpacing, titleBox.y + titleBox.height + minSpacing - seriesTop);\r\n                    if (box.collidesBBox(titleCleanArea)) {\r\n                        label.hidden = true;\r\n                        return;\r\n                    }\r\n                }\r\n                if (options.hideWhenNecessary) {\r\n                    const { textLength, hasVerticalOverflow, hasSurroundingSeriesOverflow } = this.getLabelOverflow(label.text, box, seriesRect);\r\n                    const isTooShort = label.text.length > 2 && textLength < 2;\r\n                    if (hasVerticalOverflow || isTooShort || hasSurroundingSeriesOverflow) {\r\n                        label.hidden = true;\r\n                        return;\r\n                    }\r\n                }\r\n                label.hidden = false;\r\n                textBoxes.push(box);\r\n            });\r\n            if (textBoxes.length === 0) {\r\n                return null;\r\n            }\r\n            return BBox.merge(textBoxes);\r\n        });\r\n    }\r\n    updateSectorLabelNodes() {\r\n        const { radiusScale } = this;\r\n        const innerRadius = radiusScale.convert(0);\r\n        const { fontSize, fontStyle, fontWeight, fontFamily, positionOffset, positionRatio, color } = this.sectorLabel;\r\n        const isDoughnut = innerRadius > 0;\r\n        const singleVisibleSector = this.seriesItemEnabled.filter(Boolean).length === 1;\r\n        this.sectorLabelSelection.each((text, datum) => {\r\n            const { sectorLabel, outerRadius } = datum;\r\n            let isTextVisible = false;\r\n            if (sectorLabel && outerRadius !== 0) {\r\n                const labelRadius = innerRadius * (1 - positionRatio) + outerRadius * positionRatio + positionOffset;\r\n                text.fill = color;\r\n                text.fontStyle = fontStyle;\r\n                text.fontWeight = fontWeight;\r\n                text.fontSize = fontSize;\r\n                text.fontFamily = fontFamily;\r\n                text.text = sectorLabel.text;\r\n                const shouldPutTextInCenter = !isDoughnut && singleVisibleSector;\r\n                if (shouldPutTextInCenter) {\r\n                    text.x = 0;\r\n                    text.y = 0;\r\n                }\r\n                else {\r\n                    text.x = datum.midCos * labelRadius;\r\n                    text.y = datum.midSin * labelRadius;\r\n                }\r\n                text.textAlign = 'center';\r\n                text.textBaseline = 'middle';\r\n                const bbox = text.computeBBox();\r\n                const corners = [\r\n                    [bbox.x, bbox.y],\r\n                    [bbox.x + bbox.width, bbox.y],\r\n                    [bbox.x + bbox.width, bbox.y + bbox.height],\r\n                    [bbox.x, bbox.y + bbox.height],\r\n                ];\r\n                const { startAngle, endAngle } = datum;\r\n                const sectorBounds = { startAngle, endAngle, innerRadius, outerRadius };\r\n                if (corners.every(([x, y]) => isPointInSector(x, y, sectorBounds))) {\r\n                    isTextVisible = true;\r\n                }\r\n            }\r\n            text.visible = isTextVisible;\r\n        });\r\n    }\r\n    updateInnerLabelNodes() {\r\n        const textBBoxes = [];\r\n        const margins = [];\r\n        this.innerLabelsSelection.each((text, datum) => {\r\n            const { fontStyle, fontWeight, fontSize, fontFamily, color } = datum;\r\n            text.fontStyle = fontStyle;\r\n            text.fontWeight = fontWeight;\r\n            text.fontSize = fontSize;\r\n            text.fontFamily = fontFamily;\r\n            text.text = datum.text;\r\n            text.x = 0;\r\n            text.y = 0;\r\n            text.fill = color;\r\n            text.textAlign = 'center';\r\n            text.textBaseline = 'alphabetic';\r\n            textBBoxes.push(text.computeBBox());\r\n            margins.push(datum.margin);\r\n        });\r\n        const getMarginTop = (index) => (index === 0 ? 0 : margins[index]);\r\n        const getMarginBottom = (index) => (index === margins.length - 1 ? 0 : margins[index]);\r\n        const totalHeight = textBBoxes.reduce((sum, bbox, i) => {\r\n            return sum + bbox.height + getMarginTop(i) + getMarginBottom(i);\r\n        }, 0);\r\n        const totalWidth = Math.max(...textBBoxes.map((bbox) => bbox.width));\r\n        const innerRadius = this.getInnerRadius();\r\n        const labelRadius = Math.sqrt(Math.pow(totalWidth / 2, 2) + Math.pow(totalHeight / 2, 2));\r\n        const labelsVisible = labelRadius <= (innerRadius > 0 ? innerRadius : this.getOuterRadius());\r\n        const textBottoms = [];\r\n        for (let i = 0, prev = -totalHeight / 2; i < textBBoxes.length; i++) {\r\n            const bbox = textBBoxes[i];\r\n            const bottom = bbox.height + prev + getMarginTop(i);\r\n            textBottoms.push(bottom);\r\n            prev = bottom + getMarginBottom(i);\r\n        }\r\n        this.innerLabelsSelection.each((text, _datum, index) => {\r\n            text.y = textBottoms[index];\r\n            text.visible = labelsVisible;\r\n        });\r\n    }\r\n    getDatumLegendName(nodeDatum) {\r\n        const { angleKey, calloutLabelKey, sectorLabelKey, legendItemKey } = this;\r\n        const { sectorLabel, calloutLabel, legendItem } = nodeDatum;\r\n        if (legendItemKey && legendItem !== undefined) {\r\n            return legendItem.text;\r\n        }\r\n        else if (calloutLabelKey && calloutLabelKey !== angleKey && (calloutLabel === null || calloutLabel === void 0 ? void 0 : calloutLabel.text) !== undefined) {\r\n            return calloutLabel.text;\r\n        }\r\n        else if (sectorLabelKey && sectorLabelKey !== angleKey && (sectorLabel === null || sectorLabel === void 0 ? void 0 : sectorLabel.text) !== undefined) {\r\n            return sectorLabel.text;\r\n        }\r\n    }\r\n    getTooltipHtml(nodeDatum) {\r\n        var _a;\r\n        if (!this.angleKey) {\r\n            return '';\r\n        }\r\n        const { datum, angleValue, sectorFormat: { fill: color }, } = nodeDatum;\r\n        const title = sanitizeHtml((_a = this.title) === null || _a === void 0 ? void 0 : _a.text);\r\n        const content = isNumber(angleValue) ? toFixed(angleValue) : String(angleValue);\r\n        const labelText = this.getDatumLegendName(nodeDatum);\r\n        return this.tooltip.toTooltipHtml({\r\n            title: title !== null && title !== void 0 ? title : labelText,\r\n            content: title && labelText ? `${labelText}: ${content}` : content,\r\n            backgroundColor: color,\r\n        }, {\r\n            datum,\r\n            title,\r\n            color,\r\n            seriesId: this.id,\r\n            angleKey: this.angleKey,\r\n            angleName: this.angleName,\r\n            radiusKey: this.radiusKey,\r\n            radiusName: this.radiusName,\r\n            calloutLabelKey: this.calloutLabelKey,\r\n            calloutLabelName: this.calloutLabelName,\r\n            sectorLabelKey: this.sectorLabelKey,\r\n            sectorLabelName: this.sectorLabelName,\r\n        });\r\n    }\r\n    getLegendData(legendType) {\r\n        var _a, _b, _c, _d, _e;\r\n        const { processedData, angleKey, calloutLabelKey, sectorLabelKey, legendItemKey, id, dataModel } = this;\r\n        if (!dataModel || !processedData || processedData.data.length === 0 || legendType !== 'category')\r\n            return [];\r\n        if (!legendItemKey &&\r\n            (!calloutLabelKey || calloutLabelKey === angleKey) &&\r\n            (!sectorLabelKey || sectorLabelKey === angleKey))\r\n            return [];\r\n        const { calloutLabelIdx, sectorLabelIdx, legendItemIdx } = this.getProcessedDataIndexes(dataModel);\r\n        const titleText = ((_a = this.title) === null || _a === void 0 ? void 0 : _a.showInLegend) && this.title.text;\r\n        const legendData = [];\r\n        for (let index = 0; index < processedData.data.length; index++) {\r\n            const { datum, values } = processedData.data[index];\r\n            const labelParts = [];\r\n            if (titleText) {\r\n                labelParts.push(titleText);\r\n            }\r\n            const labels = this.getLabels(datum, 2 * Math.PI, 2 * Math.PI, false, values[calloutLabelIdx], values[sectorLabelIdx], values[legendItemIdx]);\r\n            if (legendItemKey && labels.legendItem !== undefined) {\r\n                labelParts.push(labels.legendItem.text);\r\n            }\r\n            else if (calloutLabelKey && calloutLabelKey !== angleKey && ((_b = labels.calloutLabel) === null || _b === void 0 ? void 0 : _b.text) !== undefined) {\r\n                labelParts.push((_c = labels.calloutLabel) === null || _c === void 0 ? void 0 : _c.text);\r\n            }\r\n            else if (sectorLabelKey && sectorLabelKey !== angleKey && ((_d = labels.sectorLabel) === null || _d === void 0 ? void 0 : _d.text) !== undefined) {\r\n                labelParts.push((_e = labels.sectorLabel) === null || _e === void 0 ? void 0 : _e.text);\r\n            }\r\n            if (labelParts.length === 0)\r\n                continue;\r\n            const sectorFormat = this.getSectorFormat(datum, index, false);\r\n            legendData.push({\r\n                legendType: 'category',\r\n                id,\r\n                itemId: index,\r\n                seriesId: id,\r\n                enabled: this.seriesItemEnabled[index],\r\n                label: {\r\n                    text: labelParts.join(' - '),\r\n                },\r\n                marker: {\r\n                    fill: sectorFormat.fill,\r\n                    stroke: sectorFormat.stroke,\r\n                    fillOpacity: this.fillOpacity,\r\n                    strokeOpacity: this.strokeOpacity,\r\n                    strokeWidth: this.strokeWidth,\r\n                },\r\n            });\r\n        }\r\n        return legendData;\r\n    }\r\n    onLegendItemClick(event) {\r\n        const { enabled, itemId, series } = event;\r\n        if (series.id === this.id) {\r\n            this.toggleSeriesItem(itemId, enabled);\r\n        }\r\n        else if (series.type === 'pie') {\r\n            this.toggleOtherSeriesItems(series, itemId, enabled);\r\n        }\r\n    }\r\n    toggleSeriesItem(itemId, enabled) {\r\n        this.seriesItemEnabled[itemId] = enabled;\r\n        this.nodeDataRefresh = true;\r\n    }\r\n    toggleOtherSeriesItems(series, itemId, enabled) {\r\n        var _a, _b;\r\n        const { legendItemKey, dataModel } = this;\r\n        if (!legendItemKey || !dataModel)\r\n            return;\r\n        const datumToggledLegendItemValue = series.legendItemKey && ((_a = series.data) === null || _a === void 0 ? void 0 : _a.find((_, index) => index === itemId)[series.legendItemKey]);\r\n        if (!datumToggledLegendItemValue)\r\n            return;\r\n        const legendItemIdx = dataModel.resolveProcessedDataIndexById(this, `legendItemValue`).index;\r\n        (_b = this.processedData) === null || _b === void 0 ? void 0 : _b.data.forEach(({ values }, datumItemId) => {\r\n            if (values[legendItemIdx] === datumToggledLegendItemValue) {\r\n                this.toggleSeriesItem(datumItemId, enabled);\r\n            }\r\n        });\r\n    }\r\n    animateEmptyUpdateReady(_data) {\r\n        const { animationManager } = this.ctx;\r\n        const fns = preparePieSeriesAnimationFunctions(true, this.rotation, this.radiusScale, this.previousRadiusScale);\r\n        fromToMotion(this.id, 'nodes', animationManager, [this.itemSelection, this.highlightSelection], fns.nodes);\r\n        fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\r\n        seriesLabelFadeInAnimation(this, 'callout', animationManager, [this.calloutLabelSelection]);\r\n        seriesLabelFadeInAnimation(this, 'sector', animationManager, [this.sectorLabelSelection]);\r\n        seriesLabelFadeInAnimation(this, 'inner', animationManager, [this.innerLabelsSelection]);\r\n        this.previousRadiusScale.range = this.radiusScale.range;\r\n    }\r\n    animateWaitingUpdateReady() {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        const { itemSelection, highlightSelection, processedData, radiusScale, previousRadiusScale } = this;\r\n        const { animationManager } = this.ctx;\r\n        const diff = (_a = processedData === null || processedData === void 0 ? void 0 : processedData.reduced) === null || _a === void 0 ? void 0 : _a.diff;\r\n        this.ctx.animationManager.stopByAnimationGroupId(this.id);\r\n        const supportedDiff = ((_b = diff === null || diff === void 0 ? void 0 : diff.moved.length) !== null && _b !== void 0 ? _b : 0) === 0 && (diff === null || diff === void 0 ? void 0 : diff.addedIndices.every((i) => !diff.removedIndices.includes(i)));\r\n        const hasKeys = ((_c = processedData === null || processedData === void 0 ? void 0 : processedData.defs.keys.length) !== null && _c !== void 0 ? _c : 0) > 0;\r\n        const hasUniqueKeys = (_f = (_e = (_d = processedData === null || processedData === void 0 ? void 0 : processedData.reduced) === null || _d === void 0 ? void 0 : _d.animationValidation) === null || _e === void 0 ? void 0 : _e.uniqueKeys) !== null && _f !== void 0 ? _f : true;\r\n        if (!supportedDiff || !hasKeys || !hasUniqueKeys) {\r\n            this.ctx.animationManager.skipCurrentBatch();\r\n        }\r\n        const fns = preparePieSeriesAnimationFunctions(false, this.rotation, radiusScale, previousRadiusScale);\r\n        fromToMotion(this.id, 'nodes', animationManager, [itemSelection, highlightSelection], fns.nodes, (_, datum) => this.getDatumId(datum), diff);\r\n        fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\r\n        seriesLabelFadeInAnimation(this, 'callout', this.ctx.animationManager, [this.calloutLabelSelection]);\r\n        seriesLabelFadeInAnimation(this, 'sector', this.ctx.animationManager, [this.sectorLabelSelection]);\r\n        seriesLabelFadeInAnimation(this, 'inner', this.ctx.animationManager, [this.innerLabelsSelection]);\r\n        this.previousRadiusScale.range = this.radiusScale.range;\r\n    }\r\n    animateClearingUpdateEmpty() {\r\n        const { itemSelection, highlightSelection, radiusScale, previousRadiusScale } = this;\r\n        const { animationManager } = this.ctx;\r\n        const fns = preparePieSeriesAnimationFunctions(false, this.rotation, radiusScale, previousRadiusScale);\r\n        fromToMotion(this.id, 'nodes', animationManager, [itemSelection, highlightSelection], fns.nodes);\r\n        fromToMotion(this.id, `innerCircle`, animationManager, [this.innerCircleSelection], fns.innerCircle);\r\n        seriesLabelFadeOutAnimation(this, 'callout', this.ctx.animationManager, [this.calloutLabelSelection]);\r\n        seriesLabelFadeOutAnimation(this, 'sector', this.ctx.animationManager, [this.sectorLabelSelection]);\r\n        seriesLabelFadeOutAnimation(this, 'inner', this.ctx.animationManager, [this.innerLabelsSelection]);\r\n        this.previousRadiusScale.range = this.radiusScale.range;\r\n    }\r\n    getDatumIdFromData(datum) {\r\n        var _a, _b, _c;\r\n        const { calloutLabelKey, sectorLabelKey, legendItemKey } = this;\r\n        if (!((_c = (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.animationValidation) === null || _c === void 0 ? void 0 : _c.uniqueKeys)) {\r\n            return undefined;\r\n        }\r\n        if (legendItemKey) {\r\n            return datum[legendItemKey];\r\n        }\r\n        else if (calloutLabelKey) {\r\n            return datum[calloutLabelKey];\r\n        }\r\n        else if (sectorLabelKey) {\r\n            return datum[sectorLabelKey];\r\n        }\r\n    }\r\n    getDatumId(datum) {\r\n        var _a;\r\n        const { index } = datum;\r\n        return (_a = this.getDatumIdFromData(datum.datum)) !== null && _a !== void 0 ? _a : `${index}`;\r\n    }\r\n    onDataChange() {\r\n        this.processSeriesItemEnabled();\r\n    }\r\n}\r\nPieSeries.className = 'PieSeries';\r\nPieSeries.type = 'pie';\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"angleKey\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"angleName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PieSeries.prototype, \"radiusKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PieSeries.prototype, \"radiusName\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], PieSeries.prototype, \"radiusMin\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], PieSeries.prototype, \"radiusMax\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PieSeries.prototype, \"calloutLabelKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PieSeries.prototype, \"calloutLabelName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PieSeries.prototype, \"sectorLabelKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PieSeries.prototype, \"sectorLabelName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PieSeries.prototype, \"legendItemKey\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], PieSeries.prototype, \"fills\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], PieSeries.prototype, \"strokes\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_LINE_DASH),\r\n    __metadata(\"design:type\", Array)\r\n], PieSeries.prototype, \"lineDash\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], PieSeries.prototype, \"lineDashOffset\", void 0);\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    __metadata(\"design:type\", Function)\r\n], PieSeries.prototype, \"formatter\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(-360, 360)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"rotation\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"outerRadiusOffset\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"outerRadiusRatio\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"innerRadiusOffset\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"innerRadiusRatio\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PieSeries.prototype, \"strokeWidth\", void 0);\n\nconst JSON_APPLY_PLUGINS = {\r\n    constructors: {},\r\n    constructedArrays: new WeakMap(),\r\n};\r\nfunction assignJsonApplyConstructedArray(array, ctor) {\r\n    var _a;\r\n    (_a = JSON_APPLY_PLUGINS.constructedArrays) === null || _a === void 0 ? void 0 : _a.set(array, ctor);\r\n}\r\nconst JSON_APPLY_OPTIONS = {\r\n    constructors: {\r\n        title: Caption,\r\n        subtitle: Caption,\r\n        footnote: Caption,\r\n        shadow: DropShadow,\r\n        innerCircle: DoughnutInnerCircle,\r\n        'axes[].title': AxisTitle,\r\n        'series[].innerLabels[]': DoughnutInnerLabel,\r\n    },\r\n    allowedTypes: {\r\n        'legend.pagination.marker.shape': ['primitive', 'function'],\r\n        'series[].marker.shape': ['primitive', 'function'],\r\n        'axis[].tick.count': ['primitive', 'class-instance'],\r\n    },\r\n};\r\nfunction getJsonApplyOptions() {\r\n    return {\r\n        constructors: Object.assign(Object.assign({}, JSON_APPLY_OPTIONS.constructors), JSON_APPLY_PLUGINS.constructors),\r\n        constructedArrays: JSON_APPLY_PLUGINS.constructedArrays,\r\n        allowedTypes: Object.assign({}, JSON_APPLY_OPTIONS.allowedTypes),\r\n    };\r\n}\n\nclass Range extends Shape {\r\n    constructor(opts = {}) {\r\n        super(opts);\r\n        this.x1 = 0;\r\n        this.y1 = 0;\r\n        this.x2 = 0;\r\n        this.y2 = 0;\r\n        this.startLine = false;\r\n        this.endLine = false;\r\n        this.isRange = false;\r\n        this.restoreOwnStyles();\r\n    }\r\n    computeBBox() {\r\n        return new BBox(this.x1, this.y1, this.x2 - this.x1, this.y2 - this.y1);\r\n    }\r\n    isPointInPath(_x, _y) {\r\n        return false;\r\n    }\r\n    render(renderCtx) {\r\n        var _a;\r\n        const { ctx, forceRender, stats } = renderCtx;\r\n        if (this.dirty === RedrawType.NONE && !forceRender) {\r\n            if (stats)\r\n                stats.nodesSkipped += this.nodeCount.count;\r\n            return;\r\n        }\r\n        this.computeTransformMatrix();\r\n        this.matrix.toContext(ctx);\r\n        let { x1, y1, x2, y2 } = this;\r\n        x1 = this.align(x1);\r\n        y1 = this.align(y1);\r\n        x2 = this.align(x2);\r\n        y2 = this.align(y2);\r\n        const { fill, opacity, isRange } = this;\r\n        const fillActive = !!(isRange && fill);\r\n        if (fillActive) {\r\n            const { fillOpacity } = this;\r\n            ctx.fillStyle = fill;\r\n            ctx.globalAlpha = opacity * fillOpacity;\r\n            ctx.beginPath();\r\n            ctx.moveTo(x1, y1);\r\n            ctx.lineTo(x2, y1);\r\n            ctx.lineTo(x2, y2);\r\n            ctx.lineTo(x1, y2);\r\n            ctx.closePath();\r\n            ctx.fill();\r\n        }\r\n        const { stroke, strokeWidth, startLine, endLine } = this;\r\n        const strokeActive = !!((startLine || endLine) && stroke && strokeWidth);\r\n        if (strokeActive) {\r\n            const { strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin } = this;\r\n            ctx.strokeStyle = stroke;\r\n            ctx.globalAlpha = opacity * strokeOpacity;\r\n            ctx.lineWidth = strokeWidth;\r\n            if (lineDash) {\r\n                ctx.setLineDash(lineDash);\r\n            }\r\n            if (lineDashOffset) {\r\n                ctx.lineDashOffset = lineDashOffset;\r\n            }\r\n            if (lineCap) {\r\n                ctx.lineCap = lineCap;\r\n            }\r\n            if (lineJoin) {\r\n                ctx.lineJoin = lineJoin;\r\n            }\r\n            ctx.beginPath();\r\n            if (startLine) {\r\n                ctx.moveTo(x1, y1);\r\n                ctx.lineTo(x2, y1);\r\n            }\r\n            if (endLine) {\r\n                ctx.moveTo(x2, y2);\r\n                ctx.lineTo(x1, y2);\r\n            }\r\n            ctx.stroke();\r\n        }\r\n        (_a = this.fillShadow) === null || _a === void 0 ? void 0 : _a.markClean();\r\n        super.render(renderCtx);\r\n    }\r\n}\r\nRange.className = 'Range';\r\nRange.defaultStyles = Object.assign(Object.assign({}, Shape.defaultStyles), { strokeWidth: 1 });\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Range.prototype, \"x1\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Range.prototype, \"y1\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Range.prototype, \"x2\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Range.prototype, \"y2\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Boolean)\r\n], Range.prototype, \"startLine\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Boolean)\r\n], Range.prototype, \"endLine\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MINOR }),\r\n    __metadata(\"design:type\", Boolean)\r\n], Range.prototype, \"isRange\", void 0);\n\nconst horizontalCrosslineTranslationDirections = {\r\n    top: { xTranslationDirection: 0, yTranslationDirection: -1 },\r\n    bottom: { xTranslationDirection: 0, yTranslationDirection: 1 },\r\n    left: { xTranslationDirection: -1, yTranslationDirection: 0 },\r\n    right: { xTranslationDirection: 1, yTranslationDirection: 0 },\r\n    topLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\r\n    topRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\r\n    bottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\r\n    bottomRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\r\n    inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\r\n    insideLeft: { xTranslationDirection: 1, yTranslationDirection: 0 },\r\n    insideRight: { xTranslationDirection: -1, yTranslationDirection: 0 },\r\n    insideTop: { xTranslationDirection: 0, yTranslationDirection: 1 },\r\n    insideBottom: { xTranslationDirection: 0, yTranslationDirection: -1 },\r\n    insideTopLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\r\n    insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\r\n    insideTopRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\r\n    insideBottomRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\r\n};\r\nconst verticalCrossLineTranslationDirections = {\r\n    top: { xTranslationDirection: 1, yTranslationDirection: 0 },\r\n    bottom: { xTranslationDirection: -1, yTranslationDirection: 0 },\r\n    left: { xTranslationDirection: 0, yTranslationDirection: -1 },\r\n    right: { xTranslationDirection: 0, yTranslationDirection: 1 },\r\n    topLeft: { xTranslationDirection: -1, yTranslationDirection: -1 },\r\n    topRight: { xTranslationDirection: -1, yTranslationDirection: 1 },\r\n    bottomLeft: { xTranslationDirection: 1, yTranslationDirection: -1 },\r\n    bottomRight: { xTranslationDirection: 1, yTranslationDirection: 1 },\r\n    inside: { xTranslationDirection: 0, yTranslationDirection: 0 },\r\n    insideLeft: { xTranslationDirection: 0, yTranslationDirection: 1 },\r\n    insideRight: { xTranslationDirection: 0, yTranslationDirection: -1 },\r\n    insideTop: { xTranslationDirection: -1, yTranslationDirection: 0 },\r\n    insideBottom: { xTranslationDirection: 1, yTranslationDirection: 0 },\r\n    insideTopLeft: { xTranslationDirection: -1, yTranslationDirection: 1 },\r\n    insideBottomLeft: { xTranslationDirection: 1, yTranslationDirection: 1 },\r\n    insideTopRight: { xTranslationDirection: -1, yTranslationDirection: -1 },\r\n    insideBottomRight: { xTranslationDirection: 1, yTranslationDirection: -1 },\r\n};\r\nfunction calculateLabelTranslation({ yDirection, padding = 0, position = 'top', bbox, }) {\r\n    const crossLineTranslationDirections = yDirection\r\n        ? horizontalCrosslineTranslationDirections\r\n        : verticalCrossLineTranslationDirections;\r\n    const { xTranslationDirection, yTranslationDirection } = crossLineTranslationDirections[position];\r\n    const w = yDirection ? bbox.width : bbox.height;\r\n    const h = yDirection ? bbox.height : bbox.width;\r\n    const xTranslation = xTranslationDirection * (padding + w / 2);\r\n    const yTranslation = yTranslationDirection * (padding + h / 2);\r\n    return {\r\n        xTranslation,\r\n        yTranslation,\r\n    };\r\n}\r\nfunction calculateLabelChartPadding({ yDirection, bbox, padding = 0, position = 'top', }) {\r\n    const chartPadding = {};\r\n    if (position.startsWith('inside'))\r\n        return chartPadding;\r\n    if (position === 'top' && !yDirection) {\r\n        chartPadding.top = padding + bbox.height;\r\n    }\r\n    else if (position === 'bottom' && !yDirection) {\r\n        chartPadding.bottom = padding + bbox.height;\r\n    }\r\n    else if (position === 'left' && yDirection) {\r\n        chartPadding.left = padding + bbox.width;\r\n    }\r\n    else if (position === 'right' && yDirection) {\r\n        chartPadding.right = padding + bbox.width;\r\n    }\r\n    return chartPadding;\r\n}\r\nconst POSITION_TOP_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\r\n    if (yDirection) {\r\n        return { x: xEnd / 2, y: yStart };\r\n    }\r\n    else {\r\n        return { x: xEnd, y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart };\r\n    }\r\n};\r\nconst POSITION_LEFT_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\r\n    if (yDirection) {\r\n        return { x: xStart, y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart };\r\n    }\r\n    else {\r\n        return { x: xEnd / 2, y: yStart };\r\n    }\r\n};\r\nconst POSITION_RIGHT_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\r\n    if (yDirection) {\r\n        return { x: xEnd, y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart };\r\n    }\r\n    else {\r\n        return { x: xEnd / 2, y: !isNaN(yEnd) ? yEnd : yStart };\r\n    }\r\n};\r\nconst POSITION_BOTTOM_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\r\n    if (yDirection) {\r\n        return { x: xEnd / 2, y: !isNaN(yEnd) ? yEnd : yStart };\r\n    }\r\n    else {\r\n        return { x: xStart, y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart };\r\n    }\r\n};\r\nconst POSITION_INSIDE_COORDINATES = ({ xEnd, yStart, yEnd }) => {\r\n    return { x: xEnd / 2, y: !isNaN(yEnd) ? (yStart + yEnd) / 2 : yStart };\r\n};\r\nconst POSITION_TOP_LEFT_COORDINATES = ({ yDirection, xStart, xEnd, yStart }) => {\r\n    if (yDirection) {\r\n        return { x: xStart / 2, y: yStart };\r\n    }\r\n    else {\r\n        return { x: xEnd, y: yStart };\r\n    }\r\n};\r\nconst POSITION_BOTTOM_LEFT_COORDINATES = ({ yDirection, xStart, yStart, yEnd }) => {\r\n    if (yDirection) {\r\n        return { x: xStart, y: !isNaN(yEnd) ? yEnd : yStart };\r\n    }\r\n    else {\r\n        return { x: xStart, y: yStart };\r\n    }\r\n};\r\nconst POSITION_TOP_RIGHT_COORDINATES = ({ yDirection, xEnd, yStart, yEnd }) => {\r\n    if (yDirection) {\r\n        return { x: xEnd, y: yStart };\r\n    }\r\n    else {\r\n        return { x: xEnd, y: !isNaN(yEnd) ? yEnd : yStart };\r\n    }\r\n};\r\nconst POSITION_BOTTOM_RIGHT_COORDINATES = ({ yDirection, xStart, xEnd, yStart, yEnd }) => {\r\n    if (yDirection) {\r\n        return { x: xEnd, y: !isNaN(yEnd) ? yEnd : yStart };\r\n    }\r\n    else {\r\n        return { x: xStart, y: !isNaN(yEnd) ? yEnd : yStart };\r\n    }\r\n};\r\nconst labeldDirectionHandling = {\r\n    top: { c: POSITION_TOP_COORDINATES },\r\n    bottom: { c: POSITION_BOTTOM_COORDINATES },\r\n    left: { c: POSITION_LEFT_COORDINATES },\r\n    right: { c: POSITION_RIGHT_COORDINATES },\r\n    topLeft: { c: POSITION_TOP_LEFT_COORDINATES },\r\n    topRight: { c: POSITION_TOP_RIGHT_COORDINATES },\r\n    bottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },\r\n    bottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES },\r\n    inside: { c: POSITION_INSIDE_COORDINATES },\r\n    insideLeft: { c: POSITION_LEFT_COORDINATES },\r\n    insideRight: { c: POSITION_RIGHT_COORDINATES },\r\n    insideTop: { c: POSITION_TOP_COORDINATES },\r\n    insideBottom: { c: POSITION_BOTTOM_COORDINATES },\r\n    insideTopLeft: { c: POSITION_TOP_LEFT_COORDINATES },\r\n    insideBottomLeft: { c: POSITION_BOTTOM_LEFT_COORDINATES },\r\n    insideTopRight: { c: POSITION_TOP_RIGHT_COORDINATES },\r\n    insideBottomRight: { c: POSITION_BOTTOM_RIGHT_COORDINATES },\r\n};\n\nconst CROSSLINE_LABEL_POSITIONS = [\r\n    'top',\r\n    'left',\r\n    'right',\r\n    'bottom',\r\n    'topLeft',\r\n    'topRight',\r\n    'bottomLeft',\r\n    'bottomRight',\r\n    'inside',\r\n    'insideLeft',\r\n    'insideRight',\r\n    'insideTop',\r\n    'insideBottom',\r\n    'insideTopLeft',\r\n    'insideBottomLeft',\r\n    'insideTopRight',\r\n    'insideBottomRight',\r\n];\r\nconst OPT_CROSSLINE_LABEL_POSITION = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, (v) => CROSSLINE_LABEL_POSITIONS.includes(v)), `expecting an optional crossLine label position keyword such as 'topLeft', 'topRight' or 'inside'`);\r\nconst OPT_CROSSLINE_TYPE = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, (v) => v === 'range' || v === 'line'), `expecting a crossLine type keyword such as 'range' or 'line'`);\r\nclass CartesianCrossLineLabel {\r\n    constructor() {\r\n        this.enabled = undefined;\r\n        this.text = undefined;\r\n        this.fontStyle = undefined;\r\n        this.fontWeight = undefined;\r\n        this.fontSize = 14;\r\n        this.fontFamily = 'Verdana, sans-serif';\r\n        /**\r\n         * The padding between the label and the line.\r\n         */\r\n        this.padding = 5;\r\n        /**\r\n         * The color of the labels.\r\n         */\r\n        this.color = 'rgba(87, 87, 87, 1)';\r\n        this.position = undefined;\r\n        this.rotation = undefined;\r\n        this.parallel = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], CartesianCrossLineLabel.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLineLabel.prototype, \"text\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_STYLE),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLineLabel.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_WEIGHT),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLineLabel.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], CartesianCrossLineLabel.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLineLabel.prototype, \"fontFamily\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    __metadata(\"design:type\", Number)\r\n], CartesianCrossLineLabel.prototype, \"padding\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLineLabel.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(OPT_CROSSLINE_LABEL_POSITION),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLineLabel.prototype, \"position\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(-360, 360)),\r\n    __metadata(\"design:type\", Number)\r\n], CartesianCrossLineLabel.prototype, \"rotation\", void 0);\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], CartesianCrossLineLabel.prototype, \"parallel\", void 0);\r\nclass CartesianCrossLine {\r\n    constructor() {\r\n        this.id = createId(this);\r\n        this.enabled = undefined;\r\n        this.type = undefined;\r\n        this.range = undefined;\r\n        this.value = undefined;\r\n        this.fill = undefined;\r\n        this.fillOpacity = undefined;\r\n        this.stroke = undefined;\r\n        this.strokeWidth = undefined;\r\n        this.strokeOpacity = undefined;\r\n        this.lineDash = undefined;\r\n        this.label = new CartesianCrossLineLabel();\r\n        this.scale = undefined;\r\n        this.clippedRange = [-Infinity, Infinity];\r\n        this.gridLength = 0;\r\n        this.sideFlag = -1;\r\n        this.parallelFlipRotation = 0;\r\n        this.regularFlipRotation = 0;\r\n        this.direction = ChartAxisDirection.X;\r\n        this.group = new Group({ name: `${this.id}`, layer: true, zIndex: CartesianCrossLine.LINE_LAYER_ZINDEX });\r\n        this.crossLineRange = new Range();\r\n        this.crossLineLabel = new Text();\r\n        this.labelPoint = undefined;\r\n        this.data = [];\r\n        this.startLine = false;\r\n        this.endLine = false;\r\n        this.isRange = false;\r\n        const { group, crossLineRange, crossLineLabel } = this;\r\n        group.append([crossLineRange, crossLineLabel]);\r\n        crossLineRange.pointerEvents = PointerEvents.None;\r\n    }\r\n    update(visible) {\r\n        if (!this.enabled || !visible || this.data.length === 0) {\r\n            this.group.visible = false;\r\n            return;\r\n        }\r\n        this.group.visible = true;\r\n        this.group.zIndex = this.getZIndex(this.isRange);\r\n        this.updateNodes();\r\n    }\r\n    calculateLayout(visible) {\r\n        if (!visible) {\r\n            return;\r\n        }\r\n        const dataCreated = this.createNodeData();\r\n        if (!dataCreated) {\r\n            return;\r\n        }\r\n        const { sideFlag, gridLength, data } = this;\r\n        const boxes = [];\r\n        const x1 = 0;\r\n        const x2 = sideFlag * gridLength;\r\n        const y1 = data[0];\r\n        const y2 = data[1];\r\n        const crossLineBox = new BBox(Math.min(x1, x2), Math.min(y1, y2), Math.abs(x1 - x2), Math.abs(y1 - y2));\r\n        boxes.push(crossLineBox);\r\n        const labelBox = this.computeLabelBBox();\r\n        if (labelBox) {\r\n            boxes.push(labelBox);\r\n        }\r\n        return BBox.merge(boxes);\r\n    }\r\n    updateNodes() {\r\n        this.updateRangeNode();\r\n        if (this.label.enabled) {\r\n            this.updateLabel();\r\n            this.positionLabel();\r\n        }\r\n    }\r\n    createNodeData() {\r\n        var _a, _b;\r\n        const { scale, gridLength, sideFlag, direction, label: { position = 'top' }, clippedRange, strokeWidth = 0, } = this;\r\n        this.data = [];\r\n        if (!scale) {\r\n            return false;\r\n        }\r\n        const bandwidth = (_a = scale.bandwidth) !== null && _a !== void 0 ? _a : 0;\r\n        const clippedRangeClamper = (x) => Math.max(Math.min(...clippedRange), Math.min(Math.max(...clippedRange), x));\r\n        const [xStart, xEnd] = [0, sideFlag * gridLength];\r\n        let [yStart, yEnd] = this.getRange();\r\n        let [clampedYStart, clampedYEnd] = [\r\n            Number(scale.convert(yStart, { clampMode: 'clamped' })),\r\n            scale.convert(yEnd, { clampMode: 'clamped' }) + bandwidth,\r\n        ];\r\n        clampedYStart = clippedRangeClamper(clampedYStart);\r\n        clampedYEnd = clippedRangeClamper(clampedYEnd);\r\n        [yStart, yEnd] = [Number(scale.convert(yStart)), scale.convert(yEnd) + bandwidth];\r\n        const validRange = !isNaN(clampedYStart) &&\r\n            !isNaN(clampedYEnd) &&\r\n            (yStart === clampedYStart || yEnd === clampedYEnd || clampedYStart !== clampedYEnd) &&\r\n            Math.abs(clampedYEnd - clampedYStart) > 0;\r\n        if (validRange) {\r\n            const reverse = clampedYStart !== Math.min(clampedYStart, clampedYEnd);\r\n            if (reverse) {\r\n                [clampedYStart, clampedYEnd] = [\r\n                    Math.min(clampedYStart, clampedYEnd),\r\n                    Math.max(clampedYStart, clampedYEnd),\r\n                ];\r\n                [yStart, yEnd] = [yEnd, yStart];\r\n            }\r\n        }\r\n        this.isRange = validRange;\r\n        this.startLine = !isNaN(yStart) && strokeWidth > 0 && yStart === clampedYStart;\r\n        this.endLine = !isNaN(yEnd) && strokeWidth > 0 && yEnd === clampedYEnd;\r\n        if (!validRange && !this.startLine && !this.endLine) {\r\n            return false;\r\n        }\r\n        this.data = [clampedYStart, clampedYEnd];\r\n        if (this.label.enabled) {\r\n            const yDirection = direction === ChartAxisDirection.Y;\r\n            const { c = POSITION_TOP_COORDINATES } = (_b = labeldDirectionHandling[position]) !== null && _b !== void 0 ? _b : {};\r\n            const { x: labelX, y: labelY } = c({\r\n                yDirection,\r\n                xStart,\r\n                xEnd,\r\n                yStart: clampedYStart,\r\n                yEnd: clampedYEnd,\r\n            });\r\n            this.labelPoint = {\r\n                x: labelX,\r\n                y: labelY,\r\n            };\r\n        }\r\n        return true;\r\n    }\r\n    updateRangeNode() {\r\n        var _a;\r\n        const { crossLineRange, sideFlag, gridLength, data, startLine, endLine, isRange, fill, fillOpacity, stroke, strokeWidth, lineDash, } = this;\r\n        crossLineRange.x1 = 0;\r\n        crossLineRange.x2 = sideFlag * gridLength;\r\n        crossLineRange.y1 = data[0];\r\n        crossLineRange.y2 = data[1];\r\n        crossLineRange.startLine = startLine;\r\n        crossLineRange.endLine = endLine;\r\n        crossLineRange.isRange = isRange;\r\n        crossLineRange.fill = fill;\r\n        crossLineRange.fillOpacity = fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1;\r\n        crossLineRange.stroke = stroke;\r\n        crossLineRange.strokeWidth = strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 1;\r\n        crossLineRange.strokeOpacity = (_a = this.strokeOpacity) !== null && _a !== void 0 ? _a : 1;\r\n        crossLineRange.lineDash = lineDash;\r\n    }\r\n    updateLabel() {\r\n        const { crossLineLabel, label } = this;\r\n        if (!label.text) {\r\n            return;\r\n        }\r\n        crossLineLabel.fontStyle = label.fontStyle;\r\n        crossLineLabel.fontWeight = label.fontWeight;\r\n        crossLineLabel.fontSize = label.fontSize;\r\n        crossLineLabel.fontFamily = label.fontFamily;\r\n        crossLineLabel.fill = label.color;\r\n        crossLineLabel.text = label.text;\r\n    }\r\n    positionLabel() {\r\n        const { crossLineLabel, labelPoint: { x = undefined, y = undefined } = {}, label: { parallel, rotation, position = 'top', padding = 0 }, direction, parallelFlipRotation, regularFlipRotation, } = this;\r\n        if (x === undefined || y === undefined) {\r\n            return;\r\n        }\r\n        const { defaultRotation, configuredRotation } = calculateLabelRotation({\r\n            rotation,\r\n            parallel,\r\n            regularFlipRotation,\r\n            parallelFlipRotation,\r\n        });\r\n        crossLineLabel.rotation = defaultRotation + configuredRotation;\r\n        crossLineLabel.textBaseline = 'middle';\r\n        crossLineLabel.textAlign = 'center';\r\n        const bbox = crossLineLabel.computeTransformedBBox();\r\n        if (!bbox) {\r\n            return;\r\n        }\r\n        const yDirection = direction === ChartAxisDirection.Y;\r\n        const { xTranslation, yTranslation } = calculateLabelTranslation({\r\n            yDirection,\r\n            padding,\r\n            position,\r\n            bbox,\r\n        });\r\n        crossLineLabel.translationX = x + xTranslation;\r\n        crossLineLabel.translationY = y + yTranslation;\r\n    }\r\n    getZIndex(isRange = false) {\r\n        if (isRange) {\r\n            return CartesianCrossLine.RANGE_LAYER_ZINDEX;\r\n        }\r\n        return CartesianCrossLine.LINE_LAYER_ZINDEX;\r\n    }\r\n    getRange() {\r\n        const { value, range, scale } = this;\r\n        const isContinuous = ContinuousScale.is(scale);\r\n        let [start, end] = range !== null && range !== void 0 ? range : [value, undefined];\r\n        if (!isContinuous && end === undefined) {\r\n            end = start;\r\n        }\r\n        start = checkDatum(start, isContinuous) != null ? start : undefined;\r\n        end = checkDatum(end, isContinuous) != null ? end : undefined;\r\n        if (isContinuous && start === end) {\r\n            end = undefined;\r\n        }\r\n        if (start === undefined && end !== undefined) {\r\n            start = end;\r\n            end = undefined;\r\n        }\r\n        return [start, end];\r\n    }\r\n    computeLabelBBox() {\r\n        const { label } = this;\r\n        if (!label.enabled) {\r\n            return undefined;\r\n        }\r\n        const tempText = new Text();\r\n        tempText.fontFamily = label.fontFamily;\r\n        tempText.fontSize = label.fontSize;\r\n        tempText.fontStyle = label.fontStyle;\r\n        tempText.fontWeight = label.fontWeight;\r\n        tempText.text = label.text;\r\n        const { labelPoint: { x = undefined, y = undefined } = {}, label: { parallel, rotation, position = 'top', padding = 0 }, direction, parallelFlipRotation, regularFlipRotation, } = this;\r\n        if (x === undefined || y === undefined) {\r\n            return undefined;\r\n        }\r\n        const { configuredRotation } = calculateLabelRotation({\r\n            rotation,\r\n            parallel,\r\n            regularFlipRotation,\r\n            parallelFlipRotation,\r\n        });\r\n        tempText.rotation = configuredRotation;\r\n        tempText.textBaseline = 'middle';\r\n        tempText.textAlign = 'center';\r\n        const bbox = tempText.computeTransformedBBox();\r\n        if (!bbox) {\r\n            return undefined;\r\n        }\r\n        const yDirection = direction === ChartAxisDirection.Y;\r\n        const { xTranslation, yTranslation } = calculateLabelTranslation({\r\n            yDirection,\r\n            padding,\r\n            position,\r\n            bbox,\r\n        });\r\n        tempText.translationX = x + xTranslation;\r\n        tempText.translationY = y + yTranslation;\r\n        return tempText.computeTransformedBBox();\r\n    }\r\n    calculatePadding(padding) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h;\r\n        const { isRange, startLine, endLine, direction, label: { padding: labelPadding = 0, position = 'top' }, } = this;\r\n        if (!isRange && !startLine && !endLine) {\r\n            return;\r\n        }\r\n        const crossLineLabelBBox = this.computeLabelBBox();\r\n        const labelX = crossLineLabelBBox === null || crossLineLabelBBox === void 0 ? void 0 : crossLineLabelBBox.x;\r\n        const labelY = crossLineLabelBBox === null || crossLineLabelBBox === void 0 ? void 0 : crossLineLabelBBox.y;\r\n        if (!crossLineLabelBBox || labelX == undefined || labelY == undefined) {\r\n            return;\r\n        }\r\n        const chartPadding = calculateLabelChartPadding({\r\n            yDirection: direction === ChartAxisDirection.Y,\r\n            padding: labelPadding,\r\n            position,\r\n            bbox: crossLineLabelBBox,\r\n        });\r\n        padding.left = Math.max((_a = padding.left) !== null && _a !== void 0 ? _a : 0, (_b = chartPadding.left) !== null && _b !== void 0 ? _b : 0);\r\n        padding.right = Math.max((_c = padding.right) !== null && _c !== void 0 ? _c : 0, (_d = chartPadding.right) !== null && _d !== void 0 ? _d : 0);\r\n        padding.top = Math.max((_e = padding.top) !== null && _e !== void 0 ? _e : 0, (_f = chartPadding.top) !== null && _f !== void 0 ? _f : 0);\r\n        padding.bottom = Math.max((_g = padding.bottom) !== null && _g !== void 0 ? _g : 0, (_h = chartPadding.bottom) !== null && _h !== void 0 ? _h : 0);\r\n    }\r\n}\r\nCartesianCrossLine.LINE_LAYER_ZINDEX = Layers.SERIES_CROSSLINE_LINE_ZINDEX;\r\nCartesianCrossLine.RANGE_LAYER_ZINDEX = Layers.SERIES_CROSSLINE_RANGE_ZINDEX;\r\nCartesianCrossLine.className = 'CrossLine';\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], CartesianCrossLine.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(OPT_CROSSLINE_TYPE),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLine.prototype, \"type\", void 0);\r\n__decorate([\r\n    Validate(OPT_ARRAY(2)),\r\n    __metadata(\"design:type\", Array)\r\n], CartesianCrossLine.prototype, \"range\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLine.prototype, \"fill\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], CartesianCrossLine.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], CartesianCrossLine.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER()),\r\n    __metadata(\"design:type\", Number)\r\n], CartesianCrossLine.prototype, \"strokeWidth\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], CartesianCrossLine.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_LINE_DASH),\r\n    __metadata(\"design:type\", Array)\r\n], CartesianCrossLine.prototype, \"lineDash\", void 0);\n\nconst identity = (x) => x;\r\nclass LogScale extends ContinuousScale {\r\n    constructor() {\r\n        super([1, 10], [0, 1]);\r\n        this.type = 'log';\r\n        this.base = 10;\r\n        this.cacheProps = ['domain', 'range', 'nice', 'tickCount', 'base'];\r\n        this.baseLog = identity;\r\n        this.basePow = identity;\r\n        this.log = (x) => {\r\n            return this.domain[0] >= 0 ? this.baseLog(x) : -this.baseLog(-x);\r\n        };\r\n        this.pow = (x) => {\r\n            return this.domain[0] >= 0 ? this.basePow(x) : -this.basePow(-x);\r\n        };\r\n        // Handling <1 and crossing 0 cases is tricky, easiest solution is to default to clamping.\r\n        this.defaultClampMode = 'clamped';\r\n    }\r\n    toDomain(d) {\r\n        return d;\r\n    }\r\n    transform(x) {\r\n        return this.domain[0] >= 0 ? Math.log(x) : -Math.log(-x);\r\n    }\r\n    transformInvert(x) {\r\n        return this.domain[0] >= 0 ? Math.exp(x) : -Math.exp(-x);\r\n    }\r\n    update() {\r\n        if (!this.domain || this.domain.length < 2) {\r\n            return;\r\n        }\r\n        this.updateLogFn();\r\n        this.updatePowFn();\r\n        if (this.nice) {\r\n            this.updateNiceDomain();\r\n        }\r\n    }\r\n    updateLogFn() {\r\n        const { base } = this;\r\n        let log;\r\n        if (base === 10) {\r\n            log = Math.log10;\r\n        }\r\n        else if (base === Math.E) {\r\n            log = Math.log;\r\n        }\r\n        else if (base === 2) {\r\n            log = Math.log2;\r\n        }\r\n        else {\r\n            const logBase = Math.log(base);\r\n            log = (x) => Math.log(x) / logBase;\r\n        }\r\n        this.baseLog = log;\r\n    }\r\n    updatePowFn() {\r\n        const { base } = this;\r\n        let pow;\r\n        if (base === 10) {\r\n            pow = LogScale.pow10;\r\n        }\r\n        else if (base === Math.E) {\r\n            pow = Math.exp;\r\n        }\r\n        else {\r\n            pow = (x) => Math.pow(base, x);\r\n        }\r\n        this.basePow = pow;\r\n    }\r\n    updateNiceDomain() {\r\n        const [d0, d1] = this.domain;\r\n        const n0 = this.pow(Math.floor(this.log(d0)));\r\n        const n1 = this.pow(Math.ceil(this.log(d1)));\r\n        this.niceDomain = [n0, n1];\r\n    }\r\n    static pow10(x) {\r\n        return x >= 0 ? Math.pow(10, x) : 1 / Math.pow(10, -x);\r\n    }\r\n    ticks() {\r\n        var _a;\r\n        const count = (_a = this.tickCount) !== null && _a !== void 0 ? _a : 10;\r\n        if (!this.domain || this.domain.length < 2 || count < 1) {\r\n            return [];\r\n        }\r\n        this.refresh();\r\n        const base = this.base;\r\n        const [d0, d1] = this.getDomain();\r\n        let p0 = this.log(d0);\r\n        let p1 = this.log(d1);\r\n        if (this.interval) {\r\n            const step = Math.abs(this.interval);\r\n            const absDiff = Math.abs(p1 - p0);\r\n            const ticks = range$1(p0, p1, Math.min(absDiff, step))\r\n                .map((x) => this.pow(x))\r\n                .filter((t) => t >= d0 && t <= d1);\r\n            if (!this.isDenseInterval({ start: d0, stop: d1, interval: step, count: ticks.length })) {\r\n                return ticks;\r\n            }\r\n        }\r\n        const isBaseInteger = base % 1 === 0;\r\n        const isDiffLarge = p1 - p0 >= count;\r\n        if (!isBaseInteger || isDiffLarge) {\r\n            // Returns [10^1, 10^2, 10^3, 10^4, ...]\r\n            return ticks(p0, p1, Math.min(p1 - p0, count)).map((x) => this.pow(x));\r\n        }\r\n        const ticks$1 = [];\r\n        const isPositive = d0 > 0;\r\n        p0 = Math.floor(p0) - 1;\r\n        p1 = Math.round(p1) + 1;\r\n        const min = Math.min(...this.range);\r\n        const max = Math.max(...this.range);\r\n        const availableSpacing = (max - min) / count;\r\n        let lastTickPosition = Infinity;\r\n        for (let p = p0; p <= p1; p++) {\r\n            const nextMagnitudeTickPosition = this.convert(this.pow(p + 1));\r\n            for (let k = 1; k < base; k++) {\r\n                const q = isPositive ? k : base - k + 1;\r\n                const t = this.pow(p) * q;\r\n                const tickPosition = this.convert(t);\r\n                const prevSpacing = Math.abs(lastTickPosition - tickPosition);\r\n                const nextSpacing = Math.abs(tickPosition - nextMagnitudeTickPosition);\r\n                const fits = prevSpacing >= availableSpacing && nextSpacing >= availableSpacing;\r\n                if (t >= d0 && t <= d1 && (k === 1 || fits)) {\r\n                    ticks$1.push(t);\r\n                    lastTickPosition = tickPosition;\r\n                }\r\n            }\r\n        }\r\n        return ticks$1;\r\n    }\r\n    tickFormat({ count, ticks, specifier, }) {\r\n        const { base } = this;\r\n        if (specifier == null) {\r\n            specifier = base === 10 ? '.0e' : ',';\r\n        }\r\n        if (typeof specifier === 'string') {\r\n            specifier = format(specifier);\r\n        }\r\n        if (count === Infinity) {\r\n            return specifier;\r\n        }\r\n        if (ticks == null) {\r\n            this.ticks();\r\n        }\r\n        return (d) => {\r\n            return specifier(d);\r\n        };\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], LogScale.prototype, \"base\", void 0);\n\nvar DefaultTimeFormats;\r\n(function (DefaultTimeFormats) {\r\n    DefaultTimeFormats[DefaultTimeFormats[\"MILLISECOND\"] = 0] = \"MILLISECOND\";\r\n    DefaultTimeFormats[DefaultTimeFormats[\"SECOND\"] = 1] = \"SECOND\";\r\n    DefaultTimeFormats[DefaultTimeFormats[\"MINUTE\"] = 2] = \"MINUTE\";\r\n    DefaultTimeFormats[DefaultTimeFormats[\"HOUR\"] = 3] = \"HOUR\";\r\n    DefaultTimeFormats[DefaultTimeFormats[\"WEEK_DAY\"] = 4] = \"WEEK_DAY\";\r\n    DefaultTimeFormats[DefaultTimeFormats[\"SHORT_MONTH\"] = 5] = \"SHORT_MONTH\";\r\n    DefaultTimeFormats[DefaultTimeFormats[\"MONTH\"] = 6] = \"MONTH\";\r\n    DefaultTimeFormats[DefaultTimeFormats[\"SHORT_YEAR\"] = 7] = \"SHORT_YEAR\";\r\n    DefaultTimeFormats[DefaultTimeFormats[\"YEAR\"] = 8] = \"YEAR\";\r\n})(DefaultTimeFormats || (DefaultTimeFormats = {}));\r\nconst formatStrings = {\r\n    [DefaultTimeFormats.MILLISECOND]: '.%L',\r\n    [DefaultTimeFormats.SECOND]: ':%S',\r\n    [DefaultTimeFormats.MINUTE]: '%I:%M',\r\n    [DefaultTimeFormats.HOUR]: '%I %p',\r\n    [DefaultTimeFormats.WEEK_DAY]: '%a',\r\n    [DefaultTimeFormats.SHORT_MONTH]: '%b %d',\r\n    [DefaultTimeFormats.MONTH]: '%B',\r\n    [DefaultTimeFormats.SHORT_YEAR]: '%y',\r\n    [DefaultTimeFormats.YEAR]: '%Y',\r\n};\r\nfunction toNumber(x) {\r\n    return x instanceof Date ? x.getTime() : x;\r\n}\r\nclass TimeScale extends ContinuousScale {\r\n    constructor() {\r\n        super([new Date(2022, 11, 7), new Date(2022, 11, 8)], [0, 1]);\r\n        this.type = 'time';\r\n        this.cacheProps = [\r\n            'domain',\r\n            'range',\r\n            'nice',\r\n            'tickCount',\r\n            'interval',\r\n            'minTickCount',\r\n            'maxTickCount',\r\n        ];\r\n        this.year = year;\r\n        this.month = month;\r\n        this.week = sunday;\r\n        this.day = day;\r\n        this.hour = hour;\r\n        this.minute = minute;\r\n        this.second = second;\r\n        this.millisecond = millisecond;\r\n        /**\r\n         * Array of default tick intervals in the following format:\r\n         *\r\n         *     [\r\n         *         interval (unit of time),\r\n         *         number of units (step),\r\n         *         the length of that number of units in milliseconds\r\n         *     ]\r\n         */\r\n        this.tickIntervals = [\r\n            [this.second, 1, durationSecond],\r\n            [this.second, 5, 5 * durationSecond],\r\n            [this.second, 15, 15 * durationSecond],\r\n            [this.second, 30, 30 * durationSecond],\r\n            [this.minute, 1, durationMinute],\r\n            [this.minute, 5, 5 * durationMinute],\r\n            [this.minute, 15, 15 * durationMinute],\r\n            [this.minute, 30, 30 * durationMinute],\r\n            [this.hour, 1, durationHour],\r\n            [this.hour, 3, 3 * durationHour],\r\n            [this.hour, 6, 6 * durationHour],\r\n            [this.hour, 12, 12 * durationHour],\r\n            [this.day, 1, durationDay],\r\n            [this.day, 2, 2 * durationDay],\r\n            [this.week, 1, durationWeek],\r\n            [this.week, 2, 2 * durationWeek],\r\n            [this.week, 3, 3 * durationWeek],\r\n            [this.month, 1, durationMonth],\r\n            [this.month, 2, 2 * durationMonth],\r\n            [this.month, 3, 3 * durationMonth],\r\n            [this.month, 4, 4 * durationMonth],\r\n            [this.month, 6, 6 * durationMonth],\r\n            [this.year, 1, durationYear],\r\n        ];\r\n    }\r\n    toDomain(d) {\r\n        return new Date(d);\r\n    }\r\n    calculateDefaultTickFormat(ticks = []) {\r\n        let defaultTimeFormat = DefaultTimeFormats.YEAR;\r\n        const updateFormat = (format) => {\r\n            if (format < defaultTimeFormat) {\r\n                defaultTimeFormat = format;\r\n            }\r\n        };\r\n        for (const value of ticks) {\r\n            const format = this.getLowestGranularityFormat(value);\r\n            updateFormat(format);\r\n        }\r\n        const firstTick = toNumber(ticks[0]);\r\n        const lastTick = toNumber(ticks[ticks.length - 1]);\r\n        const startYear = new Date(firstTick).getFullYear();\r\n        const stopYear = new Date(lastTick).getFullYear();\r\n        const yearChange = stopYear - startYear > 0;\r\n        return this.buildFormatString(defaultTimeFormat, yearChange);\r\n    }\r\n    buildFormatString(defaultTimeFormat, yearChange) {\r\n        let formatStringArray = [formatStrings[defaultTimeFormat]];\r\n        let timeEndIndex = 0;\r\n        const domain = this.getDomain();\r\n        const start = Math.min(...domain.map(toNumber));\r\n        const stop = Math.max(...domain.map(toNumber));\r\n        const extent = stop - start;\r\n        switch (defaultTimeFormat) {\r\n            case DefaultTimeFormats.SECOND:\r\n                if (extent / durationMinute > 1) {\r\n                    formatStringArray.push(formatStrings[DefaultTimeFormats.MINUTE]);\r\n                }\r\n            // fall through deliberately\r\n            case DefaultTimeFormats.MINUTE:\r\n                if (extent / durationHour > 1) {\r\n                    formatStringArray.push(formatStrings[DefaultTimeFormats.HOUR]);\r\n                }\r\n            // fall through deliberately\r\n            case DefaultTimeFormats.HOUR:\r\n                timeEndIndex = formatStringArray.length;\r\n                if (extent / durationDay > 1) {\r\n                    formatStringArray.push(formatStrings[DefaultTimeFormats.WEEK_DAY]);\r\n                }\r\n            // fall through deliberately\r\n            case DefaultTimeFormats.WEEK_DAY:\r\n                if (extent / durationWeek > 1 || yearChange) {\r\n                    // if it's more than a week or there is a year change, don't show week day\r\n                    const weekDayIndex = formatStringArray.indexOf(formatStrings[DefaultTimeFormats.WEEK_DAY]);\r\n                    if (weekDayIndex > -1) {\r\n                        formatStringArray.splice(weekDayIndex, 1, formatStrings[DefaultTimeFormats.SHORT_MONTH]);\r\n                    }\r\n                }\r\n            // fall through deliberately\r\n            case DefaultTimeFormats.SHORT_MONTH:\r\n            case DefaultTimeFormats.MONTH:\r\n                if (extent / durationYear > 1 || yearChange) {\r\n                    formatStringArray.push(formatStrings[DefaultTimeFormats.YEAR]);\r\n                }\r\n        }\r\n        if (timeEndIndex < formatStringArray.length) {\r\n            // Insert a gap between all date components.\r\n            formatStringArray = [\r\n                ...formatStringArray.slice(0, timeEndIndex),\r\n                formatStringArray.slice(timeEndIndex).join(' '),\r\n            ];\r\n        }\r\n        if (timeEndIndex > 0) {\r\n            // Reverse order of time components, since they should be displayed in descending\r\n            // granularity.\r\n            formatStringArray = [\r\n                ...formatStringArray.slice(0, timeEndIndex).reverse(),\r\n                ...formatStringArray.slice(timeEndIndex),\r\n            ];\r\n            if (timeEndIndex < formatStringArray.length) {\r\n                // Insert a gap between time and date components.\r\n                formatStringArray.splice(timeEndIndex, 0, ' ');\r\n            }\r\n        }\r\n        return formatStringArray.join('');\r\n    }\r\n    getLowestGranularityFormat(value) {\r\n        if (this.second.floor(value) < value) {\r\n            return DefaultTimeFormats.MILLISECOND;\r\n        }\r\n        else if (this.minute.floor(value) < value) {\r\n            return DefaultTimeFormats.SECOND;\r\n        }\r\n        else if (this.hour.floor(value) < value) {\r\n            return DefaultTimeFormats.MINUTE;\r\n        }\r\n        else if (this.day.floor(value) < value) {\r\n            return DefaultTimeFormats.HOUR;\r\n        }\r\n        else if (this.month.floor(value) < value) {\r\n            if (this.week.floor(value) < value) {\r\n                return DefaultTimeFormats.WEEK_DAY;\r\n            }\r\n            return DefaultTimeFormats.SHORT_MONTH;\r\n        }\r\n        else if (this.year.floor(value) < value) {\r\n            return DefaultTimeFormats.MONTH;\r\n        }\r\n        return DefaultTimeFormats.YEAR;\r\n    }\r\n    defaultTickFormat(ticks) {\r\n        const formatString = this.calculateDefaultTickFormat(ticks);\r\n        return (date) => buildFormatter(formatString)(date);\r\n    }\r\n    /**\r\n     * @param options Tick interval options.\r\n     * @param options.start The start time (timestamp).\r\n     * @param options.stop The end time (timestamp).\r\n     * @param options.count Number of intervals between ticks.\r\n     */\r\n    getTickInterval({ start, stop, count, minCount, maxCount, }) {\r\n        const { tickIntervals } = this;\r\n        let countableTimeInterval;\r\n        let step;\r\n        const tickCount = count !== null && count !== void 0 ? count : ContinuousScale.defaultTickCount;\r\n        const target = Math.abs(stop - start) / Math.max(tickCount, 1);\r\n        let i = 0;\r\n        while (i < tickIntervals.length && target > tickIntervals[i][2]) {\r\n            i++;\r\n        }\r\n        if (i === 0) {\r\n            step = Math.max(tickStep(start, stop, tickCount, minCount, maxCount), 1);\r\n            countableTimeInterval = this.millisecond;\r\n        }\r\n        else if (i === tickIntervals.length) {\r\n            const y0 = start / durationYear;\r\n            const y1 = stop / durationYear;\r\n            step = tickStep(y0, y1, tickCount, minCount, maxCount);\r\n            countableTimeInterval = this.year;\r\n        }\r\n        else {\r\n            const diff0 = target - tickIntervals[i - 1][2];\r\n            const diff1 = tickIntervals[i][2] - target;\r\n            const index = diff0 < diff1 ? i - 1 : i;\r\n            [countableTimeInterval, step] = tickIntervals[index];\r\n        }\r\n        return countableTimeInterval.every(step);\r\n    }\r\n    invert(y) {\r\n        return new Date(super.invert(y));\r\n    }\r\n    /**\r\n     * Returns uniformly-spaced dates that represent the scale's domain.\r\n     */\r\n    ticks() {\r\n        if (!this.domain || this.domain.length < 2) {\r\n            return [];\r\n        }\r\n        this.refresh();\r\n        const [t0, t1] = this.getDomain().map(toNumber);\r\n        if (this.interval !== undefined) {\r\n            return this.getTicksForInterval({ start: t0, stop: t1 });\r\n        }\r\n        if (this.nice) {\r\n            const { tickCount } = this;\r\n            if (tickCount === 2) {\r\n                return this.niceDomain;\r\n            }\r\n            if (tickCount === 1) {\r\n                return this.niceDomain.slice(0, 1);\r\n            }\r\n        }\r\n        return this.getDefaultTicks({ start: t0, stop: t1 });\r\n    }\r\n    getDefaultTicks({ start, stop }) {\r\n        const t = this.getTickInterval({\r\n            start,\r\n            stop,\r\n            count: this.tickCount,\r\n            minCount: this.minTickCount,\r\n            maxCount: this.maxTickCount,\r\n        });\r\n        return t ? t.range(new Date(start), new Date(stop)) : []; // inclusive stop\r\n    }\r\n    getTicksForInterval({ start, stop }) {\r\n        const { interval, tickIntervals } = this;\r\n        if (!interval) {\r\n            return [];\r\n        }\r\n        if (interval instanceof TimeInterval) {\r\n            const ticks = interval.range(new Date(start), new Date(stop));\r\n            if (this.isDenseInterval({ start, stop, interval, count: ticks.length })) {\r\n                return this.getDefaultTicks({ start, stop });\r\n            }\r\n            return ticks;\r\n        }\r\n        const absInterval = Math.abs(interval);\r\n        if (this.isDenseInterval({ start, stop, interval: absInterval })) {\r\n            return this.getDefaultTicks({ start, stop });\r\n        }\r\n        const reversedInterval = [...tickIntervals];\r\n        reversedInterval.reverse();\r\n        const timeInterval = reversedInterval.find((tickInterval) => absInterval % tickInterval[2] === 0);\r\n        if (timeInterval) {\r\n            const i = timeInterval[0].every(absInterval / (timeInterval[2] / timeInterval[1]));\r\n            return i.range(new Date(start), new Date(stop));\r\n        }\r\n        let date = new Date(start);\r\n        const stopDate = new Date(stop);\r\n        const ticks = [];\r\n        while (date <= stopDate) {\r\n            ticks.push(date);\r\n            date = new Date(date);\r\n            date.setMilliseconds(date.getMilliseconds() + absInterval);\r\n        }\r\n        return ticks;\r\n    }\r\n    /**\r\n     * Returns a time format function suitable for displaying tick values.\r\n     * @param specifier If the specifier string is provided, this method is equivalent to\r\n     * the {@link TimeLocaleObject.format} method.\r\n     * If no specifier is provided, this method returns the default time format function.\r\n     */\r\n    tickFormat({ ticks, specifier }) {\r\n        return specifier == undefined ? this.defaultTickFormat(ticks) : buildFormatter(specifier);\r\n    }\r\n    update() {\r\n        if (!this.domain || this.domain.length < 2) {\r\n            return;\r\n        }\r\n        if (this.nice) {\r\n            this.updateNiceDomain();\r\n        }\r\n    }\r\n    /**\r\n     * Extends the domain so that it starts and ends on nice round values.\r\n     * This method typically modifies the scale’s domain, and may only extend the bounds to the nearest round value.\r\n     */\r\n    updateNiceDomain() {\r\n        const maxAttempts = 4;\r\n        let [d0, d1] = this.domain;\r\n        for (let i = 0; i < maxAttempts; i++) {\r\n            this.updateNiceDomainIteration(d0, d1);\r\n            const [n0, n1] = this.niceDomain;\r\n            if (toNumber(d0) === toNumber(n0) && toNumber(d1) === toNumber(n1)) {\r\n                break;\r\n            }\r\n            d0 = n0;\r\n            d1 = n1;\r\n        }\r\n    }\r\n    updateNiceDomainIteration(d0, d1) {\r\n        const start = toNumber(d0);\r\n        const stop = toNumber(d1);\r\n        const { interval } = this;\r\n        let i;\r\n        if (interval instanceof TimeInterval) {\r\n            i = interval;\r\n        }\r\n        else {\r\n            const tickCount = typeof interval === 'number' ? (stop - start) / Math.max(interval, 1) : this.tickCount;\r\n            i = this.getTickInterval({\r\n                start,\r\n                stop,\r\n                count: tickCount,\r\n                minCount: this.minTickCount,\r\n                maxCount: this.maxTickCount,\r\n            });\r\n        }\r\n        if (i) {\r\n            const intervalRange = i.range(d0, d1, true);\r\n            const n0 = intervalRange[0];\r\n            const n1 = intervalRange[intervalRange.length - 1];\r\n            this.niceDomain = [n0, n1];\r\n        }\r\n    }\r\n}\n\nclass Padding {\r\n    constructor(top = 0, right = top, bottom = top, left = right) {\r\n        this.top = top;\r\n        this.right = right;\r\n        this.bottom = bottom;\r\n        this.left = left;\r\n    }\r\n    clear() {\r\n        this.top = this.right = this.bottom = this.left = 0;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Padding.prototype, \"top\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Padding.prototype, \"right\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Padding.prototype, \"bottom\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Padding.prototype, \"left\", void 0);\n\nvar sparklinesUtil = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    extent: extent,\n    normalisedExtent: normalisedExtent,\n    normalisedExtentWithMetadata: normalisedExtentWithMetadata,\n    toFixed: toFixed,\n    isNumberEqual: isEqual,\n    tickFormat: tickFormat,\n    interpolateString: interpolate,\n    ticks: ticks,\n    tickStep: tickStep,\n    range: range$1,\n    Color: Color,\n    isString: isString,\n    isStringObject: isStringObject,\n    isDate: isDate,\n    isDiscrete: isDiscrete,\n    isContinuous: isContinuous,\n    checkDatum: checkDatum,\n    isNumber: isNumber,\n    resetIds: resetIds,\n    createId: createId,\n    Padding: Padding,\n    jsonDiff: jsonDiff,\n    DELETE: DELETE,\n    jsonMerge: jsonMerge,\n    jsonApply: jsonApply,\n    jsonWalk: jsonWalk,\n    normalizeAngle360: normalizeAngle360,\n    normalizeAngle360Inclusive: normalizeAngle360Inclusive,\n    normalizeAngle180: normalizeAngle180,\n    toRadians: toRadians,\n    toDegrees: toDegrees,\n    angleBetween: angleBetween,\n    zipObject: zipObject,\n    clamp: clamp,\n    isEqual: isEqual,\n    isNegative: isNegative,\n    round: round$1,\n    mod: mod,\n    sanitizeHtml: sanitizeHtml,\n    Logger: Logger\n});\n\nfunction areArrayNumbersEqual(arrA, arrB) {\r\n    return arrA.length === arrB.length && arrA.every((item, i) => Number(item) === Number(arrB[i]));\r\n}\n\nfunction circleRectOverlap(c, x, y, w, h) {\r\n    // Find closest horizontal and vertical edges.\r\n    let edgeX = c.x;\r\n    if (c.x < x) {\r\n        edgeX = x;\r\n    }\r\n    else if (c.x > x + w) {\r\n        edgeX = x + w;\r\n    }\r\n    let edgeY = c.y;\r\n    if (c.y < y) {\r\n        edgeY = y;\r\n    }\r\n    else if (c.y > y + h) {\r\n        edgeY = y + h;\r\n    }\r\n    // Find distance to closest edges.\r\n    const dx = c.x - edgeX;\r\n    const dy = c.y - edgeY;\r\n    const d = Math.sqrt(dx * dx + dy * dy);\r\n    return d <= c.size * 0.5;\r\n}\r\nfunction rectRectOverlap(r1, x2, y2, w2, h2) {\r\n    const xOverlap = r1.x + r1.width > x2 && r1.x < x2 + w2;\r\n    const yOverlap = r1.y + r1.height > y2 && r1.y < y2 + h2;\r\n    return xOverlap && yOverlap;\r\n}\r\nfunction rectContainsRect(r1, r2x, r2y, r2w, r2h) {\r\n    return r2x + r2w < r1.x + r1.width && r2x > r1.x && r2y > r1.y && r2y + r2h < r1.y + r1.height;\r\n}\r\nfunction isPointLabelDatum(x) {\r\n    return x != null && typeof x.point === 'object' && typeof x.label === 'object';\r\n}\r\n/**\r\n * @param data Points and labels for one or more series. The order of series determines label placement precedence.\r\n * @param bounds Bounds to fit the labels into. If a label can't be fully contained, it doesn't fit.\r\n * @returns Placed labels for the given series (in the given order).\r\n */\r\nfunction placeLabels(data, bounds, padding = 5) {\r\n    const result = [];\r\n    data = data.map((d) => d.slice().sort((a, b) => b.point.size - a.point.size));\r\n    for (let j = 0; j < data.length; j++) {\r\n        const labels = (result[j] = []);\r\n        const datum = data[j];\r\n        if (!((datum === null || datum === void 0 ? void 0 : datum.length) && datum[0].label)) {\r\n            continue;\r\n        }\r\n        for (let i = 0, ln = datum.length; i < ln; i++) {\r\n            const d = datum[i];\r\n            const l = d.label;\r\n            const r = d.point.size * 0.5;\r\n            const x = d.point.x - l.width * 0.5;\r\n            const y = d.point.y - r - l.height - padding;\r\n            const { width, height } = l;\r\n            const withinBounds = !bounds || rectContainsRect(bounds, x, y, width, height);\r\n            if (!withinBounds) {\r\n                continue;\r\n            }\r\n            const overlapPoints = data.some((datum) => datum.some((d) => circleRectOverlap(d.point, x, y, width, height)));\r\n            if (overlapPoints) {\r\n                continue;\r\n            }\r\n            const overlapLabels = result.some((labels) => labels.some((l) => rectRectOverlap(l, x, y, width, height)));\r\n            if (overlapLabels) {\r\n                continue;\r\n            }\r\n            labels.push({\r\n                index: i,\r\n                text: l.text,\r\n                x,\r\n                y,\r\n                width,\r\n                height,\r\n                datum: d,\r\n            });\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction axisLabelsOverlap(data, padding) {\r\n    const result = [];\r\n    for (let i = 0; i < data.length; i++) {\r\n        const datum = data[i];\r\n        const { point: { x, y }, label: { text }, } = datum;\r\n        let { label: { width, height }, } = datum;\r\n        width += padding !== null && padding !== void 0 ? padding : 0;\r\n        height += padding !== null && padding !== void 0 ? padding : 0;\r\n        const overlapLabels = result.some((l) => {\r\n            return rectRectOverlap(l, x, y, width, height);\r\n        });\r\n        if (overlapLabels) {\r\n            return true;\r\n        }\r\n        result.push({\r\n            index: i,\r\n            text,\r\n            x,\r\n            y,\r\n            width,\r\n            height,\r\n            datum,\r\n        });\r\n    }\r\n    return false;\r\n}\n\nconst GRID_STYLE_KEYS = ['stroke', 'lineDash'];\r\nconst GRID_STYLE = predicateWithMessage(ARRAY(undefined, (o) => {\r\n    for (const key in o) {\r\n        if (!GRID_STYLE_KEYS.includes(key)) {\r\n            return false;\r\n        }\r\n    }\r\n    return true;\r\n}), `expecting an Array of objects with gridline style properties such as 'stroke' and 'lineDash'`);\r\nclass AxisGridLine {\r\n    constructor() {\r\n        this.enabled = true;\r\n        this.width = 1;\r\n        this.style = [\r\n            {\r\n                stroke: undefined,\r\n                lineDash: [],\r\n            },\r\n        ];\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], AxisGridLine.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisGridLine.prototype, \"width\", void 0);\r\n__decorate([\r\n    Validate(GRID_STYLE),\r\n    __metadata(\"design:type\", Array)\r\n], AxisGridLine.prototype, \"style\", void 0);\n\nfunction Default(defaultValue, replaces = [undefined]) {\r\n    return addTransformToInstanceProperty((_, __, v) => {\r\n        if (replaces.includes(v)) {\r\n            return defaultValue;\r\n        }\r\n        return v;\r\n    });\r\n}\n\nclass AxisLabel {\r\n    constructor() {\r\n        this.enabled = true;\r\n        /** If set to `false`, axis labels will not be wrapped on multiple lines. */\r\n        this.autoWrap = false;\r\n        /** Used to constrain the width of the label when `autoWrap` is `true`, if the label text width exceeds the `maxWidth`, it will be wrapped on multiple lines automatically. If `maxWidth` is omitted, a default width constraint will be applied. */\r\n        this.maxWidth = undefined;\r\n        /** Used to constrain the height of the multiline label, if the label text height exceeds the `maxHeight`, it will be truncated automatically. If `maxHeight` is omitted, a default height constraint will be applied. */\r\n        this.maxHeight = undefined;\r\n        this.fontStyle = undefined;\r\n        this.fontWeight = undefined;\r\n        this.fontSize = 12;\r\n        this.fontFamily = 'Verdana, sans-serif';\r\n        /**\r\n         * The padding between the labels and the ticks.\r\n         */\r\n        this.padding = 5;\r\n        /**\r\n         * Minimum gap in pixels between the axis labels before being removed to avoid collisions.\r\n         */\r\n        this.minSpacing = NaN;\r\n        /**\r\n         * The color of the labels.\r\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\r\n         */\r\n        this.color = 'rgba(87, 87, 87, 1)';\r\n        /**\r\n         * Custom label rotation in degrees.\r\n         * Labels are rendered perpendicular to the axis line by default.\r\n         * Or parallel to the axis line, if the {@link parallel} is set to `true`.\r\n         * The value of this config is used as the angular offset/deflection\r\n         * from the default rotation.\r\n         */\r\n        this.rotation = undefined;\r\n        /**\r\n         * Avoid axis label collision by automatically reducing the number of ticks displayed. If set to `false`, axis labels may collide.\r\n         */\r\n        this.avoidCollisions = true;\r\n        /**\r\n         * By default, labels and ticks are positioned to the left of the axis line.\r\n         * `true` positions the labels to the right of the axis line.\r\n         * However, if the axis is rotated, it's easier to think in terms\r\n         * of this side or the opposite side, rather than left and right.\r\n         * We use the term `mirror` for conciseness, although it's not\r\n         * true mirroring - for example, when a label is rotated, so that\r\n         * it is inclined at the 45 degree angle, text flowing from north-west\r\n         * to south-east, ending at the tick to the left of the axis line,\r\n         * and then we set this config to `true`, the text will still be flowing\r\n         * from north-west to south-east, _starting_ at the tick to the right\r\n         * of the axis line.\r\n         */\r\n        this.mirrored = false;\r\n        /**\r\n         * Labels are rendered perpendicular to the axis line by default.\r\n         * Setting this config to `true` makes labels render parallel to the axis line\r\n         * and center aligns labels' text at the ticks.\r\n         */\r\n        this.parallel = false;\r\n        /**\r\n         * In case {@param value} is a number, the {@param fractionDigits} parameter will\r\n         * be provided as well. The `fractionDigits` corresponds to the number of fraction\r\n         * digits used by the tick step. For example, if the tick step is `0.0005`,\r\n         * the `fractionDigits` is 4.\r\n         */\r\n        this.formatter = undefined;\r\n    }\r\n    /**\r\n     * The side of the axis line to position the labels on.\r\n     * -1 = left (default)\r\n     * 1 = right\r\n     */\r\n    getSideFlag() {\r\n        return this.mirrored ? 1 : -1;\r\n    }\r\n    getFont() {\r\n        return getFont(this);\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], AxisLabel.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], AxisLabel.prototype, \"autoWrap\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisLabel.prototype, \"maxWidth\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisLabel.prototype, \"maxHeight\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_STYLE),\r\n    __metadata(\"design:type\", String)\r\n], AxisLabel.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_WEIGHT),\r\n    __metadata(\"design:type\", String)\r\n], AxisLabel.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(1)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisLabel.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", String)\r\n], AxisLabel.prototype, \"fontFamily\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisLabel.prototype, \"padding\", void 0);\r\n__decorate([\r\n    Validate(NUMBER_OR_NAN()),\r\n    Default(NaN),\r\n    __metadata(\"design:type\", Number)\r\n], AxisLabel.prototype, \"minSpacing\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AxisLabel.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(-360, 360)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisLabel.prototype, \"rotation\", void 0);\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], AxisLabel.prototype, \"avoidCollisions\", void 0);\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], AxisLabel.prototype, \"mirrored\", void 0);\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], AxisLabel.prototype, \"parallel\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AxisLabel.prototype, \"format\", void 0);\n\nclass AxisLine {\r\n    constructor() {\r\n        this.enabled = true;\r\n        this.width = 1;\r\n        this.color = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], AxisLine.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisLine.prototype, \"width\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AxisLine.prototype, \"color\", void 0);\n\nconst OPT_TICK_INTERVAL = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, (v, ctx) => (v !== 0 && NUMBER$1(0)(v, ctx)) || v instanceof TimeInterval), `expecting an optional non-zero positive Number value or, for a time axis, a Time Interval such as 'agCharts.time.month'`);\r\nclass AxisTick {\r\n    constructor() {\r\n        this.enabled = true;\r\n        /**\r\n         * The line width to be used by axis ticks.\r\n         */\r\n        this.width = 1;\r\n        /**\r\n         * The line length to be used by axis ticks.\r\n         */\r\n        this.size = 6;\r\n        /**\r\n         * The color of the axis ticks.\r\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make the ticks invisible.\r\n         */\r\n        this.color = undefined;\r\n        this.interval = undefined;\r\n        this.values = undefined;\r\n        this.minSpacing = NaN;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], AxisTick.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisTick.prototype, \"width\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AxisTick.prototype, \"size\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AxisTick.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(OPT_TICK_INTERVAL),\r\n    __metadata(\"design:type\", Object)\r\n], AxisTick.prototype, \"interval\", void 0);\r\n__decorate([\r\n    Validate(OPT_ARRAY()),\r\n    __metadata(\"design:type\", Array)\r\n], AxisTick.prototype, \"values\", void 0);\r\n__decorate([\r\n    Validate(AND(NUMBER_OR_NAN(1), LESS_THAN('maxSpacing'))),\r\n    Default(NaN),\r\n    __metadata(\"design:type\", Number)\r\n], AxisTick.prototype, \"minSpacing\", void 0);\n\nfunction prepareAxisAnimationContext(axis) {\r\n    const requestedRangeMin = Math.min(...axis.range);\r\n    const requestedRangeMax = Math.max(...axis.range);\r\n    const min = Math.floor(requestedRangeMin);\r\n    const max = Math.ceil(requestedRangeMax);\r\n    const visible = min !== max;\r\n    return { min, max, visible };\r\n}\r\nconst fullCircle = Math.PI * 2;\r\nconst halfCircle = fullCircle / 2;\r\nfunction normaliseEndRotation(start, end) {\r\n    const directDistance = Math.abs(end - start);\r\n    if (directDistance < halfCircle)\r\n        return end;\r\n    if (start > end)\r\n        return end + fullCircle;\r\n    return end - fullCircle;\r\n}\r\nfunction prepareAxisAnimationFunctions(ctx) {\r\n    const outOfBounds = (datum) => {\r\n        var _a, _b;\r\n        const min = Math.min(...((_a = datum.range) !== null && _a !== void 0 ? _a : [ctx.min]));\r\n        const max = Math.max(...((_b = datum.range) !== null && _b !== void 0 ? _b : [ctx.max]));\r\n        const translationY = Math.round(datum.translationY);\r\n        return translationY < min || translationY > max;\r\n    };\r\n    const calculateStatus = (datum, nodeDatum, status) => {\r\n        if (status !== 'removed' && outOfBounds(datum)) {\r\n            return 'removed';\r\n        }\r\n        else if (status !== 'added' && outOfBounds(nodeDatum)) {\r\n            return 'added';\r\n        }\r\n        return status;\r\n    };\r\n    const fromBase = (node, datum, status) => {\r\n        // Default to starting at the same position that the node is currently in.\r\n        const source = { translationY: Math.round(node.translationY), opacity: node.opacity };\r\n        status = calculateStatus(datum, node.datum, status);\r\n        if (status === 'added') {\r\n            source.translationY = Math.round(datum.translationY);\r\n            source.opacity = 0;\r\n        }\r\n        return Object.assign(Object.assign({}, source), FROM_TO_MIXINS[status]);\r\n    };\r\n    const toBase = (_node, datum, status) => {\r\n        const target = { translationY: Math.round(datum.translationY), opacity: 1 };\r\n        if (status === 'removed') {\r\n            target.opacity = 0;\r\n        }\r\n        return target;\r\n    };\r\n    const tick = {\r\n        fromFn: fromBase,\r\n        toFn: toBase,\r\n        intermediateFn: (node, _datum, _status) => {\r\n            return { visible: !outOfBounds(node) };\r\n        },\r\n    };\r\n    const label = {\r\n        fromFn: ((node, newDatum, status) => {\r\n            var _a;\r\n            const datum = (_a = node.previousDatum) !== null && _a !== void 0 ? _a : newDatum;\r\n            let rotation = datum.rotation;\r\n            if (status === 'added' || status === 'removed') {\r\n                rotation = newDatum.rotation;\r\n            }\r\n            return Object.assign(Object.assign({}, fromBase(node, newDatum, status)), { x: datum.x, y: datum.y, rotation, rotationCenterX: datum.rotationCenterX });\r\n        }),\r\n        toFn: ((node, datum, status) => {\r\n            var _a, _b;\r\n            let rotation;\r\n            if (status === 'added' || status === 'removed') {\r\n                rotation = datum.rotation;\r\n            }\r\n            else {\r\n                rotation = normaliseEndRotation((_b = (_a = node.previousDatum) === null || _a === void 0 ? void 0 : _a.rotation) !== null && _b !== void 0 ? _b : datum.rotation, datum.rotation);\r\n            }\r\n            return Object.assign(Object.assign({}, toBase(node, datum, status)), { x: datum.x, y: datum.y, rotation, rotationCenterX: datum.rotationCenterX, finish: { rotation: datum.rotation } });\r\n        }),\r\n    };\r\n    const line = {\r\n        fromFn: (node, datum) => {\r\n            var _a, _b;\r\n            return Object.assign(Object.assign({}, ((_b = (_a = node.previousDatum) !== null && _a !== void 0 ? _a : datum) !== null && _b !== void 0 ? _b : { y: node.y, x1: node.x1, x2: node.x2 })), FROM_TO_MIXINS['updated']);\r\n        },\r\n        toFn: (_node, datum) => {\r\n            return Object.assign({}, datum);\r\n        },\r\n    };\r\n    const group = {\r\n        fromFn: (group, _datum) => {\r\n            const { rotation, translationX, translationY } = group;\r\n            return Object.assign({ rotation,\r\n                translationX,\r\n                translationY }, FROM_TO_MIXINS['updated']);\r\n        },\r\n        toFn: (_group, datum) => {\r\n            const { rotation, translationX, translationY } = datum;\r\n            return {\r\n                rotation,\r\n                translationX,\r\n                translationY,\r\n            };\r\n        },\r\n    };\r\n    return { tick, line, label, group };\r\n}\r\nfunction resetAxisGroupFn() {\r\n    return (_node, datum) => {\r\n        return {\r\n            rotation: datum.rotation,\r\n            rotationCenterX: datum.rotationCenterX,\r\n            rotationCenterY: datum.rotationCenterY,\r\n            translationX: datum.translationX,\r\n            translationY: datum.translationY,\r\n        };\r\n    };\r\n}\r\nfunction resetAxisSelectionFn(ctx) {\r\n    const { visible: rangeVisible, min, max } = ctx;\r\n    return (_node, datum) => {\r\n        const translationY = Math.round(datum.translationY);\r\n        const visible = rangeVisible && translationY >= min && translationY <= max;\r\n        return {\r\n            translationY,\r\n            opacity: 1,\r\n            visible,\r\n        };\r\n    };\r\n}\r\nfunction resetAxisLabelSelectionFn() {\r\n    return (_node, datum) => {\r\n        return {\r\n            x: datum.x,\r\n            y: datum.y,\r\n            translationY: datum.translationY,\r\n            rotation: datum.rotation,\r\n            rotationCenterX: datum.rotationCenterX,\r\n        };\r\n    };\r\n}\r\nfunction resetAxisLineSelectionFn() {\r\n    return (_node, datum) => {\r\n        return Object.assign({}, datum);\r\n    };\r\n}\n\nvar Tags;\r\n(function (Tags) {\r\n    Tags[Tags[\"TickLine\"] = 0] = \"TickLine\";\r\n    Tags[Tags[\"TickLabel\"] = 1] = \"TickLabel\";\r\n    Tags[Tags[\"GridLine\"] = 2] = \"GridLine\";\r\n    Tags[Tags[\"GridArc\"] = 3] = \"GridArc\";\r\n    Tags[Tags[\"AxisLine\"] = 4] = \"AxisLine\";\r\n})(Tags || (Tags = {}));\r\nvar TickGenerationType;\r\n(function (TickGenerationType) {\r\n    TickGenerationType[TickGenerationType[\"CREATE\"] = 0] = \"CREATE\";\r\n    TickGenerationType[TickGenerationType[\"CREATE_SECONDARY\"] = 1] = \"CREATE_SECONDARY\";\r\n    TickGenerationType[TickGenerationType[\"FILTER\"] = 2] = \"FILTER\";\r\n    TickGenerationType[TickGenerationType[\"VALUES\"] = 3] = \"VALUES\";\r\n})(TickGenerationType || (TickGenerationType = {}));\r\n/**\r\n * A general purpose linear axis with no notion of orientation.\r\n * The axis is always rendered vertically, with horizontal labels positioned to the left\r\n * of the axis line by default. The axis can be {@link rotation | rotated} by an arbitrary angle,\r\n * so that it can be used as a top, right, bottom, left, radial or any other kind\r\n * of linear axis.\r\n * The generic `D` parameter is the type of the domain of the axis' scale.\r\n * The output range of the axis' scale is always numeric (screen coordinates).\r\n */\r\nclass Axis {\r\n    get type() {\r\n        var _a;\r\n        return (_a = this.constructor.type) !== null && _a !== void 0 ? _a : '';\r\n    }\r\n    set crossLines(value) {\r\n        var _a, _b;\r\n        (_a = this._crossLines) === null || _a === void 0 ? void 0 : _a.forEach((crossLine) => this.detachCrossLine(crossLine));\r\n        if (value) {\r\n            this.assignCrossLineArrayConstructor(value);\r\n        }\r\n        this._crossLines = value;\r\n        (_b = this._crossLines) === null || _b === void 0 ? void 0 : _b.forEach((crossLine) => {\r\n            this.attachCrossLine(crossLine);\r\n            this.initCrossLine(crossLine);\r\n        });\r\n    }\r\n    get crossLines() {\r\n        return this._crossLines;\r\n    }\r\n    constructor(moduleCtx, scale) {\r\n        this.moduleCtx = moduleCtx;\r\n        this.scale = scale;\r\n        this.id = createId(this);\r\n        this.nice = true;\r\n        this.dataDomain = { domain: [], clipped: false };\r\n        this.keys = [];\r\n        this.boundSeries = [];\r\n        this.includeInvisibleDomains = false;\r\n        this.axisGroup = new Group({ name: `${this.id}-axis`, zIndex: Layers.AXIS_ZINDEX });\r\n        this.lineNode = this.axisGroup.appendChild(new Line());\r\n        this.tickLineGroup = this.axisGroup.appendChild(new Group({ name: `${this.id}-Axis-tick-lines`, zIndex: Layers.AXIS_ZINDEX }));\r\n        this.tickLabelGroup = this.axisGroup.appendChild(new Group({ name: `${this.id}-Axis-tick-labels`, zIndex: Layers.AXIS_ZINDEX }));\r\n        this.crossLineGroup = new Group({ name: `${this.id}-CrossLines` });\r\n        this.gridGroup = new Group({ name: `${this.id}-Axis-grid` });\r\n        this.gridLineGroup = this.gridGroup.appendChild(new Group({\r\n            name: `${this.id}-gridLines`,\r\n            zIndex: Layers.AXIS_GRID_ZINDEX,\r\n        }));\r\n        this.tickLineGroupSelection = Selection.select(this.tickLineGroup, Line, false);\r\n        this.tickLabelGroupSelection = Selection.select(this.tickLabelGroup, Text, false);\r\n        this.gridLineGroupSelection = Selection.select(this.gridLineGroup, Line, false);\r\n        this.line = new AxisLine();\r\n        this.tick = this.createTick();\r\n        this.gridLine = new AxisGridLine();\r\n        this.label = this.createLabel();\r\n        this.defaultTickMinSpacing = Axis.defaultTickMinSpacing;\r\n        this.translation = { x: 0, y: 0 };\r\n        this.rotation = 0; // axis rotation angle in degrees\r\n        this.layout = {\r\n            label: {\r\n                fractionDigits: 0,\r\n                padding: this.label.padding,\r\n                format: this.label.format,\r\n            },\r\n        };\r\n        this.destroyFns = [];\r\n        this.range = [0, 1];\r\n        this.visibleRange = [0, 1];\r\n        this.title = undefined;\r\n        this._titleCaption = new Caption();\r\n        /**\r\n         * The length of the grid. The grid is only visible in case of a non-zero value.\r\n         * In case {@link radialGrid} is `true`, the value is interpreted as an angle\r\n         * (in degrees).\r\n         */\r\n        this._gridLength = 0;\r\n        this.fractionDigits = 0;\r\n        /**\r\n         * The distance between the grid ticks and the axis ticks.\r\n         */\r\n        this.gridPadding = 0;\r\n        /**\r\n         * Is used to avoid collisions between axis labels and series.\r\n         */\r\n        this.seriesAreaPadding = 0;\r\n        this.tickGenerationResult = undefined;\r\n        this.maxThickness = Infinity;\r\n        this.moduleMap = new ModuleMap(this);\r\n        this.refreshScale();\r\n        this._titleCaption.node.rotation = -Math.PI / 2;\r\n        this.axisGroup.appendChild(this._titleCaption.node);\r\n        this.destroyFns.push(moduleCtx.interactionManager.addListener('hover', (e) => this.checkAxisHover(e)));\r\n        this.animationManager = moduleCtx.animationManager;\r\n        this.animationState = new StateMachine('empty', {\r\n            empty: {\r\n                update: {\r\n                    target: 'ready',\r\n                    action: () => this.resetSelectionNodes(),\r\n                },\r\n            },\r\n            ready: {\r\n                update: (data) => this.animateReadyUpdate(data),\r\n                resize: () => this.resetSelectionNodes(),\r\n            },\r\n        });\r\n        this._crossLines = [];\r\n        this.assignCrossLineArrayConstructor(this._crossLines);\r\n        let previousSize = undefined;\r\n        this.destroyFns.push(moduleCtx.layoutService.addListener('layout-complete', (e) => {\r\n            // Fire resize animation action if chart canvas size changes.\r\n            if (previousSize != null && jsonDiff(e.chart, previousSize) != null) {\r\n                this.animationState.transition('resize');\r\n            }\r\n            previousSize = Object.assign({}, e.chart);\r\n        }));\r\n        this.destroyFns.push(moduleCtx.updateService.addListener('update-complete', (e) => {\r\n            this.minRect = e.minRect;\r\n        }));\r\n    }\r\n    attachCrossLine(crossLine) {\r\n        this.crossLineGroup.appendChild(crossLine.group);\r\n    }\r\n    detachCrossLine(crossLine) {\r\n        this.crossLineGroup.removeChild(crossLine.group);\r\n    }\r\n    destroy() {\r\n        this.moduleMap.destroy();\r\n        this.destroyFns.forEach((f) => f());\r\n    }\r\n    refreshScale() {\r\n        var _a;\r\n        this.range = this.scale.range.slice();\r\n        (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach((crossLine) => {\r\n            this.initCrossLine(crossLine);\r\n        });\r\n    }\r\n    updateRange() {\r\n        var _a;\r\n        const { range: rr, visibleRange: vr, scale } = this;\r\n        const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\r\n        const shift = span * vr[0];\r\n        const start = rr[0] - shift;\r\n        scale.range = [start, start + span];\r\n        (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach((crossLine) => {\r\n            crossLine.clippedRange = [rr[0], rr[1]];\r\n        });\r\n    }\r\n    setCrossLinesVisible(visible) {\r\n        this.crossLineGroup.visible = visible;\r\n    }\r\n    attachAxis(axisNode, gridNode) {\r\n        gridNode.appendChild(this.gridGroup);\r\n        axisNode.appendChild(this.axisGroup);\r\n        axisNode.appendChild(this.crossLineGroup);\r\n    }\r\n    detachAxis(axisNode, gridNode) {\r\n        gridNode.removeChild(this.gridGroup);\r\n        axisNode.removeChild(this.axisGroup);\r\n        axisNode.removeChild(this.crossLineGroup);\r\n    }\r\n    /**\r\n     * Checks if a point or an object is in range.\r\n     * @param x A point (or object's starting point).\r\n     * @param width Object's width.\r\n     * @param tolerance Expands the range on both ends by this amount.\r\n     */\r\n    inRange(x, width = 0, tolerance = 0) {\r\n        const min = Math.min(...this.range);\r\n        const max = Math.max(...this.range);\r\n        return x + width >= min - tolerance && x <= max + tolerance;\r\n    }\r\n    onLabelFormatChange(ticks, format) {\r\n        const { scale, fractionDigits } = this;\r\n        const logScale = scale instanceof LogScale;\r\n        const defaultLabelFormatter = !logScale && fractionDigits > 0\r\n            ? (x) => (typeof x === 'number' ? x.toFixed(fractionDigits) : String(x))\r\n            : (x) => String(x);\r\n        if (format && scale && scale.tickFormat) {\r\n            try {\r\n                this.labelFormatter = scale.tickFormat({ ticks, specifier: format });\r\n            }\r\n            catch (e) {\r\n                this.labelFormatter = defaultLabelFormatter;\r\n                Logger.warnOnce(`the axis label format string ${format} is invalid. No formatting will be applied`);\r\n            }\r\n        }\r\n        else {\r\n            this.labelFormatter = defaultLabelFormatter;\r\n        }\r\n    }\r\n    setDomain() {\r\n        var _a;\r\n        const { scale, dataDomain: { domain }, tick: { values: tickValues }, } = this;\r\n        if (tickValues && ContinuousScale.is(scale)) {\r\n            const [tickMin, tickMax] = (_a = extent(tickValues)) !== null && _a !== void 0 ? _a : [Infinity, -Infinity];\r\n            const min = Math.min(scale.fromDomain(domain[0]), tickMin);\r\n            const max = Math.max(scale.fromDomain(domain[1]), tickMax);\r\n            scale.domain = [scale.toDomain(min), scale.toDomain(max)];\r\n        }\r\n        else {\r\n            scale.domain = domain;\r\n        }\r\n    }\r\n    setTickInterval(interval) {\r\n        var _a;\r\n        this.scale.interval = (_a = this.tick.interval) !== null && _a !== void 0 ? _a : interval;\r\n    }\r\n    setTickCount(count, minTickCount, maxTickCount) {\r\n        const { scale } = this;\r\n        if (!(count && ContinuousScale.is(scale))) {\r\n            return;\r\n        }\r\n        if (typeof count === 'number') {\r\n            scale.tickCount = count;\r\n            scale.minTickCount = minTickCount !== null && minTickCount !== void 0 ? minTickCount : 0;\r\n            scale.maxTickCount = maxTickCount !== null && maxTickCount !== void 0 ? maxTickCount : Infinity;\r\n            return;\r\n        }\r\n        if (scale instanceof TimeScale) {\r\n            this.setTickInterval(count);\r\n        }\r\n    }\r\n    set gridLength(value) {\r\n        var _a;\r\n        // Was visible and now invisible, or was invisible and now visible.\r\n        if ((this._gridLength && !value) || (!this._gridLength && value)) {\r\n            this.gridLineGroupSelection.clear();\r\n        }\r\n        this._gridLength = value;\r\n        (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach((crossLine) => {\r\n            this.initCrossLine(crossLine);\r\n        });\r\n    }\r\n    get gridLength() {\r\n        return this._gridLength;\r\n    }\r\n    createTick() {\r\n        return new AxisTick();\r\n    }\r\n    createLabel() {\r\n        return new AxisLabel();\r\n    }\r\n    checkAxisHover(event) {\r\n        const bbox = this.computeBBox();\r\n        const isInAxis = bbox.containsPoint(event.offsetX, event.offsetY);\r\n        if (!isInAxis)\r\n            return;\r\n        this.moduleCtx.chartEventManager.axisHover(this.id, this.direction);\r\n    }\r\n    /**\r\n     * Creates/removes/updates the scene graph nodes that constitute the axis.\r\n     */\r\n    update(primaryTickCount) {\r\n        if (!this.tickGenerationResult) {\r\n            return;\r\n        }\r\n        const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\r\n        const sideFlag = this.label.getSideFlag();\r\n        this.updatePosition();\r\n        const lineData = this.getAxisLineCoordinates();\r\n        const _a = this.tickGenerationResult, { tickData, combinedRotation, textBaseline, textAlign } = _a, ticksResult = __rest(_a, [\"tickData\", \"combinedRotation\", \"textBaseline\", \"textAlign\"]);\r\n        const previousTicks = this.tickLabelGroupSelection.nodes().map((node) => node.datum.tickId);\r\n        this.updateSelections(lineData, tickData.ticks, {\r\n            combinedRotation,\r\n            textAlign,\r\n            textBaseline,\r\n            range: this.scale.range,\r\n        });\r\n        if (this.animationManager.isSkipped()) {\r\n            this.resetSelectionNodes();\r\n        }\r\n        else {\r\n            const diff = this.calculateUpdateDiff(previousTicks, tickData);\r\n            this.animationState.transition('update', diff);\r\n        }\r\n        this.updateAxisLine();\r\n        this.updateLabels();\r\n        this.updateVisibility();\r\n        this.updateGridLines(sideFlag);\r\n        this.updateTickLines();\r\n        this.updateTitle({ anyTickVisible: tickData.ticks.length > 0 });\r\n        this.updateCrossLines({ rotation, parallelFlipRotation, regularFlipRotation });\r\n        this.updateLayoutState();\r\n        primaryTickCount = ticksResult.primaryTickCount;\r\n        return primaryTickCount;\r\n    }\r\n    getAxisLineCoordinates() {\r\n        const { range: [start, end], } = this;\r\n        const x = 0;\r\n        const y1 = Math.min(start, end);\r\n        const y2 = Math.max(start, end);\r\n        return { x, y1, y2 };\r\n    }\r\n    getTickLineCoordinates(datum) {\r\n        const { tick, label } = this;\r\n        const sideFlag = label.getSideFlag();\r\n        const x = sideFlag * tick.size;\r\n        const x1 = Math.min(0, x);\r\n        const x2 = x1 + Math.abs(x);\r\n        const y = Math.round(datum.translationY);\r\n        return { x1, x2, y };\r\n    }\r\n    getTickLabelProps(datum, params) {\r\n        const { label } = this;\r\n        const { combinedRotation, textBaseline, textAlign, range } = params;\r\n        const text = datum.tickLabel;\r\n        const sideFlag = label.getSideFlag();\r\n        const tickSize = this.tick.size;\r\n        const labelX = sideFlag * (tickSize + label.padding + this.seriesAreaPadding);\r\n        const visible = text !== '' && text != undefined;\r\n        return {\r\n            tickId: datum.tickId,\r\n            translationY: datum.translationY,\r\n            fill: label.color,\r\n            fontFamily: label.fontFamily,\r\n            fontSize: label.fontSize,\r\n            fontStyle: label.fontStyle,\r\n            fontWeight: label.fontWeight,\r\n            rotation: combinedRotation,\r\n            rotationCenterX: labelX,\r\n            text,\r\n            textAlign,\r\n            textBaseline,\r\n            visible,\r\n            x: labelX,\r\n            y: 0,\r\n            range,\r\n        };\r\n    }\r\n    setTitleProps(caption, params) {\r\n        var _a;\r\n        const { title } = this;\r\n        if (!title) {\r\n            caption.enabled = false;\r\n            return;\r\n        }\r\n        caption.color = title.color;\r\n        caption.fontFamily = title.fontFamily;\r\n        caption.fontSize = title.fontSize;\r\n        caption.fontStyle = title.fontStyle;\r\n        caption.fontWeight = title.fontWeight;\r\n        caption.enabled = title.enabled;\r\n        caption.wrapping = title.wrapping;\r\n        if (title.enabled) {\r\n            const titleNode = caption.node;\r\n            const { tickSpace } = params;\r\n            const padding = ((_a = title.spacing) !== null && _a !== void 0 ? _a : 0) + tickSpace;\r\n            const sideFlag = this.label.getSideFlag();\r\n            const parallelFlipRotation = normalizeAngle360(this.rotation);\r\n            const titleRotationFlag = sideFlag === -1 && parallelFlipRotation > Math.PI && parallelFlipRotation < Math.PI * 2 ? -1 : 1;\r\n            const rotation = (titleRotationFlag * sideFlag * Math.PI) / 2;\r\n            const textBaseline = titleRotationFlag === 1 ? 'bottom' : 'top';\r\n            const { range } = this;\r\n            const x = Math.floor((titleRotationFlag * sideFlag * (range[0] + range[1])) / 2);\r\n            const y = sideFlag === -1 ? Math.floor(titleRotationFlag * -padding) : Math.floor(-padding);\r\n            const { callbackCache } = this.moduleCtx;\r\n            const { formatter = (params) => params.defaultValue } = title;\r\n            const text = callbackCache.call(formatter, this.getTitleFormatterParams());\r\n            titleNode.setProperties({\r\n                rotation,\r\n                text,\r\n                textBaseline,\r\n                visible: true,\r\n                x,\r\n                y,\r\n            });\r\n        }\r\n    }\r\n    calculateLayout(primaryTickCount) {\r\n        var _a;\r\n        const { rotation, parallelFlipRotation, regularFlipRotation } = this.calculateRotations();\r\n        const sideFlag = this.label.getSideFlag();\r\n        const labelX = sideFlag * (this.tick.size + this.label.padding + this.seriesAreaPadding);\r\n        this.updateScale();\r\n        this.tickGenerationResult = this.generateTicks({\r\n            primaryTickCount,\r\n            parallelFlipRotation,\r\n            regularFlipRotation,\r\n            labelX,\r\n            sideFlag,\r\n        });\r\n        const _b = this.tickGenerationResult, { tickData, combinedRotation, textBaseline, textAlign } = _b, ticksResult = __rest(_b, [\"tickData\", \"combinedRotation\", \"textBaseline\", \"textAlign\"]);\r\n        const boxes = [];\r\n        const { x, y1, y2 } = this.getAxisLineCoordinates();\r\n        const lineBox = new BBox(x, y1, 0, y2 - y1);\r\n        boxes.push(lineBox);\r\n        const { tick } = this;\r\n        if (tick.enabled) {\r\n            tickData.ticks.forEach((datum) => {\r\n                const { x1, x2, y } = this.getTickLineCoordinates(datum);\r\n                const tickLineBox = new BBox(x1, y, x2 - x1, 0);\r\n                boxes.push(tickLineBox);\r\n            });\r\n        }\r\n        const { label } = this;\r\n        if (label.enabled) {\r\n            const tempText = new Text();\r\n            tickData.ticks.forEach((datum) => {\r\n                const labelProps = this.getTickLabelProps(datum, {\r\n                    combinedRotation,\r\n                    textAlign,\r\n                    textBaseline,\r\n                    range: this.scale.range,\r\n                });\r\n                if (!labelProps.visible) {\r\n                    return;\r\n                }\r\n                tempText.setProperties(Object.assign(Object.assign({}, labelProps), { translationY: Math.round(datum.translationY) }));\r\n                const box = tempText.computeTransformedBBox();\r\n                if (box) {\r\n                    boxes.push(box);\r\n                }\r\n            });\r\n        }\r\n        const getTransformBox = (bbox) => {\r\n            const matrix = new Matrix();\r\n            const { rotation: axisRotation, translationX, translationY, rotationCenterX, rotationCenterY, } = this.getAxisTransform();\r\n            Matrix.updateTransformMatrix(matrix, 1, 1, axisRotation, translationX, translationY, {\r\n                scalingCenterX: 0,\r\n                scalingCenterY: 0,\r\n                rotationCenterX,\r\n                rotationCenterY,\r\n            });\r\n            return matrix.transformBBox(bbox);\r\n        };\r\n        const { title } = this;\r\n        if (title === null || title === void 0 ? void 0 : title.enabled) {\r\n            const caption = new Caption();\r\n            let tickSpace = 0;\r\n            if (tickData.ticks.length > 0) {\r\n                const contentBox = BBox.merge(boxes);\r\n                const tickWidth = contentBox.width;\r\n                if (isFinite(tickWidth)) {\r\n                    tickSpace += tickWidth;\r\n                }\r\n            }\r\n            this.setTitleProps(caption, { tickSpace });\r\n            const titleNode = caption.node;\r\n            const titleBox = titleNode.computeTransformedBBox();\r\n            if (titleBox) {\r\n                boxes.push(titleBox);\r\n            }\r\n        }\r\n        const bbox = BBox.merge(boxes);\r\n        const transformedBBox = getTransformBox(bbox);\r\n        const anySeriesActive = this.isAnySeriesActive();\r\n        (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach((crossLine) => {\r\n            var _a;\r\n            crossLine.sideFlag = -sideFlag;\r\n            crossLine.direction = rotation === -Math.PI / 2 ? ChartAxisDirection.X : ChartAxisDirection.Y;\r\n            if (crossLine instanceof CartesianCrossLine) {\r\n                crossLine.label.parallel = (_a = crossLine.label.parallel) !== null && _a !== void 0 ? _a : this.label.parallel;\r\n            }\r\n            crossLine.parallelFlipRotation = parallelFlipRotation;\r\n            crossLine.regularFlipRotation = regularFlipRotation;\r\n            crossLine.calculateLayout(anySeriesActive);\r\n        });\r\n        this.updateLayoutState();\r\n        primaryTickCount = ticksResult.primaryTickCount;\r\n        return { primaryTickCount, bbox: transformedBBox };\r\n    }\r\n    updateLayoutState() {\r\n        this.layout.label = {\r\n            fractionDigits: this.fractionDigits,\r\n            padding: this.label.padding,\r\n            format: this.label.format,\r\n        };\r\n    }\r\n    updateScale() {\r\n        this.updateRange();\r\n        this.calculateDomain();\r\n        this.setDomain();\r\n        this.setTickInterval(this.tick.interval);\r\n        const { scale, nice } = this;\r\n        if (!ContinuousScale.is(scale)) {\r\n            return;\r\n        }\r\n        scale.nice = nice;\r\n        scale.update();\r\n    }\r\n    calculateRotations() {\r\n        const rotation = toRadians(this.rotation);\r\n        // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\r\n        // flip the labels to avoid upside-down text, when the axis is rotated\r\n        // such that it is in the right hemisphere, i.e. the angle of rotation\r\n        // is in the [0, π] interval.\r\n        // The rotation angle is normalized, so that we have an easier time checking\r\n        // if it's in the said interval. Since the axis is always rendered vertically\r\n        // and then rotated, zero rotation means 12 (not 3) o-clock.\r\n        // -1 = flip\r\n        //  1 = don't flip (default)\r\n        const parallelFlipRotation = normalizeAngle360(rotation);\r\n        const regularFlipRotation = normalizeAngle360(rotation - Math.PI / 2);\r\n        return { rotation, parallelFlipRotation, regularFlipRotation };\r\n    }\r\n    generateTicks({ primaryTickCount, parallelFlipRotation, regularFlipRotation, labelX, sideFlag, }) {\r\n        var _a;\r\n        const { scale, tick, label: { parallel, rotation, fontFamily, fontSize, fontStyle, fontWeight }, } = this;\r\n        const secondaryAxis = primaryTickCount !== undefined;\r\n        const { defaultRotation, configuredRotation, parallelFlipFlag, regularFlipFlag } = calculateLabelRotation({\r\n            rotation,\r\n            parallel,\r\n            regularFlipRotation,\r\n            parallelFlipRotation,\r\n        });\r\n        const initialRotation = configuredRotation + defaultRotation;\r\n        const labelMatrix = new Matrix();\r\n        const { maxTickCount } = this.estimateTickCount({\r\n            minSpacing: tick.minSpacing,\r\n            maxSpacing: (_a = tick.maxSpacing) !== null && _a !== void 0 ? _a : NaN,\r\n        });\r\n        const continuous = ContinuousScale.is(scale);\r\n        const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\r\n        let textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\r\n        const textBaseline = getTextBaseline(parallel, configuredRotation, sideFlag, parallelFlipFlag);\r\n        const textProps = {\r\n            fontFamily,\r\n            fontSize,\r\n            fontStyle,\r\n            fontWeight,\r\n            textBaseline,\r\n            textAlign,\r\n        };\r\n        let tickData = {\r\n            rawTicks: [],\r\n            ticks: [],\r\n            labelCount: 0,\r\n        };\r\n        let index = 0;\r\n        let autoRotation = 0;\r\n        let labelOverlap = true;\r\n        let terminate = false;\r\n        while (labelOverlap && index <= maxIterations) {\r\n            if (terminate) {\r\n                break;\r\n            }\r\n            autoRotation = 0;\r\n            textAlign = getTextAlign(parallel, configuredRotation, 0, sideFlag, regularFlipFlag);\r\n            const tickStrategies = this.getTickStrategies({ secondaryAxis, index });\r\n            for (const strategy of tickStrategies) {\r\n                ({ tickData, index, autoRotation, terminate } = strategy({\r\n                    index,\r\n                    tickData,\r\n                    textProps,\r\n                    labelOverlap,\r\n                    terminate,\r\n                    primaryTickCount,\r\n                }));\r\n                const rotated = configuredRotation !== 0 || autoRotation !== 0;\r\n                const rotation = initialRotation + autoRotation;\r\n                textAlign = getTextAlign(parallel, configuredRotation, autoRotation, sideFlag, regularFlipFlag);\r\n                labelOverlap = this.checkLabelOverlap(rotation, rotated, labelMatrix, tickData.ticks, labelX, Object.assign(Object.assign({}, textProps), { textAlign }));\r\n            }\r\n        }\r\n        const combinedRotation = defaultRotation + configuredRotation + autoRotation;\r\n        if (!secondaryAxis && tickData.rawTicks.length > 0) {\r\n            primaryTickCount = tickData.rawTicks.length;\r\n        }\r\n        return { tickData, primaryTickCount, combinedRotation, textBaseline, textAlign };\r\n    }\r\n    getTickStrategies({ index, secondaryAxis }) {\r\n        const { scale, label, tick } = this;\r\n        const continuous = ContinuousScale.is(scale);\r\n        const avoidLabelCollisions = label.enabled && label.avoidCollisions;\r\n        const filterTicks = !continuous && index !== 0 && avoidLabelCollisions;\r\n        const autoRotate = label.autoRotate === true && label.rotation === undefined;\r\n        const strategies = [];\r\n        let tickGenerationType;\r\n        if (this.tick.values) {\r\n            tickGenerationType = TickGenerationType.VALUES;\r\n        }\r\n        else if (secondaryAxis) {\r\n            tickGenerationType = TickGenerationType.CREATE_SECONDARY;\r\n        }\r\n        else if (filterTicks) {\r\n            tickGenerationType = TickGenerationType.FILTER;\r\n        }\r\n        else {\r\n            tickGenerationType = TickGenerationType.CREATE;\r\n        }\r\n        const tickGenerationStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount);\r\n        strategies.push(tickGenerationStrategy);\r\n        if (!continuous && !isNaN(tick.minSpacing)) {\r\n            const tickFilterStrategy = ({ index, tickData, primaryTickCount, terminate }) => this.createTickData(TickGenerationType.FILTER, index, tickData, terminate, primaryTickCount);\r\n            strategies.push(tickFilterStrategy);\r\n        }\r\n        if (!avoidLabelCollisions) {\r\n            return strategies;\r\n        }\r\n        if (label.autoWrap) {\r\n            const autoWrapStrategy = ({ index, tickData, textProps }) => this.wrapLabels(tickData, index, textProps);\r\n            strategies.push(autoWrapStrategy);\r\n        }\r\n        else if (autoRotate) {\r\n            const autoRotateStrategy = ({ index, tickData, labelOverlap, terminate }) => ({\r\n                index,\r\n                tickData,\r\n                autoRotation: this.getAutoRotation(labelOverlap),\r\n                terminate,\r\n            });\r\n            strategies.push(autoRotateStrategy);\r\n        }\r\n        return strategies;\r\n    }\r\n    createTickData(tickGenerationType, index, tickData, terminate, primaryTickCount) {\r\n        var _a;\r\n        const { scale, tick } = this;\r\n        const { maxTickCount, minTickCount, defaultTickCount } = this.estimateTickCount({\r\n            minSpacing: tick.minSpacing,\r\n            maxSpacing: (_a = tick.maxSpacing) !== null && _a !== void 0 ? _a : NaN,\r\n        });\r\n        const continuous = ContinuousScale.is(scale);\r\n        const maxIterations = !continuous || isNaN(maxTickCount) ? 10 : maxTickCount;\r\n        let tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\r\n        const regenerateTicks = tick.interval === undefined &&\r\n            tick.values === undefined &&\r\n            tickCount > minTickCount &&\r\n            (continuous || tickGenerationType === TickGenerationType.FILTER);\r\n        let unchanged = true;\r\n        while (unchanged && index <= maxIterations) {\r\n            const prevTicks = tickData.rawTicks;\r\n            tickCount = continuous ? Math.max(defaultTickCount - index, minTickCount) : maxTickCount;\r\n            const { rawTicks, ticks, labelCount } = this.getTicks({\r\n                tickGenerationType,\r\n                previousTicks: prevTicks,\r\n                tickCount,\r\n                minTickCount,\r\n                maxTickCount,\r\n                primaryTickCount,\r\n            });\r\n            tickData.rawTicks = rawTicks;\r\n            tickData.ticks = ticks;\r\n            tickData.labelCount = labelCount;\r\n            unchanged = regenerateTicks ? areArrayNumbersEqual(rawTicks, prevTicks) : false;\r\n            index++;\r\n        }\r\n        const shouldTerminate = tick.interval !== undefined || tick.values !== undefined;\r\n        terminate || (terminate = shouldTerminate);\r\n        return { tickData, index, autoRotation: 0, terminate };\r\n    }\r\n    checkLabelOverlap(rotation, rotated, labelMatrix, tickData, labelX, textProps) {\r\n        Matrix.updateTransformMatrix(labelMatrix, 1, 1, rotation, 0, 0);\r\n        const labelData = this.createLabelData(tickData, labelX, textProps, labelMatrix);\r\n        const labelSpacing = getLabelSpacing(this.label.minSpacing, rotated);\r\n        return axisLabelsOverlap(labelData, labelSpacing);\r\n    }\r\n    createLabelData(tickData, labelX, textProps, labelMatrix) {\r\n        const labelData = [];\r\n        for (const tickDatum of tickData) {\r\n            const { tickLabel, translationY } = tickDatum;\r\n            if (tickLabel === '' || tickLabel == undefined) {\r\n                // skip user hidden ticks\r\n                continue;\r\n            }\r\n            const lines = splitText(tickLabel);\r\n            const { width, height } = measureText(lines, labelX, translationY, textProps);\r\n            const bbox = new BBox(labelX, translationY, width, height);\r\n            const labelDatum = calculateLabelBBox(tickLabel, bbox, labelX, translationY, labelMatrix);\r\n            labelData.push(labelDatum);\r\n        }\r\n        return labelData;\r\n    }\r\n    getAutoRotation(labelOverlap) {\r\n        var _a;\r\n        return labelOverlap ? normalizeAngle360(toRadians((_a = this.label.autoRotateAngle) !== null && _a !== void 0 ? _a : 0)) : 0;\r\n    }\r\n    getTicks({ tickGenerationType, previousTicks, tickCount, minTickCount, maxTickCount, primaryTickCount, }) {\r\n        var _a;\r\n        const { range, scale, visibleRange } = this;\r\n        let rawTicks = [];\r\n        switch (tickGenerationType) {\r\n            case TickGenerationType.VALUES:\r\n                rawTicks = this.tick.values;\r\n                break;\r\n            case TickGenerationType.CREATE_SECONDARY:\r\n                // `updateSecondaryAxisTicks` mutates `scale.domain` based on `primaryTickCount`\r\n                rawTicks = this.updateSecondaryAxisTicks(primaryTickCount);\r\n                break;\r\n            case TickGenerationType.FILTER:\r\n                rawTicks = this.filterTicks(previousTicks, tickCount);\r\n                break;\r\n            default:\r\n                rawTicks = this.createTicks(tickCount, minTickCount, maxTickCount);\r\n                break;\r\n        }\r\n        // When the scale domain or the ticks change, the label format may change\r\n        this.onLabelFormatChange(rawTicks, this.label.format);\r\n        // `ticks instanceof NumericTicks` doesn't work here, so we feature detect.\r\n        this.fractionDigits = rawTicks.fractionDigits >= 0 ? rawTicks.fractionDigits : 0;\r\n        const halfBandwidth = ((_a = scale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;\r\n        const ticks = [];\r\n        let labelCount = 0;\r\n        const tickIdCounts = new Map();\r\n        // Only get the ticks within a sliding window of the visible range to improve performance\r\n        const start = Math.max(0, Math.floor(visibleRange[0] * rawTicks.length));\r\n        const end = Math.min(rawTicks.length, Math.ceil(visibleRange[1] * rawTicks.length));\r\n        for (let i = start; i < end; i++) {\r\n            const rawTick = rawTicks[i];\r\n            const translationY = scale.convert(rawTick) + halfBandwidth;\r\n            // Do not render ticks outside the range with a small tolerance. A clip rect would trim long labels, so\r\n            // instead hide ticks based on their translation.\r\n            if (range.length > 0 && !this.inRange(translationY, 0, 0.001))\r\n                continue;\r\n            const tickLabel = this.formatTick(rawTick, i);\r\n            // Create a tick id from the label, or as an increment of the last label if this tick label is blank\r\n            let tickId = tickLabel;\r\n            if (tickIdCounts.has(tickId)) {\r\n                const count = tickIdCounts.get(tickId);\r\n                tickIdCounts.set(tickId, count + 1);\r\n                tickId = `${tickId}_${count}`;\r\n            }\r\n            else {\r\n                tickIdCounts.set(tickId, 1);\r\n            }\r\n            ticks.push({ tick: rawTick, tickId, tickLabel, translationY });\r\n            if (tickLabel === '' || tickLabel == undefined) {\r\n                continue;\r\n            }\r\n            labelCount++;\r\n        }\r\n        return { rawTicks, ticks, labelCount };\r\n    }\r\n    filterTicks(ticks, tickCount) {\r\n        var _a;\r\n        const tickSpacing = !isNaN(this.tick.minSpacing) || !isNaN((_a = this.tick.maxSpacing) !== null && _a !== void 0 ? _a : NaN);\r\n        const keepEvery = tickSpacing ? Math.ceil(ticks.length / tickCount) : 2;\r\n        return ticks.filter((_, i) => i % keepEvery === 0);\r\n    }\r\n    createTicks(tickCount, minTickCount, maxTickCount) {\r\n        var _a, _b, _c;\r\n        this.setTickCount(tickCount, minTickCount, maxTickCount);\r\n        return (_c = (_b = (_a = this.scale).ticks) === null || _b === void 0 ? void 0 : _b.call(_a)) !== null && _c !== void 0 ? _c : [];\r\n    }\r\n    estimateTickCount({ minSpacing, maxSpacing }) {\r\n        const { minRect } = this;\r\n        const rangeWithBleed = this.calculateRangeWithBleed();\r\n        const defaultMinSpacing = Math.max(this.defaultTickMinSpacing, rangeWithBleed / ContinuousScale.defaultMaxTickCount);\r\n        let clampMaxTickCount = !isNaN(maxSpacing);\r\n        if (isNaN(minSpacing)) {\r\n            minSpacing = defaultMinSpacing;\r\n        }\r\n        if (isNaN(maxSpacing)) {\r\n            maxSpacing = rangeWithBleed;\r\n        }\r\n        if (minSpacing > maxSpacing) {\r\n            if (minSpacing === defaultMinSpacing) {\r\n                minSpacing = maxSpacing;\r\n            }\r\n            else {\r\n                maxSpacing = minSpacing;\r\n            }\r\n        }\r\n        // Clamps the min spacing between ticks to be no more than the min distance between datums\r\n        const minRectDistance = minRect\r\n            ? this.direction === ChartAxisDirection.X\r\n                ? minRect.width\r\n                : minRect.height\r\n            : 1;\r\n        clampMaxTickCount && (clampMaxTickCount = minRectDistance < defaultMinSpacing);\r\n        const maxTickCount = clamp(1, Math.floor(rangeWithBleed / minSpacing), clampMaxTickCount ? Math.floor(rangeWithBleed / minRectDistance) : Infinity);\r\n        const minTickCount = Math.min(maxTickCount, Math.ceil(rangeWithBleed / maxSpacing));\r\n        const defaultTickCount = clamp(minTickCount, ContinuousScale.defaultTickCount, maxTickCount);\r\n        return { minTickCount, maxTickCount, defaultTickCount };\r\n    }\r\n    updateVisibility() {\r\n        if (this.moduleCtx.animationManager.isSkipped()) {\r\n            this.resetSelectionNodes();\r\n        }\r\n        this.tickLineGroup.visible = this.tick.enabled;\r\n        this.gridLineGroup.visible = this.gridLine.enabled;\r\n        this.tickLabelGroup.visible = this.label.enabled;\r\n    }\r\n    updateCrossLines({ rotation, parallelFlipRotation, regularFlipRotation, }) {\r\n        var _a;\r\n        const sideFlag = this.label.getSideFlag();\r\n        const anySeriesActive = this.isAnySeriesActive();\r\n        (_a = this.crossLines) === null || _a === void 0 ? void 0 : _a.forEach((crossLine) => {\r\n            var _a;\r\n            crossLine.sideFlag = -sideFlag;\r\n            crossLine.direction = rotation === -Math.PI / 2 ? ChartAxisDirection.X : ChartAxisDirection.Y;\r\n            if (crossLine instanceof CartesianCrossLine) {\r\n                crossLine.label.parallel = (_a = crossLine.label.parallel) !== null && _a !== void 0 ? _a : this.label.parallel;\r\n            }\r\n            crossLine.parallelFlipRotation = parallelFlipRotation;\r\n            crossLine.regularFlipRotation = regularFlipRotation;\r\n            crossLine.update(anySeriesActive);\r\n        });\r\n    }\r\n    updateTickLines() {\r\n        const { tick, label } = this;\r\n        const sideFlag = label.getSideFlag();\r\n        this.tickLineGroupSelection.each((line) => {\r\n            line.strokeWidth = tick.width;\r\n            line.stroke = tick.color;\r\n            line.x1 = sideFlag * tick.size;\r\n            line.x2 = 0;\r\n            line.y1 = 0;\r\n            line.y2 = 0;\r\n        });\r\n    }\r\n    calculateAvailableRange() {\r\n        const { range } = this;\r\n        const min = Math.min(...range);\r\n        const max = Math.max(...range);\r\n        return max - min;\r\n    }\r\n    /**\r\n     * Calculates the available range with an additional \"bleed\" beyond the canvas that encompasses the full axis when\r\n     * the visible range is only a portion of the axis.\r\n     */\r\n    calculateRangeWithBleed() {\r\n        const { visibleRange } = this;\r\n        const visibleScale = 1 / (visibleRange[1] - visibleRange[0]);\r\n        return round$1(this.calculateAvailableRange() * visibleScale, 2);\r\n    }\r\n    calculateDomain() {\r\n        if (this.linkedTo) {\r\n            this.dataDomain = this.linkedTo.dataDomain;\r\n        }\r\n        else {\r\n            const visibleSeries = this.boundSeries.filter((s) => this.includeInvisibleDomains || s.isEnabled());\r\n            const domains = visibleSeries.flatMap((series) => series.getDomain(this.direction));\r\n            this.dataDomain = this.normaliseDataDomain(domains);\r\n        }\r\n    }\r\n    getAxisTransform() {\r\n        return {\r\n            rotation: toRadians(this.rotation),\r\n            rotationCenterX: 0,\r\n            rotationCenterY: 0,\r\n            translationX: this.translation.x,\r\n            translationY: this.translation.y,\r\n        };\r\n    }\r\n    updatePosition() {\r\n        const { crossLineGroup, axisGroup, gridGroup, translation, gridLineGroupSelection, gridPadding, gridLength } = this;\r\n        const { rotation } = this.calculateRotations();\r\n        const sideFlag = this.label.getSideFlag();\r\n        const translationX = Math.floor(translation.x);\r\n        const translationY = Math.floor(translation.y);\r\n        crossLineGroup.setProperties({ rotation, translationX, translationY });\r\n        axisGroup.datum = this.getAxisTransform();\r\n        gridGroup.setProperties({ rotation, translationX, translationY });\r\n        gridLineGroupSelection.each((line) => {\r\n            line.x1 = gridPadding;\r\n            line.x2 = -sideFlag * gridLength + gridPadding;\r\n            line.y = 0;\r\n        });\r\n    }\r\n    updateSecondaryAxisTicks(_primaryTickCount) {\r\n        throw new Error('AG Charts - unexpected call to updateSecondaryAxisTicks() - check axes configuration.');\r\n    }\r\n    updateSelections(lineData, data, params) {\r\n        this.lineNode.datum = lineData;\r\n        this.gridLineGroupSelection.update(this.gridLength ? data : [], (group) => group.append(new Line({ tag: Tags.GridLine })), (datum) => datum.tickId);\r\n        this.tickLineGroupSelection.update(data, (group) => group.appendChild(new Line({ tag: Tags.TickLine })), (datum) => datum.tickId);\r\n        this.tickLabelGroupSelection.update(data.map((d) => this.getTickLabelProps(d, params)), (group) => group.appendChild(new Text({ tag: Tags.TickLabel })), (datum) => datum.tickId);\r\n    }\r\n    updateAxisLine() {\r\n        const { line } = this;\r\n        // Without this the layout isn't consistent when enabling/disabling the line, padding configurations are not respected.\r\n        const strokeWidth = line.enabled ? line.width : 0;\r\n        this.lineNode.setProperties({\r\n            stroke: line.color,\r\n            strokeWidth,\r\n        });\r\n    }\r\n    updateGridLines(sideFlag) {\r\n        const { gridLine: { style, width }, gridPadding, gridLength, } = this;\r\n        if (gridLength === 0 || style.length === 0) {\r\n            return;\r\n        }\r\n        this.gridLineGroupSelection.each((line, _, index) => {\r\n            const { stroke, lineDash } = style[index % style.length];\r\n            line.setProperties({\r\n                x1: gridPadding,\r\n                x2: -sideFlag * gridLength + gridPadding,\r\n                y: 0,\r\n                fill: undefined,\r\n                stroke,\r\n                strokeWidth: width,\r\n                lineDash,\r\n            });\r\n        });\r\n    }\r\n    updateLabels() {\r\n        const { label } = this;\r\n        if (!label.enabled) {\r\n            return;\r\n        }\r\n        // Apply label option values\r\n        this.tickLabelGroupSelection.each((node, datum) => {\r\n            node.setProperties(datum, [\r\n                'fill',\r\n                'fontFamily',\r\n                'fontSize',\r\n                'fontStyle',\r\n                'fontWeight',\r\n                'text',\r\n                'textAlign',\r\n                'textBaseline',\r\n            ]);\r\n        });\r\n    }\r\n    wrapLabels(tickData, index, labelProps) {\r\n        const { parallel, maxWidth, maxHeight } = this.label;\r\n        let defaultMaxWidth = this.maxThickness;\r\n        let defaultMaxHeight = Math.round(this.calculateAvailableRange() / tickData.labelCount);\r\n        if (parallel) {\r\n            [defaultMaxWidth, defaultMaxHeight] = [defaultMaxHeight, defaultMaxWidth];\r\n        }\r\n        tickData.ticks.forEach((tickDatum) => {\r\n            tickDatum.tickLabel = Text.wrap(tickDatum.tickLabel, maxWidth !== null && maxWidth !== void 0 ? maxWidth : defaultMaxWidth, maxHeight !== null && maxHeight !== void 0 ? maxHeight : defaultMaxHeight, labelProps, 'hyphenate');\r\n        });\r\n        return { tickData, index, autoRotation: 0, terminate: true };\r\n    }\r\n    updateTitle(params) {\r\n        const { rotation, title, _titleCaption, lineNode, tickLineGroup, tickLabelGroup } = this;\r\n        if (!title) {\r\n            _titleCaption.enabled = false;\r\n            return;\r\n        }\r\n        let tickSpace = 0;\r\n        const { anyTickVisible } = params;\r\n        if (title.enabled && anyTickVisible) {\r\n            const tickBBox = Group.computeBBox([tickLineGroup, tickLabelGroup, lineNode]);\r\n            const tickWidth = rotation === 0 ? tickBBox.width : tickBBox.height;\r\n            if (Math.abs(tickWidth) < Infinity) {\r\n                tickSpace += tickWidth;\r\n            }\r\n        }\r\n        this.setTitleProps(_titleCaption, { tickSpace });\r\n    }\r\n    // For formatting (nice rounded) tick values.\r\n    formatTick(datum, index) {\r\n        var _a, _b;\r\n        const { label, labelFormatter, fractionDigits, moduleCtx: { callbackCache }, } = this;\r\n        if (label.formatter) {\r\n            const value = fractionDigits > 0 ? datum : String(datum);\r\n            return ((_a = callbackCache.call(label.formatter, {\r\n                value,\r\n                index,\r\n                fractionDigits,\r\n                formatter: labelFormatter,\r\n            })) !== null && _a !== void 0 ? _a : value);\r\n        }\r\n        else if (labelFormatter) {\r\n            return (_b = callbackCache.call(labelFormatter, datum)) !== null && _b !== void 0 ? _b : String(datum);\r\n        }\r\n        // The axis is using a logScale or the`datum` is an integer, a string or an object\r\n        return String(datum);\r\n    }\r\n    // For formatting arbitrary values between the ticks.\r\n    formatDatum(datum) {\r\n        return String(datum);\r\n    }\r\n    computeBBox() {\r\n        return this.axisGroup.computeBBox();\r\n    }\r\n    initCrossLine(crossLine) {\r\n        crossLine.scale = this.scale;\r\n        crossLine.gridLength = this.gridLength;\r\n    }\r\n    isAnySeriesActive() {\r\n        return this.boundSeries.some((s) => this.includeInvisibleDomains || s.isEnabled());\r\n    }\r\n    clipTickLines(x, y, width, height) {\r\n        this.tickLineGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));\r\n    }\r\n    clipGrid(x, y, width, height) {\r\n        this.gridGroup.setClipRectInGroupCoordinateSpace(new BBox(x, y, width, height));\r\n    }\r\n    calculatePadding(min, _max) {\r\n        return [Math.abs(min * 0.01), Math.abs(min * 0.01)];\r\n    }\r\n    getTitleFormatterParams() {\r\n        var _a;\r\n        const boundSeries = this.boundSeries.reduce((acc, next) => {\r\n            const keys = next.getKeys(this.direction);\r\n            const names = next.getNames(this.direction);\r\n            for (let idx = 0; idx < keys.length; idx++) {\r\n                acc.push({ key: keys[idx], name: names[idx] });\r\n            }\r\n            return acc;\r\n        }, []);\r\n        return {\r\n            direction: this.direction,\r\n            boundSeries,\r\n            defaultValue: (_a = this.title) === null || _a === void 0 ? void 0 : _a.text,\r\n        };\r\n    }\r\n    normaliseDataDomain(d) {\r\n        return { domain: d, clipped: false };\r\n    }\r\n    getLayoutState() {\r\n        return Object.assign({ rect: this.computeBBox(), gridPadding: this.gridPadding, seriesAreaPadding: this.seriesAreaPadding, tickSize: this.tick.size }, this.layout);\r\n    }\r\n    getModuleMap() {\r\n        return this.moduleMap;\r\n    }\r\n    createModuleContext() {\r\n        var _a;\r\n        (_a = this.axisContext) !== null && _a !== void 0 ? _a : (this.axisContext = this.createAxisContext());\r\n        return Object.assign(Object.assign({}, this.moduleCtx), { parent: this.axisContext });\r\n    }\r\n    createAxisContext() {\r\n        return {\r\n            axisId: this.id,\r\n            direction: this.direction,\r\n            continuous: ContinuousScale.is(this.scale),\r\n            keys: () => this.boundSeries.flatMap((s) => s.getKeys(this.direction)),\r\n            scaleValueFormatter: (specifier) => { var _a, _b; return (_b = (_a = this.scale).tickFormat) === null || _b === void 0 ? void 0 : _b.call(_a, { specifier }); },\r\n            scaleBandwidth: () => { var _a; return (_a = this.scale.bandwidth) !== null && _a !== void 0 ? _a : 0; },\r\n            scaleConvert: (val) => this.scale.convert(val),\r\n            scaleInvert: (val) => { var _a, _b; return (_b = (_a = this.scale).invert) === null || _b === void 0 ? void 0 : _b.call(_a, val); },\r\n        };\r\n    }\r\n    animateReadyUpdate(diff) {\r\n        const { animationManager } = this.moduleCtx;\r\n        const selectionCtx = prepareAxisAnimationContext(this);\r\n        const fns = prepareAxisAnimationFunctions(selectionCtx);\r\n        fromToMotion(this.id, 'axis-group', animationManager, [this.axisGroup], fns.group);\r\n        fromToMotion(this.id, 'line', animationManager, [this.lineNode], fns.line);\r\n        fromToMotion(this.id, 'line-paths', animationManager, [this.gridLineGroupSelection, this.tickLineGroupSelection], fns.tick, (_, d) => d.tickId, diff);\r\n        fromToMotion(this.id, 'tick-labels', animationManager, [this.tickLabelGroupSelection], fns.label, (_, d) => d.tickId, diff);\r\n    }\r\n    resetSelectionNodes() {\r\n        const { gridLineGroupSelection, tickLineGroupSelection, tickLabelGroupSelection, lineNode } = this;\r\n        const selectionCtx = prepareAxisAnimationContext(this);\r\n        resetMotion([this.axisGroup], resetAxisGroupFn());\r\n        resetMotion([gridLineGroupSelection, tickLineGroupSelection], resetAxisSelectionFn(selectionCtx));\r\n        resetMotion([tickLabelGroupSelection], resetAxisLabelSelectionFn());\r\n        resetMotion([lineNode], resetAxisLineSelectionFn());\r\n    }\r\n    calculateUpdateDiff(previous, tickData) {\r\n        const added = new Set();\r\n        const removed = new Set();\r\n        const tickCount = Math.max(previous.length, tickData.ticks.length);\r\n        for (let i = 0; i < tickCount; i++) {\r\n            const tickDatum = tickData.ticks[i];\r\n            const prev = previous[i];\r\n            const tick = tickDatum === null || tickDatum === void 0 ? void 0 : tickDatum.tickId;\r\n            if (prev === tick) {\r\n                continue;\r\n            }\r\n            if (removed.has(tick)) {\r\n                removed.delete(tick);\r\n            }\r\n            else if (tick) {\r\n                added.add(tick);\r\n            }\r\n            if (added.has(prev)) {\r\n                added.delete(prev);\r\n            }\r\n            else if (prev) {\r\n                removed.add(prev);\r\n            }\r\n        }\r\n        return {\r\n            changed: added.size > 0 || removed.size > 0,\r\n            added: [...added.values()],\r\n            removed: [...removed.values()],\r\n        };\r\n    }\r\n}\r\nAxis.defaultTickMinSpacing = 50;\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], Axis.prototype, \"nice\", void 0);\r\n__decorate([\r\n    Validate(STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], Axis.prototype, \"keys\", void 0);\n\nclass CartesianAxisLabel extends AxisLabel {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * Rotation angle to use when autoRotate is applied.\r\n         */\r\n        this.autoRotateAngle = 335;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], CartesianAxisLabel.prototype, \"autoRotate\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(-360, 360)),\r\n    __metadata(\"design:type\", Number)\r\n], CartesianAxisLabel.prototype, \"autoRotateAngle\", void 0);\n\nclass CartesianAxis extends Axis {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.thickness = 0;\r\n        this.position = 'left';\r\n    }\r\n    get direction() {\r\n        return ['top', 'bottom'].includes(this.position) ? ChartAxisDirection.X : ChartAxisDirection.Y;\r\n    }\r\n    updateDirection() {\r\n        switch (this.position) {\r\n            case 'top':\r\n                this.rotation = -90;\r\n                this.label.mirrored = true;\r\n                this.label.parallel = true;\r\n                break;\r\n            case 'right':\r\n                this.rotation = 0;\r\n                this.label.mirrored = true;\r\n                this.label.parallel = false;\r\n                break;\r\n            case 'bottom':\r\n                this.rotation = -90;\r\n                this.label.mirrored = false;\r\n                this.label.parallel = true;\r\n                break;\r\n            case 'left':\r\n                this.rotation = 0;\r\n                this.label.mirrored = false;\r\n                this.label.parallel = false;\r\n                break;\r\n        }\r\n        if (this.axisContext) {\r\n            this.axisContext.position = this.position;\r\n            this.axisContext.direction = this.direction;\r\n        }\r\n    }\r\n    update(primaryTickCount) {\r\n        this.updateDirection();\r\n        return super.update(primaryTickCount);\r\n    }\r\n    calculateLayout(primaryTickCount) {\r\n        this.updateDirection();\r\n        return super.calculateLayout(primaryTickCount);\r\n    }\r\n    createAxisContext() {\r\n        return Object.assign(Object.assign({}, super.createAxisContext()), { position: this.position });\r\n    }\r\n    assignCrossLineArrayConstructor(crossLines) {\r\n        assignJsonApplyConstructedArray(crossLines, CartesianCrossLine);\r\n    }\r\n    createLabel() {\r\n        return new CartesianAxisLabel();\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], CartesianAxis.prototype, \"thickness\", void 0);\r\n__decorate([\r\n    Validate(POSITION),\r\n    __metadata(\"design:type\", String)\r\n], CartesianAxis.prototype, \"position\", void 0);\n\nclass CategoryAxis extends CartesianAxis {\r\n    constructor(moduleCtx) {\r\n        super(moduleCtx, new BandScale());\r\n        this._paddingOverrideEnabled = false;\r\n        this.groupPaddingInner = 0.1;\r\n        this.includeInvisibleDomains = true;\r\n    }\r\n    set paddingInner(value) {\r\n        this._paddingOverrideEnabled = true;\r\n        this.scale.paddingInner = value;\r\n    }\r\n    get paddingInner() {\r\n        this._paddingOverrideEnabled = true;\r\n        return this.scale.paddingInner;\r\n    }\r\n    set paddingOuter(value) {\r\n        this.scale.paddingOuter = value;\r\n    }\r\n    get paddingOuter() {\r\n        return this.scale.paddingOuter;\r\n    }\r\n    normaliseDataDomain(d) {\r\n        const domain = [];\r\n        const uniqueValues = new Set();\r\n        for (const v of d) {\r\n            const key = v instanceof Date ? v.getTime() : v;\r\n            if (!uniqueValues.has(key)) {\r\n                uniqueValues.add(key);\r\n                // Only add unique values\r\n                domain.push(v);\r\n            }\r\n        }\r\n        return { domain, clipped: false };\r\n    }\r\n    calculateDomain() {\r\n        if (!this._paddingOverrideEnabled) {\r\n            const paddings = this.boundSeries.map((s) => { var _a; return (_a = s.getBandScalePadding) === null || _a === void 0 ? void 0 : _a.call(s); }).filter((p) => p != null);\r\n            if (paddings.length > 0) {\r\n                this.scale.paddingInner = Math.min(...paddings.map((p) => p.inner));\r\n                this.scale.paddingOuter = Math.max(...paddings.map((p) => p.outer));\r\n            }\r\n        }\r\n        return super.calculateDomain();\r\n    }\r\n}\r\nCategoryAxis.className = 'CategoryAxis';\r\nCategoryAxis.type = 'category';\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], CategoryAxis.prototype, \"groupPaddingInner\", void 0);\n\n/**\r\n * The tree layout is calculated in abstract x/y coordinates, where the root is at (0, 0)\r\n * and the tree grows downward from the root.\r\n */\r\nclass TreeNode {\r\n    constructor(label = '', parent, number = 0) {\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.subtreeLeft = NaN;\r\n        this.subtreeRight = NaN;\r\n        this.screenX = 0;\r\n        this.screenY = 0;\r\n        this.children = [];\r\n        this.leafCount = 0;\r\n        this.prelim = 0;\r\n        this.mod = 0;\r\n        this.ancestor = this;\r\n        this.change = 0;\r\n        this.shift = 0;\r\n        this.label = label;\r\n        // screenX and screenY are meant to be recomputed from (layout) x and y\r\n        // when the tree is resized (without performing another layout)\r\n        this.parent = parent;\r\n        this.depth = parent ? parent.depth + 1 : 0;\r\n        this.number = number;\r\n    }\r\n    getLeftSibling() {\r\n        return this.number > 0 && this.parent ? this.parent.children[this.number - 1] : undefined;\r\n    }\r\n    getLeftmostSibling() {\r\n        return this.number > 0 && this.parent ? this.parent.children[0] : undefined;\r\n    }\r\n    // traverse the left contour of a subtree, return the successor of v on this contour\r\n    nextLeft() {\r\n        return this.children ? this.children[0] : this.thread;\r\n    }\r\n    // traverse the right contour of a subtree, return the successor of v on this contour\r\n    nextRight() {\r\n        return this.children ? this.children[this.children.length - 1] : this.thread;\r\n    }\r\n    getSiblings() {\r\n        return this.parent ? this.parent.children.filter((_, i) => i !== this.number) : [];\r\n    }\r\n}\r\n/**\r\n * Converts an array of ticks, where each tick has an array of labels, to a label tree.\r\n * If `pad` is `true`, will ensure that every branch matches the depth of the tree by\r\n * creating empty labels.\r\n */\r\nfunction ticksToTree(ticks, pad = true) {\r\n    const root = new TreeNode();\r\n    let depth = 0;\r\n    if (pad) {\r\n        ticks.forEach((tick) => (depth = Math.max(depth, tick.labels.length)));\r\n    }\r\n    ticks.forEach((tick) => {\r\n        if (pad) {\r\n            while (tick.labels.length < depth) {\r\n                tick.labels.unshift('');\r\n            }\r\n        }\r\n        insertTick(root, tick);\r\n    });\r\n    return root;\r\n}\r\nfunction insertTick(root, tick) {\r\n    const pathParts = tick.labels.slice().reverse(); // path elements from root to leaf label\r\n    const lastPartIndex = pathParts.length - 1;\r\n    pathParts.forEach((pathPart, partIndex) => {\r\n        const children = root.children;\r\n        const existingNode = children.find((child) => child.label === pathPart);\r\n        const isNotLeaf = partIndex !== lastPartIndex;\r\n        if (existingNode && isNotLeaf) {\r\n            // the isNotLeaf check is to allow duplicate leafs\r\n            root = existingNode;\r\n        }\r\n        else {\r\n            const node = new TreeNode(pathPart, root);\r\n            node.number = children.length;\r\n            children.push(node);\r\n            if (isNotLeaf) {\r\n                root = node;\r\n            }\r\n        }\r\n    });\r\n}\r\n// Shift the subtree.\r\nfunction moveSubtree(wm, wp, shift) {\r\n    const subtrees = wp.number - wm.number;\r\n    const ratio = shift / subtrees;\r\n    wp.change -= ratio;\r\n    wp.shift += shift;\r\n    wm.change += ratio;\r\n    wp.prelim += shift;\r\n    wp.mod += shift;\r\n}\r\nfunction ancestor(vim, v, defaultAncestor) {\r\n    return v.getSiblings().indexOf(vim.ancestor) >= 0 ? vim.ancestor : defaultAncestor;\r\n}\r\n// Spaces out the children.\r\nfunction executeShifts(v) {\r\n    const children = v.children;\r\n    if (children) {\r\n        let shift = 0;\r\n        let change = 0;\r\n        for (let i = children.length - 1; i >= 0; i--) {\r\n            const w = children[i];\r\n            w.prelim += shift;\r\n            w.mod += shift;\r\n            change += w.change;\r\n            shift += w.shift + change;\r\n        }\r\n    }\r\n}\r\n// Moves current subtree with v as the root if some nodes are conflicting in space.\r\nfunction apportion(v, defaultAncestor, distance) {\r\n    const w = v.getLeftSibling();\r\n    if (w) {\r\n        let vop = v;\r\n        let vip = v;\r\n        let vim = w;\r\n        let vom = vip.getLeftmostSibling();\r\n        let sip = vip.mod;\r\n        let sop = vop.mod;\r\n        let sim = vim.mod;\r\n        let som = vom.mod;\r\n        while (vim.nextRight() && vip.nextLeft()) {\r\n            vim = vim.nextRight();\r\n            vip = vip.nextLeft();\r\n            vom = vom.nextLeft();\r\n            vop = vop.nextRight();\r\n            vop.ancestor = v;\r\n            const shift = vim.prelim + sim - (vip.prelim + sip) + distance;\r\n            if (shift > 0) {\r\n                moveSubtree(ancestor(vim, v, defaultAncestor), v, shift);\r\n                sip += shift;\r\n                sop += shift;\r\n            }\r\n            sim += vim.mod;\r\n            sip += vip.mod;\r\n            som += vom.mod;\r\n            sop += vop.mod;\r\n        }\r\n        if (vim.nextRight() && !vop.nextRight()) {\r\n            vop.thread = vim.nextRight();\r\n            vop.mod += sim - sop;\r\n        }\r\n        else {\r\n            if (vip.nextLeft() && !vom.nextLeft()) {\r\n                vom.thread = vip.nextLeft();\r\n                vom.mod += sip - som;\r\n            }\r\n            defaultAncestor = v;\r\n        }\r\n    }\r\n    return defaultAncestor;\r\n}\r\n// Compute the preliminary x-coordinate of node and its children (recursively).\r\nfunction firstWalk(node, distance) {\r\n    const children = node.children;\r\n    if (children.length) {\r\n        let defaultAncestor = children[0];\r\n        children.forEach((child) => {\r\n            firstWalk(child, distance);\r\n            defaultAncestor = apportion(child, defaultAncestor, distance);\r\n        });\r\n        executeShifts(node);\r\n        const midpoint = (children[0].prelim + children[children.length - 1].prelim) / 2;\r\n        const leftSibling = node.getLeftSibling();\r\n        if (leftSibling) {\r\n            node.prelim = leftSibling.prelim + distance;\r\n            node.mod = node.prelim - midpoint;\r\n        }\r\n        else {\r\n            node.prelim = midpoint;\r\n        }\r\n    }\r\n    else {\r\n        const leftSibling = node.getLeftSibling();\r\n        node.prelim = leftSibling ? leftSibling.prelim + distance : 0;\r\n    }\r\n}\r\nclass Dimensions {\r\n    constructor() {\r\n        this.top = Infinity;\r\n        this.right = -Infinity;\r\n        this.bottom = -Infinity;\r\n        this.left = Infinity;\r\n    }\r\n    update(node, xy) {\r\n        const { x, y } = xy(node);\r\n        if (x > this.right) {\r\n            this.right = x;\r\n        }\r\n        if (x < this.left) {\r\n            this.left = x;\r\n        }\r\n        if (y > this.bottom) {\r\n            this.bottom = y;\r\n        }\r\n        if (y < this.top) {\r\n            this.top = y;\r\n        }\r\n    }\r\n}\r\nfunction secondWalk(v, m, layout) {\r\n    v.x = v.prelim + m;\r\n    v.y = v.depth;\r\n    layout.update(v);\r\n    v.children.forEach((w) => secondWalk(w, m + v.mod, layout));\r\n}\r\n// After the second walk the parent nodes are positioned at the center of their immediate children.\r\n// If we want the parent nodes to be positioned at the center of the subtree for which they are roots,\r\n// we need a third walk to adjust the positions.\r\nfunction thirdWalk(v) {\r\n    const children = v.children;\r\n    let leafCount = 0;\r\n    children.forEach((w) => {\r\n        thirdWalk(w);\r\n        if (w.children.length) {\r\n            leafCount += w.leafCount;\r\n        }\r\n        else {\r\n            leafCount++;\r\n        }\r\n    });\r\n    v.leafCount = leafCount;\r\n    if (children.length) {\r\n        v.subtreeLeft = children[0].subtreeLeft;\r\n        v.subtreeRight = children[v.children.length - 1].subtreeRight;\r\n        v.x = (v.subtreeLeft + v.subtreeRight) / 2;\r\n    }\r\n    else {\r\n        v.subtreeLeft = v.x;\r\n        v.subtreeRight = v.x;\r\n    }\r\n}\r\nfunction treeLayout(root) {\r\n    const layout = new TreeLayout();\r\n    firstWalk(root, 1);\r\n    secondWalk(root, -root.prelim, layout);\r\n    thirdWalk(root);\r\n    return layout;\r\n}\r\nclass TreeLayout {\r\n    constructor() {\r\n        this.dimensions = new Dimensions();\r\n        this.leafCount = 0;\r\n        this.nodes = [];\r\n        // One might want to process leaf nodes separately from the rest of the tree.\r\n        // For example, position labels corresponding to leafs vertically, rather than horizontally.\r\n        this.leafNodes = [];\r\n        this.nonLeafNodes = [];\r\n        this.depth = 0;\r\n    }\r\n    update(node) {\r\n        this.dimensions.update(node, (node) => ({ x: node.x, y: node.y }));\r\n        if (!node.children.length) {\r\n            this.leafCount++;\r\n            this.leafNodes.push(node);\r\n        }\r\n        else {\r\n            this.nonLeafNodes.push(node);\r\n        }\r\n        if (node.depth > this.depth) {\r\n            this.depth = node.depth;\r\n        }\r\n        this.nodes.push(node);\r\n    }\r\n    resize(width, height, shiftX = 0, shiftY = 0, flipX = false) {\r\n        const xSteps = this.leafCount - 1;\r\n        const ySteps = this.depth;\r\n        const dimensions = this.dimensions;\r\n        let scalingX = 1;\r\n        let scalingY = 1;\r\n        if (width > 0 && xSteps) {\r\n            const existingSpacingX = (dimensions.right - dimensions.left) / xSteps;\r\n            const desiredSpacingX = width / xSteps;\r\n            scalingX = desiredSpacingX / existingSpacingX;\r\n            if (flipX) {\r\n                scalingX = -scalingX;\r\n            }\r\n        }\r\n        if (height > 0 && ySteps) {\r\n            const existingSpacingY = (dimensions.bottom - dimensions.top) / ySteps;\r\n            const desiredSpacingY = height / ySteps;\r\n            scalingY = desiredSpacingY / existingSpacingY;\r\n        }\r\n        const screenDimensions = new Dimensions();\r\n        this.nodes.forEach((node) => {\r\n            node.screenX = node.x * scalingX;\r\n            node.screenY = node.y * scalingY;\r\n            screenDimensions.update(node, (node) => ({ x: node.screenX, y: node.screenY }));\r\n        });\r\n        // Normalize so that root top and leftmost leaf left start at zero.\r\n        const offsetX = -screenDimensions.left;\r\n        const offsetY = -screenDimensions.top;\r\n        this.nodes.forEach((node) => {\r\n            node.screenX += offsetX + shiftX;\r\n            node.screenY += offsetY + shiftY;\r\n        });\r\n    }\r\n}\n\nclass GroupedCategoryAxisLabel extends AxisLabel {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.grid = false;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], GroupedCategoryAxisLabel.prototype, \"grid\", void 0);\r\nclass GroupedCategoryAxis extends CartesianAxis {\r\n    constructor(moduleCtx) {\r\n        super(moduleCtx, new BandScale());\r\n        // Label scale (labels are positioned between ticks, tick count = label count + 1).\r\n        // We don't call is `labelScale` for consistency with other axes.\r\n        this.tickScale = new BandScale();\r\n        this.line = new AxisLine();\r\n        this.label = new GroupedCategoryAxisLabel();\r\n        /**\r\n         * The color of the labels.\r\n         * Use `undefined` rather than `rgba(0, 0, 0, 0)` to make labels invisible.\r\n         */\r\n        this.labelColor = 'rgba(87, 87, 87, 1)';\r\n        this.includeInvisibleDomains = true;\r\n        const { tickLineGroup, tickLabelGroup, gridLineGroup, tickScale, scale } = this;\r\n        scale.paddingOuter = 0.1;\r\n        scale.paddingInner = scale.paddingOuter * 2;\r\n        this.range = scale.range.slice();\r\n        this.refreshScale();\r\n        tickScale.paddingInner = 1;\r\n        tickScale.paddingOuter = 0;\r\n        this.gridLineSelection = Selection.select(gridLineGroup, Line);\r\n        this.axisLineSelection = Selection.select(tickLineGroup, Line);\r\n        this.separatorSelection = Selection.select(tickLineGroup, Line);\r\n        this.labelSelection = Selection.select(tickLabelGroup, Text);\r\n    }\r\n    updateRange() {\r\n        const { range: rr, visibleRange: vr, scale } = this;\r\n        const span = (rr[1] - rr[0]) / (vr[1] - vr[0]);\r\n        const shift = span * vr[0];\r\n        const start = rr[0] - shift;\r\n        this.tickScale.range = scale.range = [start, start + span];\r\n        this.resizeTickTree();\r\n    }\r\n    resizeTickTree() {\r\n        var _a;\r\n        const s = this.scale;\r\n        const range = s.domain.length ? [s.convert(s.domain[0]), s.convert(s.domain[s.domain.length - 1])] : s.range;\r\n        const layout = this.tickTreeLayout;\r\n        const lineHeight = this.lineHeight;\r\n        if (layout) {\r\n            layout.resize(Math.abs(range[1] - range[0]), layout.depth * lineHeight, (Math.min(range[0], range[1]) || 0) + ((_a = s.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2, -layout.depth * lineHeight, range[1] - range[0] < 0);\r\n        }\r\n    }\r\n    get lineHeight() {\r\n        return this.label.fontSize * 1.5;\r\n    }\r\n    /**\r\n     * The length of the grid. The grid is only visible in case of a non-zero value.\r\n     */\r\n    set gridLength(value) {\r\n        // Was visible and now invisible, or was invisible and now visible.\r\n        if ((this._gridLength && !value) || (!this._gridLength && value)) {\r\n            this.gridLineSelection.clear();\r\n            this.labelSelection.clear();\r\n        }\r\n        this._gridLength = value;\r\n    }\r\n    get gridLength() {\r\n        return this._gridLength;\r\n    }\r\n    calculateDomain() {\r\n        var _a;\r\n        const { direction } = this;\r\n        const domains = [];\r\n        let isNumericX;\r\n        this.boundSeries\r\n            .filter((s) => s.visible)\r\n            .forEach((series) => {\r\n            if (direction === ChartAxisDirection.X) {\r\n                if (isNumericX === undefined) {\r\n                    // always add first X domain\r\n                    const domain = series.getDomain(direction);\r\n                    domains.push(domain);\r\n                    isNumericX = typeof domain[0] === 'number';\r\n                }\r\n                else if (isNumericX) {\r\n                    // only add further X domains if the axis is numeric\r\n                    domains.push(series.getDomain(direction));\r\n                }\r\n            }\r\n            else {\r\n                domains.push(series.getDomain(direction));\r\n            }\r\n        });\r\n        const domain = new Array().concat(...domains);\r\n        const values = (_a = extent(domain)) !== null && _a !== void 0 ? _a : domain;\r\n        this.dataDomain = this.normaliseDataDomain(values);\r\n        this.scale.domain = this.dataDomain.domain;\r\n    }\r\n    normaliseDataDomain(d) {\r\n        // Prevent duplicate categories.\r\n        const values = d.filter((s, i, arr) => arr.indexOf(s) === i);\r\n        const tickTree = ticksToTree(values);\r\n        this.tickTreeLayout = treeLayout(tickTree);\r\n        const tickScaleDomain = values.slice();\r\n        tickScaleDomain.push('');\r\n        this.tickScale.domain = tickScaleDomain;\r\n        this.resizeTickTree();\r\n        return { domain: values, clipped: false };\r\n    }\r\n    /**\r\n     * Creates/removes/updates the scene graph nodes that constitute the axis.\r\n     * Supposed to be called _manually_ after changing _any_ of the axis properties.\r\n     * This allows to bulk set axis properties before updating the nodes.\r\n     * The node changes made by this method are rendered on the next animation frame.\r\n     * We could schedule this method call automatically on the next animation frame\r\n     * when any of the axis properties change (the way we do when properties of scene graph's\r\n     * nodes change), but this will mean that we first wait for the next animation\r\n     * frame to make changes to the nodes of the axis, then wait for another animation\r\n     * frame to render those changes. It's nice to have everything update automatically,\r\n     * but this extra level of async indirection will not just introduce an unwanted delay,\r\n     * it will also make it harder to reason about the program.\r\n     */\r\n    update() {\r\n        if (!this.computedLayout) {\r\n            return;\r\n        }\r\n        this.updatePosition();\r\n        this.updateTitleCaption();\r\n        this.updateCategoryLabels();\r\n        this.updateSeparators();\r\n        this.updateAxisLines();\r\n        this.updateCategoryGridLines();\r\n        this.resetSelectionNodes();\r\n        return undefined;\r\n    }\r\n    updateTitleCaption() {\r\n        // The Text `node` of the Caption is not used to render the title of the grouped category axis.\r\n        // The phantom root of the tree layout is used instead.\r\n        const { _titleCaption } = this;\r\n        _titleCaption.node.visible = false;\r\n    }\r\n    updateCategoryLabels() {\r\n        if (!this.computedLayout)\r\n            return;\r\n        const { tickLabelLayout } = this.computedLayout;\r\n        const labelSelection = this.labelSelection.update(tickLabelLayout);\r\n        labelSelection.each((node, datum) => {\r\n            node.setProperties(datum);\r\n        });\r\n    }\r\n    updateSeparators() {\r\n        if (!this.computedLayout)\r\n            return;\r\n        const { separatorLayout } = this.computedLayout;\r\n        const { range } = this;\r\n        const epsilon = 0.0000001;\r\n        const separatorSelection = this.separatorSelection.update(separatorLayout);\r\n        separatorSelection.each((line, datum) => {\r\n            line.x1 = datum.x1;\r\n            line.x2 = datum.x2;\r\n            line.y1 = datum.y;\r\n            line.y2 = datum.y;\r\n            line.visible = datum.y >= range[0] - epsilon && datum.y <= range[1] + epsilon;\r\n            line.stroke = this.tick.color;\r\n            line.fill = undefined;\r\n            line.strokeWidth = 1;\r\n        });\r\n    }\r\n    updateAxisLines() {\r\n        if (!this.computedLayout)\r\n            return;\r\n        const { axisLineLayout } = this.computedLayout;\r\n        const axisLineSelection = this.axisLineSelection.update(axisLineLayout);\r\n        axisLineSelection.each((line, datum) => {\r\n            line.setProperties(Object.assign(Object.assign({}, datum), { stroke: this.line.color, strokeWidth: this.line.width }));\r\n            line.x1 = datum.x;\r\n            line.x2 = datum.x;\r\n            line.y1 = datum.y1;\r\n            line.y2 = datum.y2;\r\n            line.strokeWidth = this.line.width;\r\n            line.stroke = this.line.color;\r\n        });\r\n    }\r\n    updateCategoryGridLines() {\r\n        const { gridLength, gridLine, label, range, tickScale } = this;\r\n        const ticks = tickScale.ticks();\r\n        const sideFlag = label.getSideFlag();\r\n        const gridSelection = this.gridLineSelection.update(gridLength ? ticks : []);\r\n        if (gridLength) {\r\n            const { width, style } = gridLine;\r\n            const styleCount = style.length;\r\n            gridSelection.each((line, datum, index) => {\r\n                const y = Math.round(tickScale.convert(datum));\r\n                line.x1 = 0;\r\n                line.x2 = -sideFlag * gridLength;\r\n                line.y1 = y;\r\n                line.y2 = y;\r\n                line.visible = y >= range[0] && y <= range[1];\r\n                const { stroke, lineDash } = style[index % styleCount];\r\n                line.stroke = stroke;\r\n                line.strokeWidth = width;\r\n                line.lineDash = lineDash;\r\n                line.fill = undefined;\r\n            });\r\n        }\r\n    }\r\n    computeLayout() {\r\n        this.updateDirection();\r\n        this.calculateDomain();\r\n        this.updateRange();\r\n        const { scale, label, label: { parallel }, moduleCtx: { callbackCache }, range, title, title: { formatter = (p) => p.defaultValue } = {}, } = this;\r\n        const rangeStart = scale.range[0];\r\n        const rangeEnd = scale.range[1];\r\n        const rangeLength = Math.abs(rangeEnd - rangeStart);\r\n        const bandwidth = rangeLength / scale.domain.length || 0;\r\n        const rotation = toRadians(this.rotation);\r\n        const isHorizontal = Math.abs(Math.cos(rotation)) < 1e-8;\r\n        const sideFlag = label.getSideFlag();\r\n        // The Text `node` of the Caption is not used to render the title of the grouped category axis.\r\n        // The phantom root of the tree layout is used instead.\r\n        const lineHeight = this.lineHeight;\r\n        // Render ticks and labels.\r\n        const tickTreeLayout = this.tickTreeLayout;\r\n        const labels = scale.ticks();\r\n        const treeLabels = tickTreeLayout ? tickTreeLayout.nodes : [];\r\n        const isLabelTree = tickTreeLayout ? tickTreeLayout.depth > 1 : false;\r\n        // When labels are parallel to the axis line, the `parallelFlipFlag` is used to\r\n        // flip the labels to avoid upside-down text, when the axis is rotated\r\n        // such that it is in the right hemisphere, i.e. the angle of rotation\r\n        // is in the [0, π] interval.\r\n        // The rotation angle is normalized, so that we have an easier time checking\r\n        // if it's in the said interval. Since the axis is always rendered vertically\r\n        // and then rotated, zero rotation means 12 (not 3) o-clock.\r\n        // -1 = flip\r\n        //  1 = don't flip (default)\r\n        const { defaultRotation, configuredRotation, parallelFlipFlag } = calculateLabelRotation({\r\n            rotation: label.rotation,\r\n            parallel,\r\n            regularFlipRotation: normalizeAngle360(rotation - Math.PI / 2),\r\n            parallelFlipRotation: normalizeAngle360(rotation),\r\n        });\r\n        const tickLabelLayout = [];\r\n        const copyLabelProps = (node) => {\r\n            return {\r\n                fill: node.fill,\r\n                fontFamily: node.fontFamily,\r\n                fontSize: node.fontSize,\r\n                fontStyle: node.fontStyle,\r\n                fontWeight: node.fontWeight,\r\n                rotation: node.rotation,\r\n                rotationCenterX: node.rotationCenterX,\r\n                rotationCenterY: node.rotationCenterY,\r\n                text: node.text,\r\n                textAlign: node.textAlign,\r\n                textBaseline: node.textBaseline,\r\n                translationX: node.translationX,\r\n                translationY: node.translationY,\r\n                visible: node.visible,\r\n                x: node.x,\r\n                y: node.y,\r\n            };\r\n        };\r\n        const labelBBoxes = new Map();\r\n        let maxLeafLabelWidth = 0;\r\n        const tempText = new Text();\r\n        const setLabelProps = (datum, index) => {\r\n            var _a;\r\n            tempText.setProperties({\r\n                fill: label.color,\r\n                fontFamily: label.fontFamily,\r\n                fontSize: label.fontSize,\r\n                fontStyle: label.fontStyle,\r\n                fontWeight: label.fontWeight,\r\n                textAlign: 'center',\r\n                textBaseline: parallelFlipFlag === -1 ? 'bottom' : 'hanging',\r\n                translationX: datum.screenY - label.fontSize * 0.25,\r\n                translationY: datum.screenX,\r\n            });\r\n            if (index === 0) {\r\n                const isCaptionEnabled = (title === null || title === void 0 ? void 0 : title.enabled) && labels.length > 0;\r\n                if (!isCaptionEnabled) {\r\n                    return false;\r\n                }\r\n                const text = callbackCache.call(formatter, this.getTitleFormatterParams());\r\n                tempText.setProperties({\r\n                    fill: title.color,\r\n                    fontFamily: title.fontFamily,\r\n                    fontSize: title.fontSize,\r\n                    fontStyle: title.fontStyle,\r\n                    fontWeight: title.fontWeight,\r\n                    text,\r\n                    textBaseline: 'hanging',\r\n                    translationX: datum.screenY - label.fontSize * 0.25,\r\n                    translationY: datum.screenX,\r\n                });\r\n            }\r\n            else {\r\n                const isInRange = datum.screenX >= range[0] && datum.screenX <= range[1];\r\n                if (!isInRange) {\r\n                    return false;\r\n                }\r\n                if (label.formatter) {\r\n                    tempText.text =\r\n                        (_a = callbackCache.call(label.formatter, {\r\n                            value: String(datum.label),\r\n                            index,\r\n                        })) !== null && _a !== void 0 ? _a : String(datum.label);\r\n                }\r\n                else {\r\n                    tempText.text = String(datum.label);\r\n                }\r\n            }\r\n            return true;\r\n        };\r\n        treeLabels.forEach((datum, index) => {\r\n            const isVisible = setLabelProps(datum, index);\r\n            if (isVisible) {\r\n                const bbox = tempText.computeTransformedBBox();\r\n                if (bbox) {\r\n                    labelBBoxes.set(index, bbox);\r\n                    if (bbox.width > maxLeafLabelWidth) {\r\n                        maxLeafLabelWidth = bbox.width;\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        const labelX = sideFlag * label.padding;\r\n        const labelGrid = this.label.grid;\r\n        const separatorData = [];\r\n        treeLabels.forEach((datum, index) => {\r\n            let visible = setLabelProps(datum, index);\r\n            const id = index;\r\n            tempText.x = labelX;\r\n            tempText.rotationCenterX = labelX;\r\n            const isLeaf = !datum.children.length;\r\n            if (isLeaf) {\r\n                tempText.rotation = configuredRotation;\r\n                tempText.textAlign = 'end';\r\n                tempText.textBaseline = 'middle';\r\n                const bbox = labelBBoxes.get(id);\r\n                if (bbox && bbox.height > bandwidth) {\r\n                    visible = false;\r\n                    labelBBoxes.delete(id);\r\n                }\r\n            }\r\n            else {\r\n                tempText.translationX -= maxLeafLabelWidth - lineHeight + this.label.padding;\r\n                const availableRange = datum.leafCount * bandwidth;\r\n                const bbox = labelBBoxes.get(id);\r\n                if (bbox && bbox.width > availableRange) {\r\n                    visible = false;\r\n                    labelBBoxes.delete(id);\r\n                }\r\n                else if (isHorizontal) {\r\n                    tempText.rotation = defaultRotation;\r\n                }\r\n                else {\r\n                    tempText.rotation = -Math.PI / 2;\r\n                }\r\n            }\r\n            // Calculate positions of label separators for all nodes except the root.\r\n            // Each separator is placed to the top of the current label.\r\n            if (datum.parent && isLabelTree) {\r\n                const y = isLeaf ? datum.screenX - bandwidth / 2 : datum.screenX - (datum.leafCount * bandwidth) / 2;\r\n                if (isLeaf) {\r\n                    if (datum.number !== datum.children.length - 1 || labelGrid) {\r\n                        separatorData.push({\r\n                            y,\r\n                            x1: 0,\r\n                            x2: -maxLeafLabelWidth - this.label.padding * 2,\r\n                        });\r\n                    }\r\n                }\r\n                else {\r\n                    const x = -maxLeafLabelWidth - this.label.padding * 2 + datum.screenY;\r\n                    separatorData.push({\r\n                        y,\r\n                        x1: x + lineHeight,\r\n                        x2: x,\r\n                    });\r\n                }\r\n            }\r\n            let props;\r\n            if (visible) {\r\n                const bbox = tempText.computeTransformedBBox();\r\n                if (bbox) {\r\n                    labelBBoxes.set(index, bbox);\r\n                }\r\n                props = Object.assign(Object.assign({}, copyLabelProps(tempText)), { visible });\r\n            }\r\n            else {\r\n                labelBBoxes.delete(index);\r\n                props = { visible };\r\n            }\r\n            tickLabelLayout.push(props);\r\n        });\r\n        // Calculate the position of the long separator on the far bottom of the axis.\r\n        let minX = 0;\r\n        separatorData.forEach((d) => (minX = Math.min(minX, d.x2)));\r\n        separatorData.push({\r\n            y: Math.max(rangeStart, rangeEnd),\r\n            x1: 0,\r\n            x2: minX,\r\n        });\r\n        const separatorLayout = [];\r\n        const separatorBoxes = [];\r\n        const epsilon = 0.0000001;\r\n        separatorData.forEach((datum) => {\r\n            if (datum.y >= range[0] - epsilon && datum.y <= range[1] + epsilon) {\r\n                const { x1, x2, y } = datum;\r\n                const separatorBox = new BBox(Math.min(x1, x2), y, Math.abs(x1 - x2), 0);\r\n                separatorBoxes.push(separatorBox);\r\n                separatorLayout.push({ x1, x2, y });\r\n            }\r\n        });\r\n        const axisLineLayout = [];\r\n        const axisLineBoxes = [];\r\n        const lineCount = tickTreeLayout ? tickTreeLayout.depth + 1 : 1;\r\n        for (let i = 0; i < lineCount; i++) {\r\n            const visible = labels.length > 0 && (i === 0 || (labelGrid && isLabelTree));\r\n            const x = i > 0 ? -maxLeafLabelWidth - this.label.padding * 2 - (i - 1) * lineHeight : 0;\r\n            const lineBox = new BBox(x, Math.min(...range), 0, Math.abs(range[1] - range[0]));\r\n            axisLineBoxes.push(lineBox);\r\n            axisLineLayout.push({ x, y1: range[0], y2: range[1], visible });\r\n        }\r\n        const getTransformBox = (bbox) => {\r\n            const matrix = new Matrix();\r\n            const { rotation: axisRotation, translationX, translationY, rotationCenterX, rotationCenterY, } = this.getAxisTransform();\r\n            Matrix.updateTransformMatrix(matrix, 1, 1, axisRotation, translationX, translationY, {\r\n                scalingCenterX: 0,\r\n                scalingCenterY: 0,\r\n                rotationCenterX,\r\n                rotationCenterY,\r\n            });\r\n            return matrix.transformBBox(bbox);\r\n        };\r\n        const bbox = BBox.merge([...labelBBoxes.values(), ...separatorBoxes, ...axisLineBoxes]);\r\n        const transformedBBox = getTransformBox(bbox);\r\n        return {\r\n            bbox: transformedBBox,\r\n            tickLabelLayout,\r\n            separatorLayout,\r\n            axisLineLayout,\r\n        };\r\n    }\r\n    calculateLayout() {\r\n        const { axisLineLayout, separatorLayout, tickLabelLayout, bbox } = this.computeLayout();\r\n        this.computedLayout = {\r\n            axisLineLayout,\r\n            separatorLayout,\r\n            tickLabelLayout,\r\n        };\r\n        return { bbox, primaryTickCount: undefined };\r\n    }\r\n}\r\nGroupedCategoryAxis.className = 'GroupedCategoryAxis';\r\nGroupedCategoryAxis.type = 'grouped-category';\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], GroupedCategoryAxis.prototype, \"labelColor\", void 0);\n\n/**\r\n * Wraps a native OffscreenCanvas and overrides its OffscreenCanvasRenderingContext2D to\r\n * provide resolution independent rendering based on `window.devicePixelRatio`.\r\n */\r\nclass HdpiOffscreenCanvas {\r\n    static isSupported() {\r\n        return typeof OffscreenCanvas !== 'undefined' && OffscreenCanvas.prototype.transferToImageBitmap != null;\r\n    }\r\n    // The width/height attributes of the Canvas element default to\r\n    // 300/150 according to w3.org.\r\n    constructor({ width = 600, height = 300, overrideDevicePixelRatio }) {\r\n        this.enabled = true;\r\n        // `NaN` is deliberate here, so that overrides are always applied\r\n        // and the `resetTransform` inside the `resize` method works in IE11.\r\n        this._pixelRatio = NaN;\r\n        this._width = 0;\r\n        this._height = 0;\r\n        this.canvas = new OffscreenCanvas(width, height);\r\n        this.realContext = this.canvas.getContext('2d');\r\n        this.imageSource = this.canvas.transferToImageBitmap();\r\n        this.context = this.setPixelRatio(overrideDevicePixelRatio);\r\n        this.resize(width, height);\r\n    }\r\n    snapshot() {\r\n        this.imageSource.close();\r\n        this.imageSource = this.canvas.transferToImageBitmap();\r\n    }\r\n    destroy() {\r\n        this.imageSource.close();\r\n        // Workaround memory allocation quirks in iOS Safari by resizing to 0x0 and clearing.\r\n        // See https://bugs.webkit.org/show_bug.cgi?id=195325.\r\n        this.canvas.width = 0;\r\n        this.canvas.height = 0;\r\n        this.context.clearRect(0, 0, 0, 0);\r\n    }\r\n    clear() {\r\n        this.context.save();\r\n        this.context.resetTransform();\r\n        this.context.clearRect(0, 0, this.width, this.height);\r\n        this.context.restore();\r\n    }\r\n    get pixelRatio() {\r\n        return this._pixelRatio;\r\n    }\r\n    /**\r\n     * Changes the pixel ratio of the Canvas element to the given value,\r\n     * or uses the window.devicePixelRatio (default), then resizes the Canvas\r\n     * element accordingly (default).\r\n     */\r\n    setPixelRatio(ratio) {\r\n        let pixelRatio = ratio !== null && ratio !== void 0 ? ratio : window.devicePixelRatio;\r\n        if (!isDesktop()) {\r\n            // Mobile browsers have stricter memory limits, we reduce rendering resolution to\r\n            // improve stability on mobile browsers. iOS Safari 12->16 are pain-points since they\r\n            // have memory allocation quirks - see https://bugs.webkit.org/show_bug.cgi?id=195325.\r\n            pixelRatio = 1;\r\n        }\r\n        this._pixelRatio = pixelRatio;\r\n        return HdpiCanvas.overrideScale(this.realContext, pixelRatio);\r\n    }\r\n    get width() {\r\n        return this._width;\r\n    }\r\n    get height() {\r\n        return this._height;\r\n    }\r\n    resize(width, height) {\r\n        if (!(width > 0 && height > 0)) {\r\n            return;\r\n        }\r\n        const { canvas, context, pixelRatio } = this;\r\n        canvas.width = Math.round(width * pixelRatio);\r\n        canvas.height = Math.round(height * pixelRatio);\r\n        context.resetTransform();\r\n        this._width = width;\r\n        this._height = height;\r\n    }\r\n}\n\nvar DebugSelectors;\r\n(function (DebugSelectors) {\r\n    DebugSelectors[\"SCENE\"] = \"scene\";\r\n    DebugSelectors[\"SCENE_STATS\"] = \"scene:stats\";\r\n    DebugSelectors[\"SCENE_STATS_VERBOSE\"] = \"scene:stats:verbose\";\r\n    DebugSelectors[\"SCENE_DIRTY_TREE\"] = \"scene:dirtyTree\";\r\n})(DebugSelectors || (DebugSelectors = {}));\r\nconst advancedCompositeIdentifier = 'adv-composite';\r\nconst domCompositeIdentifier = 'dom-composite';\r\nclass Scene {\r\n    constructor(opts) {\r\n        var _a;\r\n        this.id = createId(this);\r\n        this.layers = [];\r\n        this._nextZIndex = 0;\r\n        this._nextLayerId = 0;\r\n        this._dirty = false;\r\n        this._root = null;\r\n        this.debug = Debug.create(true, DebugSelectors.SCENE);\r\n        const { document, window, mode = (_a = windowValue('agChartsSceneRenderModel')) !== null && _a !== void 0 ? _a : advancedCompositeIdentifier, width, height, overrideDevicePixelRatio = undefined, } = opts;\r\n        this.overrideDevicePixelRatio = overrideDevicePixelRatio;\r\n        this.opts = { document, window, mode };\r\n        this.canvas = new HdpiCanvas({ document, window, width, height, overrideDevicePixelRatio });\r\n    }\r\n    set container(value) {\r\n        this.canvas.container = value;\r\n    }\r\n    get container() {\r\n        return this.canvas.container;\r\n    }\r\n    download(fileName, fileFormat) {\r\n        this.canvas.download(fileName, fileFormat);\r\n    }\r\n    getDataURL(type) {\r\n        return this.canvas.getDataURL(type);\r\n    }\r\n    get width() {\r\n        return this.pendingSize ? this.pendingSize[0] : this.canvas.width;\r\n    }\r\n    get height() {\r\n        return this.pendingSize ? this.pendingSize[1] : this.canvas.height;\r\n    }\r\n    resize(width, height) {\r\n        width = Math.round(width);\r\n        height = Math.round(height);\r\n        // HdpiCanvas doesn't allow width/height <= 0.\r\n        const lessThanZero = width <= 0 || height <= 0;\r\n        const nan = isNaN(width) || isNaN(height);\r\n        const unchanged = width === this.width && height === this.height;\r\n        if (unchanged || nan || lessThanZero) {\r\n            return false;\r\n        }\r\n        this.pendingSize = [width, height];\r\n        this.markDirty();\r\n        return true;\r\n    }\r\n    addLayer(opts) {\r\n        var _a;\r\n        const { mode } = this.opts;\r\n        const layeredModes = ['composite', domCompositeIdentifier, advancedCompositeIdentifier];\r\n        if (!layeredModes.includes(mode)) {\r\n            return undefined;\r\n        }\r\n        const { zIndex = this._nextZIndex++, name, zIndexSubOrder, getComputedOpacity, getVisibility } = opts;\r\n        const { width, height, overrideDevicePixelRatio } = this;\r\n        const domLayer = mode === domCompositeIdentifier;\r\n        const advLayer = mode === advancedCompositeIdentifier;\r\n        const canvas = !advLayer || !HdpiOffscreenCanvas.isSupported()\r\n            ? new HdpiCanvas({\r\n                document: this.opts.document,\r\n                window: this.opts.window,\r\n                width,\r\n                height,\r\n                domLayer,\r\n                zIndex,\r\n                name,\r\n                overrideDevicePixelRatio,\r\n            })\r\n            : new HdpiOffscreenCanvas({\r\n                width,\r\n                height,\r\n                overrideDevicePixelRatio,\r\n            });\r\n        const newLayer = {\r\n            id: this._nextLayerId++,\r\n            name,\r\n            zIndex,\r\n            zIndexSubOrder,\r\n            canvas,\r\n            getComputedOpacity,\r\n            getVisibility,\r\n        };\r\n        if (zIndex >= this._nextZIndex) {\r\n            this._nextZIndex = zIndex + 1;\r\n        }\r\n        this.layers.push(newLayer);\r\n        this.sortLayers();\r\n        if (domLayer) {\r\n            const domCanvases = this.layers\r\n                .map((v) => v.canvas)\r\n                .filter((v) => v instanceof HdpiCanvas);\r\n            const newLayerIndex = domCanvases.findIndex((v) => v === canvas);\r\n            const lastLayer = (_a = domCanvases[newLayerIndex - 1]) !== null && _a !== void 0 ? _a : this.canvas;\r\n            lastLayer.element.insertAdjacentElement('afterend', canvas.element);\r\n        }\r\n        this.debug('Scene.addLayer() - layers', this.layers);\r\n        return newLayer.canvas;\r\n    }\r\n    removeLayer(canvas) {\r\n        const index = this.layers.findIndex((l) => l.canvas === canvas);\r\n        if (index >= 0) {\r\n            this.layers.splice(index, 1);\r\n            canvas.destroy();\r\n            this.markDirty();\r\n            this.debug('Scene.removeLayer() -  layers', this.layers);\r\n        }\r\n    }\r\n    moveLayer(canvas, newZIndex, newZIndexSubOrder) {\r\n        const layer = this.layers.find((l) => l.canvas === canvas);\r\n        if (layer) {\r\n            layer.zIndex = newZIndex;\r\n            layer.zIndexSubOrder = newZIndexSubOrder;\r\n            this.sortLayers();\r\n            this.markDirty();\r\n            this.debug('Scene.moveLayer() -  layers', this.layers);\r\n        }\r\n    }\r\n    sortLayers() {\r\n        this.layers.sort((a, b) => {\r\n            var _a, _b;\r\n            return compoundAscending([a.zIndex, ...((_a = a.zIndexSubOrder) !== null && _a !== void 0 ? _a : [undefined, undefined]), a.id], [b.zIndex, ...((_b = b.zIndexSubOrder) !== null && _b !== void 0 ? _b : [undefined, undefined]), b.id], ascendingStringNumberUndefined);\r\n        });\r\n    }\r\n    markDirty() {\r\n        this._dirty = true;\r\n    }\r\n    get dirty() {\r\n        return this._dirty;\r\n    }\r\n    set root(node) {\r\n        var _a;\r\n        if (node === this._root) {\r\n            return;\r\n        }\r\n        (_a = this._root) === null || _a === void 0 ? void 0 : _a._setLayerManager();\r\n        this._root = node;\r\n        if (node) {\r\n            node._setLayerManager({\r\n                addLayer: (opts) => this.addLayer(opts),\r\n                moveLayer: (...opts) => this.moveLayer(...opts),\r\n                removeLayer: (...opts) => this.removeLayer(...opts),\r\n                markDirty: () => this.markDirty(),\r\n                canvas: this.canvas,\r\n                debug: Debug.create(DebugSelectors.SCENE),\r\n            });\r\n        }\r\n        this.markDirty();\r\n    }\r\n    get root() {\r\n        return this._root;\r\n    }\r\n    /** Alternative to destroy() that preserves re-usable resources. */\r\n    strip() {\r\n        const { layers } = this;\r\n        for (const layer of layers) {\r\n            layer.canvas.destroy();\r\n            delete layer['canvas'];\r\n        }\r\n        layers.splice(0, layers.length);\r\n        this.root = null;\r\n        this._dirty = false;\r\n        this.canvas.context.resetTransform();\r\n    }\r\n    destroy() {\r\n        this.container = undefined;\r\n        this.strip();\r\n        this.canvas.destroy();\r\n        Object.assign(this, { canvas: undefined, ctx: undefined });\r\n    }\r\n    render(opts) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { debugSplitTimes = { start: performance.now() }, extraDebugStats = {} } = opts !== null && opts !== void 0 ? opts : {};\r\n            const { canvas, canvas: { context: ctx }, root, layers, pendingSize, opts: { mode }, } = this;\r\n            if (pendingSize) {\r\n                this.canvas.resize(...pendingSize);\r\n                this.layers.forEach((layer) => layer.canvas.resize(...pendingSize));\r\n                this.pendingSize = undefined;\r\n            }\r\n            if (root && !root.visible) {\r\n                this._dirty = false;\r\n                return;\r\n            }\r\n            if (root && !this.dirty) {\r\n                this.debug('Scene.render() - no-op', {\r\n                    redrawType: RedrawType[root.dirty],\r\n                    tree: this.buildTree(root),\r\n                });\r\n                this.debugStats(debugSplitTimes, ctx, undefined, extraDebugStats);\r\n                return;\r\n            }\r\n            const renderCtx = {\r\n                ctx,\r\n                devicePixelRatio: (_a = this.canvas.pixelRatio) !== null && _a !== void 0 ? _a : 1,\r\n                forceRender: true,\r\n                resized: !!pendingSize,\r\n                debugNodes: {},\r\n            };\r\n            if (Debug.check(DebugSelectors.SCENE_STATS_VERBOSE)) {\r\n                renderCtx.stats = { layersRendered: 0, layersSkipped: 0, nodesRendered: 0, nodesSkipped: 0 };\r\n            }\r\n            let canvasCleared = false;\r\n            if (!root || root.dirty >= RedrawType.TRIVIAL) {\r\n                // start with a blank canvas, clear previous drawing\r\n                canvasCleared = true;\r\n                canvas.clear();\r\n            }\r\n            if (root) {\r\n                const { dirtyTree, paths } = this.buildDirtyTree(root);\r\n                Debug.create(DebugSelectors.SCENE_DIRTY_TREE)('Scene.render() - dirtyTree', {\r\n                    dirtyTree,\r\n                    paths,\r\n                });\r\n            }\r\n            if (root && canvasCleared) {\r\n                this.debug('Scene.render() - before', {\r\n                    redrawType: RedrawType[root.dirty],\r\n                    canvasCleared,\r\n                    tree: this.buildTree(root),\r\n                });\r\n                if (root.visible) {\r\n                    ctx.save();\r\n                    root.render(renderCtx);\r\n                    ctx.restore();\r\n                }\r\n            }\r\n            debugSplitTimes['✍️'] = performance.now();\r\n            if (mode !== domCompositeIdentifier && layers.length > 0 && canvasCleared) {\r\n                this.sortLayers();\r\n                ctx.save();\r\n                ctx.setTransform(1 / canvas.pixelRatio, 0, 0, 1 / canvas.pixelRatio, 0, 0);\r\n                layers.forEach(({ canvas: { imageSource, enabled }, getComputedOpacity, getVisibility }) => {\r\n                    if (!enabled || !getVisibility()) {\r\n                        return;\r\n                    }\r\n                    ctx.globalAlpha = getComputedOpacity();\r\n                    ctx.drawImage(imageSource, 0, 0);\r\n                });\r\n                ctx.restore();\r\n                debugSplitTimes['⛙'] = performance.now();\r\n            }\r\n            // Check for save/restore depth of zero!\r\n            (_b = ctx.verifyDepthZero) === null || _b === void 0 ? void 0 : _b.call(ctx);\r\n            this._dirty = false;\r\n            this.debugStats(debugSplitTimes, ctx, renderCtx.stats, extraDebugStats);\r\n            this.debugSceneNodeHighlight(ctx, renderCtx.debugNodes);\r\n            if (root) {\r\n                this.debug('Scene.render() - after', {\r\n                    redrawType: RedrawType[root.dirty],\r\n                    canvasCleared,\r\n                    tree: this.buildTree(root),\r\n                });\r\n            }\r\n        });\r\n    }\r\n    debugStats(debugSplitTimes, ctx, renderCtxStats, extraDebugStats = {}) {\r\n        if (Debug.check(DebugSelectors.SCENE_STATS, DebugSelectors.SCENE_STATS_VERBOSE)) {\r\n            const end = performance.now();\r\n            const start = debugSplitTimes['start'];\r\n            debugSplitTimes['end'] = performance.now();\r\n            const pct = (rendered, skipped) => {\r\n                const total = rendered + skipped;\r\n                return `${rendered} / ${total} (${Math.round((100 * rendered) / total)}%)`;\r\n            };\r\n            const time = (name, start, end) => {\r\n                return `${name}: ${Math.round((end - start) * 100) / 100}ms`;\r\n            };\r\n            const { layersRendered = 0, layersSkipped = 0, nodesRendered = 0, nodesSkipped = 0 } = renderCtxStats !== null && renderCtxStats !== void 0 ? renderCtxStats : {};\r\n            let lastSplit = 0;\r\n            const splits = Object.entries(debugSplitTimes)\r\n                .filter(([n]) => n !== 'end')\r\n                .map(([n, t], i) => {\r\n                const result = i > 0 ? time(n, lastSplit, t) : null;\r\n                lastSplit = t;\r\n                return result;\r\n            })\r\n                .filter((v) => v != null)\r\n                .join(' + ');\r\n            const extras = Object.entries(extraDebugStats)\r\n                .map(([k, v]) => `${k}: ${v}`)\r\n                .join(' ; ');\r\n            const detailedStats = Debug.check(DebugSelectors.SCENE_STATS_VERBOSE);\r\n            const stats = [\r\n                `${time('⏱️', start, end)} (${splits})`,\r\n                `${extras}`,\r\n                `Layers: ${detailedStats ? pct(layersRendered, layersSkipped) : this.layers.length}`,\r\n                detailedStats ? `Nodes: ${pct(nodesRendered, nodesSkipped)}` : null,\r\n            ].filter((v) => v != null);\r\n            const statsSize = stats.map((t) => [t, HdpiCanvas.getTextSize(t, ctx.font)]);\r\n            const width = Math.max(...statsSize.map(([, { width }]) => width));\r\n            const height = statsSize.reduce((total, [, { height }]) => total + height, 0);\r\n            ctx.save();\r\n            ctx.fillStyle = 'white';\r\n            ctx.fillRect(0, 0, width, height);\r\n            ctx.fillStyle = 'black';\r\n            let y = 0;\r\n            for (const [stat, size] of statsSize) {\r\n                y += size.height;\r\n                ctx.fillText(stat, 2, y);\r\n            }\r\n            ctx.restore();\r\n        }\r\n    }\r\n    debugSceneNodeHighlight(ctx, debugNodes) {\r\n        var _a;\r\n        const regexpPredicate = (matcher) => (n) => {\r\n            if (matcher.test(n.id)) {\r\n                return true;\r\n            }\r\n            return n instanceof Group && n.name != null && matcher.test(n.name);\r\n        };\r\n        const stringPredicate = (match) => (n) => {\r\n            if (match === n.id) {\r\n                return true;\r\n            }\r\n            return n instanceof Group && n.name != null && match === n.name;\r\n        };\r\n        const sceneNodeHighlight = toArray(windowValue('agChartsSceneDebug')).flatMap((name) => name === 'layout' ? ['seriesRoot', 'legend', 'root', /.*Axis-\\d+-axis.*/] : name);\r\n        for (const next of sceneNodeHighlight) {\r\n            if (typeof next === 'string' && debugNodes[next] != null)\r\n                continue;\r\n            const predicate = typeof next === 'string' ? stringPredicate(next) : regexpPredicate(next);\r\n            const nodes = (_a = this.root) === null || _a === void 0 ? void 0 : _a.findNodes(predicate);\r\n            if (!nodes || nodes.length === 0) {\r\n                Logger.log(`Scene.render() - no debugging node with id [${next}] in scene graph.`);\r\n                continue;\r\n            }\r\n            for (const node of nodes) {\r\n                if (node instanceof Group && node.name) {\r\n                    debugNodes[node.name] = node;\r\n                }\r\n                else {\r\n                    debugNodes[node.id] = node;\r\n                }\r\n            }\r\n        }\r\n        ctx.save();\r\n        for (const [name, node] of Object.entries(debugNodes)) {\r\n            const bbox = node.computeTransformedBBox();\r\n            if (!bbox) {\r\n                Logger.log(`Scene.render() - no bbox for debugged node [${name}].`);\r\n                continue;\r\n            }\r\n            ctx.globalAlpha = 0.8;\r\n            ctx.strokeStyle = 'red';\r\n            ctx.lineWidth = 1;\r\n            ctx.strokeRect(bbox.x, bbox.y, bbox.width, bbox.height);\r\n            ctx.fillStyle = 'red';\r\n            ctx.strokeStyle = 'white';\r\n            ctx.font = '16px sans-serif';\r\n            ctx.textBaseline = 'top';\r\n            ctx.textAlign = 'left';\r\n            ctx.lineWidth = 2;\r\n            ctx.strokeText(name, bbox.x, bbox.y, bbox.width);\r\n            ctx.fillText(name, bbox.x, bbox.y, bbox.width);\r\n        }\r\n        ctx.restore();\r\n    }\r\n    buildTree(node) {\r\n        var _a, _b;\r\n        const name = (_a = (node instanceof Group ? node.name : null)) !== null && _a !== void 0 ? _a : node.id;\r\n        return Object.assign(Object.assign({ name,\r\n            node, dirty: RedrawType[node.dirty] }, (((_b = node.parent) === null || _b === void 0 ? void 0 : _b.isVirtual)\r\n            ? {\r\n                virtualParentDirty: RedrawType[node.parent.dirty],\r\n                virtualParent: node.parent,\r\n            }\r\n            : {})), node.children\r\n            .map((c) => this.buildTree(c))\r\n            .reduce((result, childTree) => {\r\n            let { name: treeNodeName } = childTree;\r\n            const { node: { visible, opacity, zIndex, zIndexSubOrder }, node: childNode, virtualParent, } = childTree;\r\n            if (!visible || opacity <= 0) {\r\n                treeNodeName = `(${treeNodeName})`;\r\n            }\r\n            if (childNode instanceof Group && childNode.isLayer()) {\r\n                treeNodeName = `*${treeNodeName}*`;\r\n            }\r\n            const key = [\r\n                `${treeNodeName !== null && treeNodeName !== void 0 ? treeNodeName : '<unknown>'}`,\r\n                `z: ${zIndex}`,\r\n                zIndexSubOrder &&\r\n                    `zo: ${zIndexSubOrder\r\n                        .map((v) => (typeof v === 'function' ? `${v()} (fn)` : v))\r\n                        .join(' / ')}`,\r\n                virtualParent && `(virtual parent)`,\r\n            ]\r\n                .filter((v) => !!v)\r\n                .join(' ');\r\n            let selectedKey = key;\r\n            let index = 1;\r\n            while (result[selectedKey] != null && index < 100) {\r\n                selectedKey = `${key} (${index++})`;\r\n            }\r\n            result[selectedKey] = childTree;\r\n            return result;\r\n        }, {}));\r\n    }\r\n    buildDirtyTree(node) {\r\n        var _a;\r\n        if (node.dirty === RedrawType.NONE) {\r\n            return { dirtyTree: {}, paths: [] };\r\n        }\r\n        const childrenDirtyTree = node.children.map((c) => this.buildDirtyTree(c)).filter((c) => c.paths.length > 0);\r\n        const name = (_a = (node instanceof Group ? node.name : null)) !== null && _a !== void 0 ? _a : node.id;\r\n        const paths = childrenDirtyTree.length === 0\r\n            ? [name]\r\n            : childrenDirtyTree\r\n                .map((c) => c.paths)\r\n                .reduce((r, p) => r.concat(p), [])\r\n                .map((p) => `${name}.${p}`);\r\n        return {\r\n            dirtyTree: Object.assign({ name,\r\n                node, dirty: RedrawType[node.dirty] }, childrenDirtyTree\r\n                .map((c) => c.dirtyTree)\r\n                .filter((t) => t.dirty !== undefined)\r\n                .reduce((result, childTree) => {\r\n                var _a;\r\n                result[(_a = childTree.name) !== null && _a !== void 0 ? _a : '<unknown>'] = childTree;\r\n                return result;\r\n            }, {})),\r\n            paths,\r\n        };\r\n    }\r\n}\r\nScene.className = 'Scene';\n\nfunction sleep(sleepTimeoutMs) {\r\n    return new Promise((resolve) => {\r\n        setTimeout(() => resolve(undefined), sleepTimeoutMs);\r\n    });\r\n}\n\nclass CallbackCache {\r\n    constructor() {\r\n        this.cache = new WeakMap();\r\n    }\r\n    call(fn, ...params) {\r\n        let serialisedParams;\r\n        let paramCache = this.cache.get(fn);\r\n        const invoke = () => {\r\n            try {\r\n                const result = fn(...params);\r\n                if (paramCache && serialisedParams != null) {\r\n                    paramCache.set(serialisedParams, result);\r\n                }\r\n                return result;\r\n            }\r\n            catch (e) {\r\n                Logger.warnOnce(`User callback errored, ignoring`, e);\r\n                return undefined;\r\n            }\r\n        };\r\n        try {\r\n            serialisedParams = JSON.stringify(params);\r\n        }\r\n        catch (e) {\r\n            // Unable to serialise params!\r\n            // No caching possible.\r\n            return invoke();\r\n        }\r\n        if (paramCache == null) {\r\n            paramCache = new Map();\r\n            this.cache.set(fn, paramCache);\r\n        }\r\n        if (!paramCache.has(serialisedParams)) {\r\n            return invoke();\r\n        }\r\n        return paramCache.get(serialisedParams);\r\n    }\r\n    invalidateCache() {\r\n        this.cache = new WeakMap();\r\n    }\r\n}\n\nclass Mutex {\r\n    constructor() {\r\n        this.available = true;\r\n        this.acquireQueue = [];\r\n    }\r\n    acquire(cb) {\r\n        return new Promise((resolve) => {\r\n            this.acquireQueue.push([cb, resolve]);\r\n            if (this.available) {\r\n                this.dispatchNext();\r\n            }\r\n        });\r\n    }\r\n    acquireImmediately(cb) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!this.available) {\r\n                return false;\r\n            }\r\n            yield this.acquire(cb);\r\n            return true;\r\n        });\r\n    }\r\n    waitForClearAcquireQueue() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return this.acquire(() => __awaiter(this, void 0, void 0, function* () { return undefined; }));\r\n        });\r\n    }\r\n    dispatchNext() {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.available = false;\r\n            let [next, done] = (_a = this.acquireQueue.shift()) !== null && _a !== void 0 ? _a : [];\r\n            while (next) {\r\n                try {\r\n                    yield next();\r\n                    done === null || done === void 0 ? void 0 : done();\r\n                }\r\n                catch (error) {\r\n                    Logger.error('mutex callback error', error);\r\n                    done === null || done === void 0 ? void 0 : done();\r\n                }\r\n                [next, done] = (_b = this.acquireQueue.shift()) !== null && _b !== void 0 ? _b : [];\r\n            }\r\n            this.available = true;\r\n        });\r\n    }\r\n}\n\n/**\r\n * Wrap a function in debouncing trigger function. A requestAnimationFrame() is scheduled\r\n * after the first schedule() call, and subsequent schedule() calls will be ignored until the\r\n * animation callback executes.\r\n */\r\nfunction debouncedAnimationFrame(cb) {\r\n    return buildScheduler((cb, _delayMs) => requestAnimationFrame(cb), cb);\r\n}\r\nfunction debouncedCallback(cb) {\r\n    return buildScheduler((cb, delayMs = 0) => setTimeout(cb, delayMs), cb);\r\n}\r\nfunction buildScheduler(scheduleFn, cb) {\r\n    let scheduleCount = 0;\r\n    let promiseRunning = false;\r\n    let awaitingPromise;\r\n    let awaitingDone;\r\n    const busy = () => {\r\n        return promiseRunning;\r\n    };\r\n    const done = () => {\r\n        promiseRunning = false;\r\n        awaitingDone === null || awaitingDone === void 0 ? void 0 : awaitingDone();\r\n        awaitingDone = undefined;\r\n        awaitingPromise = undefined;\r\n        if (scheduleCount > 0) {\r\n            scheduleFn(scheduleCb);\r\n        }\r\n    };\r\n    const scheduleCb = () => {\r\n        const count = scheduleCount;\r\n        scheduleCount = 0;\r\n        promiseRunning = true;\r\n        const maybePromise = cb({ count });\r\n        if (!maybePromise) {\r\n            done();\r\n            return;\r\n        }\r\n        maybePromise.then(done).catch(done);\r\n    };\r\n    return {\r\n        schedule(delayMs) {\r\n            if (scheduleCount === 0 && !busy()) {\r\n                scheduleFn(scheduleCb, delayMs);\r\n            }\r\n            scheduleCount++;\r\n        },\r\n        await() {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                if (!busy()) {\r\n                    return;\r\n                }\r\n                if (awaitingPromise == null) {\r\n                    awaitingPromise = new Promise((resolve) => {\r\n                        awaitingDone = resolve;\r\n                    });\r\n                }\r\n                while (busy()) {\r\n                    yield awaitingPromise;\r\n                }\r\n            });\r\n        },\r\n    };\r\n}\n\nclass SizeMonitor {\r\n    static init(document) {\r\n        if (typeof ResizeObserver !== 'undefined') {\r\n            this.resizeObserver = new ResizeObserver((entries) => {\r\n                for (const entry of entries) {\r\n                    const { width, height } = entry.contentRect;\r\n                    this.checkSize(this.elements.get(entry.target), entry.target, width, height);\r\n                }\r\n            });\r\n        }\r\n        else {\r\n            // polyfill (more reliable even in browsers that support ResizeObserver)\r\n            const step = () => {\r\n                this.elements.forEach((entry, element) => {\r\n                    this.checkClientSize(element, entry);\r\n                });\r\n            };\r\n            this.pollerHandler = window.setInterval(step, 100);\r\n        }\r\n        this.ready = true;\r\n        this.documentReady = document.readyState !== 'loading';\r\n        if (this.documentReady)\r\n            return;\r\n        // Add DOMContentLoaded listener so we can check if the main document is ready again, and\r\n        // if it is then attach any queued requests for resize monitoring.\r\n        //\r\n        // If we attach before ent.readyState !== 'loading', then additional incorrect resize events\r\n        // are fired, leading to multiple re-renderings on chart initial load. Waiting for the\r\n        // document to be loaded irons out this browser quirk.\r\n        this.readyEventFn = () => {\r\n            const newState = document.readyState !== 'loading';\r\n            const oldState = this.documentReady;\r\n            this.documentReady = newState;\r\n            if (!newState)\r\n                return;\r\n            if (newState === oldState)\r\n                return;\r\n            for (const [el, cb] of this.queuedObserveRequests) {\r\n                this.observe(el, cb);\r\n            }\r\n            this.queuedObserveRequests.length = 0;\r\n        };\r\n        document.addEventListener('DOMContentLoaded', this.readyEventFn);\r\n    }\r\n    static destroy() {\r\n        var _a;\r\n        if (this.pollerHandler != null) {\r\n            clearInterval(this.pollerHandler);\r\n            this.pollerHandler = undefined;\r\n        }\r\n        if (this.readyEventFn) {\r\n            document.removeEventListener('DOMContentLoaded', this.readyEventFn);\r\n            this.readyEventFn = undefined;\r\n        }\r\n        (_a = this.resizeObserver) === null || _a === void 0 ? void 0 : _a.disconnect();\r\n        this.resizeObserver = undefined;\r\n        this.ready = false;\r\n    }\r\n    static checkSize(entry, element, width, height) {\r\n        if (!entry)\r\n            return;\r\n        if (!entry.size || width !== entry.size.width || height !== entry.size.height) {\r\n            entry.size = { width, height };\r\n            entry.cb(entry.size, element);\r\n        }\r\n    }\r\n    // Only a single callback is supported.\r\n    static observe(element, cb) {\r\n        if (!this.ready) {\r\n            this.init(element.ownerDocument);\r\n        }\r\n        if (!this.documentReady) {\r\n            this.queuedObserveRequests.push([element, cb]);\r\n            return;\r\n        }\r\n        this.unobserve(element, false);\r\n        if (this.resizeObserver) {\r\n            this.resizeObserver.observe(element);\r\n        }\r\n        this.elements.set(element, { cb });\r\n    }\r\n    static unobserve(element, cleanup = true) {\r\n        if (this.resizeObserver) {\r\n            this.resizeObserver.unobserve(element);\r\n        }\r\n        this.elements.delete(element);\r\n        this.queuedObserveRequests = this.queuedObserveRequests.filter(([el]) => el === element);\r\n        if (cleanup && this.elements.size === 0) {\r\n            this.destroy();\r\n        }\r\n    }\r\n    static checkClientSize(element, entry) {\r\n        const width = element.clientWidth ? element.clientWidth : 0;\r\n        const height = element.clientHeight ? element.clientHeight : 0;\r\n        this.checkSize(entry, element, width, height);\r\n    }\r\n}\r\nSizeMonitor.elements = new Map();\r\nSizeMonitor.ready = false;\r\nSizeMonitor.documentReady = false;\r\nSizeMonitor.queuedObserveRequests = [];\n\nclass ChartHighlight {\r\n    constructor() {\r\n        this.range = 'tooltip';\r\n    }\r\n}\r\n__decorate([\r\n    Validate(STRING_UNION('tooltip', 'node')),\r\n    __metadata(\"design:type\", String)\r\n], ChartHighlight.prototype, \"range\", void 0);\n\n/** Types of chart-update, in pipeline execution order. */\r\nvar ChartUpdateType;\r\n(function (ChartUpdateType) {\r\n    ChartUpdateType[ChartUpdateType[\"FULL\"] = 0] = \"FULL\";\r\n    ChartUpdateType[ChartUpdateType[\"PROCESS_DATA\"] = 1] = \"PROCESS_DATA\";\r\n    ChartUpdateType[ChartUpdateType[\"PERFORM_LAYOUT\"] = 2] = \"PERFORM_LAYOUT\";\r\n    ChartUpdateType[ChartUpdateType[\"SERIES_UPDATE\"] = 3] = \"SERIES_UPDATE\";\r\n    ChartUpdateType[ChartUpdateType[\"TOOLTIP_RECALCULATION\"] = 4] = \"TOOLTIP_RECALCULATION\";\r\n    ChartUpdateType[ChartUpdateType[\"SCENE_RENDER\"] = 5] = \"SCENE_RENDER\";\r\n    ChartUpdateType[ChartUpdateType[\"NONE\"] = 6] = \"NONE\";\r\n})(ChartUpdateType || (ChartUpdateType = {}));\n\nclass DataDomain {\r\n    constructor(type) {\r\n        this.type = type;\r\n        this.continuousDomain = [Infinity, -Infinity];\r\n        this.discreteDomain = new Set();\r\n    }\r\n    extend(val) {\r\n        if (this.type === 'discrete') {\r\n            this.discreteDomain.add(val);\r\n        }\r\n        else if (this.type === 'continuous') {\r\n            if (this.continuousDomain[0] > val) {\r\n                this.continuousDomain[0] = val;\r\n            }\r\n            if (this.continuousDomain[1] < val) {\r\n                this.continuousDomain[1] = val;\r\n            }\r\n        }\r\n    }\r\n    getDomain() {\r\n        if (this.type === 'discrete') {\r\n            return this.discreteDomain;\r\n        }\r\n        else if (this.type === 'continuous') {\r\n            return this.continuousDomain;\r\n        }\r\n        throw new Error('AG Charts - Unsupported data domain type: ' + this.type);\r\n    }\r\n}\n\nfunction toKeyString(keys) {\r\n    return keys\r\n        .map((v) => {\r\n        if (v == null) {\r\n            return v;\r\n        }\r\n        else if (typeof v === 'number' || typeof v === 'string' || typeof v === 'boolean') {\r\n            return v;\r\n        }\r\n        else if (typeof v === 'object') {\r\n            return JSON.stringify(v);\r\n        }\r\n        return v;\r\n    })\r\n        .join('-');\r\n}\r\nfunction round(val) {\r\n    const accuracy = 10000;\r\n    if (Number.isInteger(val)) {\r\n        return val;\r\n    }\r\n    else if (Math.abs(val) > accuracy) {\r\n        return Math.trunc(val);\r\n    }\r\n    return Math.round(val * accuracy) / accuracy;\r\n}\r\nfunction fixNumericExtentInternal(extent) {\r\n    if (extent === undefined) {\r\n        // Don't return a range, there is no range.\r\n        return [];\r\n    }\r\n    let [min, max] = extent;\r\n    min = +min;\r\n    max = +max;\r\n    if (min === 0 && max === 0) {\r\n        // domain has zero length and the single valid value is 0. Use the default of [0, 1].\r\n        return [0, 1];\r\n    }\r\n    if (min === Infinity && max === -Infinity) {\r\n        // There's no data in the domain.\r\n        return [];\r\n    }\r\n    if (min === Infinity) {\r\n        min = 0;\r\n    }\r\n    if (max === -Infinity) {\r\n        max = 0;\r\n    }\r\n    if (!(isNumber(min) && isNumber(max))) {\r\n        return [];\r\n    }\r\n    return [min, max];\r\n}\r\nfunction fixNumericExtent(extent, axis) {\r\n    var _a;\r\n    const fixedExtent = fixNumericExtentInternal(extent);\r\n    if (fixedExtent.length === 0) {\r\n        return fixedExtent;\r\n    }\r\n    let [min, max] = fixedExtent;\r\n    if (min === max) {\r\n        // domain has zero length, there is only a single valid value in data\r\n        const [paddingMin, paddingMax] = (_a = axis === null || axis === void 0 ? void 0 : axis.calculatePadding(min, max)) !== null && _a !== void 0 ? _a : [1, 1];\r\n        min -= paddingMin;\r\n        max += paddingMax;\r\n    }\r\n    return [min, max];\r\n}\r\nconst INVALID_VALUE = Symbol('invalid');\r\nclass DataModel {\r\n    constructor(opts) {\r\n        const { props, mode = 'standalone' } = opts;\r\n        this.mode = mode;\r\n        // Validate that keys appear before values in the definitions, as output ordering depends\r\n        // on configuration ordering, but we process keys before values.\r\n        let keys = true;\r\n        for (const next of props) {\r\n            if (next.type === 'key' && !keys) {\r\n                throw new Error('AG Charts - internal config error: keys must come before values.');\r\n            }\r\n            if (next.type === 'value' && keys) {\r\n                keys = false;\r\n            }\r\n        }\r\n        this.opts = Object.assign({ dataVisible: true }, opts);\r\n        this.keys = props\r\n            .filter((def) => def.type === 'key')\r\n            .map((def, index) => (Object.assign(Object.assign({}, def), { index, missing: 0 })));\r\n        this.values = props\r\n            .filter((def) => def.type === 'value')\r\n            .map((def, index) => (Object.assign(Object.assign({}, def), { index, missing: 0 })));\r\n        this.aggregates = props\r\n            .filter((def) => def.type === 'aggregate')\r\n            .map((def, index) => (Object.assign(Object.assign({}, def), { index })));\r\n        this.groupProcessors = props\r\n            .filter((def) => def.type === 'group-value-processor')\r\n            .map((def, index) => (Object.assign(Object.assign({}, def), { index })));\r\n        this.propertyProcessors = props\r\n            .filter((def) => def.type === 'property-value-processor')\r\n            .map((def, index) => (Object.assign(Object.assign({}, def), { index })));\r\n        this.reducers = props\r\n            .filter((def) => def.type === 'reducer')\r\n            .map((def, index) => (Object.assign(Object.assign({}, def), { index })));\r\n        this.processors = props\r\n            .filter((def) => def.type === 'processor')\r\n            .map((def, index) => (Object.assign(Object.assign({}, def), { index })));\r\n        for (const def of this.values) {\r\n            if (def.property == null) {\r\n                throw new Error(`AG Charts - internal config error: no properties specified for value definitions: ${JSON.stringify(def)}`);\r\n            }\r\n        }\r\n        const verifyMatchGroupId = ({ matchGroupIds }) => {\r\n            for (const matchGroupId of matchGroupIds !== null && matchGroupIds !== void 0 ? matchGroupIds : []) {\r\n                if (!this.values.some((def) => def.groupId === matchGroupId)) {\r\n                    throw new Error(`AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchGroupId}).`);\r\n                }\r\n            }\r\n        };\r\n        const verifyMatchIds = ({ matchIds }) => {\r\n            for (const matchId of matchIds !== null && matchIds !== void 0 ? matchIds : []) {\r\n                if (!this.values.some((def) => { var _a; return (_a = def.ids) === null || _a === void 0 ? void 0 : _a.some(([scope, id]) => scope === matchId[0] && id === matchId[1]); })) {\r\n                    throw new Error(`AG Charts - internal config error: matchGroupIds properties must match defined groups (${matchId}).`);\r\n                }\r\n            }\r\n        };\r\n        for (const def of [...this.groupProcessors, ...this.aggregates]) {\r\n            verifyMatchIds(def);\r\n            verifyMatchGroupId(def);\r\n        }\r\n    }\r\n    resolveProcessedDataIndexById(scope, searchId) {\r\n        var _a;\r\n        const { index, def } = (_a = this.resolveProcessedDataDefById(scope, searchId)) !== null && _a !== void 0 ? _a : {};\r\n        return { index, def };\r\n    }\r\n    resolveProcessedDataIndicesById(scope, searchId) {\r\n        return this.resolveProcessedDataDefsById(scope, searchId).map(({ index, def }) => ({ index, def }));\r\n    }\r\n    resolveProcessedDataDefById(scope, searchId) {\r\n        return this.resolveProcessedDataDefsById(scope, searchId)[0];\r\n    }\r\n    resolveProcessedDataDefsByIds(scope, searchIds) {\r\n        const defs = [];\r\n        for (const searchId of searchIds) {\r\n            defs.push([searchId, this.resolveProcessedDataDefsById(scope, searchId)]);\r\n        }\r\n        return defs;\r\n    }\r\n    resolveProcessedDataDefsValues(defs, { keys, values }) {\r\n        const result = {};\r\n        for (const [searchId, [{ index, def }]] of defs) {\r\n            const processedData = def.type === 'key' ? keys : values;\r\n            result[searchId] = processedData[index];\r\n        }\r\n        return result;\r\n    }\r\n    resolveProcessedDataDefsById(searchScope, searchId) {\r\n        const { keys, values, aggregates, groupProcessors, reducers } = this;\r\n        const match = (prop) => {\r\n            const { ids, scopes } = prop;\r\n            if (ids == null)\r\n                return false;\r\n            if (searchScope != null && !(scopes === null || scopes === void 0 ? void 0 : scopes.some((scope) => scope === searchScope.id)))\r\n                return false;\r\n            return ids.some(([scope, id]) => scope === searchScope.id && (typeof searchId === 'string' ? id === searchId : searchId.test(id)));\r\n        };\r\n        const allDefs = [\r\n            keys,\r\n            values,\r\n            aggregates,\r\n            groupProcessors,\r\n            reducers,\r\n        ];\r\n        const result = [];\r\n        for (const defs of allDefs) {\r\n            result.push(...defs.filter(match).map((def) => ({ index: def.index, def })));\r\n        }\r\n        if (result.length > 0) {\r\n            return result;\r\n        }\r\n        throw new Error(`AG Charts - didn't find property definition for [${searchId}, ${searchScope.id}]`);\r\n    }\r\n    getDomain(scope, searchId, type = 'value', processedData) {\r\n        var _a, _b, _c, _d;\r\n        let matches;\r\n        try {\r\n            matches = this.resolveProcessedDataIndicesById(scope, searchId);\r\n        }\r\n        catch (e) {\r\n            if (typeof searchId !== 'string' && /didn't find property definition/.test(e.message))\r\n                return [];\r\n            throw e;\r\n        }\r\n        let domainProp;\r\n        switch (type) {\r\n            case 'key':\r\n                domainProp = 'keys';\r\n                break;\r\n            case 'value':\r\n                domainProp = 'values';\r\n                break;\r\n            case 'aggregate':\r\n                domainProp = 'aggValues';\r\n                break;\r\n            case 'group-value-processor':\r\n                domainProp = 'groups';\r\n                break;\r\n            default:\r\n                return [];\r\n        }\r\n        const firstMatch = (_b = (_a = processedData.domain[domainProp]) === null || _a === void 0 ? void 0 : _a[matches[0].index]) !== null && _b !== void 0 ? _b : [];\r\n        if (matches.length === 1) {\r\n            return firstMatch;\r\n        }\r\n        const result = [...firstMatch];\r\n        for (const idx of matches.slice(1)) {\r\n            extendDomain((_d = (_c = processedData.domain[domainProp]) === null || _c === void 0 ? void 0 : _c[idx.index]) !== null && _d !== void 0 ? _d : [], result);\r\n        }\r\n        return result;\r\n    }\r\n    processData(data) {\r\n        const { opts: { groupByKeys, groupByFn }, aggregates, groupProcessors, reducers, processors, propertyProcessors, } = this;\r\n        const start = performance.now();\r\n        for (const def of [...this.keys, ...this.values]) {\r\n            def.missing = 0;\r\n        }\r\n        if (groupByKeys && this.keys.length === 0) {\r\n            return undefined;\r\n        }\r\n        let processedData = this.extractData(data);\r\n        if (groupByKeys) {\r\n            processedData = this.groupData(processedData);\r\n        }\r\n        else if (groupByFn) {\r\n            processedData = this.groupData(processedData, groupByFn(processedData));\r\n        }\r\n        if (groupProcessors.length > 0) {\r\n            this.postProcessGroups(processedData);\r\n        }\r\n        if (aggregates.length > 0) {\r\n            this.aggregateData(processedData);\r\n        }\r\n        if (propertyProcessors.length > 0) {\r\n            this.postProcessProperties(processedData);\r\n        }\r\n        if (reducers.length > 0) {\r\n            this.reduceData(processedData);\r\n        }\r\n        if (processors.length > 0) {\r\n            this.postProcessData(processedData);\r\n        }\r\n        for (const def of [...this.keys, ...this.values]) {\r\n            if (data.length > 0 && def.missing >= data.length) {\r\n                Logger.warnOnce(`the key '${def.property}' was not found in any data element.`);\r\n            }\r\n        }\r\n        const end = performance.now();\r\n        processedData.time = end - start;\r\n        if (Debug.check(true, 'data-model')) {\r\n            logProcessedData(processedData);\r\n        }\r\n        return processedData;\r\n    }\r\n    valueGroupIdxLookup({ matchGroupIds, matchIds }) {\r\n        return this.values\r\n            .map((def, index) => ({ def, index }))\r\n            .filter(({ def }) => {\r\n            if (matchGroupIds && (def.groupId == null || !matchGroupIds.includes(def.groupId))) {\r\n                return false;\r\n            }\r\n            if (!matchIds)\r\n                return true;\r\n            if (def.ids == null)\r\n                return false;\r\n            return matchIds.some(([matchScope, matchId]) => { var _a; return (_a = def.ids) === null || _a === void 0 ? void 0 : _a.some(([defScope, defId]) => defScope === matchScope && defId === matchId); });\r\n        })\r\n            .map(({ index }) => index);\r\n    }\r\n    valueIdxLookup(scopes, prop) {\r\n        const noScopesToMatch = scopes == null || scopes.length === 0;\r\n        const scopeMatch = (compareTo) => {\r\n            const anyScope = compareTo == null;\r\n            if (anyScope)\r\n                return true;\r\n            const noScopes = compareTo == null || compareTo.length === 0;\r\n            if (noScopesToMatch === noScopes)\r\n                return true;\r\n            return compareTo === null || compareTo === void 0 ? void 0 : compareTo.some((s) => scopes.includes(s));\r\n        };\r\n        const propId = typeof prop === 'string' ? prop : prop.id;\r\n        const idMatch = ([scope, id]) => {\r\n            return scopeMatch([scope]) && id === propId;\r\n        };\r\n        const result = this.values.findIndex((def) => {\r\n            var _a;\r\n            return (scopeMatch(def.scopes) &&\r\n                (((_a = def.ids) === null || _a === void 0 ? void 0 : _a.some((id) => idMatch(id))) || def.property === propId || def.id === propId));\r\n        });\r\n        if (result >= 0) {\r\n            return result;\r\n        }\r\n        throw new Error(`AG Charts - configuration error, unknown property ${JSON.stringify(prop)} in scope(s) ${JSON.stringify(scopes)}`);\r\n    }\r\n    extractData(data) {\r\n        var _a;\r\n        const { keys: keyDefs, values: valueDefs, opts: { dataVisible }, } = this;\r\n        const { dataDomain, processValue, scopes, allScopesHaveSameDefs } = this.initDataDomainProcessor();\r\n        const resultData = new Array(dataVisible ? data.length : 0);\r\n        let resultDataIdx = 0;\r\n        let partialValidDataCount = 0;\r\n        for (const datum of data) {\r\n            const validScopes = scopes.size > 0 ? new Set(scopes) : undefined;\r\n            const keys = dataVisible ? new Array(keyDefs.length) : undefined;\r\n            let keyIdx = 0;\r\n            let key;\r\n            for (const def of keyDefs) {\r\n                key = processValue(def, datum, key);\r\n                if (key === INVALID_VALUE)\r\n                    break;\r\n                if (keys) {\r\n                    keys[keyIdx++] = key;\r\n                }\r\n            }\r\n            if (key === INVALID_VALUE)\r\n                continue;\r\n            const values = dataVisible && valueDefs.length > 0 ? new Array(valueDefs.length) : undefined;\r\n            let valueIdx = 0;\r\n            let value;\r\n            for (const def of valueDefs) {\r\n                value = processValue(def, datum, value);\r\n                if (value === INVALID_VALUE) {\r\n                    if (allScopesHaveSameDefs)\r\n                        break;\r\n                    for (const scope of (_a = def.scopes) !== null && _a !== void 0 ? _a : scopes) {\r\n                        validScopes === null || validScopes === void 0 ? void 0 : validScopes.delete(scope);\r\n                    }\r\n                    valueIdx++;\r\n                    if ((validScopes === null || validScopes === void 0 ? void 0 : validScopes.size) === 0)\r\n                        break;\r\n                }\r\n                else if (values) {\r\n                    values[valueIdx++] = value;\r\n                }\r\n            }\r\n            if (value === INVALID_VALUE && allScopesHaveSameDefs)\r\n                continue;\r\n            if ((validScopes === null || validScopes === void 0 ? void 0 : validScopes.size) === 0)\r\n                continue;\r\n            if (dataVisible) {\r\n                const result = {\r\n                    datum,\r\n                    keys: keys,\r\n                    values,\r\n                };\r\n                if (!allScopesHaveSameDefs && validScopes && validScopes.size < scopes.size) {\r\n                    partialValidDataCount++;\r\n                    result.validScopes = [...validScopes];\r\n                }\r\n                resultData[resultDataIdx++] = result;\r\n            }\r\n        }\r\n        resultData.length = resultDataIdx;\r\n        const propertyDomain = (def) => {\r\n            const result = dataDomain.get(def).getDomain();\r\n            if (Array.isArray(result) && result[0] > result[1]) {\r\n                // Ignore starting values.\r\n                return [];\r\n            }\r\n            return [...result];\r\n        };\r\n        return {\r\n            type: 'ungrouped',\r\n            input: { count: data.length },\r\n            data: resultData,\r\n            domain: {\r\n                keys: keyDefs.map((def) => propertyDomain(def)),\r\n                values: valueDefs.map((def) => propertyDomain(def)),\r\n            },\r\n            defs: {\r\n                allScopesHaveSameDefs,\r\n                keys: keyDefs,\r\n                values: valueDefs,\r\n            },\r\n            partialValidDataCount,\r\n            time: 0,\r\n        };\r\n    }\r\n    groupData(data, groupingFn) {\r\n        var _a, _b, _c, _d;\r\n        const processedData = new Map();\r\n        for (const dataEntry of data.data) {\r\n            const { keys, values, datum, validScopes } = dataEntry;\r\n            const group = groupingFn ? groupingFn(dataEntry) : keys;\r\n            const groupStr = toKeyString(group);\r\n            if (processedData.has(groupStr)) {\r\n                const existingData = processedData.get(groupStr);\r\n                existingData.values.push(values);\r\n                existingData.datum.push(datum);\r\n                if (validScopes != null) {\r\n                    // Intersection of existing validScopes with new validScopes.\r\n                    for (let index = 0; index < ((_b = (_a = existingData.validScopes) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0); index++) {\r\n                        const scope = (_c = existingData.validScopes) === null || _c === void 0 ? void 0 : _c[index];\r\n                        if (validScopes.some((s) => s === scope))\r\n                            continue;\r\n                        (_d = existingData.validScopes) === null || _d === void 0 ? void 0 : _d.splice(index, 1);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                processedData.set(groupStr, {\r\n                    keys: group,\r\n                    values: [values],\r\n                    datum: [datum],\r\n                    validScopes,\r\n                });\r\n            }\r\n        }\r\n        const resultData = new Array(processedData.size);\r\n        const resultGroups = new Array(processedData.size);\r\n        let dataIndex = 0;\r\n        for (const [, { keys, values, datum, validScopes }] of processedData.entries()) {\r\n            if ((validScopes === null || validScopes === void 0 ? void 0 : validScopes.length) === 0)\r\n                continue;\r\n            resultGroups[dataIndex] = keys;\r\n            resultData[dataIndex++] = {\r\n                keys,\r\n                values,\r\n                datum,\r\n                validScopes,\r\n            };\r\n        }\r\n        return Object.assign(Object.assign({}, data), { type: 'grouped', data: resultData, domain: Object.assign(Object.assign({}, data.domain), { groups: resultGroups }) });\r\n    }\r\n    aggregateData(processedData) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h;\r\n        const { aggregates: aggDefs } = this;\r\n        if (!aggDefs)\r\n            return;\r\n        const resultAggValues = aggDefs.map(() => [Infinity, -Infinity]);\r\n        const resultAggValueIndices = aggDefs.map((def) => this.valueGroupIdxLookup(def));\r\n        const resultAggFns = aggDefs.map((def) => def.aggregateFunction);\r\n        const resultGroupAggFns = aggDefs.map((def) => def.groupAggregateFunction);\r\n        const resultFinalFns = aggDefs.map((def) => def.finalFunction);\r\n        for (const group of processedData.data) {\r\n            let { values } = group;\r\n            const { validScopes } = group;\r\n            (_a = group.aggValues) !== null && _a !== void 0 ? _a : (group.aggValues = new Array(resultAggValueIndices.length));\r\n            if (processedData.type === 'ungrouped') {\r\n                values = [values];\r\n            }\r\n            let resultIdx = 0;\r\n            for (const indices of resultAggValueIndices) {\r\n                const scopeValid = (_b = validScopes === null || validScopes === void 0 ? void 0 : validScopes.some((s) => { var _a; return (_a = aggDefs[resultIdx].matchScopes) === null || _a === void 0 ? void 0 : _a.some((as) => s === as); })) !== null && _b !== void 0 ? _b : true;\r\n                if (!scopeValid) {\r\n                    resultIdx++;\r\n                    continue;\r\n                }\r\n                let groupAggValues = (_d = (_c = resultGroupAggFns[resultIdx]) === null || _c === void 0 ? void 0 : _c.call(resultGroupAggFns)) !== null && _d !== void 0 ? _d : extendDomain([]);\r\n                for (const distinctValues of values) {\r\n                    const valuesToAgg = indices.map((valueIdx) => distinctValues[valueIdx]);\r\n                    const valuesAgg = resultAggFns[resultIdx](valuesToAgg, group.keys);\r\n                    if (valuesAgg) {\r\n                        groupAggValues =\r\n                            (_f = (_e = resultGroupAggFns[resultIdx]) === null || _e === void 0 ? void 0 : _e.call(resultGroupAggFns, valuesAgg, groupAggValues)) !== null && _f !== void 0 ? _f : extendDomain(valuesAgg, groupAggValues);\r\n                    }\r\n                }\r\n                const finalValues = ((_h = (_g = resultFinalFns[resultIdx]) === null || _g === void 0 ? void 0 : _g.call(resultFinalFns, groupAggValues)) !== null && _h !== void 0 ? _h : groupAggValues).map((v) => round(v));\r\n                extendDomain(finalValues, resultAggValues[resultIdx]);\r\n                group.aggValues[resultIdx++] = finalValues;\r\n            }\r\n        }\r\n        processedData.domain.aggValues = resultAggValues;\r\n    }\r\n    postProcessGroups(processedData) {\r\n        var _a, _b, _c, _d, _e;\r\n        const { groupProcessors } = this;\r\n        if (!groupProcessors)\r\n            return;\r\n        const affectedIndices = new Set();\r\n        const updatedDomains = new Map();\r\n        const groupProcessorIndices = new Map();\r\n        const groupProcessorInitFns = new Map();\r\n        for (const processor of groupProcessors) {\r\n            const indices = this.valueGroupIdxLookup(processor);\r\n            groupProcessorIndices.set(processor, indices);\r\n            groupProcessorInitFns.set(processor, processor.adjust());\r\n            for (const idx of indices) {\r\n                const valueDef = this.values[idx];\r\n                affectedIndices.add(idx);\r\n                updatedDomains.set(idx, new DataDomain(valueDef.valueType === 'category' ? 'discrete' : 'continuous'));\r\n            }\r\n        }\r\n        const updateDomains = (values) => {\r\n            var _a;\r\n            for (const valueIndex of affectedIndices) {\r\n                (_a = updatedDomains.get(valueIndex)) === null || _a === void 0 ? void 0 : _a.extend(values[valueIndex]);\r\n            }\r\n        };\r\n        for (const group of processedData.data) {\r\n            for (const processor of groupProcessors) {\r\n                const scopeValid = (_b = (_a = group.validScopes) === null || _a === void 0 ? void 0 : _a.some((s) => { var _a; return (_a = processor.matchScopes) === null || _a === void 0 ? void 0 : _a.some((as) => s === as); })) !== null && _b !== void 0 ? _b : true;\r\n                if (!scopeValid) {\r\n                    continue;\r\n                }\r\n                const valueIndexes = (_c = groupProcessorIndices.get(processor)) !== null && _c !== void 0 ? _c : [];\r\n                const adjustFn = (_e = (_d = groupProcessorInitFns.get(processor)) === null || _d === void 0 ? void 0 : _d()) !== null && _e !== void 0 ? _e : (() => undefined);\r\n                if (processedData.type === 'grouped') {\r\n                    for (const values of group.values) {\r\n                        if (values) {\r\n                            adjustFn(values, valueIndexes);\r\n                        }\r\n                    }\r\n                    continue;\r\n                }\r\n                if (group.values) {\r\n                    adjustFn(group.values, valueIndexes);\r\n                }\r\n            }\r\n            if (processedData.type === 'grouped') {\r\n                for (const values of group.values) {\r\n                    updateDomains(values);\r\n                }\r\n            }\r\n            else {\r\n                updateDomains(group.values);\r\n            }\r\n        }\r\n        for (const [idx, dataDomain] of updatedDomains) {\r\n            processedData.domain.values[idx] = [...dataDomain.getDomain()];\r\n        }\r\n    }\r\n    postProcessProperties(processedData) {\r\n        const { propertyProcessors } = this;\r\n        if (!propertyProcessors)\r\n            return;\r\n        for (const { adjust, property, scopes } of propertyProcessors) {\r\n            adjust()(processedData, this.valueIdxLookup(scopes !== null && scopes !== void 0 ? scopes : [], property));\r\n        }\r\n    }\r\n    reduceData(processedData) {\r\n        var _a, _b, _c;\r\n        const { reducers: reducerDefs } = this;\r\n        const scopes = reducerDefs.map((def) => def.scopes);\r\n        const reducers = reducerDefs.map((def) => def.reducer());\r\n        const accValues = reducerDefs.map((def) => def.initialValue);\r\n        for (const group of processedData.data) {\r\n            let reducerIndex = 0;\r\n            for (const reducer of reducers) {\r\n                const scopeValid = (_b = (_a = group.validScopes) === null || _a === void 0 ? void 0 : _a.some((s) => { var _a; return (_a = scopes[reducerIndex]) === null || _a === void 0 ? void 0 : _a.some((as) => s === as); })) !== null && _b !== void 0 ? _b : true;\r\n                if (!scopeValid) {\r\n                    reducerIndex++;\r\n                    continue;\r\n                }\r\n                accValues[reducerIndex] = reducer(accValues[reducerIndex], group);\r\n                reducerIndex++;\r\n            }\r\n        }\r\n        for (let accIdx = 0; accIdx < accValues.length; accIdx++) {\r\n            (_c = processedData.reduced) !== null && _c !== void 0 ? _c : (processedData.reduced = {});\r\n            processedData.reduced[reducerDefs[accIdx].property] = accValues[accIdx];\r\n        }\r\n    }\r\n    postProcessData(processedData) {\r\n        var _a;\r\n        const { processors: processorDefs } = this;\r\n        for (const def of processorDefs) {\r\n            (_a = processedData.reduced) !== null && _a !== void 0 ? _a : (processedData.reduced = {});\r\n            processedData.reduced[def.property] = def.calculate(processedData);\r\n        }\r\n    }\r\n    initDataDomainProcessor() {\r\n        var _a;\r\n        const { keys: keyDefs, values: valueDefs } = this;\r\n        const scopes = new Set();\r\n        for (const valueDef of valueDefs) {\r\n            for (const scope of (_a = valueDef.scopes) !== null && _a !== void 0 ? _a : []) {\r\n                scopes.add(scope);\r\n            }\r\n        }\r\n        const scopesCount = scopes.size;\r\n        const dataDomain = new Map();\r\n        const processorFns = new Map();\r\n        let allScopesHaveSameDefs = true;\r\n        const initDataDomainKey = (key, type, updateDataDomain = dataDomain) => {\r\n            var _a;\r\n            if (type === 'category') {\r\n                updateDataDomain.set(key, new DataDomain('discrete'));\r\n            }\r\n            else {\r\n                updateDataDomain.set(key, new DataDomain('continuous'));\r\n                allScopesHaveSameDefs && (allScopesHaveSameDefs = ((_a = key.scopes) !== null && _a !== void 0 ? _a : []).length === scopesCount);\r\n            }\r\n        };\r\n        const initDataDomain = () => {\r\n            keyDefs.forEach((def) => initDataDomainKey(def, def.valueType));\r\n            valueDefs.forEach((def) => initDataDomainKey(def, def.valueType));\r\n        };\r\n        initDataDomain();\r\n        const accessors = this.buildAccessors(...keyDefs, ...valueDefs);\r\n        const processValue = (def, datum, previousDatum) => {\r\n            var _a, _b, _c, _d;\r\n            const hasAccessor = def.property in accessors;\r\n            let valueInDatum = false;\r\n            let value;\r\n            if (hasAccessor) {\r\n                try {\r\n                    value = accessors[def.property](datum);\r\n                }\r\n                catch (error) {\r\n                    // Swallow errors - these get reported as missing values to the user later.\r\n                }\r\n                valueInDatum = value !== undefined;\r\n            }\r\n            else {\r\n                valueInDatum = def.property in datum;\r\n                value = valueInDatum ? datum[def.property] : def.missingValue;\r\n            }\r\n            if (def.forceValue != null) {\r\n                // Maintain sign of forceValue from actual value, this maybe significant later when\r\n                // we account fo the value falling into positive/negative buckets.\r\n                const valueNegative = valueInDatum && isNegative(value);\r\n                value = valueNegative ? -1 * def.forceValue : def.forceValue;\r\n                valueInDatum = true;\r\n            }\r\n            const missingValueDef = 'missingValue' in def;\r\n            if (!valueInDatum && !missingValueDef) {\r\n                def.missing++;\r\n            }\r\n            if (!dataDomain.has(def)) {\r\n                initDataDomain();\r\n            }\r\n            if (valueInDatum) {\r\n                const valid = (_b = (_a = def.validation) === null || _a === void 0 ? void 0 : _a.call(def, value, datum)) !== null && _b !== void 0 ? _b : true;\r\n                if (!valid) {\r\n                    if ('invalidValue' in def) {\r\n                        value = def.invalidValue;\r\n                    }\r\n                    else {\r\n                        return INVALID_VALUE;\r\n                    }\r\n                }\r\n            }\r\n            if (def.processor) {\r\n                if (!processorFns.has(def)) {\r\n                    processorFns.set(def, def.processor());\r\n                }\r\n                value = (_c = processorFns.get(def)) === null || _c === void 0 ? void 0 : _c(value, previousDatum !== INVALID_VALUE ? previousDatum : undefined);\r\n            }\r\n            (_d = dataDomain.get(def)) === null || _d === void 0 ? void 0 : _d.extend(value);\r\n            return value;\r\n        };\r\n        return { dataDomain, processValue, initDataDomain, scopes, allScopesHaveSameDefs };\r\n    }\r\n    buildAccessors(...defs) {\r\n        const result = {};\r\n        if (this.mode === 'integrated')\r\n            return result;\r\n        for (const def of defs) {\r\n            const isPath = def.property.indexOf('.') >= 0 || def.property.indexOf('[') >= 0;\r\n            if (!isPath)\r\n                continue;\r\n            let fnBody;\r\n            if (def.property.startsWith('[')) {\r\n                fnBody = `return datum${def.property};`;\r\n            }\r\n            else {\r\n                fnBody = `return datum.${def.property};`;\r\n            }\r\n            result[def.property] = new Function('datum', fnBody);\r\n        }\r\n        return result;\r\n    }\r\n}\r\nfunction logProcessedData(processedData) {\r\n    var _a, _b;\r\n    const logValues = (name, data) => {\r\n        if (data.length > 0) {\r\n            Logger.log(`DataModel.processData() - ${name}`);\r\n            Logger.table(data);\r\n        }\r\n    };\r\n    Logger.log('DataModel.processData() - processedData', processedData);\r\n    logValues('Key Domains', processedData.domain.keys);\r\n    logValues('Group Domains', (_a = processedData.domain.groups) !== null && _a !== void 0 ? _a : []);\r\n    logValues('Value Domains', processedData.domain.values);\r\n    logValues('Aggregate Domains', (_b = processedData.domain.aggValues) !== null && _b !== void 0 ? _b : []);\r\n    if (processedData.type === 'grouped') {\r\n        const flattenedValues = processedData.data.reduce((acc, next) => {\r\n            var _a, _b;\r\n            const keys = (_a = next.keys) !== null && _a !== void 0 ? _a : [];\r\n            const aggValues = (_b = next.aggValues) !== null && _b !== void 0 ? _b : [];\r\n            const skipKeys = next.keys.map(() => undefined);\r\n            const skipAggValues = aggValues === null || aggValues === void 0 ? void 0 : aggValues.map(() => undefined);\r\n            acc.push(...next.values.map((v, i) => [\r\n                ...(i === 0 ? keys : skipKeys),\r\n                ...(v !== null && v !== void 0 ? v : []),\r\n                ...(i == 0 ? aggValues : skipAggValues),\r\n            ]));\r\n            return acc;\r\n        }, []);\r\n        logValues('Values', flattenedValues);\r\n    }\r\n    else {\r\n        const flattenedValues = processedData.data.reduce((acc, next) => {\r\n            var _a;\r\n            const aggValues = (_a = next.aggValues) !== null && _a !== void 0 ? _a : [];\r\n            acc.push([...next.keys, ...next.values, ...aggValues]);\r\n            return acc;\r\n        }, []);\r\n        logValues('Values', flattenedValues);\r\n    }\r\n}\n\n/** Implements cross-series data model coordination. */\r\nclass DataController {\r\n    constructor(mode) {\r\n        this.mode = mode;\r\n        this.debug = Debug.create(true, 'data-model');\r\n        this.requested = [];\r\n        this.status = 'setup';\r\n    }\r\n    request(id, data, opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.status !== 'setup')\r\n                throw new Error(`AG Charts - data request after data setup phase.`);\r\n            return new Promise((resolve, reject) => {\r\n                this.requested.push({\r\n                    id,\r\n                    opts,\r\n                    data,\r\n                    resultCb: resolve,\r\n                    reject,\r\n                });\r\n            });\r\n        });\r\n    }\r\n    execute() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.status !== 'setup')\r\n                throw new Error(`AG Charts - data request after data setup phase.`);\r\n            this.status = 'executed';\r\n            this.debug('DataController.execute() - requested', this.requested);\r\n            const merged = this.mergeRequested();\r\n            this.debug('DataController.execute() - merged', merged);\r\n            const debugMode = Debug.check(true, 'data-model');\r\n            if (debugMode) {\r\n                window.processedData = [];\r\n            }\r\n            for (const { opts, data, resultCbs, rejects, ids } of merged) {\r\n                try {\r\n                    const dataModel = new DataModel(Object.assign(Object.assign({}, opts), { mode: this.mode }));\r\n                    const processedData = dataModel.processData(data);\r\n                    if (debugMode) {\r\n                        window.processedData.push(processedData);\r\n                    }\r\n                    if (processedData && processedData.partialValidDataCount === 0) {\r\n                        resultCbs.forEach((cb) => cb({ dataModel, processedData }));\r\n                    }\r\n                    else if (processedData) {\r\n                        this.splitResult(dataModel, processedData, ids, resultCbs);\r\n                    }\r\n                    else {\r\n                        rejects.forEach((cb) => cb(new Error(`AG Charts - no processed data generated`)));\r\n                    }\r\n                }\r\n                catch (error) {\r\n                    rejects.forEach((cb) => cb(error));\r\n                }\r\n            }\r\n        });\r\n    }\r\n    mergeRequested() {\r\n        const grouped = [];\r\n        const keys = (props) => {\r\n            return props\r\n                .filter((p) => p.type === 'key')\r\n                .map((p) => p.property)\r\n                .join(';');\r\n        };\r\n        const groupMatch = ({ opts, data }) => (gr) => {\r\n            return (gr[0].data === data &&\r\n                gr[0].opts.groupByKeys === opts.groupByKeys &&\r\n                gr[0].opts.dataVisible === opts.dataVisible &&\r\n                gr[0].opts.groupByFn === opts.groupByFn &&\r\n                keys(gr[0].opts.props) === keys(opts.props));\r\n        };\r\n        const propMatch = (prop) => (existing) => {\r\n            var _a;\r\n            if (existing.type !== prop.type)\r\n                return false;\r\n            const diff = (_a = jsonDiff(existing, prop)) !== null && _a !== void 0 ? _a : {};\r\n            delete diff['scopes'];\r\n            delete diff['id'];\r\n            delete diff['ids'];\r\n            return Object.keys(diff).length === 0;\r\n        };\r\n        const mergeOpts = (opts) => {\r\n            return Object.assign(Object.assign({}, opts[0]), { props: opts.reduce((result, next) => {\r\n                    var _a, _b, _c, _d, _e, _f;\r\n                    for (const prop of next.props) {\r\n                        if (prop.id != null) {\r\n                            (_a = prop.ids) !== null && _a !== void 0 ? _a : (prop.ids = []);\r\n                            (_b = prop.scopes) === null || _b === void 0 ? void 0 : _b.forEach((scope) => { var _a; return (_a = prop.ids) === null || _a === void 0 ? void 0 : _a.push([scope, prop.id]); });\r\n                        }\r\n                        const match = result.find(propMatch(prop));\r\n                        if (!match) {\r\n                            result.push(prop);\r\n                            continue;\r\n                        }\r\n                        (_c = match.scopes) !== null && _c !== void 0 ? _c : (match.scopes = []);\r\n                        match.scopes.push(...((_d = prop.scopes) !== null && _d !== void 0 ? _d : []));\r\n                        if (match.type !== 'key' && match.type !== 'value')\r\n                            continue;\r\n                        (_e = match.ids) === null || _e === void 0 ? void 0 : _e.push(...((_f = prop.ids) !== null && _f !== void 0 ? _f : []));\r\n                    }\r\n                    return result;\r\n                }, []) });\r\n        };\r\n        const merge = (props) => {\r\n            return {\r\n                ids: props.map(({ id }) => id),\r\n                resultCbs: props.map(({ resultCb }) => resultCb),\r\n                rejects: props.map(({ reject }) => reject),\r\n                data: props[0].data,\r\n                opts: mergeOpts(props.map(({ opts }) => opts)),\r\n            };\r\n        };\r\n        for (const request of this.requested) {\r\n            const match = grouped.find(groupMatch(request));\r\n            if (match) {\r\n                match.push(request);\r\n            }\r\n            else {\r\n                grouped.push([request]);\r\n            }\r\n        }\r\n        return grouped.map(merge);\r\n    }\r\n    splitResult(dataModel, processedData, scopes, resultCbs) {\r\n        for (let index = 0; index < scopes.length; index++) {\r\n            const scope = scopes[index];\r\n            const resultCb = resultCbs[index];\r\n            resultCb({\r\n                dataModel,\r\n                processedData: Object.assign(Object.assign({}, processedData), { data: processedData.data.filter(({ validScopes }) => {\r\n                        return validScopes == null || validScopes.some((s) => s === scope);\r\n                    }) }),\r\n            });\r\n        }\r\n    }\r\n}\n\nclass DataService {\r\n    constructor(getSeries) {\r\n        this.getSeries = getSeries;\r\n    }\r\n}\n\nclass BaseManager {\r\n    constructor() {\r\n        this.listeners = new Listeners();\r\n    }\r\n    addListener(type, handler, meta) {\r\n        return this.listeners.addListener(type, handler, meta);\r\n    }\r\n    removeListener(listenerSymbol) {\r\n        this.listeners.removeListener(listenerSymbol);\r\n    }\r\n}\n\nconst DEBUG_SELECTORS = [true, 'animation'];\r\n/**\r\n * Manage animations across a chart, running all animations through only one `requestAnimationFrame` callback,\r\n * preventing duplicate animations and handling their lifecycle.\r\n */\r\nclass AnimationManager extends BaseManager {\r\n    constructor(interactionManager, chartUpdateMutex) {\r\n        super();\r\n        this.interactionManager = interactionManager;\r\n        this.chartUpdateMutex = chartUpdateMutex;\r\n        this.defaultDuration = 1000;\r\n        this.batch = new AnimationBatch();\r\n        this.debug = Debug.create(...DEBUG_SELECTORS);\r\n        this.isPlaying = false;\r\n        this.requestId = null;\r\n        this.skipAnimations = false;\r\n    }\r\n    /**\r\n     * Create an animation to tween a value between the `from` and `to` properties. If an animation already exists\r\n     * with the same `id`, immediately stop it.\r\n     */\r\n    animate(_a) {\r\n        var _b, _c;\r\n        var { disableInteractions = true, immutable = true } = _a, opts = __rest(_a, [\"disableInteractions\", \"immutable\"]);\r\n        const { batch } = this;\r\n        try {\r\n            if (opts.id != null && batch.controllers.has(opts.id)) {\r\n                if (!immutable) {\r\n                    return batch.controllers.get(opts.id).reset(opts);\r\n                }\r\n                batch.controllers.get(opts.id).stop();\r\n                this.debug(`Skipping animation batch due to update of existing animation: ${opts.id}`);\r\n                this.batch.skip();\r\n            }\r\n        }\r\n        catch (error) {\r\n            this.failsafeOnError(error);\r\n            return;\r\n        }\r\n        const id = (_b = opts.id) !== null && _b !== void 0 ? _b : Math.random().toString();\r\n        const skip = this.isSkipped();\r\n        if (skip) {\r\n            this.debug('AnimationManager - skipping animation');\r\n        }\r\n        return new Animation(Object.assign(Object.assign({}, opts), { id,\r\n            skip, autoplay: this.isPlaying ? opts.autoplay : false, duration: (_c = opts.duration) !== null && _c !== void 0 ? _c : this.defaultDuration, onPlay: (controller) => {\r\n                var _a;\r\n                batch.controllers.set(id, controller);\r\n                this.requestAnimation();\r\n                if (disableInteractions) {\r\n                    this.interactionManager.pause('animation');\r\n                }\r\n                (_a = opts.onPlay) === null || _a === void 0 ? void 0 : _a.call(controller, controller);\r\n            }, onStop: (controller) => {\r\n                var _a;\r\n                batch.controllers.delete(id);\r\n                if (disableInteractions) {\r\n                    this.interactionManager.resume('animation');\r\n                }\r\n                (_a = opts.onStop) === null || _a === void 0 ? void 0 : _a.call(controller, controller);\r\n            } }));\r\n    }\r\n    play() {\r\n        if (this.isPlaying) {\r\n            return;\r\n        }\r\n        this.isPlaying = true;\r\n        this.debug('AnimationManager.play()');\r\n        for (const controller of this.batch.controllers.values()) {\r\n            try {\r\n                controller.play();\r\n            }\r\n            catch (error) {\r\n                this.failsafeOnError(error);\r\n            }\r\n        }\r\n        this.requestAnimation();\r\n    }\r\n    pause() {\r\n        if (!this.isPlaying) {\r\n            return;\r\n        }\r\n        this.isPlaying = false;\r\n        this.cancelAnimation();\r\n        this.debug('AnimationManager.pause()');\r\n        for (const controller of this.batch.controllers.values()) {\r\n            try {\r\n                controller.pause();\r\n            }\r\n            catch (error) {\r\n                this.failsafeOnError(error);\r\n            }\r\n        }\r\n    }\r\n    stop() {\r\n        this.isPlaying = false;\r\n        this.cancelAnimation();\r\n        this.debug('AnimationManager.stop()');\r\n        for (const controller of this.batch.controllers.values()) {\r\n            try {\r\n                controller.stop();\r\n            }\r\n            catch (error) {\r\n                this.failsafeOnError(error, false);\r\n            }\r\n        }\r\n    }\r\n    stopByAnimationId(id) {\r\n        var _a;\r\n        try {\r\n            if (id != null && this.batch.controllers.has(id)) {\r\n                (_a = this.batch.controllers.get(id)) === null || _a === void 0 ? void 0 : _a.stop();\r\n            }\r\n        }\r\n        catch (error) {\r\n            this.failsafeOnError(error);\r\n            return;\r\n        }\r\n    }\r\n    stopByAnimationGroupId(id) {\r\n        for (const controller of this.batch.controllers.values()) {\r\n            if (controller.groupId === id) {\r\n                this.stopByAnimationId(controller.id);\r\n            }\r\n        }\r\n    }\r\n    reset() {\r\n        if (this.isPlaying) {\r\n            this.stop();\r\n            this.play();\r\n        }\r\n        else {\r\n            this.stop();\r\n        }\r\n    }\r\n    skip(skip = true) {\r\n        this.skipAnimations = skip;\r\n    }\r\n    isSkipped() {\r\n        return this.skipAnimations || this.batch.isSkipped();\r\n    }\r\n    isActive() {\r\n        return this.isPlaying && this.batch.isActive();\r\n    }\r\n    skipCurrentBatch() {\r\n        if (Debug.check(...DEBUG_SELECTORS)) {\r\n            this.debug(`AnimationManager - skipCurrentBatch()`, { stack: new Error().stack });\r\n        }\r\n        this.batch.skip();\r\n    }\r\n    /** Mocking point for tests to guarantee that animation updates happen. */\r\n    isSkippingFrames() {\r\n        return true;\r\n    }\r\n    /** Mocking point for tests to capture requestAnimationFrame callbacks. */\r\n    scheduleAnimationFrame(cb) {\r\n        this.requestId = requestAnimationFrame(cb);\r\n    }\r\n    requestAnimation() {\r\n        if (!this.batch.isActive() || this.requestId !== null)\r\n            return;\r\n        let prevTime;\r\n        const onAnimationFrame = (time) => __awaiter(this, void 0, void 0, function* () {\r\n            const executeAnimationFrame = () => __awaiter(this, void 0, void 0, function* () {\r\n                const deltaTime = time - (prevTime !== null && prevTime !== void 0 ? prevTime : time);\r\n                prevTime = time;\r\n                this.debug('AnimationManager - onAnimationFrame()', {\r\n                    controllersCount: this.batch.controllers.size,\r\n                });\r\n                for (const controller of this.batch.controllers.values()) {\r\n                    try {\r\n                        controller.update(deltaTime);\r\n                    }\r\n                    catch (error) {\r\n                        this.failsafeOnError(error);\r\n                    }\r\n                }\r\n                this.listeners.dispatch('animation-frame', {\r\n                    type: 'animation-frame',\r\n                    deltaMs: deltaTime,\r\n                });\r\n            });\r\n            if (this.isSkippingFrames()) {\r\n                // Only run the animation frame if we can acquire the chart update mutex immediately.\r\n                yield this.chartUpdateMutex.acquireImmediately(executeAnimationFrame);\r\n            }\r\n            else {\r\n                // Wait for the next available point we can execute.\r\n                yield this.chartUpdateMutex.acquire(executeAnimationFrame);\r\n            }\r\n            if (this.batch.isActive()) {\r\n                this.scheduleAnimationFrame(onAnimationFrame);\r\n            }\r\n        });\r\n        this.scheduleAnimationFrame(onAnimationFrame);\r\n    }\r\n    cancelAnimation() {\r\n        if (this.requestId === null)\r\n            return;\r\n        cancelAnimationFrame(this.requestId);\r\n        this.requestId = null;\r\n        this.startBatch();\r\n    }\r\n    failsafeOnError(error, cancelAnimation = true) {\r\n        Logger.error('Error during animation, skipping animations', error);\r\n        if (cancelAnimation) {\r\n            this.cancelAnimation();\r\n        }\r\n    }\r\n    startBatch(skipAnimations) {\r\n        this.debug(`AnimationManager - startBatch() with skipAnimations=${skipAnimations}.`);\r\n        this.reset();\r\n        this.batch.destroy();\r\n        this.batch = new AnimationBatch();\r\n        if (skipAnimations === true) {\r\n            this.batch.skip();\r\n        }\r\n    }\r\n    endBatch() {\r\n        this.debug(`AnimationManager - endBatch() with ${this.batch.controllers.size} animations; skipped: ${this.batch.isSkipped()}.`);\r\n        if (this.batch.isSkipped() && !this.batch.isActive()) {\r\n            this.batch.skip(false);\r\n        }\r\n    }\r\n}\r\n/**\r\n * A batch of animations that are synchronised together. Can be skipped independently of other batches and the main\r\n * animation skipping status.\r\n */\r\nclass AnimationBatch {\r\n    constructor() {\r\n        this.controllers = new Map();\r\n        this.skipAnimations = false;\r\n    }\r\n    // private phase?: 'initial-load' | 'remove' | 'update' | 'add';\r\n    isActive() {\r\n        return this.controllers.size > 0;\r\n    }\r\n    skip(skip = true) {\r\n        if (this.skipAnimations === false && skip === true) {\r\n            for (const controller of this.controllers.values()) {\r\n                controller.stop();\r\n            }\r\n            this.controllers.clear();\r\n        }\r\n        this.skipAnimations = skip;\r\n    }\r\n    isSkipped() {\r\n        return this.skipAnimations;\r\n    }\r\n    destroy() { }\r\n}\n\nclass ChartEventManager extends BaseManager {\r\n    legendItemClick(series, itemId, enabled, legendItemName) {\r\n        const event = {\r\n            type: 'legend-item-click',\r\n            series,\r\n            itemId,\r\n            enabled,\r\n            legendItemName,\r\n        };\r\n        this.listeners.dispatch('legend-item-click', event);\r\n    }\r\n    legendItemDoubleClick(series, itemId, enabled, numVisibleItems, legendItemName) {\r\n        const event = {\r\n            type: 'legend-item-double-click',\r\n            series,\r\n            itemId,\r\n            enabled,\r\n            legendItemName,\r\n            numVisibleItems,\r\n        };\r\n        this.listeners.dispatch('legend-item-double-click', event);\r\n    }\r\n    axisHover(axisId, direction) {\r\n        const event = {\r\n            type: 'axis-hover',\r\n            axisId,\r\n            direction,\r\n        };\r\n        this.listeners.dispatch('axis-hover', event);\r\n    }\r\n}\n\n/**\r\n * Manages the cursor styling for an element. Tracks the requested styling from distinct\r\n * dependents and handles conflicting styling requests.\r\n */\r\nclass CursorManager {\r\n    constructor(element) {\r\n        this.states = {};\r\n        this.element = element;\r\n    }\r\n    updateCursor(callerId, style) {\r\n        delete this.states[callerId];\r\n        if (style != null) {\r\n            this.states[callerId] = { style };\r\n        }\r\n        this.applyStates();\r\n    }\r\n    applyStates() {\r\n        let styleToApply = 'default';\r\n        // Last added entry wins.\r\n        Object.entries(this.states)\r\n            .reverse()\r\n            .slice(0, 1)\r\n            .forEach(([_, { style }]) => (styleToApply = style));\r\n        this.element.style.cursor = styleToApply;\r\n    }\r\n    getCursor() {\r\n        return this.element.style.cursor;\r\n    }\r\n}\n\n/**\r\n * Manages the actively highlighted series/datum for a chart. Tracks the requested highlights from\r\n * distinct dependents and handles conflicting highlight requests.\r\n */\r\nclass HighlightManager extends BaseManager {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.highlightStates = new Map();\r\n        this.pickedStates = new Map();\r\n    }\r\n    updateHighlight(callerId, highlightedDatum) {\r\n        this.highlightStates.delete(callerId);\r\n        if (highlightedDatum != null) {\r\n            this.highlightStates.set(callerId, highlightedDatum);\r\n        }\r\n        this.applyHighlightStates();\r\n    }\r\n    getActiveHighlight() {\r\n        return this.activeHighlight;\r\n    }\r\n    updatePicked(callerId, clickableDatum) {\r\n        this.pickedStates.delete(callerId);\r\n        if (clickableDatum != null) {\r\n            this.pickedStates.set(callerId, clickableDatum);\r\n        }\r\n        this.applyPickedStates();\r\n    }\r\n    getActivePicked() {\r\n        return this.activePicked;\r\n    }\r\n    applyHighlightStates() {\r\n        // Last added entry wins.\r\n        const { activeHighlight: previousHighlight } = this;\r\n        this.activeHighlight = Array.from(this.highlightStates.values()).pop();\r\n        if (!this.isEqual(this.activeHighlight, previousHighlight)) {\r\n            this.listeners.dispatch('highlight-change', {\r\n                type: 'highlight-change',\r\n                currentHighlight: this.activeHighlight,\r\n                previousHighlight,\r\n            });\r\n        }\r\n    }\r\n    applyPickedStates() {\r\n        this.activePicked = Array.from(this.pickedStates.values()).pop();\r\n    }\r\n    isEqual(a, b) {\r\n        return a === b || ((a === null || a === void 0 ? void 0 : a.series) === (b === null || b === void 0 ? void 0 : b.series) && (a === null || a === void 0 ? void 0 : a.itemId) === (b === null || b === void 0 ? void 0 : b.itemId) && (a === null || a === void 0 ? void 0 : a.datum) === (b === null || b === void 0 ? void 0 : b.datum));\r\n    }\r\n}\n\nconst WINDOW_EVENT_HANDLERS = ['pagehide', 'mousemove', 'mouseup'];\r\nconst EVENT_HANDLERS = [\r\n    'click',\r\n    'dblclick',\r\n    'contextmenu',\r\n    'mousedown',\r\n    'mouseout',\r\n    'mouseenter',\r\n    'touchstart',\r\n    'touchmove',\r\n    'touchend',\r\n    'touchcancel',\r\n    'wheel',\r\n];\r\nconst CSS = `\n.ag-chart-wrapper {\n    touch-action: none;\n}\n`;\r\n/**\r\n * Manages user interactions with a specific HTMLElement (or interactions that bubble from it's\r\n * children)\r\n */\r\nclass InteractionManager extends BaseManager {\r\n    constructor(element, document, window) {\r\n        super();\r\n        this.eventHandler = (event) => this.processEvent(event);\r\n        this.mouseDown = false;\r\n        this.touchDown = false;\r\n        this.pausers = { animation: 0, 'context-menu': 0 };\r\n        this.rootElement = document.body;\r\n        this.element = element;\r\n        this.window = window;\r\n        for (const type of EVENT_HANDLERS) {\r\n            if (type.startsWith('touch')) {\r\n                element.addEventListener(type, this.eventHandler, { passive: true });\r\n            }\r\n            else if (type === 'wheel') {\r\n                element.addEventListener(type, this.eventHandler, { passive: false });\r\n            }\r\n            else {\r\n                element.addEventListener(type, this.eventHandler);\r\n            }\r\n        }\r\n        for (const type of WINDOW_EVENT_HANDLERS) {\r\n            this.window.addEventListener(type, this.eventHandler);\r\n        }\r\n        if (!InteractionManager.interactionDocuments.includes(document)) {\r\n            injectStyle(document, CSS);\r\n            InteractionManager.interactionDocuments.push(document);\r\n        }\r\n    }\r\n    destroy() {\r\n        for (const type of WINDOW_EVENT_HANDLERS) {\r\n            this.window.removeEventListener(type, this.eventHandler);\r\n        }\r\n        for (const type of EVENT_HANDLERS) {\r\n            this.element.removeEventListener(type, this.eventHandler);\r\n        }\r\n    }\r\n    resume(pauseType) {\r\n        this.pausers[pauseType]--;\r\n    }\r\n    pause(pauseType) {\r\n        this.pausers[pauseType]++;\r\n    }\r\n    processEvent(event) {\r\n        const types = this.decideInteractionEventTypes(event);\r\n        if (types.length > 0) {\r\n            // Async dispatch to avoid blocking the event-processing thread.\r\n            this.dispatchEvent(event, types).catch((e) => Logger.errorOnce(e));\r\n        }\r\n    }\r\n    dispatchEvent(event, types) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const coords = this.calculateCoordinates(event);\r\n            if (coords == null) {\r\n                return;\r\n            }\r\n            const pauses = Object.entries(this.pausers)\r\n                .filter(([, count]) => count > 0)\r\n                .map(([pause]) => pause);\r\n            for (const type of types) {\r\n                this.listeners.dispatchWrapHandlers(type, (handler, meta, interactionEvent) => {\r\n                    var _a;\r\n                    if (pauses.length > 0 && !((_a = meta === null || meta === void 0 ? void 0 : meta.bypassPause) === null || _a === void 0 ? void 0 : _a.some((p) => pauses.includes(p)))) {\r\n                        return;\r\n                    }\r\n                    if (!interactionEvent.consumed) {\r\n                        handler(interactionEvent);\r\n                    }\r\n                }, this.buildEvent(Object.assign({ type, event, pauses }, coords)));\r\n            }\r\n        });\r\n    }\r\n    decideInteractionEventTypes(event) {\r\n        const dragStart = 'drag-start';\r\n        switch (event.type) {\r\n            case 'click':\r\n                return ['click'];\r\n            case 'dblclick':\r\n                return ['dblclick'];\r\n            case 'contextmenu':\r\n                return ['contextmenu'];\r\n            case 'mousedown':\r\n                this.mouseDown = true;\r\n                this.dragStartElement = event.target;\r\n                return [dragStart];\r\n            case 'touchstart':\r\n                this.touchDown = true;\r\n                this.dragStartElement = event.target;\r\n                return [dragStart];\r\n            case 'touchmove':\r\n            case 'mousemove':\r\n                if (!this.mouseDown && !this.touchDown && !this.isEventOverElement(event)) {\r\n                    // We only care about these events if the target is the canvas, unless\r\n                    // we're in the middle of a drag/slide.\r\n                    return [];\r\n                }\r\n                return this.mouseDown || this.touchDown ? ['drag'] : ['hover'];\r\n            case 'mouseup':\r\n                if (!this.mouseDown && !this.isEventOverElement(event)) {\r\n                    // We only care about these events if the target is the canvas, unless\r\n                    // we're in the middle of a drag.\r\n                    return [];\r\n                }\r\n                this.mouseDown = false;\r\n                this.dragStartElement = undefined;\r\n                return ['drag-end'];\r\n            case 'touchend':\r\n                if (!this.touchDown && !this.isEventOverElement(event)) {\r\n                    // We only care about these events if the target is the canvas, unless\r\n                    // we're in the middle of a slide.\r\n                    return [];\r\n                }\r\n                this.touchDown = false;\r\n                this.dragStartElement = undefined;\r\n                return ['drag-end'];\r\n            case 'mouseout':\r\n            case 'touchcancel':\r\n                return ['leave'];\r\n            case 'mouseenter':\r\n                const mouseButtonDown = event instanceof MouseEvent && (event.buttons & 1) === 1;\r\n                if (this.mouseDown !== mouseButtonDown) {\r\n                    this.mouseDown = mouseButtonDown;\r\n                    return [mouseButtonDown ? dragStart : 'drag-end'];\r\n                }\r\n                return [];\r\n            case 'pagehide':\r\n                return ['page-left'];\r\n            case 'wheel':\r\n                return ['wheel'];\r\n        }\r\n        return [];\r\n    }\r\n    isEventOverElement(event) {\r\n        var _a;\r\n        return event.target === this.element || ((_a = event.target) === null || _a === void 0 ? void 0 : _a.parentElement) === this.element;\r\n    }\r\n    calculateCoordinates(event) {\r\n        var _a;\r\n        if (event instanceof MouseEvent) {\r\n            const { clientX, clientY, pageX, pageY, offsetX, offsetY } = event;\r\n            return this.fixOffsets(event, { clientX, clientY, pageX, pageY, offsetX, offsetY });\r\n        }\r\n        else if (typeof TouchEvent !== 'undefined' && event instanceof TouchEvent) {\r\n            const lastTouch = (_a = event.touches[0]) !== null && _a !== void 0 ? _a : event.changedTouches[0];\r\n            const { clientX, clientY, pageX, pageY } = lastTouch;\r\n            return Object.assign(Object.assign({}, InteractionManager.NULL_COORDS), { clientX, clientY, pageX, pageY });\r\n        }\r\n        else if (event instanceof PageTransitionEvent) {\r\n            if (event.persisted) {\r\n                // Don't fire the page-left event since the page maybe revisited.\r\n                return;\r\n            }\r\n            return InteractionManager.NULL_COORDS;\r\n        }\r\n        // Unsupported event - abort.\r\n    }\r\n    fixOffsets(event, coords) {\r\n        const offsets = (el) => {\r\n            let x = 0;\r\n            let y = 0;\r\n            while (el) {\r\n                x += el.offsetLeft;\r\n                y += el.offsetTop;\r\n                el = el.offsetParent;\r\n            }\r\n            return { x, y };\r\n        };\r\n        if (this.dragStartElement != null && event.target !== this.dragStartElement) {\r\n            // Offsets need to be relative to the drag-start element to avoid jumps when\r\n            // the pointer moves between element boundaries.\r\n            const offsetDragStart = offsets(this.dragStartElement);\r\n            const offsetEvent = offsets(event.target);\r\n            coords.offsetX -= offsetDragStart.x - offsetEvent.x;\r\n            coords.offsetY -= offsetDragStart.y - offsetEvent.y;\r\n        }\r\n        return coords;\r\n    }\r\n    buildEvent(opts) {\r\n        const { type, event, clientX, clientY, pauses } = opts;\r\n        let { offsetX, offsetY, pageX, pageY } = opts;\r\n        if (!isNumber(offsetX) || !isNumber(offsetY)) {\r\n            const rect = this.element.getBoundingClientRect();\r\n            offsetX = clientX - rect.left;\r\n            offsetY = clientY - rect.top;\r\n        }\r\n        if (!isNumber(pageX) || !isNumber(pageY)) {\r\n            const pageRect = this.rootElement.getBoundingClientRect();\r\n            pageX = clientX - pageRect.left;\r\n            pageY = clientY - pageRect.top;\r\n        }\r\n        const builtEvent = {\r\n            type,\r\n            offsetX: offsetX,\r\n            offsetY: offsetY,\r\n            pageX: pageX,\r\n            pageY: pageY,\r\n            sourceEvent: event,\r\n            consumed: false,\r\n            pauses,\r\n            consume() {\r\n                builtEvent.consumed = true;\r\n            },\r\n        };\r\n        return builtEvent;\r\n    }\r\n}\r\nInteractionManager.interactionDocuments = [];\r\nInteractionManager.NULL_COORDS = {\r\n    clientX: -Infinity,\r\n    clientY: -Infinity,\r\n    pageX: -Infinity,\r\n    pageY: -Infinity,\r\n    offsetX: -Infinity,\r\n    offsetY: -Infinity,\r\n};\n\n/**\r\n * Manages the tooltip HTML an element. Tracks the requested HTML from distinct dependents and\r\n * handles conflicting tooltip requests.\r\n */\r\nclass TooltipManager {\r\n    constructor(tooltip, interactionManager) {\r\n        this.states = {};\r\n        this.exclusiveAreas = {};\r\n        this.destroyFns = [];\r\n        this.tooltip = tooltip;\r\n        this.destroyFns.push(interactionManager.addListener('hover', (e) => this.checkExclusiveRects(e)));\r\n    }\r\n    getRange() {\r\n        return this.tooltip.range;\r\n    }\r\n    updateTooltip(callerId, meta, content) {\r\n        var _a;\r\n        if (content == null) {\r\n            content = (_a = this.states[callerId]) === null || _a === void 0 ? void 0 : _a.content;\r\n        }\r\n        this.states[callerId] = { content, meta };\r\n        this.applyStates();\r\n    }\r\n    updateExclusiveRect(callerId, area) {\r\n        if (area) {\r\n            this.exclusiveAreas[callerId] = area;\r\n        }\r\n        else {\r\n            delete this.exclusiveAreas[callerId];\r\n        }\r\n    }\r\n    removeTooltip(callerId) {\r\n        delete this.states[callerId];\r\n        this.applyStates();\r\n    }\r\n    getTooltipMeta(callerId) {\r\n        var _a;\r\n        return (_a = this.states[callerId]) === null || _a === void 0 ? void 0 : _a.meta;\r\n    }\r\n    destroy() {\r\n        for (const destroyFn of this.destroyFns) {\r\n            destroyFn();\r\n        }\r\n    }\r\n    checkExclusiveRects(e) {\r\n        let newAppliedExclusiveArea;\r\n        for (const [entryId, area] of Object.entries(this.exclusiveAreas)) {\r\n            if (!area.containsPoint(e.offsetX, e.offsetY)) {\r\n                continue;\r\n            }\r\n            newAppliedExclusiveArea = entryId;\r\n            break;\r\n        }\r\n        if (newAppliedExclusiveArea === this.appliedExclusiveArea) {\r\n            return;\r\n        }\r\n        this.appliedExclusiveArea = newAppliedExclusiveArea;\r\n        this.applyStates();\r\n    }\r\n    applyStates() {\r\n        var _a;\r\n        const ids = this.appliedExclusiveArea ? [this.appliedExclusiveArea] : Object.keys(this.states);\r\n        let contentToApply;\r\n        let metaToApply;\r\n        // Last added entry wins.\r\n        ids.reverse();\r\n        ids.slice(0, 1).forEach((id) => {\r\n            var _a;\r\n            const { content, meta } = (_a = this.states[id]) !== null && _a !== void 0 ? _a : {};\r\n            contentToApply = content;\r\n            metaToApply = meta;\r\n        });\r\n        if (metaToApply === undefined || contentToApply === undefined) {\r\n            this.appliedState = undefined;\r\n            this.tooltip.toggle(false);\r\n            return;\r\n        }\r\n        if (((_a = this.appliedState) === null || _a === void 0 ? void 0 : _a.content) === contentToApply) {\r\n            const renderInstantly = this.tooltip.isVisible();\r\n            this.tooltip.show(metaToApply, undefined, renderInstantly);\r\n        }\r\n        else {\r\n            this.tooltip.show(metaToApply, contentToApply);\r\n        }\r\n        this.appliedState = { content: contentToApply, meta: metaToApply };\r\n    }\r\n    static makeTooltipMeta(event, canvas, datum, window) {\r\n        var _a, _b, _c, _d;\r\n        const { pageX, pageY, offsetX, offsetY } = event;\r\n        const position = {\r\n            xOffset: datum.series.tooltip.position.xOffset,\r\n            yOffset: datum.series.tooltip.position.yOffset,\r\n        };\r\n        const meta = {\r\n            pageX,\r\n            pageY,\r\n            offsetX,\r\n            offsetY,\r\n            event: event,\r\n            showArrow: datum.series.tooltip.showArrow,\r\n            position,\r\n        };\r\n        // On line and scatter series, the tooltip covers the top of errorbars when using\r\n        // datum.midPoint. Using datum.yBar.upperPoint renders the tooltip higher up.\r\n        const refPoint = (_b = (_a = datum.yBar) === null || _a === void 0 ? void 0 : _a.upperPoint) !== null && _b !== void 0 ? _b : datum.midPoint;\r\n        if (datum.series.tooltip.position.type === 'node' && refPoint) {\r\n            const { x, y } = refPoint;\r\n            const point = datum.series.contentGroup.inverseTransformPoint(x, y);\r\n            const canvasRect = canvas.element.getBoundingClientRect();\r\n            return Object.assign(Object.assign({}, meta), { pageX: Math.round(canvasRect.left + window.scrollX + point.x), pageY: Math.round(canvasRect.top + window.scrollY + point.y), offsetX: Math.round(point.x), offsetY: Math.round(point.y) });\r\n        }\r\n        meta.enableInteraction = (_d = (_c = datum.series.tooltip.interaction) === null || _c === void 0 ? void 0 : _c.enabled) !== null && _d !== void 0 ? _d : false;\r\n        return meta;\r\n    }\r\n}\n\n/**\r\n * Manages the current zoom state for a chart. Tracks the requested zoom from distinct dependents\r\n * and handles conflicting zoom requests.\r\n */\r\nclass ZoomManager extends BaseManager {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.axes = {};\r\n    }\r\n    updateAxes(axes) {\r\n        var _a;\r\n        const removedAxes = new Set(Object.keys(this.axes));\r\n        axes.forEach((axis) => {\r\n            var _a;\r\n            var _b, _c;\r\n            removedAxes.delete(axis.id);\r\n            (_a = (_b = this.axes)[_c = axis.id]) !== null && _a !== void 0 ? _a : (_b[_c] = new AxisZoomManager(axis));\r\n        });\r\n        removedAxes.forEach((axisId) => {\r\n            delete this.axes[axisId];\r\n        });\r\n        if ((_a = this.initialZoom) === null || _a === void 0 ? void 0 : _a.newZoom) {\r\n            this.updateZoom(this.initialZoom.callerId, this.initialZoom.newZoom);\r\n        }\r\n        this.initialZoom = undefined;\r\n    }\r\n    updateZoom(callerId, newZoom) {\r\n        if (Object.keys(this.axes).length === 0) {\r\n            this.initialZoom = { callerId, newZoom };\r\n            return;\r\n        }\r\n        Object.values(this.axes).forEach((axis) => {\r\n            axis.updateZoom(callerId, newZoom === null || newZoom === void 0 ? void 0 : newZoom[axis.getDirection()]);\r\n        });\r\n        this.applyStates();\r\n    }\r\n    updateAxisZoom(callerId, axisId, newZoom) {\r\n        var _a;\r\n        (_a = this.axes[axisId]) === null || _a === void 0 ? void 0 : _a.updateZoom(callerId, newZoom);\r\n        this.applyStates();\r\n    }\r\n    getZoom() {\r\n        let x;\r\n        let y;\r\n        // TODO: this only works when there is a single axis on each direction as it gets the last of each\r\n        Object.values(this.axes).forEach((axis) => {\r\n            if (axis.getDirection() === ChartAxisDirection.X) {\r\n                x = axis.getZoom();\r\n            }\r\n            else if (axis.getDirection() === ChartAxisDirection.Y) {\r\n                y = axis.getZoom();\r\n            }\r\n        });\r\n        if (x || y) {\r\n            return { x, y };\r\n        }\r\n    }\r\n    getAxisZoom(axisId) {\r\n        var _a;\r\n        return (_a = this.axes[axisId]) === null || _a === void 0 ? void 0 : _a.getZoom();\r\n    }\r\n    getAxisZooms() {\r\n        const axes = {};\r\n        for (const [axisId, axis] of Object.entries(this.axes)) {\r\n            axes[axisId] = {\r\n                direction: axis.getDirection(),\r\n                zoom: axis.getZoom(),\r\n            };\r\n        }\r\n        return axes;\r\n    }\r\n    applyStates() {\r\n        const changed = Object.values(this.axes)\r\n            .map((axis) => axis.applyStates())\r\n            .some(Boolean);\r\n        if (!changed) {\r\n            return;\r\n        }\r\n        const currentZoom = this.getZoom();\r\n        const axes = {};\r\n        for (const [axisId, axis] of Object.entries(this.axes)) {\r\n            axes[axisId] = axis.getZoom();\r\n        }\r\n        this.listeners.dispatch('zoom-change', Object.assign(Object.assign({ type: 'zoom-change' }, (currentZoom !== null && currentZoom !== void 0 ? currentZoom : {})), { axes }));\r\n    }\r\n}\r\nclass AxisZoomManager {\r\n    constructor(axis) {\r\n        this.states = {};\r\n        this.axis = axis;\r\n        const [min = 0, max = 1] = axis.visibleRange;\r\n        this.currentZoom = { min, max };\r\n        this.states['__initial__'] = this.currentZoom;\r\n    }\r\n    getDirection() {\r\n        return this.axis.direction;\r\n    }\r\n    updateZoom(callerId, newZoom) {\r\n        delete this.states[callerId];\r\n        if (newZoom != null) {\r\n            this.states[callerId] = Object.assign({}, newZoom);\r\n        }\r\n    }\r\n    getZoom() {\r\n        return this.currentZoom;\r\n    }\r\n    applyStates() {\r\n        var _a, _b;\r\n        const prevZoom = this.currentZoom;\r\n        const last = Object.keys(this.states)[Object.keys(this.states).length - 1];\r\n        this.currentZoom = Object.assign({}, this.states[last]);\r\n        return (prevZoom === null || prevZoom === void 0 ? void 0 : prevZoom.min) !== ((_a = this.currentZoom) === null || _a === void 0 ? void 0 : _a.min) || (prevZoom === null || prevZoom === void 0 ? void 0 : prevZoom.max) !== ((_b = this.currentZoom) === null || _b === void 0 ? void 0 : _b.max);\r\n    }\r\n}\n\nclass LayoutService extends Listeners {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.layoutComplete = 'layout-complete';\r\n    }\r\n    addListener(eventType, handler) {\r\n        if (this.isLayoutStage(eventType) || this.isLayoutComplete(eventType)) {\r\n            return super.addListener(eventType, handler);\r\n        }\r\n        throw new Error(`AG Charts - unsupported listener type: ${eventType}`);\r\n    }\r\n    dispatchPerformLayout(stage, ctx) {\r\n        if (this.isLayoutStage(stage)) {\r\n            return this.getListenersByType(stage).reduce((result, listener) => {\r\n                try {\r\n                    return listener.handler(result);\r\n                }\r\n                catch (e) {\r\n                    Logger.errorOnce(e);\r\n                    return result;\r\n                }\r\n            }, ctx);\r\n        }\r\n        return ctx;\r\n    }\r\n    dispatchLayoutComplete(event) {\r\n        this.dispatch(this.layoutComplete, event);\r\n    }\r\n    isLayoutStage(eventType) {\r\n        return eventType !== this.layoutComplete;\r\n    }\r\n    isLayoutComplete(eventType) {\r\n        return eventType === this.layoutComplete;\r\n    }\r\n}\n\nfunction gridLayout({ orientation, bboxes, maxHeight, maxWidth, itemPaddingY = 0, itemPaddingX = 0, forceResult = false, }) {\r\n    const horizontal = orientation === 'horizontal';\r\n    const primary = {\r\n        max: horizontal ? maxWidth : maxHeight,\r\n        fn: horizontal ? (b) => b.width : (b) => b.height,\r\n        padding: horizontal ? itemPaddingX : itemPaddingY,\r\n    };\r\n    const secondary = {\r\n        max: !horizontal ? maxWidth : maxHeight,\r\n        fn: !horizontal ? (b) => b.width : (b) => b.height,\r\n        padding: !horizontal ? itemPaddingX : itemPaddingY,\r\n    };\r\n    let processedBBoxCount = 0;\r\n    const rawPages = [];\r\n    while (processedBBoxCount < bboxes.length) {\r\n        const unprocessedBBoxes = bboxes.slice(processedBBoxCount);\r\n        const result = processBBoxes(unprocessedBBoxes, processedBBoxCount, primary, secondary, forceResult);\r\n        if (!result) {\r\n            return;\r\n        }\r\n        processedBBoxCount += result.processedBBoxCount;\r\n        rawPages.push(result.pageIndices);\r\n    }\r\n    return buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX);\r\n}\r\nfunction processBBoxes(bboxes, indexOffset, primary, secondary, forceResult) {\r\n    // If calculatePage() fails on the first guess, we could use the number of items that fit\r\n    // as a good guess for the next iteration.\r\n    const minGuess = 1;\r\n    let startingGuess = estimateStartingGuess(bboxes, primary);\r\n    if (startingGuess < minGuess) {\r\n        if (!forceResult) {\r\n            return undefined;\r\n        }\r\n        // Legend constraints too small! Display at least one row/column if forceResult is true\r\n        startingGuess = minGuess;\r\n    }\r\n    for (let guess = startingGuess; guess >= minGuess; guess--) {\r\n        const pageIndices = calculatePage(bboxes, indexOffset, guess, primary, secondary, forceResult);\r\n        if (pageIndices == null && guess <= minGuess) {\r\n            // Can't layout!\r\n            return undefined;\r\n        }\r\n        if (pageIndices == null) {\r\n            // Guess again!\r\n            continue;\r\n        }\r\n        if (typeof pageIndices === 'number') {\r\n            // calculatePage() suggested a better guess, use that if it's more than minGuess.\r\n            if (pageIndices <= minGuess) {\r\n                // Can't layout!\r\n                return undefined;\r\n            }\r\n            guess = pageIndices < guess && pageIndices > minGuess ? pageIndices : guess;\r\n            continue;\r\n        }\r\n        const processedBBoxCount = pageIndices.length * pageIndices[0].length; // this is an estimate, not all rows/columns will have the same length\r\n        return { processedBBoxCount, pageIndices };\r\n    }\r\n}\r\nfunction calculatePage(bboxes, indexOffset, primaryCount, primary, secondary, forceResult) {\r\n    var _a;\r\n    const result = [];\r\n    let sumSecondary = 0;\r\n    let currentMaxSecondary = 0;\r\n    let currentPrimaryIndices = [];\r\n    const maxPrimaryValues = [];\r\n    for (let bboxIndex = 0; bboxIndex < bboxes.length; bboxIndex++) {\r\n        const primaryValueIdx = (bboxIndex + primaryCount) % primaryCount;\r\n        if (primaryValueIdx === 0) {\r\n            sumSecondary += currentMaxSecondary;\r\n            currentMaxSecondary = 0;\r\n            if (currentPrimaryIndices.length > 0) {\r\n                result.push(currentPrimaryIndices);\r\n            }\r\n            currentPrimaryIndices = [];\r\n        }\r\n        const primaryValue = primary.fn(bboxes[bboxIndex]) + primary.padding;\r\n        maxPrimaryValues[primaryValueIdx] = Math.max((_a = maxPrimaryValues[primaryValueIdx]) !== null && _a !== void 0 ? _a : 0, primaryValue);\r\n        currentMaxSecondary = Math.max(currentMaxSecondary, secondary.fn(bboxes[bboxIndex]) + secondary.padding);\r\n        const currentSecondaryDimension = sumSecondary + currentMaxSecondary;\r\n        const returnResult = !forceResult || result.length > 0;\r\n        if (currentSecondaryDimension > secondary.max && returnResult) {\r\n            // Breached max secondary dimension size, return indices accumlated so far (but not in-progress row/column).\r\n            currentPrimaryIndices = [];\r\n            break;\r\n        }\r\n        const sumPrimary = maxPrimaryValues.reduce((sum, next) => sum + next, 0);\r\n        if (sumPrimary > primary.max && !forceResult) {\r\n            // Breached max main dimension size.\r\n            if (maxPrimaryValues.length < primaryCount) {\r\n                // Feedback as guess for next iteration if we're on the first round still.\r\n                return maxPrimaryValues.length;\r\n            }\r\n            return undefined;\r\n        }\r\n        currentPrimaryIndices.push(bboxIndex + indexOffset);\r\n    }\r\n    if (currentPrimaryIndices.length > 0) {\r\n        result.push(currentPrimaryIndices);\r\n    }\r\n    return result.length > 0 ? result : undefined;\r\n}\r\nfunction buildPages(rawPages, orientation, bboxes, itemPaddingY, itemPaddingX) {\r\n    let maxPageWidth = 0;\r\n    let maxPageHeight = 0;\r\n    const pages = rawPages.map((indices) => {\r\n        if (orientation === 'horizontal') {\r\n            indices = transpose(indices);\r\n        }\r\n        let endIndex = 0;\r\n        const columns = indices.map((colIndices) => {\r\n            const colBBoxes = colIndices.map((bboxIndex) => {\r\n                endIndex = Math.max(bboxIndex, endIndex);\r\n                return bboxes[bboxIndex];\r\n            });\r\n            let columnHeight = 0;\r\n            let columnWidth = 0;\r\n            colBBoxes.forEach((bbox) => {\r\n                columnHeight += bbox.height + itemPaddingY;\r\n                columnWidth = Math.max(columnWidth, bbox.width + itemPaddingX);\r\n            });\r\n            return {\r\n                indices: colIndices,\r\n                bboxes: colBBoxes,\r\n                columnHeight: Math.ceil(columnHeight),\r\n                columnWidth: Math.ceil(columnWidth),\r\n            };\r\n        });\r\n        let pageWidth = 0;\r\n        let pageHeight = 0;\r\n        columns.forEach((column) => {\r\n            pageWidth += column.columnWidth;\r\n            pageHeight = Math.max(pageHeight, column.columnHeight);\r\n        });\r\n        maxPageWidth = Math.max(pageWidth, maxPageWidth);\r\n        maxPageHeight = Math.max(pageHeight, maxPageHeight);\r\n        return {\r\n            columns,\r\n            startIndex: indices[0][0],\r\n            endIndex,\r\n            pageWidth,\r\n            pageHeight,\r\n        };\r\n    });\r\n    return { pages, maxPageWidth, maxPageHeight };\r\n}\r\nfunction transpose(data) {\r\n    const result = [];\r\n    for (const _ of data[0]) {\r\n        result.push([]);\r\n    }\r\n    data.forEach((innerData, dataIdx) => {\r\n        innerData.forEach((item, itemIdx) => {\r\n            result[itemIdx][dataIdx] = item;\r\n        });\r\n    });\r\n    return result;\r\n}\r\nfunction estimateStartingGuess(bboxes, primary) {\r\n    const n = bboxes.length;\r\n    let primarySum = 0;\r\n    for (let bboxIndex = 0; bboxIndex < n; bboxIndex++) {\r\n        primarySum += primary.fn(bboxes[bboxIndex]) + primary.padding;\r\n        if (primarySum > primary.max) {\r\n            const ratio = n / bboxIndex;\r\n            if (ratio < 2) {\r\n                return Math.ceil(n / 2);\r\n            }\r\n            return bboxIndex;\r\n        }\r\n    }\r\n    return n;\r\n}\n\nclass Cross extends Marker {\r\n    updatePath() {\r\n        const s = this.size / 4.2;\r\n        super.applyPath(s, Cross.moves);\r\n    }\r\n}\r\nCross.className = 'Cross';\r\nCross.moves = [\r\n    { x: -1, y: 0, t: 'move' },\r\n    { x: -1, y: -1 },\r\n    { x: +1, y: -1 },\r\n    { x: +1, y: +1 },\r\n    { x: +1, y: -1 },\r\n    { x: +1, y: +1 },\r\n    { x: -1, y: +1 },\r\n    { x: +1, y: +1 },\r\n    { x: -1, y: +1 },\r\n    { x: -1, y: -1 },\r\n    { x: -1, y: +1 },\r\n    { x: -1, y: -1 },\r\n];\n\nclass Diamond extends Marker {\r\n    updatePath() {\r\n        const s = this.size / 2;\r\n        super.applyPath(s, Diamond.moves);\r\n    }\r\n}\r\nDiamond.className = 'Diamond';\r\nDiamond.moves = [\r\n    { x: 0, y: -1, t: 'move' },\r\n    { x: +1, y: +1 },\r\n    { x: -1, y: +1 },\r\n    { x: -1, y: -1 },\r\n    { x: +1, y: -1 },\r\n];\n\nclass Heart extends Marker {\r\n    rad(degree) {\r\n        return (degree / 180) * Math.PI;\r\n    }\r\n    updatePath() {\r\n        const { x, path, size, rad } = this;\r\n        const r = size / 4;\r\n        const y = this.y + r / 2;\r\n        path.clear();\r\n        path.arc(x - r, y - r, r, rad(130), rad(330));\r\n        path.arc(x + r, y - r, r, rad(220), rad(50));\r\n        path.lineTo(x, y + r);\r\n        path.closePath();\r\n    }\r\n}\r\nHeart.className = 'Heart';\n\nclass Plus extends Marker {\r\n    updatePath() {\r\n        const s = this.size / 3;\r\n        super.applyPath(s, Plus.moves);\r\n    }\r\n}\r\nPlus.className = 'Plus';\r\nPlus.moves = [\r\n    { x: -0.5, y: -0.5, t: 'move' },\r\n    { x: 0, y: -1 },\r\n    { x: +1, y: 0 },\r\n    { x: 0, y: +1 },\r\n    { x: +1, y: 0 },\r\n    { x: 0, y: +1 },\r\n    { x: -1, y: 0 },\r\n    { x: 0, y: +1 },\r\n    { x: -1, y: 0 },\r\n    { x: 0, y: -1 },\r\n    { x: -1, y: 0 },\r\n    { x: 0, y: -1 },\r\n];\n\nclass Square extends Marker {\r\n    updatePath() {\r\n        const { path, x, y } = this;\r\n        const hs = this.size / 2;\r\n        path.clear();\r\n        path.moveTo(this.align(x - hs), this.align(y - hs));\r\n        path.lineTo(this.align(x + hs), this.align(y - hs));\r\n        path.lineTo(this.align(x + hs), this.align(y + hs));\r\n        path.lineTo(this.align(x - hs), this.align(y + hs));\r\n        path.closePath();\r\n    }\r\n}\r\nSquare.className = 'Square';\n\nclass Triangle extends Marker {\r\n    updatePath() {\r\n        const s = this.size * 1.1;\r\n        super.applyPath(s, Triangle.moves);\r\n    }\r\n}\r\nTriangle.className = 'Triangle';\r\nTriangle.moves = [\r\n    { x: 0, y: -0.48, t: 'move' },\r\n    { x: 0.5, y: 0.87 },\r\n    { x: -1, y: 0 },\r\n];\n\nconst MARKER_SHAPES = {\r\n    circle: Circle,\r\n    cross: Cross,\r\n    diamond: Diamond,\r\n    heart: Heart,\r\n    plus: Plus,\r\n    square: Square,\r\n    triangle: Triangle,\r\n};\r\nconst MARKER_SUPPORTED_SHAPES = Object.keys(MARKER_SHAPES);\r\nfunction isMarkerShape(shape) {\r\n    return MARKER_SUPPORTED_SHAPES.includes(shape);\r\n}\r\n// This function is in its own file because putting it into SeriesMarker makes the Legend\r\n// suddenly aware of the series (it's an agnostic component), and putting it into Marker\r\n// introduces circular dependencies.\r\nfunction getMarker(shape = Square) {\r\n    if (isMarkerShape(shape)) {\r\n        return MARKER_SHAPES[shape];\r\n    }\r\n    if (typeof shape === 'function') {\r\n        return shape;\r\n    }\r\n    return Square;\r\n}\n\nclass MarkerLabel extends Group {\r\n    constructor() {\r\n        super({ name: 'markerLabelGroup' });\r\n        this.label = new Text();\r\n        this._marker = new Square();\r\n        this._markerSize = 15;\r\n        this._spacing = 8;\r\n        const label = this.label;\r\n        label.textBaseline = 'middle';\r\n        label.fontSize = 12;\r\n        label.fontFamily = 'Verdana, sans-serif';\r\n        label.fill = 'black';\r\n        // For better looking vertical alignment of labels to markers.\r\n        label.y = HdpiCanvas.has.textMetrics ? 1 : 0;\r\n        this.append([this.marker, label]);\r\n        this.update();\r\n    }\r\n    set marker(value) {\r\n        if (this._marker !== value) {\r\n            this.removeChild(this._marker);\r\n            this._marker = value;\r\n            this.appendChild(value);\r\n            this.update();\r\n        }\r\n    }\r\n    get marker() {\r\n        return this._marker;\r\n    }\r\n    set markerSize(value) {\r\n        if (this._markerSize !== value) {\r\n            this._markerSize = value;\r\n            this.update();\r\n        }\r\n    }\r\n    get markerSize() {\r\n        return this._markerSize;\r\n    }\r\n    set spacing(value) {\r\n        if (this._spacing !== value) {\r\n            this._spacing = value;\r\n            this.update();\r\n        }\r\n    }\r\n    get spacing() {\r\n        return this._spacing;\r\n    }\r\n    update() {\r\n        const marker = this.marker;\r\n        const markerSize = this.markerSize;\r\n        marker.size = markerSize;\r\n        this.label.x = markerSize / 2 + this.spacing;\r\n    }\r\n    render(renderCtx) {\r\n        // Cannot override field Group.opacity with get/set pair, so\r\n        // propagate opacity changes here.\r\n        this.marker.opacity = this.opacity;\r\n        this.label.opacity = this.opacity;\r\n        super.render(renderCtx);\r\n    }\r\n}\r\nMarkerLabel.className = 'MarkerLabel';\r\n__decorate([\r\n    ProxyPropertyOnWrite('label'),\r\n    __metadata(\"design:type\", String)\r\n], MarkerLabel.prototype, \"text\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('label'),\r\n    __metadata(\"design:type\", String)\r\n], MarkerLabel.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('label'),\r\n    __metadata(\"design:type\", String)\r\n], MarkerLabel.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('label'),\r\n    __metadata(\"design:type\", Number)\r\n], MarkerLabel.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('label'),\r\n    __metadata(\"design:type\", String)\r\n], MarkerLabel.prototype, \"fontFamily\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('label', 'fill'),\r\n    __metadata(\"design:type\", String)\r\n], MarkerLabel.prototype, \"color\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('marker', 'fill'),\r\n    __metadata(\"design:type\", String)\r\n], MarkerLabel.prototype, \"markerFill\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('marker', 'stroke'),\r\n    __metadata(\"design:type\", String)\r\n], MarkerLabel.prototype, \"markerStroke\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('marker', 'strokeWidth'),\r\n    __metadata(\"design:type\", Number)\r\n], MarkerLabel.prototype, \"markerStrokeWidth\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('marker', 'fillOpacity'),\r\n    __metadata(\"design:type\", Number)\r\n], MarkerLabel.prototype, \"markerFillOpacity\", void 0);\r\n__decorate([\r\n    ProxyPropertyOnWrite('marker', 'strokeOpacity'),\r\n    __metadata(\"design:type\", Number)\r\n], MarkerLabel.prototype, \"markerStrokeOpacity\", void 0);\n\nclass PaginationLabel {\r\n    constructor() {\r\n        this.color = 'black';\r\n        this.fontStyle = undefined;\r\n        this.fontWeight = undefined;\r\n        this.fontSize = 12;\r\n        this.fontFamily = 'Verdana, sans-serif';\r\n    }\r\n}\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PaginationLabel.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_STYLE),\r\n    __metadata(\"design:type\", String)\r\n], PaginationLabel.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_WEIGHT),\r\n    __metadata(\"design:type\", String)\r\n], PaginationLabel.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], PaginationLabel.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", String)\r\n], PaginationLabel.prototype, \"fontFamily\", void 0);\r\nclass PaginationMarkerStyle {\r\n    constructor() {\r\n        this.size = 15;\r\n        this.fill = undefined;\r\n        this.fillOpacity = undefined;\r\n        this.stroke = undefined;\r\n        this.strokeWidth = 1;\r\n        this.strokeOpacity = 1;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PaginationMarkerStyle.prototype, \"size\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PaginationMarkerStyle.prototype, \"fill\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], PaginationMarkerStyle.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], PaginationMarkerStyle.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], PaginationMarkerStyle.prototype, \"strokeWidth\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], PaginationMarkerStyle.prototype, \"strokeOpacity\", void 0);\r\nclass PaginationMarker {\r\n    constructor(parent) {\r\n        this.parent = parent;\r\n        this.shape = Triangle;\r\n        this.size = 15;\r\n        /**\r\n         * Inner padding between a pagination button and the label.\r\n         */\r\n        this.padding = 8;\r\n    }\r\n}\r\n__decorate([\r\n    ActionOnSet({\r\n        changeValue() {\r\n            if (this.parent.marker === this) {\r\n                this.parent.onMarkerShapeChange();\r\n            }\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Object)\r\n], PaginationMarker.prototype, \"shape\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], PaginationMarker.prototype, \"size\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], PaginationMarker.prototype, \"padding\", void 0);\r\nclass Pagination {\r\n    constructor(chartUpdateCallback, pageUpdateCallback, interactionManager, cursorManager) {\r\n        this.chartUpdateCallback = chartUpdateCallback;\r\n        this.pageUpdateCallback = pageUpdateCallback;\r\n        this.interactionManager = interactionManager;\r\n        this.cursorManager = cursorManager;\r\n        this.id = createId(this);\r\n        this.group = new Group({ name: 'pagination' });\r\n        this.labelNode = new Text();\r\n        this.marker = new PaginationMarker(this);\r\n        this.activeStyle = new PaginationMarkerStyle();\r\n        this.inactiveStyle = new PaginationMarkerStyle();\r\n        this.highlightStyle = new PaginationMarkerStyle();\r\n        this.label = new PaginationLabel();\r\n        this.totalPages = 0;\r\n        this.currentPage = 0;\r\n        this.translationX = 0;\r\n        this.translationY = 0;\r\n        this.nextButtonDisabled = false;\r\n        this.previousButtonDisabled = false;\r\n        this._visible = true;\r\n        this._enabled = true;\r\n        this._orientation = 'vertical';\r\n        this._nextButton = new Triangle();\r\n        this._previousButton = new Triangle();\r\n        const { labelNode } = this;\r\n        labelNode.textBaseline = 'middle';\r\n        labelNode.fontSize = 12;\r\n        labelNode.fontFamily = 'Verdana, sans-serif';\r\n        labelNode.fill = 'black';\r\n        labelNode.y = HdpiCanvas.has.textMetrics ? 1 : 0;\r\n        this.group.append([this.nextButton, this.previousButton, labelNode]);\r\n        this.interactionManager.addListener('click', (event) => this.onPaginationClick(event));\r\n        this.interactionManager.addListener('hover', (event) => this.onPaginationMouseMove(event));\r\n        this.update();\r\n        this.updateMarkers();\r\n    }\r\n    set visible(value) {\r\n        this._visible = value;\r\n        this.updateGroupVisibility();\r\n    }\r\n    get visible() {\r\n        return this._visible;\r\n    }\r\n    set enabled(value) {\r\n        this._enabled = value;\r\n        this.updateGroupVisibility();\r\n    }\r\n    get enabled() {\r\n        return this._enabled;\r\n    }\r\n    updateGroupVisibility() {\r\n        this.group.visible = this.enabled && this.visible;\r\n    }\r\n    set orientation(value) {\r\n        this._orientation = value;\r\n        switch (value) {\r\n            case 'horizontal': {\r\n                this.previousButton.rotation = -Math.PI / 2;\r\n                this.nextButton.rotation = Math.PI / 2;\r\n                break;\r\n            }\r\n            case 'vertical':\r\n            default: {\r\n                this.previousButton.rotation = 0;\r\n                this.nextButton.rotation = Math.PI;\r\n            }\r\n        }\r\n    }\r\n    get orientation() {\r\n        return this._orientation;\r\n    }\r\n    set nextButton(value) {\r\n        if (this._nextButton !== value) {\r\n            this.group.removeChild(this._nextButton);\r\n            this._nextButton = value;\r\n            this.group.appendChild(value);\r\n        }\r\n    }\r\n    get nextButton() {\r\n        return this._nextButton;\r\n    }\r\n    set previousButton(value) {\r\n        if (this._previousButton !== value) {\r\n            this.group.removeChild(this._previousButton);\r\n            this._previousButton = value;\r\n            this.group.appendChild(value);\r\n        }\r\n    }\r\n    get previousButton() {\r\n        return this._previousButton;\r\n    }\r\n    update() {\r\n        this.updateLabel();\r\n        this.updatePositions();\r\n        this.enableOrDisableButtons();\r\n    }\r\n    updatePositions() {\r\n        this.group.translationX = this.translationX;\r\n        this.group.translationY = this.translationY;\r\n        this.updateLabelPosition();\r\n        this.updateNextButtonPosition();\r\n    }\r\n    updateLabelPosition() {\r\n        const { size: markerSize, padding: markerPadding } = this.marker;\r\n        this.nextButton.size = markerSize;\r\n        this.previousButton.size = markerSize;\r\n        this.labelNode.x = markerSize / 2 + markerPadding;\r\n    }\r\n    updateNextButtonPosition() {\r\n        const labelBBox = this.labelNode.computeBBox();\r\n        this.nextButton.translationX = labelBBox.x + labelBBox.width + this.marker.size / 2 + this.marker.padding;\r\n    }\r\n    updateLabel() {\r\n        const { currentPage, totalPages: pages, labelNode, label: { color, fontStyle, fontWeight, fontSize, fontFamily }, } = this;\r\n        labelNode.text = `${currentPage + 1} / ${pages}`;\r\n        labelNode.fill = color;\r\n        labelNode.fontStyle = fontStyle;\r\n        labelNode.fontWeight = fontWeight;\r\n        labelNode.fontSize = fontSize;\r\n        labelNode.fontFamily = fontFamily;\r\n    }\r\n    updateMarkers() {\r\n        const { nextButton, previousButton, nextButtonDisabled, previousButtonDisabled, activeStyle, inactiveStyle, highlightStyle, highlightActive, } = this;\r\n        const buttonStyle = (button, disabled) => {\r\n            if (disabled) {\r\n                return inactiveStyle;\r\n            }\r\n            else if (button === highlightActive) {\r\n                return highlightStyle;\r\n            }\r\n            return activeStyle;\r\n        };\r\n        this.updateMarker(nextButton, buttonStyle('next', nextButtonDisabled));\r\n        this.updateMarker(previousButton, buttonStyle('previous', previousButtonDisabled));\r\n    }\r\n    updateMarker(marker, style) {\r\n        var _a;\r\n        const { size } = this.marker;\r\n        marker.size = size;\r\n        marker.fill = style.fill;\r\n        marker.fillOpacity = (_a = style.fillOpacity) !== null && _a !== void 0 ? _a : 1;\r\n        marker.stroke = style.stroke;\r\n        marker.strokeWidth = style.strokeWidth;\r\n        marker.strokeOpacity = style.strokeOpacity;\r\n    }\r\n    enableOrDisableButtons() {\r\n        const { currentPage, totalPages } = this;\r\n        const zeroPagesToDisplay = totalPages === 0;\r\n        const onLastPage = currentPage === totalPages - 1;\r\n        const onFirstPage = currentPage === 0;\r\n        this.nextButtonDisabled = onLastPage || zeroPagesToDisplay;\r\n        this.previousButtonDisabled = onFirstPage || zeroPagesToDisplay;\r\n    }\r\n    nextButtonContainsPoint(offsetX, offsetY) {\r\n        return !this.nextButtonDisabled && this.nextButton.containsPoint(offsetX, offsetY);\r\n    }\r\n    previousButtonContainsPoint(offsetX, offsetY) {\r\n        return !this.previousButtonDisabled && this.previousButton.containsPoint(offsetX, offsetY);\r\n    }\r\n    onPaginationClick(event) {\r\n        const { offsetX, offsetY } = event;\r\n        if (this.nextButtonContainsPoint(offsetX, offsetY)) {\r\n            this.incrementPage();\r\n            this.onPaginationChanged();\r\n            event.consume();\r\n        }\r\n        else if (this.previousButtonContainsPoint(offsetX, offsetY)) {\r\n            this.decrementPage();\r\n            this.onPaginationChanged();\r\n            event.consume();\r\n        }\r\n    }\r\n    onPaginationMouseMove(event) {\r\n        const { offsetX, offsetY } = event;\r\n        if (this.nextButtonContainsPoint(offsetX, offsetY)) {\r\n            this.cursorManager.updateCursor(this.id, 'pointer');\r\n            this.highlightActive = 'next';\r\n        }\r\n        else if (this.previousButtonContainsPoint(offsetX, offsetY)) {\r\n            this.cursorManager.updateCursor(this.id, 'pointer');\r\n            this.highlightActive = 'previous';\r\n        }\r\n        else {\r\n            this.cursorManager.updateCursor(this.id);\r\n            this.highlightActive = undefined;\r\n        }\r\n        this.updateMarkers();\r\n        this.chartUpdateCallback(ChartUpdateType.SCENE_RENDER);\r\n    }\r\n    onPaginationChanged() {\r\n        this.pageUpdateCallback(this.currentPage);\r\n    }\r\n    incrementPage() {\r\n        this.currentPage = Math.min(this.currentPage + 1, this.totalPages - 1);\r\n    }\r\n    decrementPage() {\r\n        this.currentPage = Math.max(this.currentPage - 1, 0);\r\n    }\r\n    onMarkerShapeChange() {\r\n        const Marker = getMarker(this.marker.shape || Triangle);\r\n        this.previousButton = new Marker();\r\n        this.nextButton = new Marker();\r\n        this.updatePositions();\r\n        this.updateMarkers();\r\n        this.chartUpdateCallback(ChartUpdateType.SCENE_RENDER);\r\n    }\r\n    attachPagination(node) {\r\n        node.append(this.group);\r\n    }\r\n    computeBBox() {\r\n        return this.group.computeBBox();\r\n    }\r\n}\r\nPagination.className = 'Pagination';\n\nconst ORIENTATIONS = ['horizontal', 'vertical'];\r\nconst OPT_ORIENTATION = predicateWithMessage((v, ctx) => OPTIONAL(v, ctx, (v) => ORIENTATIONS.includes(v)), `expecting an orientation keyword such as 'horizontal' or 'vertical'`);\r\nclass LegendLabel {\r\n    constructor() {\r\n        this.maxLength = undefined;\r\n        this.color = 'black';\r\n        this.fontStyle = undefined;\r\n        this.fontWeight = undefined;\r\n        this.fontSize = 12;\r\n        this.fontFamily = 'Verdana, sans-serif';\r\n        this.formatter = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], LegendLabel.prototype, \"maxLength\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], LegendLabel.prototype, \"color\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_STYLE),\r\n    __metadata(\"design:type\", String)\r\n], LegendLabel.prototype, \"fontStyle\", void 0);\r\n__decorate([\r\n    Validate(OPT_FONT_WEIGHT),\r\n    __metadata(\"design:type\", String)\r\n], LegendLabel.prototype, \"fontWeight\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], LegendLabel.prototype, \"fontSize\", void 0);\r\n__decorate([\r\n    Validate(STRING),\r\n    __metadata(\"design:type\", String)\r\n], LegendLabel.prototype, \"fontFamily\", void 0);\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    __metadata(\"design:type\", Function)\r\n], LegendLabel.prototype, \"formatter\", void 0);\r\nclass LegendMarker {\r\n    constructor() {\r\n        this.size = 15;\r\n        /**\r\n         * If the marker type is set, the legend will always use that marker type for all its items,\r\n         * regardless of the type that comes from the `data`.\r\n         */\r\n        this._shape = undefined;\r\n        /**\r\n         * Padding between the marker and the label within each legend item.\r\n         */\r\n        this.padding = 8;\r\n        this.strokeWidth = undefined;\r\n    }\r\n    set shape(value) {\r\n        var _a;\r\n        this._shape = value;\r\n        (_a = this.parent) === null || _a === void 0 ? void 0 : _a.onMarkerShapeChange();\r\n    }\r\n    get shape() {\r\n        return this._shape;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], LegendMarker.prototype, \"size\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], LegendMarker.prototype, \"padding\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Object)\r\n], LegendMarker.prototype, \"strokeWidth\", void 0);\r\nclass LegendItem {\r\n    constructor() {\r\n        this.marker = new LegendMarker();\r\n        this.label = new LegendLabel();\r\n        /** Used to constrain the width of legend items. */\r\n        this.maxWidth = undefined;\r\n        /**\r\n         * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,\r\n         * and as few rows as possible when positioned to top or bottom. This config specifies the amount of horizontal\r\n         * padding between legend items.\r\n         */\r\n        this.paddingX = 16;\r\n        /**\r\n         * The legend uses grid layout for its items, occupying as few columns as possible when positioned to left or right,\r\n         * and as few rows as possible when positioned to top or bottom. This config specifies the amount of vertical\r\n         * padding between legend items.\r\n         */\r\n        this.paddingY = 8;\r\n        this.toggleSeriesVisible = true;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], LegendItem.prototype, \"maxWidth\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], LegendItem.prototype, \"paddingX\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], LegendItem.prototype, \"paddingY\", void 0);\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], LegendItem.prototype, \"toggleSeriesVisible\", void 0);\r\nclass LegendListeners {\r\n    constructor() {\r\n        this.legendItemClick = undefined;\r\n        this.legendItemDoubleClick = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    __metadata(\"design:type\", Function)\r\n], LegendListeners.prototype, \"legendItemClick\", void 0);\r\nclass Legend {\r\n    set data(value) {\r\n        this._data = value;\r\n        this.updateGroupVisibility();\r\n    }\r\n    get data() {\r\n        return this._data;\r\n    }\r\n    set enabled(value) {\r\n        this._enabled = value;\r\n        this.updateGroupVisibility();\r\n    }\r\n    get enabled() {\r\n        return this._enabled;\r\n    }\r\n    getOrientation() {\r\n        if (this.orientation !== undefined) {\r\n            return this.orientation;\r\n        }\r\n        switch (this.position) {\r\n            case 'right':\r\n            case 'left':\r\n                return 'vertical';\r\n            case 'bottom':\r\n            case 'top':\r\n                return 'horizontal';\r\n        }\r\n    }\r\n    constructor(ctx) {\r\n        this.ctx = ctx;\r\n        this.id = createId(this);\r\n        this.group = new Group({ name: 'legend', layer: true, zIndex: Layers.LEGEND_ZINDEX });\r\n        this.itemSelection = Selection.select(this.group, MarkerLabel);\r\n        this.oldSize = [0, 0];\r\n        this.pages = [];\r\n        this.maxPageSize = [0, 0];\r\n        /** Item index to track on re-pagination, so current page updates appropriately. */\r\n        this.paginationTrackingIndex = 0;\r\n        this.item = new LegendItem();\r\n        this.listeners = new LegendListeners();\r\n        this.truncatedItems = new Set();\r\n        this._data = [];\r\n        this._enabled = true;\r\n        this.position = 'bottom';\r\n        /** Used to constrain the width of the legend. */\r\n        this.maxWidth = undefined;\r\n        /** Used to constrain the height of the legend. */\r\n        this.maxHeight = undefined;\r\n        /** Reverse the display order of legend items if `true`. */\r\n        this.reverseOrder = undefined;\r\n        this.destroyFns = [];\r\n        /**\r\n         * Spacing between the legend and the edge of the chart's element.\r\n         */\r\n        this.spacing = 20;\r\n        this.characterWidths = new Map();\r\n        this.size = [0, 0];\r\n        this._visible = true;\r\n        this.item.marker.parent = this;\r\n        this.pagination = new Pagination((type) => ctx.updateService.update(type), (page) => this.updatePageNumber(page), ctx.interactionManager, ctx.cursorManager);\r\n        this.pagination.attachPagination(this.group);\r\n        this.item.marker.parent = this;\r\n        const bypass = { bypassPause: ['animation'] };\r\n        this.destroyFns.push(ctx.interactionManager.addListener('click', (e) => this.checkLegendClick(e), bypass), ctx.interactionManager.addListener('dblclick', (e) => this.checkLegendDoubleClick(e), bypass), ctx.interactionManager.addListener('hover', (e) => this.handleLegendMouseMove(e)), ctx.layoutService.addListener('start-layout', (e) => this.positionLegend(e.shrinkRect)), () => this.detachLegend());\r\n    }\r\n    destroy() {\r\n        this.destroyFns.forEach((f) => f());\r\n    }\r\n    onMarkerShapeChange() {\r\n        this.itemSelection.clear();\r\n        this.group.markDirty(this.group, RedrawType.MINOR);\r\n    }\r\n    getCharacterWidths(font) {\r\n        const { characterWidths } = this;\r\n        if (characterWidths.has(font)) {\r\n            return characterWidths.get(font);\r\n        }\r\n        const cw = {\r\n            '...': HdpiCanvas.getTextSize('...', font).width,\r\n        };\r\n        characterWidths.set(font, cw);\r\n        return cw;\r\n    }\r\n    set visible(value) {\r\n        this._visible = value;\r\n        this.updateGroupVisibility();\r\n    }\r\n    get visible() {\r\n        return this._visible;\r\n    }\r\n    updateGroupVisibility() {\r\n        this.group.visible = this.enabled && this.visible && this.data.length > 0;\r\n    }\r\n    attachLegend(node) {\r\n        node.append(this.group);\r\n    }\r\n    detachLegend() {\r\n        var _a;\r\n        (_a = this.group.parent) === null || _a === void 0 ? void 0 : _a.removeChild(this.group);\r\n    }\r\n    getItemLabel(datum) {\r\n        const { ctx: { callbackCache }, } = this;\r\n        const { formatter } = this.item.label;\r\n        if (formatter) {\r\n            return callbackCache.call(formatter, {\r\n                itemId: datum.itemId,\r\n                value: datum.label.text,\r\n                seriesId: datum.seriesId,\r\n            });\r\n        }\r\n        return datum.label.text;\r\n    }\r\n    /**\r\n     * The method is given the desired size of the legend, which only serves as a hint.\r\n     * The vertically oriented legend will take as much horizontal space as needed, but will\r\n     * respect the height constraints, and the horizontal legend will take as much vertical\r\n     * space as needed in an attempt not to exceed the given width.\r\n     * After the layout is done, the {@link size} will contain the actual size of the legend.\r\n     * If the actual size is not the same as the previous actual size, the legend will fire\r\n     * the 'layoutChange' event to communicate that another layout is needed, and the above\r\n     * process should be repeated.\r\n     * @param width\r\n     * @param height\r\n     */\r\n    performLayout(width, height) {\r\n        const { paddingX, paddingY, label, maxWidth, marker: { size: markerSize, padding: markerPadding, shape: markerShape }, label: { maxLength = Infinity, fontStyle, fontWeight, fontSize, fontFamily }, } = this.item;\r\n        const data = [...this.data];\r\n        if (this.reverseOrder) {\r\n            data.reverse();\r\n        }\r\n        this.itemSelection.update(data);\r\n        // Update properties that affect the size of the legend items and measure them.\r\n        const bboxes = [];\r\n        const font = getFont(label);\r\n        const itemMaxWidthPercentage = 0.8;\r\n        const maxItemWidth = maxWidth !== null && maxWidth !== void 0 ? maxWidth : width * itemMaxWidthPercentage;\r\n        const paddedMarkerWidth = markerSize + markerPadding + paddingX;\r\n        this.itemSelection.each((markerLabel, datum) => {\r\n            var _a;\r\n            const Marker = getMarker(markerShape !== null && markerShape !== void 0 ? markerShape : datum.marker.shape);\r\n            if (!(markerLabel.marker && markerLabel.marker instanceof Marker)) {\r\n                markerLabel.marker = new Marker();\r\n            }\r\n            markerLabel.markerSize = markerSize;\r\n            markerLabel.spacing = markerPadding;\r\n            markerLabel.fontStyle = fontStyle;\r\n            markerLabel.fontWeight = fontWeight;\r\n            markerLabel.fontSize = fontSize;\r\n            markerLabel.fontFamily = fontFamily;\r\n            const id = (_a = datum.itemId) !== null && _a !== void 0 ? _a : datum.id;\r\n            const labelText = this.getItemLabel(datum);\r\n            const text = (labelText !== null && labelText !== void 0 ? labelText : '<unknown>').replace(/\\r?\\n/g, ' ');\r\n            markerLabel.text = this.truncate(text, maxLength, maxItemWidth, paddedMarkerWidth, font, id);\r\n            bboxes.push(markerLabel.computeBBox());\r\n        });\r\n        width = Math.max(1, width);\r\n        height = Math.max(1, height);\r\n        if (!isFinite(width)) {\r\n            return false;\r\n        }\r\n        const size = this.size;\r\n        const oldSize = this.oldSize;\r\n        size[0] = width;\r\n        size[1] = height;\r\n        if (size[0] !== oldSize[0] || size[1] !== oldSize[1]) {\r\n            oldSize[0] = size[0];\r\n            oldSize[1] = size[1];\r\n        }\r\n        const { pages, maxPageHeight, maxPageWidth } = this.updatePagination(bboxes, width, height);\r\n        this.pages = pages;\r\n        this.maxPageSize = [maxPageWidth - paddingX, maxPageHeight - paddingY];\r\n        const pageNumber = this.pagination.currentPage;\r\n        const page = this.pages[pageNumber];\r\n        if (this.pages.length < 1 || !page) {\r\n            this.visible = false;\r\n            return;\r\n        }\r\n        this.visible = true;\r\n        // Position legend items\r\n        this.updatePositions(pageNumber);\r\n        // Update legend item properties that don't affect the layout.\r\n        this.update();\r\n    }\r\n    truncate(text, maxCharLength, maxItemWidth, paddedMarkerWidth, font, id) {\r\n        const ellipsis = `...`;\r\n        const textChars = text.split('');\r\n        let addEllipsis = false;\r\n        if (text.length > maxCharLength) {\r\n            text = `${text.substring(0, maxCharLength)}`;\r\n            addEllipsis = true;\r\n        }\r\n        const labelWidth = Math.floor(paddedMarkerWidth + HdpiCanvas.getTextSize(text, font).width);\r\n        if (labelWidth > maxItemWidth) {\r\n            let truncatedText = '';\r\n            const characterWidths = this.getCharacterWidths(font);\r\n            let cumulativeWidth = paddedMarkerWidth + characterWidths[ellipsis];\r\n            for (const char of textChars) {\r\n                if (!characterWidths[char]) {\r\n                    characterWidths[char] = HdpiCanvas.getTextSize(char, font).width;\r\n                }\r\n                cumulativeWidth += characterWidths[char];\r\n                if (cumulativeWidth > maxItemWidth) {\r\n                    break;\r\n                }\r\n                truncatedText += char;\r\n            }\r\n            text = truncatedText;\r\n            addEllipsis = true;\r\n        }\r\n        if (addEllipsis) {\r\n            text += ellipsis;\r\n            this.truncatedItems.add(id);\r\n        }\r\n        else {\r\n            this.truncatedItems.delete(id);\r\n        }\r\n        return text;\r\n    }\r\n    updatePagination(bboxes, width, height) {\r\n        const orientation = this.getOrientation();\r\n        const trackingIndex = Math.min(this.paginationTrackingIndex, bboxes.length);\r\n        this.pagination.orientation = orientation;\r\n        this.pagination.translationX = 0;\r\n        this.pagination.translationY = 0;\r\n        const { pages, maxPageHeight, maxPageWidth, paginationBBox, paginationVertical } = this.calculatePagination(bboxes, width, height);\r\n        const newCurrentPage = pages.findIndex((p) => p.endIndex >= trackingIndex);\r\n        this.pagination.currentPage = Math.min(Math.max(newCurrentPage, 0), pages.length - 1);\r\n        const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\r\n        const paginationComponentPadding = 8;\r\n        const legendItemsWidth = maxPageWidth - itemPaddingX;\r\n        const legendItemsHeight = maxPageHeight - itemPaddingY;\r\n        let paginationX = 0;\r\n        let paginationY = -paginationBBox.y - this.item.marker.size / 2;\r\n        if (paginationVertical) {\r\n            paginationY += legendItemsHeight + paginationComponentPadding;\r\n        }\r\n        else {\r\n            paginationX += -paginationBBox.x + legendItemsWidth + paginationComponentPadding;\r\n            paginationY += (legendItemsHeight - paginationBBox.height) / 2;\r\n        }\r\n        this.pagination.translationX = paginationX;\r\n        this.pagination.translationY = paginationY;\r\n        this.pagination.update();\r\n        this.pagination.updateMarkers();\r\n        return {\r\n            maxPageHeight,\r\n            maxPageWidth,\r\n            pages,\r\n        };\r\n    }\r\n    calculatePagination(bboxes, width, height) {\r\n        var _a, _b, _c;\r\n        const { paddingX: itemPaddingX, paddingY: itemPaddingY } = this.item;\r\n        const orientation = this.getOrientation();\r\n        const paginationVertical = ['left', 'right'].includes(this.position);\r\n        let paginationBBox = this.pagination.computeBBox();\r\n        let lastPassPaginationBBox = new BBox(0, 0, 0, 0);\r\n        let pages = [];\r\n        let maxPageWidth = 0;\r\n        let maxPageHeight = 0;\r\n        let count = 0;\r\n        const stableOutput = (lastPassPaginationBBox) => {\r\n            const { width, height } = lastPassPaginationBBox;\r\n            return width === paginationBBox.width && height === paginationBBox.height;\r\n        };\r\n        const forceResult = this.maxWidth !== undefined || this.maxHeight !== undefined;\r\n        do {\r\n            if (count++ > 10) {\r\n                Logger.warn('unable to find stable legend layout.');\r\n                break;\r\n            }\r\n            paginationBBox = lastPassPaginationBBox;\r\n            const maxWidth = width - (paginationVertical ? 0 : paginationBBox.width);\r\n            const maxHeight = height - (paginationVertical ? paginationBBox.height : 0);\r\n            const layout = gridLayout({\r\n                orientation,\r\n                bboxes,\r\n                maxHeight,\r\n                maxWidth,\r\n                itemPaddingY,\r\n                itemPaddingX,\r\n                forceResult,\r\n            });\r\n            pages = (_a = layout === null || layout === void 0 ? void 0 : layout.pages) !== null && _a !== void 0 ? _a : [];\r\n            maxPageWidth = (_b = layout === null || layout === void 0 ? void 0 : layout.maxPageWidth) !== null && _b !== void 0 ? _b : 0;\r\n            maxPageHeight = (_c = layout === null || layout === void 0 ? void 0 : layout.maxPageHeight) !== null && _c !== void 0 ? _c : 0;\r\n            const totalPages = pages.length;\r\n            this.pagination.visible = totalPages > 1;\r\n            this.pagination.totalPages = totalPages;\r\n            this.pagination.update();\r\n            lastPassPaginationBBox = this.pagination.computeBBox();\r\n            if (!this.pagination.visible) {\r\n                break;\r\n            }\r\n        } while (!stableOutput(lastPassPaginationBBox));\r\n        return { maxPageWidth, maxPageHeight, pages, paginationBBox, paginationVertical };\r\n    }\r\n    updatePositions(pageNumber = 0) {\r\n        const { item: { paddingY }, itemSelection, pages, } = this;\r\n        if (pages.length < 1 || !pages[pageNumber]) {\r\n            return;\r\n        }\r\n        const { columns, startIndex: visibleStart, endIndex: visibleEnd } = pages[pageNumber];\r\n        // Position legend items using the layout computed above.\r\n        let x = 0;\r\n        let y = 0;\r\n        const columnCount = columns.length;\r\n        const rowCount = columns[0].indices.length;\r\n        const horizontal = this.getOrientation() === 'horizontal';\r\n        const itemHeight = columns[0].bboxes[0].height + paddingY;\r\n        const rowSumColumnWidths = [];\r\n        itemSelection.each((markerLabel, _, i) => {\r\n            var _a, _b;\r\n            if (i < visibleStart || i > visibleEnd) {\r\n                markerLabel.visible = false;\r\n                return;\r\n            }\r\n            const pageIndex = i - visibleStart;\r\n            let columnIndex = 0;\r\n            let rowIndex = 0;\r\n            if (horizontal) {\r\n                columnIndex = pageIndex % columnCount;\r\n                rowIndex = Math.floor(pageIndex / columnCount);\r\n            }\r\n            else {\r\n                columnIndex = Math.floor(pageIndex / rowCount);\r\n                rowIndex = pageIndex % rowCount;\r\n            }\r\n            markerLabel.visible = true;\r\n            const column = columns[columnIndex];\r\n            if (!column) {\r\n                return;\r\n            }\r\n            y = itemHeight * rowIndex;\r\n            x = (_a = rowSumColumnWidths[rowIndex]) !== null && _a !== void 0 ? _a : 0;\r\n            rowSumColumnWidths[rowIndex] = ((_b = rowSumColumnWidths[rowIndex]) !== null && _b !== void 0 ? _b : 0) + column.columnWidth;\r\n            // Round off for pixel grid alignment to work properly.\r\n            markerLabel.translationX = Math.floor(x);\r\n            markerLabel.translationY = Math.floor(y);\r\n        });\r\n    }\r\n    updatePageNumber(pageNumber) {\r\n        const { pages } = this;\r\n        // Track an item on the page in re-pagination cases (e.g. resize).\r\n        const { startIndex, endIndex } = pages[pageNumber];\r\n        if (startIndex === 0) {\r\n            // Stay on first page on pagination update.\r\n            this.paginationTrackingIndex = 0;\r\n        }\r\n        else if (pageNumber === pages.length - 1) {\r\n            // Stay on last page on pagination update.\r\n            this.paginationTrackingIndex = endIndex;\r\n        }\r\n        else {\r\n            // Track the middle item on the page).\r\n            this.paginationTrackingIndex = Math.floor((startIndex + endIndex) / 2);\r\n        }\r\n        this.pagination.update();\r\n        this.pagination.updateMarkers();\r\n        this.updatePositions(pageNumber);\r\n        this.ctx.updateService.update(ChartUpdateType.SCENE_RENDER);\r\n    }\r\n    update() {\r\n        const { label: { color }, marker: itemMarker, } = this.item;\r\n        this.itemSelection.each((markerLabel, datum) => {\r\n            var _a;\r\n            const marker = datum.marker;\r\n            markerLabel.markerFill = marker.fill;\r\n            markerLabel.markerStroke = marker.stroke;\r\n            markerLabel.markerStrokeWidth = (_a = itemMarker.strokeWidth) !== null && _a !== void 0 ? _a : Math.min(2, marker.strokeWidth);\r\n            markerLabel.markerFillOpacity = marker.fillOpacity;\r\n            markerLabel.markerStrokeOpacity = marker.strokeOpacity;\r\n            markerLabel.opacity = datum.enabled ? 1 : 0.5;\r\n            markerLabel.color = color;\r\n        });\r\n    }\r\n    getDatumForPoint(x, y) {\r\n        const visibleChildBBoxes = [];\r\n        const closestLeftTop = { dist: Infinity, datum: undefined };\r\n        for (const child of this.group.children) {\r\n            if (!child.visible)\r\n                continue;\r\n            if (!(child instanceof MarkerLabel))\r\n                continue;\r\n            const childBBox = child.computeBBox();\r\n            childBBox.grow(this.item.paddingX / 2, 'horizontal');\r\n            childBBox.grow(this.item.paddingY / 2, 'vertical');\r\n            if (childBBox.containsPoint(x, y)) {\r\n                return child.datum;\r\n            }\r\n            const distX = x - childBBox.x - this.item.paddingX / 2;\r\n            const distY = y - childBBox.y - this.item.paddingY / 2;\r\n            const dist = Math.pow(distX, 2) + Math.pow(distY, 2);\r\n            const toTheLeftTop = distX >= 0 && distY >= 0;\r\n            if (toTheLeftTop && dist < closestLeftTop.dist) {\r\n                closestLeftTop.dist = dist;\r\n                closestLeftTop.datum = child.datum;\r\n            }\r\n            visibleChildBBoxes.push(childBBox);\r\n        }\r\n        const pageBBox = BBox.merge(visibleChildBBoxes);\r\n        if (!pageBBox.containsPoint(x, y)) {\r\n            // We're not in-between legend items.\r\n            return undefined;\r\n        }\r\n        // Fallback to returning closest match to the left/up.\r\n        return closestLeftTop.datum;\r\n    }\r\n    computeBBox() {\r\n        return this.group.computeBBox();\r\n    }\r\n    computePagedBBox() {\r\n        const actualBBox = this.group.computeBBox();\r\n        if (this.pages.length <= 1) {\r\n            return actualBBox;\r\n        }\r\n        const [maxPageWidth, maxPageHeight] = this.maxPageSize;\r\n        actualBBox.height = Math.max(maxPageHeight, actualBBox.height);\r\n        actualBBox.width = Math.max(maxPageWidth, actualBBox.width);\r\n        return actualBBox;\r\n    }\r\n    checkLegendClick(event) {\r\n        const { listeners: { legendItemClick }, ctx: { dataService, highlightManager }, item: { toggleSeriesVisible }, } = this;\r\n        const { offsetX, offsetY } = event;\r\n        const legendBBox = this.computeBBox();\r\n        const pointerInsideLegend = this.group.visible && legendBBox.containsPoint(offsetX, offsetY);\r\n        const datum = this.getDatumForPoint(offsetX, offsetY);\r\n        if (!pointerInsideLegend || !datum) {\r\n            return;\r\n        }\r\n        const { id, itemId, enabled } = datum;\r\n        const chartSeries = dataService.getSeries();\r\n        const series = chartSeries.find((s) => s.id === id);\r\n        if (!series) {\r\n            return;\r\n        }\r\n        event.consume();\r\n        let newEnabled = enabled;\r\n        if (toggleSeriesVisible) {\r\n            newEnabled = !enabled;\r\n            this.ctx.chartEventManager.legendItemClick(series, itemId, newEnabled, datum.legendItemName);\r\n        }\r\n        if (!newEnabled) {\r\n            highlightManager.updateHighlight(this.id);\r\n        }\r\n        else {\r\n            highlightManager.updateHighlight(this.id, {\r\n                series,\r\n                itemId,\r\n                datum: undefined,\r\n            });\r\n        }\r\n        this.ctx.updateService.update(ChartUpdateType.PROCESS_DATA, { forceNodeDataRefresh: true });\r\n        legendItemClick === null || legendItemClick === void 0 ? void 0 : legendItemClick({ type: 'click', enabled: newEnabled, itemId, seriesId: series.id });\r\n    }\r\n    checkLegendDoubleClick(event) {\r\n        var _a;\r\n        const { listeners: { legendItemDoubleClick }, ctx: { dataService }, item: { toggleSeriesVisible }, } = this;\r\n        const { offsetX, offsetY } = event;\r\n        // Integrated charts do not handle double click behaviour correctly due to multiple instances of the\r\n        // chart being created. See https://ag-grid.atlassian.net/browse/RTI-1381\r\n        if (this.ctx.mode === 'integrated') {\r\n            return;\r\n        }\r\n        const legendBBox = this.computeBBox();\r\n        const pointerInsideLegend = this.group.visible && legendBBox.containsPoint(offsetX, offsetY);\r\n        const datum = this.getDatumForPoint(offsetX, offsetY);\r\n        if (!pointerInsideLegend || !datum) {\r\n            return;\r\n        }\r\n        const { id, itemId, seriesId } = datum;\r\n        const chartSeries = dataService.getSeries();\r\n        const series = chartSeries.find((s) => s.id === id);\r\n        if (!series) {\r\n            return;\r\n        }\r\n        event.consume();\r\n        if (toggleSeriesVisible) {\r\n            const numVisibleItems = {};\r\n            const legendData = chartSeries.flatMap((series) => series.getLegendData('category'));\r\n            legendData.forEach((d) => {\r\n                var _a;\r\n                var _b;\r\n                (_a = numVisibleItems[_b = d.seriesId]) !== null && _a !== void 0 ? _a : (numVisibleItems[_b] = 0);\r\n                if (d.enabled) {\r\n                    numVisibleItems[d.seriesId]++;\r\n                }\r\n            });\r\n            const clickedItem = legendData.find((d) => d.itemId === itemId && d.seriesId === seriesId);\r\n            this.ctx.chartEventManager.legendItemDoubleClick(series, itemId, (_a = clickedItem === null || clickedItem === void 0 ? void 0 : clickedItem.enabled) !== null && _a !== void 0 ? _a : false, numVisibleItems, clickedItem === null || clickedItem === void 0 ? void 0 : clickedItem.legendItemName);\r\n        }\r\n        this.ctx.updateService.update(ChartUpdateType.PROCESS_DATA, { forceNodeDataRefresh: true });\r\n        legendItemDoubleClick === null || legendItemDoubleClick === void 0 ? void 0 : legendItemDoubleClick({ type: 'dblclick', enabled: true, itemId, seriesId: series.id });\r\n    }\r\n    handleLegendMouseMove(event) {\r\n        var _a;\r\n        const { enabled, item: { toggleSeriesVisible }, listeners, } = this;\r\n        if (!enabled) {\r\n            return;\r\n        }\r\n        const legendBBox = this.computeBBox();\r\n        const { pageX, pageY, offsetX, offsetY } = event;\r\n        const pointerInsideLegend = this.group.visible && legendBBox.containsPoint(offsetX, offsetY);\r\n        if (!pointerInsideLegend) {\r\n            this.ctx.cursorManager.updateCursor(this.id);\r\n            this.ctx.highlightManager.updateHighlight(this.id);\r\n            this.ctx.tooltipManager.removeTooltip(this.id);\r\n            return;\r\n        }\r\n        // Prevent other handlers from consuming this event if it's generated inside the legend\r\n        // boundaries.\r\n        event.consume();\r\n        const datum = this.getDatumForPoint(offsetX, offsetY);\r\n        const pointerOverLegendDatum = pointerInsideLegend && datum !== undefined;\r\n        if (!pointerOverLegendDatum) {\r\n            this.ctx.cursorManager.updateCursor(this.id);\r\n            this.ctx.highlightManager.updateHighlight(this.id);\r\n            return;\r\n        }\r\n        const series = datum ? this.ctx.dataService.getSeries().find((series) => series.id === (datum === null || datum === void 0 ? void 0 : datum.id)) : undefined;\r\n        if (datum && this.truncatedItems.has((_a = datum.itemId) !== null && _a !== void 0 ? _a : datum.id)) {\r\n            this.ctx.tooltipManager.updateTooltip(this.id, { pageX, pageY, offsetX, offsetY, event, showArrow: false }, toTooltipHtml({ content: this.getItemLabel(datum) }));\r\n        }\r\n        else {\r\n            this.ctx.tooltipManager.removeTooltip(this.id);\r\n        }\r\n        if (toggleSeriesVisible || listeners.legendItemClick != null || listeners.legendItemDoubleClick != null) {\r\n            this.ctx.cursorManager.updateCursor(this.id, 'pointer');\r\n        }\r\n        if ((datum === null || datum === void 0 ? void 0 : datum.enabled) && series) {\r\n            this.ctx.highlightManager.updateHighlight(this.id, {\r\n                series,\r\n                itemId: datum === null || datum === void 0 ? void 0 : datum.itemId,\r\n                datum: undefined,\r\n            });\r\n        }\r\n        else {\r\n            this.ctx.highlightManager.updateHighlight(this.id);\r\n        }\r\n    }\r\n    positionLegend(shrinkRect) {\r\n        const newShrinkRect = shrinkRect.clone();\r\n        if (!this.enabled || !this.data.length) {\r\n            return { shrinkRect: newShrinkRect };\r\n        }\r\n        const [legendWidth, legendHeight] = this.calculateLegendDimensions(shrinkRect);\r\n        this.group.translationX = 0;\r\n        this.group.translationY = 0;\r\n        this.performLayout(legendWidth, legendHeight);\r\n        const legendBBox = this.computePagedBBox();\r\n        const calculateTranslationPerpendicularDimension = () => {\r\n            switch (this.position) {\r\n                case 'top':\r\n                case 'left':\r\n                    return 0;\r\n                case 'bottom':\r\n                    return shrinkRect.height - legendBBox.height;\r\n                case 'right':\r\n                default:\r\n                    return shrinkRect.width - legendBBox.width;\r\n            }\r\n        };\r\n        if (this.visible) {\r\n            let translationX;\r\n            let translationY;\r\n            switch (this.position) {\r\n                case 'top':\r\n                case 'bottom':\r\n                    translationX = (shrinkRect.width - legendBBox.width) / 2;\r\n                    translationY = calculateTranslationPerpendicularDimension();\r\n                    newShrinkRect.shrink(legendBBox.height, this.position);\r\n                    break;\r\n                case 'left':\r\n                case 'right':\r\n                default:\r\n                    translationX = calculateTranslationPerpendicularDimension();\r\n                    translationY = (shrinkRect.height - legendBBox.height) / 2;\r\n                    newShrinkRect.shrink(legendBBox.width, this.position);\r\n            }\r\n            // Round off for pixel grid alignment to work properly.\r\n            this.group.translationX = Math.floor(-legendBBox.x + shrinkRect.x + translationX);\r\n            this.group.translationY = Math.floor(-legendBBox.y + shrinkRect.y + translationY);\r\n        }\r\n        if (this.visible && this.enabled && this.data.length) {\r\n            const legendPadding = this.spacing;\r\n            newShrinkRect.shrink(legendPadding, this.position);\r\n            const legendPositionedBBox = legendBBox.clone();\r\n            legendPositionedBBox.x += this.group.translationX;\r\n            legendPositionedBBox.y += this.group.translationY;\r\n            this.ctx.tooltipManager.updateExclusiveRect(this.id, legendPositionedBBox);\r\n        }\r\n        else {\r\n            this.ctx.tooltipManager.updateExclusiveRect(this.id);\r\n        }\r\n        return { shrinkRect: newShrinkRect };\r\n    }\r\n    calculateLegendDimensions(shrinkRect) {\r\n        const { width, height } = shrinkRect;\r\n        const aspectRatio = width / height;\r\n        const maxCoefficient = 0.5;\r\n        const minHeightCoefficient = 0.2;\r\n        const minWidthCoefficient = 0.25;\r\n        let legendWidth, legendHeight;\r\n        switch (this.position) {\r\n            case 'top':\r\n            case 'bottom':\r\n                // A horizontal legend should take maximum between 20 to 50 percent of the chart height if height is larger than width\r\n                // and maximum 20 percent of the chart height if height is smaller than width.\r\n                const heightCoefficient = aspectRatio < 1\r\n                    ? Math.min(maxCoefficient, minHeightCoefficient * (1 / aspectRatio))\r\n                    : minHeightCoefficient;\r\n                legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : width;\r\n                legendHeight = this.maxHeight\r\n                    ? Math.min(this.maxHeight, height)\r\n                    : Math.round(height * heightCoefficient);\r\n                break;\r\n            case 'left':\r\n            case 'right':\r\n            default:\r\n                // A vertical legend should take maximum between 25 to 50 percent of the chart width if width is larger than height\r\n                // and maximum 25 percent of the chart width if width is smaller than height.\r\n                const widthCoefficient = aspectRatio > 1 ? Math.min(maxCoefficient, minWidthCoefficient * aspectRatio) : minWidthCoefficient;\r\n                legendWidth = this.maxWidth ? Math.min(this.maxWidth, width) : Math.round(width * widthCoefficient);\r\n                legendHeight = this.maxHeight ? Math.min(this.maxHeight, height) : height;\r\n        }\r\n        return [legendWidth, legendHeight];\r\n    }\r\n}\r\nLegend.className = 'Legend';\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], Legend.prototype, \"_enabled\", void 0);\r\n__decorate([\r\n    Validate(POSITION),\r\n    __metadata(\"design:type\", String)\r\n], Legend.prototype, \"position\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Legend.prototype, \"maxWidth\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], Legend.prototype, \"maxHeight\", void 0);\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], Legend.prototype, \"reverseOrder\", void 0);\r\n__decorate([\r\n    Validate(OPT_ORIENTATION),\r\n    __metadata(\"design:type\", String)\r\n], Legend.prototype, \"orientation\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], Legend.prototype, \"spacing\", void 0);\n\nclass Overlay {\r\n    constructor(className, parent, document) {\r\n        this.text = undefined;\r\n        this.className = className;\r\n        this.parentElement = parent;\r\n        this.document = document;\r\n    }\r\n    show(rect) {\r\n        var _a, _b;\r\n        let element = this.element;\r\n        if (!element) {\r\n            element = this.document.createElement('div');\r\n            element.className = this.className;\r\n            this.element = element;\r\n        }\r\n        element.style.position = 'absolute';\r\n        element.style.left = `${rect.x}px`;\r\n        element.style.top = `${rect.y}px`;\r\n        element.style.width = `${rect.width}px`;\r\n        element.style.height = `${rect.height}px`;\r\n        if (this.renderer) {\r\n            element.innerHTML = this.renderer();\r\n        }\r\n        else {\r\n            const content = this.document.createElement('div');\r\n            content.style.alignItems = 'center';\r\n            content.style.boxSizing = 'border-box';\r\n            content.style.display = 'flex';\r\n            content.style.justifyContent = 'center';\r\n            content.style.margin = '8px';\r\n            content.style.height = '100%';\r\n            content.style.font = '12px Verdana, sans-serif';\r\n            content.innerText = (_a = this.text) !== null && _a !== void 0 ? _a : 'No data to display';\r\n            element.append(content);\r\n        }\r\n        (_b = this.parentElement) === null || _b === void 0 ? void 0 : _b.append(element);\r\n    }\r\n    hide() {\r\n        var _a;\r\n        (_a = this.element) === null || _a === void 0 ? void 0 : _a.remove();\r\n        this.element = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    __metadata(\"design:type\", Function)\r\n], Overlay.prototype, \"renderer\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], Overlay.prototype, \"text\", void 0);\n\nclass ChartOverlays {\r\n    constructor(parent) {\r\n        this.noData = new Overlay('ag-chart-no-data-overlay', parent, parent.ownerDocument);\r\n    }\r\n}\n\nconst SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION = 30;\r\nclass SeriesLayerManager {\r\n    constructor(rootGroup) {\r\n        this.groups = {};\r\n        this.series = {};\r\n        this.expectedSeriesCount = 1;\r\n        this.mode = 'normal';\r\n        this.rootGroup = rootGroup;\r\n    }\r\n    setSeriesCount(count) {\r\n        this.expectedSeriesCount = count;\r\n    }\r\n    requestGroup(seriesConfig) {\r\n        var _a, _b;\r\n        var _c, _d;\r\n        const { id, type, rootGroup: seriesRootGroup, highlightGroup: seriesHighlightGroup, annotationGroup: seriesAnnotationGroup, seriesGrouping, } = seriesConfig;\r\n        const { groupIndex = id } = seriesGrouping !== null && seriesGrouping !== void 0 ? seriesGrouping : {};\r\n        if (this.series[id] != null) {\r\n            throw new Error(`AG Charts - series already has an allocated layer: ${this.series[id]}`);\r\n        }\r\n        // Re-evaluate mode only on first series addition - we can't swap strategy mid-setup.\r\n        if (Object.keys(this.series).length === 0) {\r\n            this.mode =\r\n                this.expectedSeriesCount >= SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION\r\n                    ? 'aggressive-grouping'\r\n                    : 'normal';\r\n        }\r\n        (_a = (_c = this.groups)[type]) !== null && _a !== void 0 ? _a : (_c[type] = {});\r\n        const lookupIndex = this.lookupIdx(groupIndex);\r\n        let groupInfo = this.groups[type][lookupIndex];\r\n        if (!groupInfo) {\r\n            groupInfo = (_b = (_d = this.groups[type])[lookupIndex]) !== null && _b !== void 0 ? _b : (_d[lookupIndex] = {\r\n                seriesIds: [],\r\n                group: this.rootGroup.appendChild(new Group({\r\n                    name: `${type}-content`,\r\n                    layer: true,\r\n                    zIndex: Layers.SERIES_LAYER_ZINDEX,\r\n                    zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder('data'),\r\n                })),\r\n                highlight: this.rootGroup.appendChild(new Group({\r\n                    name: `${type}-highlight`,\r\n                    layer: true,\r\n                    zIndex: Layers.SERIES_LAYER_ZINDEX,\r\n                    zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder('highlight'),\r\n                })),\r\n                annotation: this.rootGroup.appendChild(new Group({\r\n                    name: `${type}-annotation`,\r\n                    layer: true,\r\n                    zIndex: Layers.SERIES_LAYER_ZINDEX,\r\n                    zIndexSubOrder: seriesConfig.getGroupZIndexSubOrder('annotation'),\r\n                })),\r\n            });\r\n        }\r\n        this.series[id] = { layerState: groupInfo, seriesConfig };\r\n        groupInfo.seriesIds.push(id);\r\n        groupInfo.group.appendChild(seriesRootGroup);\r\n        groupInfo.highlight.appendChild(seriesHighlightGroup);\r\n        groupInfo.annotation.appendChild(seriesAnnotationGroup);\r\n        return groupInfo.group;\r\n    }\r\n    changeGroup(seriesConfig) {\r\n        var _a, _b;\r\n        const { id, seriesGrouping, type, rootGroup, highlightGroup, annotationGroup, oldGrouping } = seriesConfig;\r\n        const { groupIndex = id } = seriesGrouping !== null && seriesGrouping !== void 0 ? seriesGrouping : {};\r\n        if ((_b = (_a = this.groups[type]) === null || _a === void 0 ? void 0 : _a[groupIndex]) === null || _b === void 0 ? void 0 : _b.seriesIds.includes(id)) {\r\n            // Already in the right group, nothing to do.\r\n            return;\r\n        }\r\n        if (this.series[id] != null) {\r\n            this.releaseGroup({ id, seriesGrouping: oldGrouping, type, rootGroup, highlightGroup, annotationGroup });\r\n        }\r\n        this.requestGroup(seriesConfig);\r\n    }\r\n    releaseGroup(seriesConfig) {\r\n        var _a, _b, _c, _d, _e;\r\n        const { id, seriesGrouping, rootGroup, highlightGroup, annotationGroup, type } = seriesConfig;\r\n        const { groupIndex = id } = seriesGrouping !== null && seriesGrouping !== void 0 ? seriesGrouping : {};\r\n        if (this.series[id] == null) {\r\n            throw new Error(`AG Charts - series doesn't have an allocated layer: ${id}`);\r\n        }\r\n        const lookupIndex = this.lookupIdx(groupIndex);\r\n        const groupInfo = (_b = (_a = this.groups[type]) === null || _a === void 0 ? void 0 : _a[lookupIndex]) !== null && _b !== void 0 ? _b : (_c = this.series[id]) === null || _c === void 0 ? void 0 : _c.layerState;\r\n        if (groupInfo) {\r\n            groupInfo.seriesIds = groupInfo.seriesIds.filter((v) => v !== id);\r\n            groupInfo.group.removeChild(rootGroup);\r\n            groupInfo.highlight.removeChild(highlightGroup);\r\n            groupInfo.annotation.removeChild(annotationGroup);\r\n        }\r\n        if ((groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.seriesIds.length) === 0) {\r\n            // Last member of the layer, cleanup.\r\n            this.rootGroup.removeChild(groupInfo.group);\r\n            this.rootGroup.removeChild(groupInfo.highlight);\r\n            this.rootGroup.removeChild(groupInfo.annotation);\r\n            delete this.groups[type][lookupIndex];\r\n            delete this.groups[type][id];\r\n        }\r\n        else if ((groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.seriesIds.length) > 0) {\r\n            // Update zIndexSubOrder to avoid it becoming stale as series are removed and re-added\r\n            // with the same groupIndex, but are otherwise unrelated.\r\n            const leadSeriesConfig = (_e = this.series[(_d = groupInfo === null || groupInfo === void 0 ? void 0 : groupInfo.seriesIds) === null || _d === void 0 ? void 0 : _d[0]]) === null || _e === void 0 ? void 0 : _e.seriesConfig;\r\n            groupInfo.group.zIndexSubOrder = leadSeriesConfig === null || leadSeriesConfig === void 0 ? void 0 : leadSeriesConfig.getGroupZIndexSubOrder('data');\r\n            groupInfo.highlight.zIndexSubOrder = leadSeriesConfig === null || leadSeriesConfig === void 0 ? void 0 : leadSeriesConfig.getGroupZIndexSubOrder('highlight');\r\n            groupInfo.annotation.zIndexSubOrder = leadSeriesConfig === null || leadSeriesConfig === void 0 ? void 0 : leadSeriesConfig.getGroupZIndexSubOrder('annotation');\r\n        }\r\n        delete this.series[id];\r\n    }\r\n    lookupIdx(groupIndex) {\r\n        if (this.mode === 'normal') {\r\n            return groupIndex;\r\n        }\r\n        if (typeof groupIndex === 'string') {\r\n            groupIndex = Number(groupIndex.split('-').slice(-1)[0]);\r\n            if (!groupIndex)\r\n                return 0;\r\n        }\r\n        return Math.floor(Math.max(Math.min(groupIndex / this.expectedSeriesCount, 1), 0) *\r\n            SERIES_THRESHOLD_FOR_AGGRESSIVE_LAYER_REDUCTION);\r\n    }\r\n    destroy() {\r\n        for (const groups of Object.values(this.groups)) {\r\n            for (const groupInfo of Object.values(groups)) {\r\n                this.rootGroup.removeChild(groupInfo.group);\r\n                this.rootGroup.removeChild(groupInfo.highlight);\r\n                this.rootGroup.removeChild(groupInfo.annotation);\r\n            }\r\n        }\r\n        this.groups = {};\r\n        this.series = {};\r\n    }\r\n}\n\nclass SeriesStateManager {\r\n    constructor() {\r\n        this.groups = {};\r\n    }\r\n    registerSeries({ id, seriesGrouping, visible, type, }) {\r\n        var _a;\r\n        var _b;\r\n        if (!seriesGrouping)\r\n            return;\r\n        (_a = (_b = this.groups)[type]) !== null && _a !== void 0 ? _a : (_b[type] = {});\r\n        this.groups[type][id] = { grouping: seriesGrouping, visible };\r\n    }\r\n    deregisterSeries({ id, type }) {\r\n        if (this.groups[type]) {\r\n            delete this.groups[type][id];\r\n        }\r\n        if (this.groups[type] && Object.keys(this.groups[type]).length === 0) {\r\n            delete this.groups[type];\r\n        }\r\n    }\r\n    getVisiblePeerGroupIndex({ type, seriesGrouping }) {\r\n        var _a;\r\n        if (!seriesGrouping)\r\n            return { visibleGroupCount: 1, index: 0 };\r\n        const visibleGroups = [\r\n            ...Object.entries((_a = this.groups[type]) !== null && _a !== void 0 ? _a : {})\r\n                .filter(([_, entry]) => entry.visible)\r\n                .reduce((result, [_, next]) => {\r\n                if (next.visible) {\r\n                    result.add(next.grouping.groupIndex);\r\n                }\r\n                return result;\r\n            }, new Set())\r\n                .values(),\r\n        ];\r\n        visibleGroups.sort((a, b) => a - b);\r\n        return {\r\n            visibleGroupCount: visibleGroups.length,\r\n            index: visibleGroups.indexOf(seriesGrouping.groupIndex),\r\n        };\r\n    }\r\n}\n\nclass BaseLayoutProcessor {\r\n    constructor(chartLike, layoutService) {\r\n        this.chartLike = chartLike;\r\n        this.layoutService = layoutService;\r\n        this.destroyFns = [];\r\n        this.destroyFns.push(\r\n        // eslint-disable-next-line sonarjs/no-duplicate-string\r\n        this.layoutService.addListener('layout-complete', (e) => this.layoutComplete(e)), this.layoutService.addListener('start-layout', (e) => this.positionPadding(e.shrinkRect)), this.layoutService.addListener('start-layout', (e) => this.positionCaptions(e.shrinkRect)));\r\n    }\r\n    destroy() {\r\n        this.destroyFns.forEach((cb) => cb());\r\n    }\r\n    layoutComplete({ clipSeries, series: { paddedRect } }) {\r\n        const { seriesArea, seriesRoot } = this.chartLike;\r\n        if (seriesArea.clip || clipSeries) {\r\n            seriesRoot.setClipRectInGroupCoordinateSpace(paddedRect);\r\n        }\r\n        else {\r\n            seriesRoot.setClipRectInGroupCoordinateSpace();\r\n        }\r\n    }\r\n    positionPadding(shrinkRect) {\r\n        const { padding } = this.chartLike;\r\n        shrinkRect.shrink(padding.left, 'left');\r\n        shrinkRect.shrink(padding.top, 'top');\r\n        shrinkRect.shrink(padding.right, 'right');\r\n        shrinkRect.shrink(padding.bottom, 'bottom');\r\n        return { shrinkRect };\r\n    }\r\n    positionCaptions(shrinkRect) {\r\n        var _a, _b, _c, _d;\r\n        const { title, subtitle, footnote } = this.chartLike;\r\n        const newShrinkRect = shrinkRect.clone();\r\n        const updateCaption = (caption) => {\r\n            var _a;\r\n            const defaultCaptionHeight = shrinkRect.height / 10;\r\n            const captionLineHeight = (_a = caption.lineHeight) !== null && _a !== void 0 ? _a : caption.fontSize * Text.defaultLineHeightRatio;\r\n            const maxWidth = shrinkRect.width;\r\n            const maxHeight = Math.max(captionLineHeight, defaultCaptionHeight);\r\n            caption.computeTextWrap(maxWidth, maxHeight);\r\n        };\r\n        const positionTopAndShrinkBBox = (caption, spacing) => {\r\n            const baseY = newShrinkRect.y;\r\n            caption.node.x = newShrinkRect.x + newShrinkRect.width / 2;\r\n            caption.node.y = baseY;\r\n            caption.node.textBaseline = 'top';\r\n            updateCaption(caption);\r\n            const bbox = caption.node.computeBBox();\r\n            // As the bbox (x,y) ends up at a different location than specified above, we need to\r\n            // take it into consideration when calculating how much space needs to be reserved to\r\n            // accommodate the caption.\r\n            const bboxHeight = Math.ceil(bbox.y - baseY + bbox.height + spacing);\r\n            newShrinkRect.shrink(bboxHeight, 'top');\r\n        };\r\n        const positionBottomAndShrinkBBox = (caption, spacing) => {\r\n            const baseY = newShrinkRect.y + newShrinkRect.height;\r\n            caption.node.x = newShrinkRect.x + newShrinkRect.width / 2;\r\n            caption.node.y = baseY;\r\n            caption.node.textBaseline = 'bottom';\r\n            updateCaption(caption);\r\n            const bbox = caption.node.computeBBox();\r\n            const bboxHeight = Math.ceil(baseY - bbox.y + spacing);\r\n            newShrinkRect.shrink(bboxHeight, 'bottom');\r\n        };\r\n        if (subtitle) {\r\n            subtitle.node.visible = (_a = subtitle.enabled) !== null && _a !== void 0 ? _a : false;\r\n        }\r\n        if (title) {\r\n            title.node.visible = title.enabled;\r\n            if (title.node.visible) {\r\n                const defaultTitleSpacing = (subtitle === null || subtitle === void 0 ? void 0 : subtitle.node.visible) ? Caption.SMALL_PADDING : Caption.LARGE_PADDING;\r\n                const spacing = (_b = title.spacing) !== null && _b !== void 0 ? _b : defaultTitleSpacing;\r\n                positionTopAndShrinkBBox(title, spacing);\r\n            }\r\n        }\r\n        if (subtitle && subtitle.node.visible) {\r\n            positionTopAndShrinkBBox(subtitle, (_c = subtitle.spacing) !== null && _c !== void 0 ? _c : 0);\r\n        }\r\n        if (footnote) {\r\n            footnote.node.visible = footnote.enabled;\r\n            if (footnote.node.visible) {\r\n                positionBottomAndShrinkBBox(footnote, (_d = footnote.spacing) !== null && _d !== void 0 ? _d : 0);\r\n            }\r\n        }\r\n        return { shrinkRect: newShrinkRect };\r\n    }\r\n}\n\nclass UpdateService extends Listeners {\r\n    constructor(updateCallback) {\r\n        super();\r\n        this.updateCallback = updateCallback;\r\n    }\r\n    update(type = ChartUpdateType.FULL, { forceNodeDataRefresh = false, skipAnimations = false } = {}) {\r\n        this.updateCallback(type, { forceNodeDataRefresh, skipAnimations });\r\n    }\r\n    dispatchUpdateComplete(minRect) {\r\n        const event = { type: 'update-complete', minRect };\r\n        this.dispatch('update-complete', event);\r\n    }\r\n}\n\nfunction initialiseSpecialOverrides(opts) {\r\n    let globalWindow;\r\n    if (opts.window != null) {\r\n        globalWindow = opts.window;\r\n    }\r\n    else if (typeof window !== 'undefined') {\r\n        globalWindow = window;\r\n    }\r\n    else if (typeof global !== 'undefined') {\r\n        globalWindow = global.window;\r\n    }\r\n    else {\r\n        throw new Error('AG Charts - unable to resolve global window');\r\n    }\r\n    let globalDocument;\r\n    if (opts.document != null) {\r\n        globalDocument = opts.document;\r\n    }\r\n    else if (typeof document !== 'undefined') {\r\n        globalDocument = document;\r\n    }\r\n    else if (typeof global !== 'undefined') {\r\n        globalDocument = global.document;\r\n    }\r\n    else {\r\n        throw new Error('AG Charts - unable to resolve global document');\r\n    }\r\n    return {\r\n        document: globalDocument,\r\n        window: globalWindow,\r\n        overrideDevicePixelRatio: opts.overrideDevicePixelRatio,\r\n        sceneMode: opts.sceneMode,\r\n    };\r\n}\r\nclass SeriesArea {\r\n    constructor() {\r\n        this.clip = undefined;\r\n        this.padding = new Padding(0);\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], SeriesArea.prototype, \"clip\", void 0);\r\nclass Chart extends Observable {\r\n    getOptions() {\r\n        var _a;\r\n        const { queuedUserOptions } = this;\r\n        const lastUpdateOptions = (_a = queuedUserOptions[queuedUserOptions.length - 1]) !== null && _a !== void 0 ? _a : this.userOptions;\r\n        return jsonMerge([lastUpdateOptions]);\r\n    }\r\n    autoSizeChanged(value) {\r\n        const { style } = this.element;\r\n        if (value) {\r\n            style.display = 'block';\r\n            style.width = '100%';\r\n            style.height = '100%';\r\n            if (!this._lastAutoSize) {\r\n                return;\r\n            }\r\n            this.resize(undefined, undefined, 'autoSize option');\r\n        }\r\n        else {\r\n            style.display = 'inline-block';\r\n            style.width = 'auto';\r\n            style.height = 'auto';\r\n        }\r\n    }\r\n    download(fileName, fileFormat) {\r\n        this.scene.download(fileName, fileFormat);\r\n    }\r\n    get destroyed() {\r\n        return this._destroyed;\r\n    }\r\n    constructor(specialOverrides, resources) {\r\n        var _a;\r\n        super();\r\n        this.id = createId(this);\r\n        this.processedOptions = {};\r\n        this.userOptions = {};\r\n        this.queuedUserOptions = [];\r\n        this.seriesRoot = new Group({ name: `${this.id}-Series-root` });\r\n        this.debug = Debug.create();\r\n        this.extraDebugStats = {};\r\n        this.container = undefined;\r\n        this.data = [];\r\n        this._firstAutoSize = true;\r\n        this.padding = new Padding(20);\r\n        this.seriesArea = new SeriesArea();\r\n        this.title = undefined;\r\n        this.subtitle = undefined;\r\n        this.footnote = undefined;\r\n        this.mode = 'standalone';\r\n        this._destroyed = false;\r\n        this._destroyFns = [];\r\n        this.modules = {};\r\n        this.legendModules = {};\r\n        this.processors = [];\r\n        this.legends = new Map();\r\n        this._pendingFactoryUpdatesCount = 0;\r\n        this._performUpdateNoRenderCount = 0;\r\n        this._performUpdateType = ChartUpdateType.NONE;\r\n        this._performUpdateSkipAnimations = false;\r\n        this.updateShortcutCount = 0;\r\n        this.seriesToUpdate = new Set();\r\n        this.updateMutex = new Mutex();\r\n        this.updateRequestors = {};\r\n        this.performUpdateTrigger = debouncedCallback(({ count }) => __awaiter(this, void 0, void 0, function* () {\r\n            if (this._destroyed)\r\n                return;\r\n            this.updateMutex.acquire(() => __awaiter(this, void 0, void 0, function* () {\r\n                try {\r\n                    yield this.performUpdate(count);\r\n                }\r\n                catch (error) {\r\n                    this._lastPerformUpdateError = error;\r\n                    Logger.error('update error', error);\r\n                }\r\n            }));\r\n        }));\r\n        this._axes = [];\r\n        this._series = [];\r\n        this.lastInteractionEvent = undefined;\r\n        this.pointerScheduler = debouncedAnimationFrame(() => {\r\n            if (this.lastInteractionEvent) {\r\n                this.handlePointer(this.lastInteractionEvent);\r\n            }\r\n            this.lastInteractionEvent = undefined;\r\n        });\r\n        this.onSeriesNodeClick = (event) => {\r\n            const seriesNodeClickEvent = Object.assign(Object.assign({}, event), { type: 'seriesNodeClick' });\r\n            Object.defineProperty(seriesNodeClickEvent, 'series', {\r\n                enumerable: false,\r\n                // Should display the deprecation warning\r\n                get: () => event.series,\r\n            });\r\n            this.fireEvent(seriesNodeClickEvent);\r\n        };\r\n        this.onSeriesNodeDoubleClick = (event) => {\r\n            const seriesNodeDoubleClick = Object.assign(Object.assign({}, event), { type: 'seriesNodeDoubleClick' });\r\n            this.fireEvent(seriesNodeDoubleClick);\r\n        };\r\n        this.specialOverrides = initialiseSpecialOverrides(specialOverrides);\r\n        const { window, document } = this.specialOverrides;\r\n        const scene = resources === null || resources === void 0 ? void 0 : resources.scene;\r\n        const element = (_a = resources === null || resources === void 0 ? void 0 : resources.element) !== null && _a !== void 0 ? _a : document.createElement('div');\r\n        const container = resources === null || resources === void 0 ? void 0 : resources.container;\r\n        const root = new Group({ name: 'root' });\r\n        // Prevent the scene from rendering chart components in an invalid state\r\n        // (before first layout is performed).\r\n        root.visible = false;\r\n        root.append(this.seriesRoot);\r\n        this.axisGridGroup = new Group({ name: 'Axes-Grids', layer: true, zIndex: Layers.AXIS_GRID_ZINDEX });\r\n        root.appendChild(this.axisGridGroup);\r\n        this.axisGroup = new Group({ name: 'Axes', layer: true, zIndex: Layers.AXIS_ZINDEX });\r\n        root.appendChild(this.axisGroup);\r\n        this.element = element;\r\n        element.classList.add('ag-chart-wrapper');\r\n        element.style.position = 'relative';\r\n        this.scene = scene !== null && scene !== void 0 ? scene : new Scene(this.specialOverrides);\r\n        this.scene.root = root;\r\n        this.scene.container = element;\r\n        this.autoSize = true;\r\n        this.chartEventManager = new ChartEventManager();\r\n        this.cursorManager = new CursorManager(element);\r\n        this.highlightManager = new HighlightManager();\r\n        this.interactionManager = new InteractionManager(element, document, window);\r\n        this.zoomManager = new ZoomManager();\r\n        this.dataService = new DataService(() => this.series);\r\n        this.layoutService = new LayoutService();\r\n        this.updateService = new UpdateService((type = ChartUpdateType.FULL, { forceNodeDataRefresh, skipAnimations }) => this.update(type, { forceNodeDataRefresh, skipAnimations }));\r\n        this.seriesStateManager = new SeriesStateManager();\r\n        this.seriesLayerManager = new SeriesLayerManager(this.seriesRoot);\r\n        this.callbackCache = new CallbackCache();\r\n        this.animationManager = new AnimationManager(this.interactionManager, this.updateMutex);\r\n        this.animationManager.skip();\r\n        this.animationManager.play();\r\n        this.processors = [new BaseLayoutProcessor(this, this.layoutService)];\r\n        this.tooltip = new Tooltip(this.scene.canvas.element, document, window, document.body);\r\n        this.tooltipManager = new TooltipManager(this.tooltip, this.interactionManager);\r\n        this.overlays = new ChartOverlays(this.element);\r\n        this.highlight = new ChartHighlight();\r\n        this.container = container;\r\n        SizeMonitor.observe(this.element, (size) => this.rawResize(size));\r\n        this._destroyFns.push(this.interactionManager.addListener('click', (event) => this.onClick(event)), this.interactionManager.addListener('dblclick', (event) => this.onDoubleClick(event)), this.interactionManager.addListener('hover', (event) => this.onMouseMove(event)), this.interactionManager.addListener('leave', (event) => this.onLeave(event)), this.interactionManager.addListener('page-left', () => this.destroy()), this.interactionManager.addListener('wheel', () => this.disablePointer()), \r\n        // Block redundant and interfering attempts to update the hovered element during dragging.\r\n        this.interactionManager.addListener('drag-start', () => this.disablePointer()), this.animationManager.addListener('animation-frame', (_) => {\r\n            this.update(ChartUpdateType.SCENE_RENDER);\r\n        }), this.highlightManager.addListener('highlight-change', (event) => this.changeHighlightDatum(event)), this.zoomManager.addListener('zoom-change', (_) => this.update(ChartUpdateType.PROCESS_DATA, { forceNodeDataRefresh: true, skipAnimations: true })));\r\n        this.legend = this.attachLegend('category', Legend);\r\n    }\r\n    addModule(module) {\r\n        if (this.modules[module.optionsKey] != null) {\r\n            throw new Error('AG Charts - module already initialised: ' + module.optionsKey);\r\n        }\r\n        const moduleInstance = new module.instanceConstructor(this.getModuleContext());\r\n        this.modules[module.optionsKey] = { instance: moduleInstance };\r\n        this[module.optionsKey] = moduleInstance; // TODO remove\r\n    }\r\n    removeModule(module) {\r\n        var _a;\r\n        (_a = this.modules[module.optionsKey]) === null || _a === void 0 ? void 0 : _a.instance.destroy();\r\n        delete this.modules[module.optionsKey];\r\n        delete this[module.optionsKey]; // TODO remove\r\n    }\r\n    attachLegend(legendType, legendConstructor) {\r\n        const legend = new legendConstructor(this.getModuleContext());\r\n        this.legends.set(legendType, legend);\r\n        legend.attachLegend(this.scene.root);\r\n        return legend;\r\n    }\r\n    addLegendModule(module) {\r\n        if (this.modules[module.optionsKey] != null) {\r\n            throw new Error('AG Charts - module already initialised: ' + module.optionsKey);\r\n        }\r\n        const legend = this.attachLegend(module.identifier, module.instanceConstructor);\r\n        this.modules[module.optionsKey] = { instance: legend };\r\n        this[module.optionsKey] = legend;\r\n    }\r\n    removeLegendModule(module) {\r\n        this.legends.delete(module.identifier);\r\n        this.removeModule(module);\r\n    }\r\n    isModuleEnabled(module) {\r\n        return this.modules[module.optionsKey] != null;\r\n    }\r\n    getModuleContext() {\r\n        const { scene, animationManager, chartEventManager, cursorManager, highlightManager, interactionManager, tooltipManager, zoomManager, dataService, layoutService, updateService, seriesStateManager, seriesLayerManager, mode, callbackCache, specialOverrides: { window, document }, } = this;\r\n        return {\r\n            window,\r\n            document,\r\n            scene,\r\n            animationManager,\r\n            chartEventManager,\r\n            cursorManager,\r\n            highlightManager,\r\n            interactionManager,\r\n            tooltipManager,\r\n            zoomManager,\r\n            dataService,\r\n            layoutService,\r\n            updateService,\r\n            mode,\r\n            seriesStateManager,\r\n            seriesLayerManager,\r\n            callbackCache,\r\n        };\r\n    }\r\n    destroy(opts) {\r\n        if (this._destroyed) {\r\n            return;\r\n        }\r\n        const keepTransferableResources = opts === null || opts === void 0 ? void 0 : opts.keepTransferableResources;\r\n        let result;\r\n        this._performUpdateType = ChartUpdateType.NONE;\r\n        this._destroyFns.forEach((fn) => fn());\r\n        this.processors.forEach((p) => p.destroy());\r\n        this.tooltipManager.destroy();\r\n        this.tooltip.destroy();\r\n        Object.values(this.legends).forEach((legend) => legend.destroy());\r\n        this.legends.clear();\r\n        this.overlays.noData.hide();\r\n        SizeMonitor.unobserve(this.element);\r\n        for (const optionsKey of Object.keys(this.modules)) {\r\n            this.removeModule({ optionsKey });\r\n        }\r\n        this.interactionManager.destroy();\r\n        this.animationManager.stop();\r\n        if (keepTransferableResources) {\r\n            this.scene.strip();\r\n            result = { container: this.container, scene: this.scene, element: this.element };\r\n        }\r\n        else {\r\n            this.scene.destroy();\r\n            this.container = undefined;\r\n        }\r\n        this.removeAllSeries();\r\n        this.seriesLayerManager.destroy();\r\n        this.axes.forEach((a) => a.destroy());\r\n        this.axes = [];\r\n        this.callbackCache.invalidateCache();\r\n        this._destroyed = true;\r\n        return result;\r\n    }\r\n    disablePointer(highlightOnly = false) {\r\n        if (!highlightOnly) {\r\n            this.tooltipManager.removeTooltip(this.id);\r\n        }\r\n        this.highlightManager.updateHighlight(this.id);\r\n        if (this.lastInteractionEvent) {\r\n            this.lastInteractionEvent = undefined;\r\n        }\r\n    }\r\n    requestFactoryUpdate(cb) {\r\n        this._pendingFactoryUpdatesCount++;\r\n        this.updateMutex.acquire(() => __awaiter(this, void 0, void 0, function* () {\r\n            yield cb();\r\n            this._pendingFactoryUpdatesCount--;\r\n        }));\r\n    }\r\n    get performUpdateType() {\r\n        return this._performUpdateType;\r\n    }\r\n    get lastPerformUpdateError() {\r\n        return this._lastPerformUpdateError;\r\n    }\r\n    update(type = ChartUpdateType.FULL, opts) {\r\n        var _a, _b;\r\n        const { forceNodeDataRefresh = false, skipAnimations, seriesToUpdate = this.series, newAnimationBatch, } = opts !== null && opts !== void 0 ? opts : {};\r\n        if (forceNodeDataRefresh) {\r\n            this.series.forEach((series) => series.markNodeDataDirty());\r\n        }\r\n        for (const series of seriesToUpdate) {\r\n            this.seriesToUpdate.add(series);\r\n        }\r\n        if (skipAnimations) {\r\n            this.animationManager.skipCurrentBatch();\r\n            this._performUpdateSkipAnimations = true;\r\n        }\r\n        if (newAnimationBatch) {\r\n            if (this.animationManager.isActive()) {\r\n                this._performUpdateSkipAnimations = true;\r\n            }\r\n            else {\r\n                (_a = this._performUpdateSkipAnimations) !== null && _a !== void 0 ? _a : (this._performUpdateSkipAnimations = false);\r\n            }\r\n        }\r\n        if (Debug.check(true)) {\r\n            let stack = (_b = new Error().stack) !== null && _b !== void 0 ? _b : '<unknown>';\r\n            stack = stack.replace(/\\([^)]*/g, '');\r\n            this.updateRequestors[stack] = type;\r\n        }\r\n        if (type < this._performUpdateType) {\r\n            this._performUpdateType = type;\r\n            this.performUpdateTrigger.schedule(opts === null || opts === void 0 ? void 0 : opts.backOffMs);\r\n        }\r\n    }\r\n    performUpdate(count) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { _performUpdateType: performUpdateType, extraDebugStats } = this;\r\n            const seriesToUpdate = [...this.seriesToUpdate];\r\n            // Clear state immediately so that side-effects can be detected prior to SCENE_RENDER.\r\n            this._performUpdateType = ChartUpdateType.NONE;\r\n            this.seriesToUpdate.clear();\r\n            if (this.updateShortcutCount === 0 && performUpdateType < ChartUpdateType.SCENE_RENDER) {\r\n                this.animationManager.startBatch(this._performUpdateSkipAnimations);\r\n            }\r\n            this.debug('Chart.performUpdate() - start', ChartUpdateType[performUpdateType]);\r\n            const splits = { start: performance.now() };\r\n            switch (performUpdateType) {\r\n                case ChartUpdateType.FULL:\r\n                case ChartUpdateType.PROCESS_DATA:\r\n                    yield this.processData();\r\n                    this.disablePointer(true);\r\n                    splits['🏭'] = performance.now();\r\n                // fallthrough\r\n                case ChartUpdateType.PERFORM_LAYOUT:\r\n                    if (this.checkUpdateShortcut(ChartUpdateType.PERFORM_LAYOUT))\r\n                        break;\r\n                    if (!this.checkFirstAutoSize(seriesToUpdate))\r\n                        break;\r\n                    yield this.processLayout();\r\n                    splits['⌖'] = performance.now();\r\n                // fallthrough\r\n                case ChartUpdateType.SERIES_UPDATE:\r\n                    if (this.checkUpdateShortcut(ChartUpdateType.SERIES_UPDATE))\r\n                        break;\r\n                    const { seriesRect } = this;\r\n                    const seriesUpdates = [...seriesToUpdate].map((series) => series.update({ seriesRect }));\r\n                    yield Promise.all(seriesUpdates);\r\n                    splits['🤔'] = performance.now();\r\n                // fallthrough\r\n                case ChartUpdateType.TOOLTIP_RECALCULATION:\r\n                    if (this.checkUpdateShortcut(ChartUpdateType.TOOLTIP_RECALCULATION))\r\n                        break;\r\n                    const tooltipMeta = this.tooltipManager.getTooltipMeta(this.id);\r\n                    const isHovered = ((_a = tooltipMeta === null || tooltipMeta === void 0 ? void 0 : tooltipMeta.event) === null || _a === void 0 ? void 0 : _a.type) === 'hover';\r\n                    if (performUpdateType <= ChartUpdateType.SERIES_UPDATE && isHovered) {\r\n                        this.handlePointer(tooltipMeta.event);\r\n                    }\r\n                    splits['↖'] = performance.now();\r\n                // fallthrough\r\n                case ChartUpdateType.SCENE_RENDER:\r\n                    if (this.checkUpdateShortcut(ChartUpdateType.SCENE_RENDER))\r\n                        break;\r\n                    extraDebugStats['updateShortcutCount'] = this.updateShortcutCount;\r\n                    yield this.scene.render({ debugSplitTimes: splits, extraDebugStats });\r\n                    this.extraDebugStats = {};\r\n                // fallthrough\r\n                case ChartUpdateType.NONE:\r\n                    // Do nothing.\r\n                    this.updateShortcutCount = 0;\r\n                    this.updateRequestors = {};\r\n                    this._performUpdateSkipAnimations = undefined;\r\n                    this.animationManager.endBatch();\r\n            }\r\n            this.updateService.dispatchUpdateComplete(this.getMinRect());\r\n            const end = performance.now();\r\n            this.debug('Chart.performUpdate() - end', {\r\n                chart: this,\r\n                durationMs: Math.round((end - splits['start']) * 100) / 100,\r\n                count,\r\n                performUpdateType: ChartUpdateType[performUpdateType],\r\n            });\r\n        });\r\n    }\r\n    checkUpdateShortcut(checkUpdateType) {\r\n        const maxShortcuts = 3;\r\n        if (this.updateShortcutCount > maxShortcuts) {\r\n            Logger.warn(`exceeded the maximum number of simultaneous updates (${maxShortcuts + 1}), discarding changes and rendering`, this.updateRequestors);\r\n            return false;\r\n        }\r\n        if (this.performUpdateType <= checkUpdateType) {\r\n            // A previous step modified series state, and we need to re-run this or an earlier step before rendering.\r\n            this.updateShortcutCount++;\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    checkFirstAutoSize(seriesToUpdate) {\r\n        if (this.autoSize && !this._lastAutoSize) {\r\n            const count = this._performUpdateNoRenderCount++;\r\n            const backOffMs = (count ^ 2) * 10;\r\n            if (count < 8) {\r\n                // Reschedule if canvas size hasn't been set yet to avoid a race.\r\n                this.update(ChartUpdateType.PERFORM_LAYOUT, { seriesToUpdate, backOffMs });\r\n                this.debug('Chart.checkFirstAutoSize() - backing off until first size update', backOffMs);\r\n                return false;\r\n            }\r\n            // After several failed passes, continue and accept there maybe a redundant\r\n            // render. Sometimes this case happens when we already have the correct\r\n            // width/height, and we end up never rendering the chart in that scenario.\r\n            this.debug('Chart.checkFirstAutoSize() - timeout for first size update.');\r\n        }\r\n        this._performUpdateNoRenderCount = 0;\r\n        return true;\r\n    }\r\n    set axes(values) {\r\n        const removedAxes = new Set();\r\n        this._axes.forEach((axis) => {\r\n            axis.detachAxis(this.axisGroup, this.axisGridGroup);\r\n            removedAxes.add(axis);\r\n        });\r\n        // make linked axes go after the regular ones (simulates stable sort by `linkedTo` property)\r\n        this._axes = values.filter((a) => !a.linkedTo).concat(values.filter((a) => a.linkedTo));\r\n        this._axes.forEach((axis) => {\r\n            axis.attachAxis(this.axisGroup, this.axisGridGroup);\r\n            removedAxes.delete(axis);\r\n        });\r\n        this.zoomManager.updateAxes(this._axes);\r\n        removedAxes.forEach((axis) => axis.destroy());\r\n    }\r\n    get axes() {\r\n        return this._axes;\r\n    }\r\n    set series(values) {\r\n        this.removeAllSeries();\r\n        this.seriesLayerManager.setSeriesCount(values.length);\r\n        values.forEach((series) => this.addSeries(series));\r\n    }\r\n    get series() {\r\n        return this._series;\r\n    }\r\n    addSeries(series) {\r\n        const { series: allSeries } = this;\r\n        const canAdd = allSeries.indexOf(series) < 0;\r\n        if (canAdd) {\r\n            allSeries.push(series);\r\n            if (series.rootGroup.parent == null) {\r\n                this.seriesLayerManager.requestGroup(series);\r\n            }\r\n            this.initSeries(series);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    initSeries(series) {\r\n        const chart = this;\r\n        series.chart = {\r\n            get mode() {\r\n                return chart.mode;\r\n            },\r\n            get seriesRect() {\r\n                return chart.seriesRect;\r\n            },\r\n            placeLabels() {\r\n                return chart.placeLabels();\r\n            },\r\n        };\r\n        series.setChartData(this.data);\r\n        this.addSeriesListeners(series);\r\n        series.addChartEventListeners();\r\n    }\r\n    removeAllSeries() {\r\n        this.series.forEach((series) => {\r\n            series.removeEventListener('nodeClick', this.onSeriesNodeClick);\r\n            series.removeEventListener('nodeDoubleClick', this.onSeriesNodeDoubleClick);\r\n            series.destroy();\r\n            series.chart = undefined;\r\n        });\r\n        this._series = []; // using `_series` instead of `series` to prevent infinite recursion\r\n    }\r\n    addSeriesListeners(series) {\r\n        if (this.hasEventListener('seriesNodeClick')) {\r\n            series.addEventListener('nodeClick', this.onSeriesNodeClick);\r\n        }\r\n        if (this.hasEventListener('seriesNodeDoubleClick')) {\r\n            series.addEventListener('nodeDoubleClick', this.onSeriesNodeDoubleClick);\r\n        }\r\n    }\r\n    updateAllSeriesListeners() {\r\n        this.series.forEach((series) => {\r\n            series.removeEventListener('nodeClick', this.onSeriesNodeClick);\r\n            series.removeEventListener('nodeDoubleClick', this.onSeriesNodeDoubleClick);\r\n            this.addSeriesListeners(series);\r\n        });\r\n    }\r\n    assignSeriesToAxes() {\r\n        this.axes.forEach((axis) => {\r\n            axis.boundSeries = this.series.filter((s) => {\r\n                const seriesAxis = s.axes[axis.direction];\r\n                return seriesAxis === axis;\r\n            });\r\n        });\r\n    }\r\n    assignAxesToSeries() {\r\n        // This method has to run before `assignSeriesToAxes`.\r\n        const directionToAxesMap = {};\r\n        this.axes.forEach((axis) => {\r\n            var _a;\r\n            const direction = axis.direction;\r\n            const directionAxes = ((_a = directionToAxesMap[direction]) !== null && _a !== void 0 ? _a : (directionToAxesMap[direction] = []));\r\n            directionAxes.push(axis);\r\n        });\r\n        this.series.forEach((series) => {\r\n            series.directions.forEach((direction) => {\r\n                const directionAxes = directionToAxesMap[direction];\r\n                if (!directionAxes) {\r\n                    Logger.warnOnce(`no available axis for direction [${direction}]; check series and axes configuration.`);\r\n                    return;\r\n                }\r\n                const seriesKeys = series.getKeys(direction);\r\n                const newAxis = this.findMatchingAxis(directionAxes, seriesKeys);\r\n                if (!newAxis) {\r\n                    Logger.warnOnce(`no matching axis for direction [${direction}] and keys [${seriesKeys}]; check series and axes configuration.`);\r\n                    return;\r\n                }\r\n                series.axes[direction] = newAxis;\r\n            });\r\n        });\r\n    }\r\n    findMatchingAxis(directionAxes, directionKeys) {\r\n        for (const axis of directionAxes) {\r\n            const axisKeys = axis.keys;\r\n            if (!axisKeys.length) {\r\n                return axis;\r\n            }\r\n            if (!directionKeys) {\r\n                continue;\r\n            }\r\n            for (const directionKey of directionKeys) {\r\n                if (axisKeys.indexOf(directionKey) >= 0) {\r\n                    return axis;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    rawResize(size) {\r\n        var _a;\r\n        let { width, height } = size;\r\n        width = Math.floor(width);\r\n        height = Math.floor(height);\r\n        if (!this.autoSize) {\r\n            return;\r\n        }\r\n        if (width === 0 && height === 0) {\r\n            return;\r\n        }\r\n        const [autoWidth = 0, authHeight = 0] = (_a = this._lastAutoSize) !== null && _a !== void 0 ? _a : [];\r\n        if (autoWidth === width && authHeight === height) {\r\n            return;\r\n        }\r\n        this._lastAutoSize = [width, height];\r\n        this.resize(undefined, undefined, 'SizeMonitor');\r\n    }\r\n    resize(width, height, source) {\r\n        var _a, _b, _c, _d;\r\n        width !== null && width !== void 0 ? width : (width = (_a = this.width) !== null && _a !== void 0 ? _a : (this.autoSize ? (_b = this._lastAutoSize) === null || _b === void 0 ? void 0 : _b[0] : this.scene.canvas.width));\r\n        height !== null && height !== void 0 ? height : (height = (_c = this.height) !== null && _c !== void 0 ? _c : (this.autoSize ? (_d = this._lastAutoSize) === null || _d === void 0 ? void 0 : _d[1] : this.scene.canvas.height));\r\n        this.debug(`Chart.resize() from ${source}`, { width, height, stack: new Error().stack });\r\n        if (!width || !height || !Number.isFinite(width) || !Number.isFinite(height))\r\n            return;\r\n        if (this.scene.resize(width, height)) {\r\n            this.disablePointer();\r\n            this.animationManager.reset();\r\n            let skipAnimations = true;\r\n            if (this.autoSize && this._firstAutoSize) {\r\n                skipAnimations = false;\r\n                this._firstAutoSize = false;\r\n            }\r\n            this.update(ChartUpdateType.PERFORM_LAYOUT, { forceNodeDataRefresh: true, skipAnimations });\r\n        }\r\n    }\r\n    processData() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.series.some((s) => s.canHaveAxes)) {\r\n                this.assignAxesToSeries();\r\n                this.assignSeriesToAxes();\r\n            }\r\n            const dataController = new DataController(this.mode);\r\n            const seriesPromises = this.series.map((s) => s.processData(dataController));\r\n            yield dataController.execute();\r\n            yield Promise.all(seriesPromises);\r\n            yield this.updateLegend();\r\n        });\r\n    }\r\n    placeLabels() {\r\n        const visibleSeries = [];\r\n        const data = [];\r\n        for (const series of this.series) {\r\n            if (!series.visible) {\r\n                continue;\r\n            }\r\n            const labelData = series.getLabelData();\r\n            if (!(labelData && isPointLabelDatum(labelData[0]))) {\r\n                continue;\r\n            }\r\n            data.push(labelData);\r\n            visibleSeries.push(series);\r\n        }\r\n        const { seriesRect } = this;\r\n        const labels = seriesRect && data.length > 0\r\n            ? placeLabels(data, { x: 0, y: 0, width: seriesRect.width, height: seriesRect.height })\r\n            : [];\r\n        return new Map(labels.map((l, i) => [visibleSeries[i], l]));\r\n    }\r\n    updateLegend() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.legends.forEach((legend, legendType) => {\r\n                const isCategoryLegendData = (data) => data.every((d) => d.legendType === 'category');\r\n                const legendData = this.series.filter((s) => s.showInLegend).flatMap((s) => s.getLegendData(legendType));\r\n                if (isCategoryLegendData(legendData)) {\r\n                    this.validateCategoryLegendData(legendData);\r\n                }\r\n                legend.data = legendData;\r\n            });\r\n        });\r\n    }\r\n    validateCategoryLegendData(legendData) {\r\n        // Validate each series that shares a legend item label uses the same fill colour\r\n        const labelMarkerFills = {};\r\n        legendData.forEach((d) => {\r\n            var _a, _b, _c;\r\n            var _d, _e;\r\n            const seriesType = (_a = this.series.find((s) => s.id === d.seriesId)) === null || _a === void 0 ? void 0 : _a.type;\r\n            if (!seriesType)\r\n                return;\r\n            (_b = labelMarkerFills[seriesType]) !== null && _b !== void 0 ? _b : (labelMarkerFills[seriesType] = {});\r\n            (_c = (_d = labelMarkerFills[seriesType])[_e = d.label.text]) !== null && _c !== void 0 ? _c : (_d[_e] = new Set());\r\n            if (d.marker.fill != null) {\r\n                labelMarkerFills[seriesType][d.label.text].add(d.marker.fill);\r\n            }\r\n        });\r\n        for (const seriesMarkers of Object.values(labelMarkerFills)) {\r\n            for (const [name, fills] of Object.entries(seriesMarkers)) {\r\n                if (fills.size > 1) {\r\n                    Logger.warnOnce(`legend item '${name}' has multiple fill colors, this may cause unexpected behaviour.`);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    processLayout() {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const oldRect = this.animationRect;\r\n            yield this.performLayout();\r\n            if (oldRect && !((_a = this.animationRect) === null || _a === void 0 ? void 0 : _a.equals(oldRect))) {\r\n                // Skip animations if the layout changed.\r\n                this.animationManager.skipCurrentBatch();\r\n            }\r\n            this.handleNoDataOverlay();\r\n            this.debug('Chart.performUpdate() - seriesRect', this.seriesRect);\r\n        });\r\n    }\r\n    performLayout() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (this.scene.root) {\r\n                this.scene.root.visible = true;\r\n            }\r\n            const { width, height } = this.scene;\r\n            let ctx = { shrinkRect: new BBox(0, 0, width, height) };\r\n            ctx = this.layoutService.dispatchPerformLayout('start-layout', ctx);\r\n            ctx = this.layoutService.dispatchPerformLayout('before-series', ctx);\r\n            return ctx.shrinkRect;\r\n        });\r\n    }\r\n    // x/y are local canvas coordinates in CSS pixels, not actual pixels\r\n    pickSeriesNode(point, exactMatchOnly, maxDistance) {\r\n        var _a, _b;\r\n        const start = performance.now();\r\n        // Disable 'nearest match' options if looking for exact matches only\r\n        const pickModes = exactMatchOnly ? [SeriesNodePickMode.EXACT_SHAPE_MATCH] : undefined;\r\n        // Iterate through series in reverse, as later declared series appears on top of earlier\r\n        // declared series.\r\n        const reverseSeries = [...this.series].reverse();\r\n        let result;\r\n        for (const series of reverseSeries) {\r\n            if (!series.visible || !series.rootGroup.visible) {\r\n                continue;\r\n            }\r\n            const { match, distance } = (_a = series.pickNode(point, pickModes)) !== null && _a !== void 0 ? _a : {};\r\n            if (!match || distance == null) {\r\n                continue;\r\n            }\r\n            if ((!result || result.distance > distance) && distance <= (maxDistance !== null && maxDistance !== void 0 ? maxDistance : Infinity)) {\r\n                result = { series, distance, datum: match };\r\n            }\r\n            if (distance === 0) {\r\n                break;\r\n            }\r\n        }\r\n        this.extraDebugStats['pickSeriesNode'] = Math.round(((_b = this.extraDebugStats['pickSeriesNode']) !== null && _b !== void 0 ? _b : 0) + (performance.now() - start));\r\n        return result;\r\n    }\r\n    onMouseMove(event) {\r\n        this.lastInteractionEvent = event;\r\n        this.pointerScheduler.schedule();\r\n        this.extraDebugStats['mouseX'] = event.offsetX;\r\n        this.extraDebugStats['mouseY'] = event.offsetY;\r\n        this.update(ChartUpdateType.SCENE_RENDER);\r\n    }\r\n    onLeave(event) {\r\n        if (this.tooltip.pointerLeftOntoTooltip(event)) {\r\n            return;\r\n        }\r\n        this.disablePointer();\r\n    }\r\n    handlePointer(event) {\r\n        const { lastPick, hoverRect } = this;\r\n        const { offsetX, offsetY } = event;\r\n        const disablePointer = (highlightOnly = false) => {\r\n            if (lastPick) {\r\n                // Cursor moved from a non-marker node to empty space.\r\n                this.disablePointer(highlightOnly);\r\n            }\r\n        };\r\n        if (!(hoverRect === null || hoverRect === void 0 ? void 0 : hoverRect.containsPoint(offsetX, offsetY))) {\r\n            disablePointer();\r\n            return;\r\n        }\r\n        // Handle node highlighting and tooltip toggling when pointer within `tooltip.range`\r\n        this.handlePointerTooltip(event, disablePointer);\r\n        // Handle node highlighting and mouse cursor when pointer withing `series[].nodeClickRange`\r\n        this.handlePointerNode(event);\r\n    }\r\n    handlePointerTooltip(event, disablePointer) {\r\n        const { lastPick, tooltip } = this;\r\n        const { range } = tooltip;\r\n        const { offsetX, offsetY } = event;\r\n        let pixelRange;\r\n        if (typeof range === 'number' && Number.isFinite(range)) {\r\n            pixelRange = range;\r\n        }\r\n        const pick = this.pickSeriesNode({ x: offsetX, y: offsetY }, range === 'exact', pixelRange);\r\n        if (!pick) {\r\n            this.tooltipManager.removeTooltip(this.id);\r\n            if (this.highlight.range === 'tooltip')\r\n                disablePointer(true);\r\n            return;\r\n        }\r\n        const isNewDatum = this.highlight.range === 'node' || !lastPick || lastPick.datum !== pick.datum;\r\n        let html;\r\n        if (isNewDatum) {\r\n            html = pick.series.getTooltipHtml(pick.datum);\r\n            if (this.highlight.range === 'tooltip') {\r\n                this.highlightManager.updateHighlight(this.id, pick.datum);\r\n            }\r\n        }\r\n        else if (lastPick) {\r\n            lastPick.event = event.sourceEvent;\r\n        }\r\n        const isPixelRange = pixelRange != null;\r\n        const tooltipEnabled = this.tooltip.enabled && pick.series.tooltip.enabled;\r\n        const exactlyMatched = range === 'exact' && pick.distance === 0;\r\n        const rangeMatched = range === 'nearest' || isPixelRange || exactlyMatched;\r\n        const shouldUpdateTooltip = tooltipEnabled && rangeMatched && (!isNewDatum || html !== undefined);\r\n        const meta = TooltipManager.makeTooltipMeta(event, this.scene.canvas, pick.datum, this.specialOverrides.window);\r\n        if (shouldUpdateTooltip) {\r\n            this.tooltipManager.updateTooltip(this.id, meta, html);\r\n        }\r\n    }\r\n    handlePointerNode(event) {\r\n        const found = this.checkSeriesNodeRange(event, (series, datum) => {\r\n            if (series.hasEventListener('nodeClick') || series.hasEventListener('nodeDoubleClick')) {\r\n                this.cursorManager.updateCursor('chart', 'pointer');\r\n            }\r\n            if (this.highlight.range === 'node') {\r\n                this.highlightManager.updateHighlight(this.id, datum);\r\n            }\r\n        });\r\n        if (!found) {\r\n            this.cursorManager.updateCursor('chart');\r\n            if (this.highlight.range === 'node') {\r\n                this.highlightManager.updateHighlight(this.id);\r\n            }\r\n        }\r\n    }\r\n    onClick(event) {\r\n        if (this.checkSeriesNodeClick(event)) {\r\n            this.update(ChartUpdateType.SERIES_UPDATE);\r\n            return;\r\n        }\r\n        this.fireEvent({\r\n            type: 'click',\r\n            event: event.sourceEvent,\r\n        });\r\n    }\r\n    onDoubleClick(event) {\r\n        if (this.checkSeriesNodeDoubleClick(event)) {\r\n            this.update(ChartUpdateType.SERIES_UPDATE);\r\n            return;\r\n        }\r\n        this.fireEvent({\r\n            type: 'doubleClick',\r\n            event: event.sourceEvent,\r\n        });\r\n    }\r\n    checkSeriesNodeClick(event) {\r\n        return this.checkSeriesNodeRange(event, (series, datum) => series.fireNodeClickEvent(event.sourceEvent, datum));\r\n    }\r\n    checkSeriesNodeDoubleClick(event) {\r\n        return this.checkSeriesNodeRange(event, (series, datum) => series.fireNodeDoubleClickEvent(event.sourceEvent, datum));\r\n    }\r\n    checkSeriesNodeRange(event, callback) {\r\n        const nearestNode = this.pickSeriesNode({ x: event.offsetX, y: event.offsetY }, false);\r\n        const datum = nearestNode === null || nearestNode === void 0 ? void 0 : nearestNode.datum;\r\n        const nodeClickRange = datum === null || datum === void 0 ? void 0 : datum.series.nodeClickRange;\r\n        let pixelRange;\r\n        if (typeof nodeClickRange === 'number' && Number.isFinite(nodeClickRange)) {\r\n            pixelRange = nodeClickRange;\r\n        }\r\n        // Find the node if exactly matched and update the highlight picked node\r\n        let pickedNode = this.pickSeriesNode({ x: event.offsetX, y: event.offsetY }, true);\r\n        if (pickedNode) {\r\n            this.highlightManager.updatePicked(this.id, pickedNode.datum);\r\n        }\r\n        else {\r\n            this.highlightManager.updatePicked(this.id);\r\n        }\r\n        // First check if we should trigger the callback based on nearest node\r\n        if (datum && nodeClickRange === 'nearest') {\r\n            callback(datum.series, datum);\r\n            return true;\r\n        }\r\n        if (nodeClickRange !== 'exact') {\r\n            pickedNode = this.pickSeriesNode({ x: event.offsetX, y: event.offsetY }, false, pixelRange);\r\n        }\r\n        if (!pickedNode)\r\n            return false;\r\n        // Then if we've picked a node within the pixel range, or exactly, trigger the callback\r\n        const isPixelRange = pixelRange != null;\r\n        const exactlyMatched = nodeClickRange === 'exact' && pickedNode.distance === 0;\r\n        if (isPixelRange || exactlyMatched) {\r\n            callback(pickedNode.series, pickedNode.datum);\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    changeHighlightDatum(event) {\r\n        var _a, _b;\r\n        const seriesToUpdate = new Set();\r\n        const { series: newSeries = undefined, datum: newDatum } = (_a = event.currentHighlight) !== null && _a !== void 0 ? _a : {};\r\n        const { series: lastSeries = undefined, datum: lastDatum } = (_b = event.previousHighlight) !== null && _b !== void 0 ? _b : {};\r\n        if (lastSeries) {\r\n            seriesToUpdate.add(lastSeries);\r\n        }\r\n        if (newSeries) {\r\n            seriesToUpdate.add(newSeries);\r\n        }\r\n        // Adjust cursor if a specific datum is highlighted, rather than just a series.\r\n        if ((lastSeries === null || lastSeries === void 0 ? void 0 : lastSeries.cursor) && lastDatum) {\r\n            this.cursorManager.updateCursor(lastSeries.id);\r\n        }\r\n        if ((newSeries === null || newSeries === void 0 ? void 0 : newSeries.cursor) && newDatum) {\r\n            this.cursorManager.updateCursor(newSeries.id, newSeries.cursor);\r\n        }\r\n        this.lastPick = event.currentHighlight ? { datum: event.currentHighlight } : undefined;\r\n        const updateAll = newSeries == null || lastSeries == null;\r\n        if (updateAll) {\r\n            this.update(ChartUpdateType.SERIES_UPDATE);\r\n        }\r\n        else {\r\n            this.update(ChartUpdateType.SERIES_UPDATE, { seriesToUpdate });\r\n        }\r\n    }\r\n    waitForUpdate(timeoutMs = 5000) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const start = performance.now();\r\n            if (this._pendingFactoryUpdatesCount > 0) {\r\n                // Await until any pending updates are flushed through.\r\n                yield this.updateMutex.waitForClearAcquireQueue();\r\n            }\r\n            while (this._performUpdateType !== ChartUpdateType.NONE) {\r\n                if (performance.now() - start > timeoutMs) {\r\n                    throw new Error('waitForUpdate() timeout reached.');\r\n                }\r\n                yield sleep(5);\r\n            }\r\n            // Await until any remaining updates are flushed through.\r\n            yield this.updateMutex.waitForClearAcquireQueue();\r\n        });\r\n    }\r\n    handleNoDataOverlay() {\r\n        const shouldDisplayNoDataOverlay = !this.series.some((s) => s.hasData());\r\n        if (shouldDisplayNoDataOverlay && this.seriesRect) {\r\n            this.overlays.noData.show(this.seriesRect);\r\n        }\r\n        else {\r\n            this.overlays.noData.hide();\r\n        }\r\n    }\r\n    getMinRect() {\r\n        const minRects = this.series.map((series) => series.getMinRect()).filter((rect) => rect !== undefined);\r\n        if (!minRects.length)\r\n            return undefined;\r\n        return new BBox(0, 0, minRects.reduce((max, rect) => Math.max(max, rect.width), 0), minRects.reduce((max, rect) => Math.max(max, rect.height), 0));\r\n    }\r\n}\r\n__decorate([\r\n    ActionOnSet({\r\n        newValue(value) {\r\n            if (this.destroyed)\r\n                return;\r\n            value.appendChild(this.element);\r\n        },\r\n        oldValue(value) {\r\n            value.removeChild(this.element);\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Object)\r\n], Chart.prototype, \"container\", void 0);\r\n__decorate([\r\n    ActionOnSet({\r\n        newValue(value) {\r\n            var _a;\r\n            (_a = this.series) === null || _a === void 0 ? void 0 : _a.forEach((series) => {\r\n                series.setChartData(value);\r\n            });\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Object)\r\n], Chart.prototype, \"data\", void 0);\r\n__decorate([\r\n    ActionOnSet({\r\n        newValue(value) {\r\n            this.resize(value, undefined, 'width option');\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Chart.prototype, \"width\", void 0);\r\n__decorate([\r\n    ActionOnSet({\r\n        newValue(value) {\r\n            this.resize(undefined, value, 'height option');\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Number)\r\n], Chart.prototype, \"height\", void 0);\r\n__decorate([\r\n    ActionOnSet({\r\n        changeValue(value) {\r\n            this.autoSizeChanged(value);\r\n        },\r\n    }),\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], Chart.prototype, \"autoSize\", void 0);\r\n__decorate([\r\n    ActionOnSet({\r\n        newValue(value) {\r\n            var _a;\r\n            (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(value.node);\r\n        },\r\n        oldValue(oldValue) {\r\n            var _a;\r\n            (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(oldValue.node);\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Function)\r\n], Chart.prototype, \"title\", void 0);\r\n__decorate([\r\n    ActionOnSet({\r\n        newValue(value) {\r\n            var _a;\r\n            (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(value.node);\r\n        },\r\n        oldValue(oldValue) {\r\n            var _a;\r\n            (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(oldValue.node);\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Function)\r\n], Chart.prototype, \"subtitle\", void 0);\r\n__decorate([\r\n    ActionOnSet({\r\n        newValue(value) {\r\n            var _a;\r\n            (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(value.node);\r\n        },\r\n        oldValue(oldValue) {\r\n            var _a;\r\n            (_a = this.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(oldValue.node);\r\n        },\r\n    }),\r\n    __metadata(\"design:type\", Function)\r\n], Chart.prototype, \"footnote\", void 0);\r\n__decorate([\r\n    Validate(STRING_UNION('standalone', 'integrated')),\r\n    __metadata(\"design:type\", String)\r\n], Chart.prototype, \"mode\", void 0);\n\nvar ArcType;\r\n(function (ArcType) {\r\n    ArcType[ArcType[\"Open\"] = 0] = \"Open\";\r\n    ArcType[ArcType[\"Chord\"] = 1] = \"Chord\";\r\n    ArcType[ArcType[\"Round\"] = 2] = \"Round\";\r\n})(ArcType || (ArcType = {}));\r\n/**\r\n * Elliptical arc node.\r\n */\r\nclass Arc extends Path {\r\n    constructor() {\r\n        super();\r\n        this.centerX = 0;\r\n        this.centerY = 0;\r\n        this.radius = 10;\r\n        this.startAngle = 0;\r\n        this.endAngle = Math.PI * 2;\r\n        this.counterClockwise = false;\r\n        /**\r\n         * The type of arc to render:\r\n         * - {@link ArcType.Open} - end points of the arc segment are not connected (default)\r\n         * - {@link ArcType.Chord} - end points of the arc segment are connected by a line segment\r\n         * - {@link ArcType.Round} - each of the end points of the arc segment are connected\r\n         *                           to the center of the arc\r\n         * Arcs with {@link ArcType.Open} do not support hit testing, even if they have their\r\n         * {@link Shape.fillStyle} set, because they are not closed paths. Hit testing support\r\n         * would require using two paths - one for rendering, another for hit testing - and there\r\n         * doesn't seem to be a compelling reason to do that, when one can just use {@link ArcType.Chord}\r\n         * to create a closed path.\r\n         */\r\n        this.type = ArcType.Open;\r\n        this.restoreOwnStyles();\r\n    }\r\n    get fullPie() {\r\n        return isEqual(normalizeAngle360(this.startAngle), normalizeAngle360(this.endAngle));\r\n    }\r\n    updatePath() {\r\n        const path = this.path;\r\n        path.clear(); // No need to recreate the Path, can simply clear the existing one.\r\n        path.arc(this.centerX, this.centerY, this.radius, this.startAngle, this.endAngle, this.counterClockwise);\r\n        if (this.type === ArcType.Chord) {\r\n            path.closePath();\r\n        }\r\n        else if (this.type === ArcType.Round && !this.fullPie) {\r\n            path.lineTo(this.centerX, this.centerY);\r\n            path.closePath();\r\n        }\r\n    }\r\n    computeBBox() {\r\n        // Only works with full arcs (circles) and untransformed ellipses.\r\n        return new BBox(this.centerX - this.radius, this.centerY - this.radius, this.radius * 2, this.radius * 2);\r\n    }\r\n    isPointInPath(x, y) {\r\n        const point = this.transformPoint(x, y);\r\n        const bbox = this.computeBBox();\r\n        return (this.type !== ArcType.Open &&\r\n            bbox.containsPoint(point.x, point.y) &&\r\n            this.path.isPointInPath(point.x, point.y));\r\n    }\r\n}\r\nArc.className = 'Arc';\r\nArc.defaultStyles = Object.assign({}, Shape.defaultStyles, {\r\n    lineWidth: 1,\r\n    fillStyle: null,\r\n});\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Arc.prototype, \"centerX\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Arc.prototype, \"centerY\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Arc.prototype, \"radius\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Arc.prototype, \"startAngle\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Arc.prototype, \"endAngle\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Boolean)\r\n], Arc.prototype, \"counterClockwise\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Arc.prototype, \"type\", void 0);\n\nconst convertColorStringToHsla = (v) => {\r\n    const color = Color.fromString(v);\r\n    const [h, s, l] = Color.RGBtoHSL(color.r, color.g, color.b);\r\n    return { h, s, l, a: color.a };\r\n};\r\nconst interpolateHsla = (x, y, d) => {\r\n    d = Math.min(Math.max(d, 0), 1);\r\n    let h;\r\n    let s;\r\n    if (Number.isNaN(x.h) && Number.isNaN(y.h)) {\r\n        h = 0;\r\n        s = 0;\r\n    }\r\n    else if (Number.isNaN(x.h)) {\r\n        h = y.h;\r\n        s = y.s;\r\n    }\r\n    else if (Number.isNaN(y.h)) {\r\n        h = x.h;\r\n        s = x.s;\r\n    }\r\n    else {\r\n        const xH = x.h;\r\n        let yH = y.h;\r\n        const deltaH = y.h - x.h;\r\n        if (deltaH > 180) {\r\n            yH -= 360;\r\n        }\r\n        else if (deltaH < -180) {\r\n            yH += 360;\r\n        }\r\n        h = xH * (1 - d) + yH * d;\r\n        s = x.s * (1 - d) + y.s * d;\r\n    }\r\n    const l = x.l * (1 - d) + y.l * d;\r\n    const a = x.a * (1 - d) + y.a * d;\r\n    return Color.fromHSL(h, s, l, a);\r\n};\r\nclass ColorScale {\r\n    constructor() {\r\n        this.domain = [0, 1];\r\n        this.range = ['red', 'blue'];\r\n        this.parsedRange = this.range.map(convertColorStringToHsla);\r\n    }\r\n    update() {\r\n        const { domain, range } = this;\r\n        if (domain.length < 2) {\r\n            Logger.warnOnce('`colorDomain` should have at least 2 values.');\r\n            if (domain.length === 0) {\r\n                domain.push(0, 1);\r\n            }\r\n            else if (domain.length === 1) {\r\n                domain.push(domain[0] + 1);\r\n            }\r\n        }\r\n        for (let i = 1; i < domain.length; i++) {\r\n            const a = domain[i - 1];\r\n            const b = domain[i];\r\n            if (a >= b) {\r\n                Logger.warnOnce('`colorDomain` values should be supplied in ascending order.');\r\n                domain.sort((a, b) => a - b);\r\n                break;\r\n            }\r\n        }\r\n        if (range.length < domain.length) {\r\n            for (let i = range.length; i < domain.length; i++) {\r\n                range.push(range.length > 0 ? range[0] : 'black');\r\n            }\r\n        }\r\n        this.parsedRange = this.range.map(convertColorStringToHsla);\r\n    }\r\n    convert(x) {\r\n        const { domain, range, parsedRange } = this;\r\n        const d0 = domain[0];\r\n        const d1 = domain[domain.length - 1];\r\n        const r0 = range[0];\r\n        const r1 = range[range.length - 1];\r\n        if (x <= d0) {\r\n            return r0;\r\n        }\r\n        if (x >= d1) {\r\n            return r1;\r\n        }\r\n        let index;\r\n        let q;\r\n        if (domain.length === 2) {\r\n            const t = (x - d0) / (d1 - d0);\r\n            const step = 1 / (range.length - 1);\r\n            index = range.length <= 2 ? 0 : Math.min(Math.floor(t * (range.length - 1)), range.length - 2);\r\n            q = (t - index * step) / step;\r\n        }\r\n        else {\r\n            for (index = 0; index < domain.length - 2; index++) {\r\n                if (x < domain[index + 1]) {\r\n                    break;\r\n                }\r\n            }\r\n            const a = domain[index];\r\n            const b = domain[index + 1];\r\n            q = (x - a) / (b - a);\r\n        }\r\n        const c0 = parsedRange[index];\r\n        const c1 = parsedRange[index + 1];\r\n        return interpolateHsla(c0, c1, q).toRgbaString();\r\n    }\r\n}\n\nclass LinearGradientFill extends Shape {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.direction = 'to-right';\r\n        this.stops = undefined;\r\n        this._mask = undefined;\r\n    }\r\n    get mask() {\r\n        return this._mask;\r\n    }\r\n    set mask(newMask) {\r\n        if (this._mask != null) {\r\n            this.removeChild(this._mask);\r\n        }\r\n        if (newMask != null) {\r\n            this.appendChild(newMask);\r\n        }\r\n        this._mask = newMask;\r\n    }\r\n    isPointInPath(x, y) {\r\n        var _a, _b;\r\n        return (_b = (_a = this.mask) === null || _a === void 0 ? void 0 : _a.isPointInPath(x, y)) !== null && _b !== void 0 ? _b : false;\r\n    }\r\n    computeBBox() {\r\n        var _a;\r\n        return (_a = this.mask) === null || _a === void 0 ? void 0 : _a.computeBBox();\r\n    }\r\n    render(renderCtx) {\r\n        const { mask, stops } = this;\r\n        const { ctx, devicePixelRatio } = renderCtx;\r\n        const pixelLength = 1 / devicePixelRatio;\r\n        const maskBbox = mask === null || mask === void 0 ? void 0 : mask.computeTransformedBBox();\r\n        if (mask == null || stops == null || maskBbox == null)\r\n            return;\r\n        if (mask.dirtyPath) {\r\n            mask.updatePath();\r\n            mask.dirtyPath = false;\r\n        }\r\n        ctx.save();\r\n        ctx.beginPath();\r\n        mask.path.draw(ctx);\r\n        ctx.clip();\r\n        ctx.resetTransform();\r\n        const x0 = Math.floor(maskBbox.x);\r\n        const x1 = Math.ceil(maskBbox.x + maskBbox.width);\r\n        const y0 = Math.floor(maskBbox.y);\r\n        const y1 = Math.ceil(maskBbox.y + maskBbox.height);\r\n        const colorScale = new ColorScale();\r\n        const [i0, i1] = this.direction === 'to-right' ? [x0, x1] : [y0, y1];\r\n        colorScale.domain = stops.map((_, index) => {\r\n            return i0 + ((i1 - i0) * index) / (stops.length - 1);\r\n        });\r\n        colorScale.range = stops;\r\n        colorScale.update();\r\n        if (this.direction === 'to-right') {\r\n            const height = y1 - y0;\r\n            for (let x = x0; x <= x1; x += pixelLength) {\r\n                ctx.fillStyle = colorScale.convert(x);\r\n                ctx.fillRect(x, y0, pixelLength, height);\r\n            }\r\n        }\r\n        else {\r\n            const width = x1 - x0;\r\n            for (let y = y0; y <= y1; y += pixelLength) {\r\n                ctx.fillStyle = colorScale.convert(y);\r\n                ctx.fillRect(x0, y, width, pixelLength);\r\n            }\r\n        }\r\n        ctx.restore();\r\n    }\r\n}\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", String)\r\n], LinearGradientFill.prototype, \"direction\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Array)\r\n], LinearGradientFill.prototype, \"stops\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Function)\r\n], LinearGradientFill.prototype, \"_mask\", void 0);\n\nclass Rect extends Path {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.borderPath = new Path2D();\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.width = 10;\r\n        this.height = 10;\r\n        this.radius = 0;\r\n        /**\r\n         * If `true`, the rect is aligned to the pixel grid for crisp looking lines.\r\n         * Animated rects may not look nice with this option enabled, for example\r\n         * when a rect is translated by a sub-pixel value on each frame.\r\n         */\r\n        this.crisp = false;\r\n        this.lastUpdatePathStrokeWidth = Shape.defaultStyles.strokeWidth;\r\n        this.effectiveStrokeWidth = Shape.defaultStyles.strokeWidth;\r\n        /**\r\n         * When the rectangle's width or height is less than a pixel\r\n         * and crisp mode is on, the rectangle will still fit into the pixel,\r\n         * but will be less opaque to make an effect of holding less space.\r\n         */\r\n        this.microPixelEffectOpacity = 1;\r\n    }\r\n    isDirtyPath() {\r\n        var _a;\r\n        if (this.lastUpdatePathStrokeWidth !== this.strokeWidth) {\r\n            return true;\r\n        }\r\n        return !!(this.path.isDirty() || this.borderPath.isDirty() || ((_a = this.clipPath) === null || _a === void 0 ? void 0 : _a.isDirty()));\r\n    }\r\n    updatePath() {\r\n        var _a, _b, _c;\r\n        const { path, borderPath, crisp } = this;\r\n        let { x, y, width: w, height: h, strokeWidth } = this;\r\n        const pixelRatio = (_b = (_a = this.layerManager) === null || _a === void 0 ? void 0 : _a.canvas.pixelRatio) !== null && _b !== void 0 ? _b : 1;\r\n        const pixelSize = 1 / pixelRatio;\r\n        let microPixelEffectOpacity = 1;\r\n        path.clear({ trackChanges: true });\r\n        borderPath.clear({ trackChanges: true });\r\n        if (crisp) {\r\n            if (w <= pixelSize) {\r\n                microPixelEffectOpacity *= w / pixelSize;\r\n            }\r\n            if (h <= pixelSize) {\r\n                microPixelEffectOpacity *= h / pixelSize;\r\n            }\r\n            w = this.align(x, w);\r\n            h = this.align(y, h);\r\n            x = this.align(x);\r\n            y = this.align(y);\r\n        }\r\n        if (strokeWidth) {\r\n            if (w < pixelSize) {\r\n                // Too narrow, draw a vertical stroke\r\n                const lx = x + pixelSize / 2;\r\n                borderPath.moveTo(lx, y);\r\n                borderPath.lineTo(lx, y + h);\r\n                strokeWidth = pixelSize;\r\n                this.borderClipPath = undefined;\r\n            }\r\n            else if (h < pixelSize) {\r\n                // Too narrow, draw a horizontal stroke\r\n                const ly = y + pixelSize / 2;\r\n                borderPath.moveTo(x, ly);\r\n                borderPath.lineTo(x + w, ly);\r\n                strokeWidth = pixelSize;\r\n                this.borderClipPath = undefined;\r\n            }\r\n            else if (strokeWidth < w && strokeWidth < h) {\r\n                const halfStrokeWidth = strokeWidth / 2;\r\n                x += halfStrokeWidth;\r\n                y += halfStrokeWidth;\r\n                w -= strokeWidth;\r\n                h -= strokeWidth;\r\n                // Clipping not needed in this case; fill to center of stroke.\r\n                this.borderClipPath = undefined;\r\n                path.rect(x, y, w, h);\r\n                borderPath.rect(x, y, w, h);\r\n            }\r\n            else {\r\n                // Skip the fill and just render the stroke.\r\n                this.borderClipPath = (_c = this.borderClipPath) !== null && _c !== void 0 ? _c : new Path2D();\r\n                this.borderClipPath.clear({ trackChanges: true });\r\n                this.borderClipPath.rect(x, y, w, h);\r\n                borderPath.rect(x, y, w, h);\r\n            }\r\n        }\r\n        else {\r\n            // No borderPath needed, and thus no clipPath needed either. Fill to full extent of\r\n            // Rect.\r\n            this.borderClipPath = undefined;\r\n            path.rect(x, y, w, h);\r\n        }\r\n        this.effectiveStrokeWidth = strokeWidth;\r\n        this.lastUpdatePathStrokeWidth = strokeWidth;\r\n        this.microPixelEffectOpacity = microPixelEffectOpacity;\r\n    }\r\n    computeBBox() {\r\n        const { x, y, width, height } = this;\r\n        return new BBox(x, y, width, height);\r\n    }\r\n    isPointInPath(x, y) {\r\n        const point = this.transformPoint(x, y);\r\n        const bbox = this.computeBBox();\r\n        return bbox.containsPoint(point.x, point.y);\r\n    }\r\n    applyFillAlpha(ctx) {\r\n        const { fillOpacity, microPixelEffectOpacity, opacity } = this;\r\n        const { globalAlpha } = ctx;\r\n        ctx.globalAlpha = globalAlpha * opacity * fillOpacity * microPixelEffectOpacity;\r\n    }\r\n    renderStroke(ctx) {\r\n        const { stroke, effectiveStrokeWidth, borderPath, borderClipPath, opacity, microPixelEffectOpacity } = this;\r\n        const borderActive = !!stroke && !!effectiveStrokeWidth;\r\n        if (borderActive) {\r\n            const { strokeOpacity, lineDash, lineDashOffset, lineCap, lineJoin } = this;\r\n            if (borderClipPath) {\r\n                // strokeWidth is larger than width or height, so use clipping to render correctly.\r\n                // This is the simplest way to achieve the correct rendering due to nuances with ~0\r\n                // width/height lines in Canvas operations.\r\n                borderClipPath.draw(ctx);\r\n                ctx.clip();\r\n            }\r\n            borderPath.draw(ctx);\r\n            const { globalAlpha } = ctx;\r\n            ctx.strokeStyle = stroke;\r\n            ctx.globalAlpha = globalAlpha * opacity * strokeOpacity * microPixelEffectOpacity;\r\n            ctx.lineWidth = effectiveStrokeWidth;\r\n            if (lineDash) {\r\n                ctx.setLineDash(lineDash);\r\n            }\r\n            if (lineDashOffset) {\r\n                ctx.lineDashOffset = lineDashOffset;\r\n            }\r\n            if (lineCap) {\r\n                ctx.lineCap = lineCap;\r\n            }\r\n            if (lineJoin) {\r\n                ctx.lineJoin = lineJoin;\r\n            }\r\n            ctx.stroke();\r\n            ctx.globalAlpha = globalAlpha;\r\n        }\r\n    }\r\n}\r\nRect.className = 'Rect';\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Rect.prototype, \"x\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Rect.prototype, \"y\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Rect.prototype, \"width\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Rect.prototype, \"height\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Number)\r\n], Rect.prototype, \"radius\", void 0);\r\n__decorate([\r\n    ScenePathChangeDetection(),\r\n    __metadata(\"design:type\", Boolean)\r\n], Rect.prototype, \"crisp\", void 0);\n\nclass Image extends Node {\r\n    constructor(sourceImage) {\r\n        super();\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.width = 0;\r\n        this.height = 0;\r\n        this.opacity = 1;\r\n        this.sourceImage = sourceImage;\r\n    }\r\n    render(renderCtx) {\r\n        const { ctx, forceRender, stats } = renderCtx;\r\n        if (this.dirty === RedrawType.NONE && !forceRender) {\r\n            if (stats)\r\n                stats.nodesSkipped++;\r\n            return;\r\n        }\r\n        this.computeTransformMatrix();\r\n        this.matrix.toContext(ctx);\r\n        const image = this.sourceImage;\r\n        ctx.globalAlpha = this.opacity;\r\n        ctx.drawImage(image, 0, 0, image.width, image.height, this.x, this.y, this.width, this.height);\r\n        super.render(renderCtx);\r\n    }\r\n}\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Image.prototype, \"x\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Image.prototype, \"y\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Image.prototype, \"width\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Image.prototype, \"height\", void 0);\r\n__decorate([\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], Image.prototype, \"opacity\", void 0);\n\nconst motion = Object.assign(Object.assign({}, fromToMotion$1), resetMotion$1);\n\nvar integratedChartsScene = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    motion: motion,\n    Caption: Caption,\n    DropShadow: DropShadow,\n    Group: Group,\n    Scene: Scene,\n    Node: Node,\n    get PointerEvents () { return PointerEvents; },\n    get RedrawType () { return RedrawType; },\n    SceneChangeDetection: SceneChangeDetection,\n    Selection: Selection,\n    Arc: Arc,\n    Line: Line,\n    LinearGradientFill: LinearGradientFill,\n    Path: Path,\n    ScenePathChangeDetection: ScenePathChangeDetection,\n    Rect: Rect,\n    Sector: Sector,\n    Shape: Shape,\n    Text: Text,\n    getFont: getFont,\n    ContinuousScale: ContinuousScale,\n    BandScale: BandScale,\n    LinearScale: LinearScale,\n    toRadians: toRadians,\n    Label: Label,\n    Marker: Marker,\n    getMarker: getMarker,\n    Circle: Circle,\n    Diamond: Diamond,\n    Square: Square,\n    Triangle: Triangle,\n    Tooltip: Tooltip,\n    toTooltipHtml: toTooltipHtml,\n    BBox: BBox,\n    nearestSquared: nearestSquared,\n    nearestSquaredInContainer: nearestSquaredInContainer,\n    HdpiCanvas: HdpiCanvas,\n    Image: Image,\n    Path2D: Path2D,\n    easing: easing\n});\n\nconst DEFAULT_DIRECTION_KEYS = {\r\n    [ChartAxisDirection.X]: ['xKey'],\r\n    [ChartAxisDirection.Y]: ['yKey'],\r\n};\r\nconst DEFAULT_DIRECTION_NAMES = {\r\n    [ChartAxisDirection.X]: ['xName'],\r\n    [ChartAxisDirection.Y]: ['yName'],\r\n};\r\nclass CartesianSeriesNodeClickEvent extends SeriesNodeClickEvent {\r\n    constructor(type, nativeEvent, datum, series) {\r\n        super(type, nativeEvent, datum, series);\r\n        this.xKey = series.xKey;\r\n        this.yKey = series.yKey;\r\n    }\r\n}\r\nclass CartesianSeries extends DataModelSeries {\r\n    get contextNodeData() {\r\n        return this._contextNodeData.slice();\r\n    }\r\n    constructor(_a) {\r\n        var { pathsPerSeries = 1, hasMarkers = false, hasHighlightedLabels = false, pathsZIndexSubOrderOffset = [], directionKeys = DEFAULT_DIRECTION_KEYS, directionNames = DEFAULT_DIRECTION_NAMES, datumSelectionGarbageCollection = true, markerSelectionGarbageCollection = true, animationResetFns } = _a, otherOpts = __rest(_a, [\"pathsPerSeries\", \"hasMarkers\", \"hasHighlightedLabels\", \"pathsZIndexSubOrderOffset\", \"directionKeys\", \"directionNames\", \"datumSelectionGarbageCollection\", \"markerSelectionGarbageCollection\", \"animationResetFns\"]);\r\n        super(Object.assign({ directionKeys,\r\n            directionNames, useSeriesGroupLayer: true, canHaveAxes: true }, otherOpts));\r\n        this.legendItemName = undefined;\r\n        this._contextNodeData = [];\r\n        this.NodeClickEvent = CartesianSeriesNodeClickEvent;\r\n        this.highlightSelection = Selection.select(this.highlightNode, () => this.opts.hasMarkers ? this.markerFactory() : this.nodeFactory());\r\n        this.highlightLabelSelection = Selection.select(this.highlightLabel, Text);\r\n        this.annotationSelections = new Set();\r\n        this.subGroups = [];\r\n        this.subGroupId = 0;\r\n        this.debug = Debug.create();\r\n        this.opts = {\r\n            pathsPerSeries,\r\n            hasMarkers,\r\n            hasHighlightedLabels,\r\n            pathsZIndexSubOrderOffset,\r\n            directionKeys,\r\n            directionNames,\r\n            animationResetFns,\r\n            datumSelectionGarbageCollection,\r\n            markerSelectionGarbageCollection,\r\n        };\r\n        this.animationState = new StateMachine('empty', {\r\n            empty: {\r\n                update: {\r\n                    target: 'ready',\r\n                    action: (data) => this.animateEmptyUpdateReady(data),\r\n                },\r\n            },\r\n            ready: {\r\n                updateData: 'waiting',\r\n                clear: 'clearing',\r\n                highlight: (data) => this.animateReadyHighlight(data),\r\n                highlightMarkers: (data) => this.animateReadyHighlightMarkers(data),\r\n                resize: (data) => this.animateReadyResize(data),\r\n            },\r\n            waiting: {\r\n                update: {\r\n                    target: 'ready',\r\n                    action: (data) => this.animateWaitingUpdateReady(data),\r\n                },\r\n            },\r\n            clearing: {\r\n                update: {\r\n                    target: 'empty',\r\n                    action: (data) => this.animateClearingUpdateEmpty(data),\r\n                },\r\n            },\r\n        }, () => this.checkProcessedDataAnimatable());\r\n    }\r\n    addChartEventListeners() {\r\n        this.ctx.chartEventManager.addListener('legend-item-click', (event) => this.onLegendItemClick(event));\r\n        this.ctx.chartEventManager.addListener('legend-item-double-click', (event) => this.onLegendItemDoubleClick(event));\r\n    }\r\n    destroy() {\r\n        super.destroy();\r\n        this._contextNodeData.splice(0, this._contextNodeData.length);\r\n        this.subGroups.splice(0, this.subGroups.length);\r\n    }\r\n    update({ seriesRect }) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { visible, _contextNodeData: previousContextData } = this;\r\n            const { series } = (_b = (_a = this.ctx.highlightManager) === null || _a === void 0 ? void 0 : _a.getActiveHighlight()) !== null && _b !== void 0 ? _b : {};\r\n            const seriesHighlighted = series ? series === this : undefined;\r\n            const resize = this.checkResize(seriesRect);\r\n            const highlightItems = yield this.updateHighlightSelection(seriesHighlighted);\r\n            yield this.updateSelections(visible);\r\n            yield this.updateNodes(highlightItems, seriesHighlighted, visible);\r\n            const animationData = this.getAnimationData(seriesRect, previousContextData);\r\n            if (resize) {\r\n                this.animationState.transition('resize', animationData);\r\n            }\r\n            this.animationState.transition('update', animationData);\r\n        });\r\n    }\r\n    updateSelections(anySeriesItemEnabled) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (!anySeriesItemEnabled && this.ctx.animationManager.isSkipped()) {\r\n                return;\r\n            }\r\n            if (!this.nodeDataRefresh && !this.isPathOrSelectionDirty()) {\r\n                return;\r\n            }\r\n            if (this.nodeDataRefresh) {\r\n                this.nodeDataRefresh = false;\r\n                this.debug(`CartesianSeries.updateSelections() - calling createNodeData() for`, this.id);\r\n                this._contextNodeData = yield this.createNodeData();\r\n                const animationValid = this.isProcessedDataAnimatable();\r\n                this._contextNodeData.forEach((nodeData) => {\r\n                    var _a;\r\n                    (_a = nodeData.animationValid) !== null && _a !== void 0 ? _a : (nodeData.animationValid = animationValid);\r\n                });\r\n                yield this.updateSeriesGroups();\r\n                const { dataModel, processedData } = this;\r\n                if (dataModel !== undefined && processedData !== undefined) {\r\n                    this.dispatch('data-update', { dataModel, processedData });\r\n                }\r\n            }\r\n            yield Promise.all(this.subGroups.map((g, i) => this.updateSeriesGroupSelections(g, i)));\r\n        });\r\n    }\r\n    updateSeriesGroupSelections(subGroup, seriesIdx, seriesHighlighted) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { datumSelection, labelSelection, markerSelection, paths } = subGroup;\r\n            const contextData = this._contextNodeData[seriesIdx];\r\n            const { nodeData, labelData, itemId } = contextData;\r\n            yield this.updatePaths({ seriesHighlighted, itemId, contextData, paths, seriesIdx });\r\n            subGroup.datumSelection = yield this.updateDatumSelection({ nodeData, datumSelection, seriesIdx });\r\n            subGroup.labelSelection = yield this.updateLabelSelection({ labelData, labelSelection, seriesIdx });\r\n            if (markerSelection) {\r\n                subGroup.markerSelection = yield this.updateMarkerSelection({\r\n                    nodeData,\r\n                    markerSelection,\r\n                    seriesIdx,\r\n                });\r\n            }\r\n        });\r\n    }\r\n    markerFactory() {\r\n        const MarkerShape = getMarker();\r\n        return new MarkerShape();\r\n    }\r\n    updateSeriesGroups() {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { _contextNodeData: contextNodeData, contentGroup, subGroups, opts: { pathsPerSeries, hasMarkers, datumSelectionGarbageCollection, markerSelectionGarbageCollection }, } = this;\r\n            if (contextNodeData.length === subGroups.length) {\r\n                return;\r\n            }\r\n            if (contextNodeData.length < subGroups.length) {\r\n                subGroups.splice(contextNodeData.length).forEach(({ dataNodeGroup, markerGroup, labelGroup, paths }) => {\r\n                    contentGroup.removeChild(dataNodeGroup);\r\n                    if (markerGroup) {\r\n                        contentGroup.removeChild(markerGroup);\r\n                    }\r\n                    if (labelGroup) {\r\n                        contentGroup.removeChild(labelGroup);\r\n                    }\r\n                    for (const path of paths) {\r\n                        contentGroup.removeChild(path);\r\n                    }\r\n                });\r\n            }\r\n            const totalGroups = contextNodeData.length;\r\n            while (totalGroups > subGroups.length) {\r\n                const layer = false;\r\n                const subGroupId = this.subGroupId++;\r\n                const dataNodeGroup = new Group({\r\n                    name: `${this.id}-series-sub${subGroupId}-dataNodes`,\r\n                    layer,\r\n                    zIndex: Layers.SERIES_LAYER_ZINDEX,\r\n                    zIndexSubOrder: this.getGroupZIndexSubOrder('data', subGroupId),\r\n                });\r\n                const markerGroup = hasMarkers\r\n                    ? new Group({\r\n                        name: `${this.id}-series-sub${this.subGroupId++}-markers`,\r\n                        layer,\r\n                        zIndex: Layers.SERIES_LAYER_ZINDEX,\r\n                        zIndexSubOrder: this.getGroupZIndexSubOrder('marker', subGroupId),\r\n                    })\r\n                    : undefined;\r\n                const labelGroup = new Group({\r\n                    name: `${this.id}-series-sub${this.subGroupId++}-labels`,\r\n                    layer,\r\n                    zIndex: Layers.SERIES_LABEL_ZINDEX,\r\n                    zIndexSubOrder: this.getGroupZIndexSubOrder('labels', subGroupId),\r\n                });\r\n                contentGroup.appendChild(dataNodeGroup);\r\n                contentGroup.appendChild(labelGroup);\r\n                if (markerGroup) {\r\n                    contentGroup.appendChild(markerGroup);\r\n                }\r\n                const paths = [];\r\n                for (let index = 0; index < pathsPerSeries; index++) {\r\n                    paths[index] = new Path();\r\n                    paths[index].zIndex = Layers.SERIES_LAYER_ZINDEX;\r\n                    paths[index].zIndexSubOrder = this.getGroupZIndexSubOrder('paths', index);\r\n                    contentGroup.appendChild(paths[index]);\r\n                }\r\n                subGroups.push({\r\n                    paths,\r\n                    dataNodeGroup,\r\n                    markerGroup,\r\n                    labelGroup,\r\n                    labelSelection: Selection.select(labelGroup, Text),\r\n                    datumSelection: Selection.select(dataNodeGroup, () => this.nodeFactory(), datumSelectionGarbageCollection),\r\n                    markerSelection: markerGroup\r\n                        ? Selection.select(markerGroup, () => this.markerFactory(), markerSelectionGarbageCollection)\r\n                        : undefined,\r\n                });\r\n            }\r\n        });\r\n    }\r\n    getGroupZIndexSubOrder(type, subIndex = 0) {\r\n        var _a;\r\n        const result = super.getGroupZIndexSubOrder(type, subIndex);\r\n        if (type === 'paths') {\r\n            const pathOffset = (_a = this.opts.pathsZIndexSubOrderOffset[subIndex]) !== null && _a !== void 0 ? _a : 0;\r\n            const superFn = result[0];\r\n            if (typeof superFn === 'function') {\r\n                result[0] = () => +superFn() + pathOffset;\r\n            }\r\n            else {\r\n                result[0] = +superFn + pathOffset;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    updateNodes(highlightedItems, seriesHighlighted, anySeriesItemEnabled) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { highlightSelection, highlightLabelSelection, opts: { hasMarkers, hasHighlightedLabels }, } = this;\r\n            const animationEnabled = !this.ctx.animationManager.isSkipped();\r\n            const visible = this.visible && ((_a = this._contextNodeData) === null || _a === void 0 ? void 0 : _a.length) > 0 && anySeriesItemEnabled;\r\n            this.rootGroup.visible = animationEnabled || visible;\r\n            this.contentGroup.visible = animationEnabled || visible;\r\n            this.highlightGroup.visible = (animationEnabled || visible) && !!seriesHighlighted;\r\n            const subGroupOpacity = this.getOpacity();\r\n            if (hasMarkers) {\r\n                yield this.updateMarkerNodes({\r\n                    markerSelection: highlightSelection,\r\n                    isHighlight: true,\r\n                    seriesIdx: -1,\r\n                });\r\n                this.animationState.transition('highlightMarkers', highlightSelection);\r\n            }\r\n            else {\r\n                yield this.updateDatumNodes({\r\n                    datumSelection: highlightSelection,\r\n                    isHighlight: true,\r\n                    seriesIdx: -1,\r\n                });\r\n                this.animationState.transition('highlight', highlightSelection);\r\n            }\r\n            if (hasHighlightedLabels) {\r\n                yield this.updateLabelNodes({ labelSelection: highlightLabelSelection, seriesIdx: -1 });\r\n            }\r\n            yield Promise.all(this.subGroups.map((subGroup, seriesIdx) => __awaiter(this, void 0, void 0, function* () {\r\n                const { dataNodeGroup, markerGroup, datumSelection, labelSelection, markerSelection, paths, labelGroup, } = subGroup;\r\n                const { itemId } = this.contextNodeData[seriesIdx];\r\n                const subGroupVisible = visible;\r\n                dataNodeGroup.opacity = subGroupOpacity;\r\n                dataNodeGroup.visible = animationEnabled || subGroupVisible;\r\n                labelGroup.visible = subGroupVisible;\r\n                if (markerGroup) {\r\n                    markerGroup.opacity = subGroupOpacity;\r\n                    markerGroup.zIndex =\r\n                        dataNodeGroup.zIndex >= Layers.SERIES_LAYER_ZINDEX\r\n                            ? dataNodeGroup.zIndex\r\n                            : dataNodeGroup.zIndex + 1;\r\n                    markerGroup.visible = subGroupVisible;\r\n                }\r\n                if (labelGroup) {\r\n                    labelGroup.opacity = subGroupOpacity;\r\n                }\r\n                yield this.updatePathNodes({\r\n                    seriesHighlighted,\r\n                    itemId,\r\n                    paths,\r\n                    seriesIdx,\r\n                    opacity: subGroupOpacity,\r\n                    visible: subGroupVisible,\r\n                    animationEnabled,\r\n                });\r\n                if (!dataNodeGroup.visible) {\r\n                    return;\r\n                }\r\n                yield this.updateDatumNodes({ datumSelection, highlightedItems, isHighlight: false, seriesIdx });\r\n                yield this.updateLabelNodes({ labelSelection, seriesIdx });\r\n                if (hasMarkers && markerSelection) {\r\n                    yield this.updateMarkerNodes({ markerSelection, isHighlight: false, seriesIdx });\r\n                }\r\n            })));\r\n        });\r\n    }\r\n    getHighlightLabelData(labelData, highlightedItem) {\r\n        const labelItem = labelData.find((ld) => ld.datum === highlightedItem.datum && ld.itemId === highlightedItem.itemId);\r\n        return labelItem ? [labelItem] : undefined;\r\n    }\r\n    getHighlightData(_nodeData, highlightedItem) {\r\n        return highlightedItem ? [highlightedItem] : undefined;\r\n    }\r\n    updateHighlightSelection(seriesHighlighted) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { highlightSelection, highlightLabelSelection, _contextNodeData: contextNodeData } = this;\r\n            const highlightedDatum = (_a = this.ctx.highlightManager) === null || _a === void 0 ? void 0 : _a.getActiveHighlight();\r\n            const item = seriesHighlighted && (highlightedDatum === null || highlightedDatum === void 0 ? void 0 : highlightedDatum.datum) ? highlightedDatum : undefined;\r\n            let labelItems;\r\n            let highlightItems;\r\n            if (item != null) {\r\n                const labelsEnabled = this.isLabelEnabled();\r\n                for (const { labelData, nodeData } of contextNodeData) {\r\n                    highlightItems = this.getHighlightData(nodeData, item);\r\n                    labelItems = labelsEnabled ? this.getHighlightLabelData(labelData, item) : undefined;\r\n                    if ((!labelsEnabled || labelItems != null) && highlightItems != null) {\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n            this.highlightSelection = yield this.updateHighlightSelectionItem({\r\n                items: highlightItems,\r\n                highlightSelection,\r\n            });\r\n            this.highlightLabelSelection = yield this.updateHighlightSelectionLabel({\r\n                items: labelItems,\r\n                highlightLabelSelection,\r\n            });\r\n            return highlightItems;\r\n        });\r\n    }\r\n    pickNodeExactShape(point) {\r\n        var _a;\r\n        const result = super.pickNodeExactShape(point);\r\n        if (result) {\r\n            return result;\r\n        }\r\n        const { x, y } = point;\r\n        const { opts: { hasMarkers }, } = this;\r\n        for (const { dataNodeGroup, markerGroup } of this.subGroups) {\r\n            let match = dataNodeGroup.pickNode(x, y);\r\n            if (!match && hasMarkers) {\r\n                match = markerGroup === null || markerGroup === void 0 ? void 0 : markerGroup.pickNode(x, y);\r\n            }\r\n            if (match) {\r\n                break;\r\n            }\r\n        }\r\n        {\r\n            for (const mod of this.moduleMap) {\r\n                const { datum } = (_a = mod.pickNodeExact(point)) !== null && _a !== void 0 ? _a : {};\r\n                if (datum !== undefined) {\r\n                    return { datum, distance: 0 };\r\n                }\r\n            }\r\n        }\r\n    }\r\n    pickNodeClosestDatum(point) {\r\n        var _a, _b;\r\n        const { x, y } = point;\r\n        const { axes, rootGroup, _contextNodeData: contextNodeData } = this;\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        const hitPoint = rootGroup.transformPoint(x, y);\r\n        let minDistance = Infinity;\r\n        let closestDatum;\r\n        for (const context of contextNodeData) {\r\n            for (const datum of context.nodeData) {\r\n                const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;\r\n                if (isNaN(datumX) || isNaN(datumY)) {\r\n                    continue;\r\n                }\r\n                const isInRange = (xAxis === null || xAxis === void 0 ? void 0 : xAxis.inRange(datumX)) && (yAxis === null || yAxis === void 0 ? void 0 : yAxis.inRange(datumY));\r\n                if (!isInRange) {\r\n                    continue;\r\n                }\r\n                // No need to use Math.sqrt() since x < y implies Math.sqrt(x) < Math.sqrt(y) for\r\n                // values > 1\r\n                const distance = Math.max(Math.pow((hitPoint.x - datumX), 2) + Math.pow((hitPoint.y - datumY), 2), 0);\r\n                if (distance < minDistance) {\r\n                    minDistance = distance;\r\n                    closestDatum = datum;\r\n                }\r\n            }\r\n        }\r\n        for (const mod of this.moduleMap) {\r\n            const modPick = mod.pickNodeNearest(point);\r\n            if (modPick !== undefined && modPick.distanceSquared < minDistance) {\r\n                minDistance = modPick.distanceSquared;\r\n                closestDatum = modPick.datum;\r\n                break;\r\n            }\r\n        }\r\n        if (closestDatum) {\r\n            const distance = Math.max(Math.sqrt(minDistance) - ((_b = (_a = closestDatum.point) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0), 0);\r\n            return { datum: closestDatum, distance };\r\n        }\r\n    }\r\n    pickNodeMainAxisFirst(point, requireCategoryAxis) {\r\n        var _a, _b;\r\n        const { x, y } = point;\r\n        const { axes, rootGroup, _contextNodeData: contextNodeData } = this;\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        // Prefer to start search with any available category axis.\r\n        const directions = [xAxis, yAxis]\r\n            .filter((a) => a instanceof CategoryAxis)\r\n            .map((a) => a.direction);\r\n        if (requireCategoryAxis && directions.length === 0) {\r\n            return;\r\n        }\r\n        // Default to X-axis unless we found a suitable category axis.\r\n        const [primaryDirection = ChartAxisDirection.X] = directions;\r\n        const hitPoint = rootGroup.transformPoint(x, y);\r\n        const hitPointCoords = primaryDirection === ChartAxisDirection.X ? [hitPoint.x, hitPoint.y] : [hitPoint.y, hitPoint.x];\r\n        const minDistance = [Infinity, Infinity];\r\n        let closestDatum;\r\n        for (const context of contextNodeData) {\r\n            for (const datum of context.nodeData) {\r\n                const { point: { x: datumX = NaN, y: datumY = NaN } = {} } = datum;\r\n                if (isNaN(datumX) || isNaN(datumY)) {\r\n                    continue;\r\n                }\r\n                const isInRange = (xAxis === null || xAxis === void 0 ? void 0 : xAxis.inRange(datumX)) && (yAxis === null || yAxis === void 0 ? void 0 : yAxis.inRange(datumY));\r\n                if (!isInRange) {\r\n                    continue;\r\n                }\r\n                const point = primaryDirection === ChartAxisDirection.X ? [datumX, datumY] : [datumY, datumX];\r\n                // Compare distances from most significant dimension to least.\r\n                let newMinDistance = true;\r\n                for (let i = 0; i < point.length; i++) {\r\n                    const dist = Math.abs(point[i] - hitPointCoords[i]);\r\n                    if (dist > minDistance[i]) {\r\n                        newMinDistance = false;\r\n                        break;\r\n                    }\r\n                    if (dist < minDistance[i]) {\r\n                        minDistance[i] = dist;\r\n                        minDistance.fill(Infinity, i + 1, minDistance.length);\r\n                    }\r\n                }\r\n                if (newMinDistance) {\r\n                    closestDatum = datum;\r\n                }\r\n            }\r\n        }\r\n        if (closestDatum) {\r\n            let closestDistanceSquared = Math.max(Math.pow(minDistance[0], 2) + Math.pow(minDistance[1], 2) - ((_b = (_a = closestDatum.point) === null || _a === void 0 ? void 0 : _a.size) !== null && _b !== void 0 ? _b : 0), 0);\r\n            for (const mod of this.moduleMap) {\r\n                const modPick = mod.pickNodeMainAxisFirst(point);\r\n                if (modPick !== undefined && modPick.distanceSquared < closestDistanceSquared) {\r\n                    closestDatum = modPick.datum;\r\n                    closestDistanceSquared = modPick.distanceSquared;\r\n                    break;\r\n                }\r\n            }\r\n            return { datum: closestDatum, distance: Math.sqrt(closestDistanceSquared) };\r\n        }\r\n    }\r\n    onLegendItemClick(event) {\r\n        const { enabled, itemId, series, legendItemName } = event;\r\n        const matchedLegendItemName = this.legendItemName != null && this.legendItemName === legendItemName;\r\n        if (series.id === this.id || matchedLegendItemName) {\r\n            this.toggleSeriesItem(itemId, enabled);\r\n        }\r\n    }\r\n    onLegendItemDoubleClick(event) {\r\n        const { enabled, itemId, series, numVisibleItems, legendItemName } = event;\r\n        const totalVisibleItems = Object.values(numVisibleItems).reduce((p, v) => p + v, 0);\r\n        const matchedLegendItemName = this.legendItemName != null && this.legendItemName === legendItemName;\r\n        if (series.id === this.id || matchedLegendItemName) {\r\n            // Double-clicked item should always become visible.\r\n            this.toggleSeriesItem(itemId, true);\r\n        }\r\n        else if (enabled && totalVisibleItems === 1) {\r\n            // Other items should become visible if there is only one existing visible item.\r\n            this.toggleSeriesItem(itemId, true);\r\n        }\r\n        else {\r\n            // Disable other items if not exactly one enabled.\r\n            this.toggleSeriesItem(itemId, false);\r\n        }\r\n    }\r\n    isPathOrSelectionDirty() {\r\n        // Override point to allow more sophisticated dirty selection detection.\r\n        return false;\r\n    }\r\n    getLabelData() {\r\n        return [];\r\n    }\r\n    shouldFlipXY() {\r\n        return false;\r\n    }\r\n    /**\r\n     * Get the minimum bounding box that contains any adjacent two nodes. The axes are treated independently, so this\r\n     * may not represent the same two points for both directions. The dimensions represent the greatest distance\r\n     * between any two adjacent nodes.\r\n     */\r\n    getMinRect() {\r\n        const [context] = this._contextNodeData;\r\n        if (!context || context.nodeData.length == 0)\r\n            return;\r\n        const width = context.nodeData\r\n            .map(({ midPoint }) => { var _a; return (_a = midPoint === null || midPoint === void 0 ? void 0 : midPoint.x) !== null && _a !== void 0 ? _a : 0; })\r\n            .sort((a, b) => a - b)\r\n            .reduce((max, x, i, array) => (i > 0 ? Math.max(max, x - array[i - 1]) : max), 0);\r\n        const height = context.nodeData\r\n            .map(({ midPoint }) => { var _a; return (_a = midPoint === null || midPoint === void 0 ? void 0 : midPoint.y) !== null && _a !== void 0 ? _a : 0; })\r\n            .sort((a, b) => a - b)\r\n            .reduce((max, y, i, array) => (i > 0 ? Math.max(max, y - array[i - 1]) : max), 0);\r\n        return new BBox(0, 0, width, height);\r\n    }\r\n    updateHighlightSelectionItem(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { opts: { hasMarkers }, } = this;\r\n            const { items, highlightSelection } = opts;\r\n            const nodeData = items !== null && items !== void 0 ? items : [];\r\n            if (hasMarkers) {\r\n                const markerSelection = highlightSelection;\r\n                return this.updateMarkerSelection({ nodeData, markerSelection, seriesIdx: -1 });\r\n            }\r\n            else {\r\n                return this.updateDatumSelection({\r\n                    nodeData,\r\n                    datumSelection: highlightSelection,\r\n                    seriesIdx: -1,\r\n                });\r\n            }\r\n        });\r\n    }\r\n    updateHighlightSelectionLabel(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { items, highlightLabelSelection } = opts;\r\n            const labelData = items !== null && items !== void 0 ? items : [];\r\n            return this.updateLabelSelection({ labelData, labelSelection: highlightLabelSelection, seriesIdx: -1 });\r\n        });\r\n    }\r\n    updateDatumSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Override point for sub-classes.\r\n            return opts.datumSelection;\r\n        });\r\n    }\r\n    updateDatumNodes(_opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Override point for sub-classes.\r\n        });\r\n    }\r\n    updateMarkerSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Override point for sub-classes.\r\n            return opts.markerSelection;\r\n        });\r\n    }\r\n    updateMarkerNodes(_opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Override point for sub-classes.\r\n        });\r\n    }\r\n    updatePaths(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            // Override point for sub-classes.\r\n            opts.paths.forEach((p) => (p.visible = false));\r\n        });\r\n    }\r\n    updatePathNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { paths, opacity, visible } = opts;\r\n            for (const path of paths) {\r\n                path.opacity = opacity;\r\n                path.visible = visible;\r\n            }\r\n        });\r\n    }\r\n    resetAllAnimation(data) {\r\n        var _a, _b;\r\n        const { path, datum, label, marker } = (_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.animationResetFns) !== null && _b !== void 0 ? _b : {};\r\n        // Stop any running animations by prefix convention.\r\n        this.ctx.animationManager.stopByAnimationGroupId(this.id);\r\n        if (path) {\r\n            data.paths.forEach((paths) => {\r\n                resetMotion(paths, path);\r\n            });\r\n        }\r\n        if (datum) {\r\n            resetMotion(data.datumSelections, datum);\r\n        }\r\n        if (label) {\r\n            resetMotion(data.labelSelections, label);\r\n        }\r\n        if (marker) {\r\n            resetMotion(data.markerSelections, marker);\r\n        }\r\n        if (data.contextData.some((d) => d.animationValid === false)) {\r\n            this.ctx.animationManager.skipCurrentBatch();\r\n        }\r\n    }\r\n    animateEmptyUpdateReady(data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation(data);\r\n    }\r\n    animateWaitingUpdateReady(data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation(data);\r\n    }\r\n    animateReadyHighlight(data) {\r\n        var _a, _b;\r\n        const { datum } = (_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.animationResetFns) !== null && _b !== void 0 ? _b : {};\r\n        if (datum) {\r\n            resetMotion([data], datum);\r\n        }\r\n    }\r\n    animateReadyHighlightMarkers(data) {\r\n        var _a, _b;\r\n        const { marker } = (_b = (_a = this.opts) === null || _a === void 0 ? void 0 : _a.animationResetFns) !== null && _b !== void 0 ? _b : {};\r\n        if (marker) {\r\n            resetMotion([data], marker);\r\n        }\r\n    }\r\n    animateReadyResize(data) {\r\n        this.resetAllAnimation(data);\r\n    }\r\n    animateClearingUpdateEmpty(data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation(data);\r\n    }\r\n    animationTransitionClear() {\r\n        this.animationState.transition('clear', this.getAnimationData());\r\n    }\r\n    getAnimationData(seriesRect, previousContextData) {\r\n        const animationData = {\r\n            datumSelections: this.subGroups.map(({ datumSelection }) => datumSelection),\r\n            markerSelections: this.subGroups\r\n                .filter(({ markerSelection }) => markerSelection !== undefined)\r\n                .map(({ markerSelection }) => markerSelection),\r\n            labelSelections: this.subGroups.map(({ labelSelection }) => labelSelection),\r\n            annotationSelections: [...this.annotationSelections],\r\n            contextData: this._contextNodeData,\r\n            previousContextData,\r\n            paths: this.subGroups.map(({ paths }) => paths),\r\n            seriesRect,\r\n        };\r\n        return animationData;\r\n    }\r\n    calculateScaling() {\r\n        const result = {};\r\n        const addScale = (direction) => {\r\n            const axis = this.axes[direction];\r\n            if (!axis)\r\n                return;\r\n            if (axis.scale instanceof LogScale) {\r\n                const { range, domain } = axis.scale;\r\n                result[direction] = {\r\n                    type: 'log',\r\n                    convert: (domain) => axis.scale.convert(domain),\r\n                    domain: [domain[0], domain[1]],\r\n                    range: [range[0], range[1]],\r\n                };\r\n            }\r\n            else if (axis.scale instanceof ContinuousScale) {\r\n                const { range } = axis.scale;\r\n                const domain = axis.scale.getDomain();\r\n                result[direction] = {\r\n                    type: 'continuous',\r\n                    domain: [domain[0], domain[1]],\r\n                    range: [range[0], range[1]],\r\n                };\r\n            }\r\n            else if (axis.scale) {\r\n                const { domain } = axis.scale;\r\n                result[direction] = {\r\n                    type: 'category',\r\n                    domain,\r\n                    range: domain.map((d) => axis.scale.convert(d)),\r\n                };\r\n            }\r\n        };\r\n        addScale(ChartAxisDirection.X);\r\n        addScale(ChartAxisDirection.Y);\r\n        return result;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], CartesianSeries.prototype, \"legendItemName\", void 0);\n\nconst directions = ['top', 'right', 'bottom', 'left'];\r\nclass CartesianChart extends Chart {\r\n    constructor(specialOverrides, resources) {\r\n        super(specialOverrides, resources);\r\n        /** Integrated Charts feature state - not used in Standalone Charts. */\r\n        this.paired = true;\r\n        this._lastAxisWidths = {\r\n            top: 0,\r\n            bottom: 0,\r\n            left: 0,\r\n            right: 0,\r\n        };\r\n        this._lastVisibility = {\r\n            crossLines: true,\r\n            series: true,\r\n        };\r\n    }\r\n    performLayout() {\r\n        const _super = Object.create(null, {\r\n            performLayout: { get: () => super.performLayout }\r\n        });\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const shrinkRect = yield _super.performLayout.call(this);\r\n            const { animationRect, seriesRect, visibility, clipSeries } = this.updateAxes(shrinkRect);\r\n            this.seriesRoot.visible = visibility.series;\r\n            this.seriesRect = seriesRect;\r\n            this.animationRect = animationRect;\r\n            this.seriesRoot.translationX = Math.floor(seriesRect.x);\r\n            this.seriesRoot.translationY = Math.floor(seriesRect.y);\r\n            const { seriesArea: { padding }, } = this;\r\n            // Recreate padding object to prevent issues with getters in `BBox.shrink()`\r\n            const seriesPaddedRect = seriesRect.clone().grow({\r\n                top: padding.top,\r\n                right: padding.right,\r\n                bottom: padding.bottom,\r\n                left: padding.left,\r\n            });\r\n            this.hoverRect = seriesPaddedRect;\r\n            this.layoutService.dispatchLayoutComplete({\r\n                type: 'layout-complete',\r\n                chart: { width: this.scene.width, height: this.scene.height },\r\n                clipSeries,\r\n                series: {\r\n                    rect: seriesRect,\r\n                    paddedRect: seriesPaddedRect,\r\n                    visible: visibility.series,\r\n                    shouldFlipXY: this.shouldFlipXY(),\r\n                },\r\n                axes: this.axes.map((axis) => (Object.assign({ id: axis.id }, axis.getLayoutState()))),\r\n            });\r\n            return shrinkRect;\r\n        });\r\n    }\r\n    updateAxes(inputShrinkRect) {\r\n        var _a;\r\n        // Start with a good approximation from the last update - this should mean that in many resize\r\n        // cases that only a single pass is needed \\o/.\r\n        const axisWidths = Object.assign({}, this._lastAxisWidths);\r\n        const visibility = Object.assign({}, this._lastVisibility);\r\n        // Clean any positions which aren't valid with the current axis status (otherwise we end up\r\n        // never being able to find a stable result).\r\n        const liveAxisWidths = new Set(this._axes.map((a) => a.position));\r\n        for (const position of Object.keys(axisWidths)) {\r\n            if (!liveAxisWidths.has(position)) {\r\n                delete axisWidths[position];\r\n            }\r\n        }\r\n        const stableOutputs = (otherAxisWidths, otherVisibility) => {\r\n            // Check for new axis positions.\r\n            if (Object.keys(otherAxisWidths).some((k) => axisWidths[k] == null)) {\r\n                return false;\r\n            }\r\n            return (visibility.crossLines === otherVisibility.crossLines &&\r\n                visibility.series === otherVisibility.series &&\r\n                // Check for existing axis positions and equality.\r\n                Object.entries(axisWidths).every(([p, w]) => {\r\n                    const otherW = otherAxisWidths[p];\r\n                    if (w != null || otherW != null) {\r\n                        return w === otherW;\r\n                    }\r\n                    return true;\r\n                }));\r\n        };\r\n        const ceilValues = (records) => {\r\n            return Object.entries(records).reduce((out, [key, value]) => {\r\n                if (value && Math.abs(value) === Infinity) {\r\n                    value = 0;\r\n                }\r\n                out[key] = value != null ? Math.ceil(value) : value;\r\n                return out;\r\n            }, {});\r\n        };\r\n        // Iteratively try to resolve axis widths - since X axis width affects Y axis range,\r\n        // and vice-versa, we need to iteratively try and find a fit for the axes and their\r\n        // ticks/labels.\r\n        let lastPassAxisWidths = {};\r\n        let lastPassVisibility = {};\r\n        let clipSeries = false;\r\n        let seriesRect = (_a = this.seriesRect) === null || _a === void 0 ? void 0 : _a.clone();\r\n        let count = 0;\r\n        let primaryTickCounts = {};\r\n        do {\r\n            Object.assign(axisWidths, lastPassAxisWidths);\r\n            Object.assign(visibility, lastPassVisibility);\r\n            const result = this.updateAxesPass(axisWidths, inputShrinkRect.clone(), seriesRect);\r\n            lastPassAxisWidths = ceilValues(result.axisWidths);\r\n            lastPassVisibility = result.visibility;\r\n            clipSeries = result.clipSeries;\r\n            seriesRect = result.seriesRect;\r\n            primaryTickCounts = result.primaryTickCounts;\r\n            if (count++ > 10) {\r\n                Logger.warn('unable to find stable axis layout.');\r\n                break;\r\n            }\r\n        } while (!stableOutputs(lastPassAxisWidths, lastPassVisibility));\r\n        this.axes.forEach((axis) => {\r\n            const { direction } = axis;\r\n            const primaryTickCount = primaryTickCounts[direction];\r\n            axis.update(primaryTickCount);\r\n        });\r\n        const clipRectPadding = 5;\r\n        this.axes.forEach((axis) => {\r\n            // update visibility of crosslines\r\n            axis.setCrossLinesVisible(visibility.crossLines);\r\n            if (!seriesRect) {\r\n                return;\r\n            }\r\n            axis.clipGrid(seriesRect.x, seriesRect.y, seriesRect.width + clipRectPadding, seriesRect.height + clipRectPadding);\r\n            switch (axis.position) {\r\n                case 'left':\r\n                case 'right':\r\n                    axis.clipTickLines(inputShrinkRect.x, seriesRect.y, inputShrinkRect.width + clipRectPadding, seriesRect.height + clipRectPadding);\r\n                    break;\r\n                case 'top':\r\n                case 'bottom':\r\n                    axis.clipTickLines(seriesRect.x, inputShrinkRect.y, seriesRect.width + clipRectPadding, inputShrinkRect.height + clipRectPadding);\r\n                    break;\r\n            }\r\n        });\r\n        this._lastAxisWidths = axisWidths;\r\n        this._lastVisibility = visibility;\r\n        return { seriesRect, animationRect: inputShrinkRect, visibility, clipSeries };\r\n    }\r\n    updateAxesPass(axisWidths, bounds, lastPassSeriesRect) {\r\n        const { axes } = this;\r\n        const visited = {};\r\n        const newAxisWidths = {};\r\n        const visibility = {\r\n            series: true,\r\n            crossLines: true,\r\n        };\r\n        let clipSeries = false;\r\n        const primaryTickCounts = {};\r\n        const paddedBounds = this.applySeriesPadding(bounds);\r\n        const crossLinePadding = lastPassSeriesRect ? this.buildCrossLinePadding(axisWidths) : {};\r\n        const axisBound = this.buildAxisBound(paddedBounds, axisWidths, crossLinePadding, visibility);\r\n        const seriesRect = this.buildSeriesRect(axisBound, axisWidths);\r\n        // Set the number of ticks for continuous axes based on the available range\r\n        // before updating the axis domain via `this.updateAxes()` as the tick count has an effect on the calculated `nice` domain extent\r\n        axes.forEach((axis) => {\r\n            var _a, _b;\r\n            const { position = 'left' } = axis;\r\n            const { clipSeries: newClipSeries, axisThickness, axisOffset, } = this.calculateAxisDimensions({\r\n                axis,\r\n                seriesRect,\r\n                paddedBounds,\r\n                axisWidths,\r\n                newAxisWidths,\r\n                primaryTickCounts,\r\n                clipSeries,\r\n                addInterAxisPadding: ((_a = visited[position]) !== null && _a !== void 0 ? _a : 0) > 0,\r\n            });\r\n            visited[position] = ((_b = visited[position]) !== null && _b !== void 0 ? _b : 0) + 1;\r\n            clipSeries = clipSeries || newClipSeries;\r\n            this.positionAxis({\r\n                axis,\r\n                axisBound,\r\n                axisOffset,\r\n                axisThickness,\r\n                axisWidths,\r\n                primaryTickCounts,\r\n                seriesRect,\r\n            });\r\n        });\r\n        return { clipSeries, seriesRect, axisWidths: newAxisWidths, visibility, primaryTickCounts };\r\n    }\r\n    buildCrossLinePadding(axisWidths) {\r\n        var _a;\r\n        const crossLinePadding = {};\r\n        this.axes.forEach((axis) => {\r\n            if (axis.crossLines) {\r\n                axis.crossLines.forEach((crossLine) => {\r\n                    crossLine.calculatePadding(crossLinePadding);\r\n                });\r\n            }\r\n        });\r\n        // Reduce cross-line padding to account for overlap with axes.\r\n        for (const [side, padding = 0] of Object.entries(crossLinePadding)) {\r\n            crossLinePadding[side] = Math.max(padding - ((_a = axisWidths[side]) !== null && _a !== void 0 ? _a : 0), 0);\r\n        }\r\n        return crossLinePadding;\r\n    }\r\n    applySeriesPadding(bounds) {\r\n        const paddedRect = bounds.clone();\r\n        const reversedAxes = this.axes.slice().reverse();\r\n        directions.forEach((dir) => {\r\n            const padding = this.seriesArea.padding[dir];\r\n            const axis = reversedAxes.find((axis) => axis.position === dir);\r\n            if (axis) {\r\n                axis.seriesAreaPadding = padding;\r\n            }\r\n            else {\r\n                paddedRect.shrink(padding, dir);\r\n            }\r\n        });\r\n        return paddedRect;\r\n    }\r\n    buildAxisBound(bounds, axisWidths, crossLinePadding, visibility) {\r\n        var _a, _b, _c, _d;\r\n        const result = bounds.clone();\r\n        const { top = 0, right = 0, bottom = 0, left = 0 } = crossLinePadding;\r\n        const horizontalPadding = left + right;\r\n        const verticalPadding = top + bottom;\r\n        const totalWidth = ((_a = axisWidths.left) !== null && _a !== void 0 ? _a : 0) + ((_b = axisWidths.right) !== null && _b !== void 0 ? _b : 0) + horizontalPadding;\r\n        const totalHeight = ((_c = axisWidths.top) !== null && _c !== void 0 ? _c : 0) + ((_d = axisWidths.bottom) !== null && _d !== void 0 ? _d : 0) + verticalPadding;\r\n        if (result.width <= totalWidth || result.height <= totalHeight) {\r\n            // Not enough space for crossLines and series\r\n            visibility.crossLines = false;\r\n            visibility.series = false;\r\n            return result;\r\n        }\r\n        result.x += left;\r\n        result.y += top;\r\n        result.width -= horizontalPadding;\r\n        result.height -= verticalPadding;\r\n        return result;\r\n    }\r\n    buildSeriesRect(axisBound, axisWidths) {\r\n        const result = axisBound.clone();\r\n        const { top, bottom, left, right } = axisWidths;\r\n        result.x += left !== null && left !== void 0 ? left : 0;\r\n        result.y += top !== null && top !== void 0 ? top : 0;\r\n        result.width -= (left !== null && left !== void 0 ? left : 0) + (right !== null && right !== void 0 ? right : 0);\r\n        result.height -= (top !== null && top !== void 0 ? top : 0) + (bottom !== null && bottom !== void 0 ? bottom : 0);\r\n        // Width and height should not be negative.\r\n        result.width = Math.max(0, result.width);\r\n        result.height = Math.max(0, result.height);\r\n        return result;\r\n    }\r\n    clampToOutsideSeriesRect(seriesRect, value, dimension, direction) {\r\n        const { x, y, width, height } = seriesRect;\r\n        const clampBounds = [x, y, x + width, y + height];\r\n        const fn = direction === 1 ? Math.min : Math.max;\r\n        const compareTo = clampBounds[(dimension === 'x' ? 0 : 1) + (direction === 1 ? 0 : 2)];\r\n        return fn(value, compareTo);\r\n    }\r\n    calculateAxisDimensions(opts) {\r\n        var _a, _b, _c, _d, _e;\r\n        const { axis, seriesRect, paddedBounds, axisWidths, newAxisWidths, primaryTickCounts, addInterAxisPadding } = opts;\r\n        let { clipSeries } = opts;\r\n        const { position = 'left', direction } = axis;\r\n        const axisLeftRightRange = (axis) => {\r\n            if (axis instanceof CategoryAxis || axis instanceof GroupedCategoryAxis) {\r\n                return [0, seriesRect.height];\r\n            }\r\n            return [seriesRect.height, 0];\r\n        };\r\n        const axisOffset = (_a = newAxisWidths[position]) !== null && _a !== void 0 ? _a : 0;\r\n        switch (position) {\r\n            case 'top':\r\n            case 'bottom':\r\n                axis.range = [0, seriesRect.width];\r\n                axis.gridLength = seriesRect.height;\r\n                break;\r\n            case 'right':\r\n            case 'left':\r\n                axis.range = axisLeftRightRange(axis);\r\n                axis.gridLength = seriesRect.width;\r\n                break;\r\n        }\r\n        const zoom = this.zoomManager.getAxisZoom(axis.id);\r\n        const { min = 0, max = 1 } = zoom !== null && zoom !== void 0 ? zoom : {};\r\n        axis.visibleRange = [min, max];\r\n        const rangeClipped = axis.dataDomain.clipped || axis.visibleRange[0] > 0 || axis.visibleRange[1] < 1;\r\n        clipSeries || (clipSeries = rangeClipped);\r\n        let primaryTickCount = axis.nice ? primaryTickCounts[direction] : undefined;\r\n        const paddedBoundsCoefficient = 0.3;\r\n        if (axis.thickness != null && axis.thickness > 0) {\r\n            axis.maxThickness = axis.thickness;\r\n        }\r\n        else if (direction === ChartAxisDirection.Y) {\r\n            axis.maxThickness = paddedBounds.width * paddedBoundsCoefficient;\r\n        }\r\n        else {\r\n            axis.maxThickness = paddedBounds.height * paddedBoundsCoefficient;\r\n        }\r\n        const layout = axis.calculateLayout(primaryTickCount);\r\n        primaryTickCount = layout.primaryTickCount;\r\n        primaryTickCounts[direction] = (_b = primaryTickCounts[direction]) !== null && _b !== void 0 ? _b : primaryTickCount;\r\n        let axisThickness = 0;\r\n        if (axis.thickness != null && axis.thickness > 0) {\r\n            axisThickness = axis.thickness;\r\n        }\r\n        else {\r\n            const { bbox } = layout;\r\n            axisThickness = direction === ChartAxisDirection.X ? bbox.height : bbox.width;\r\n        }\r\n        // for multiple axes in the same direction and position, apply padding at the top of each inner axis (i.e. between axes).\r\n        const axisPadding = 15;\r\n        if (addInterAxisPadding) {\r\n            axisThickness += axisPadding;\r\n        }\r\n        axisThickness = Math.ceil(axisThickness);\r\n        newAxisWidths[position] = ((_c = newAxisWidths[position]) !== null && _c !== void 0 ? _c : 0) + axisThickness;\r\n        axis.gridPadding = ((_d = axisWidths[position]) !== null && _d !== void 0 ? _d : 0) - ((_e = newAxisWidths[position]) !== null && _e !== void 0 ? _e : 0);\r\n        return { clipSeries, axisThickness, axisOffset, primaryTickCount };\r\n    }\r\n    positionAxis(opts) {\r\n        var _a, _b, _c, _d;\r\n        const { axis, axisBound, axisWidths, seriesRect, axisOffset, axisThickness } = opts;\r\n        const { position } = axis;\r\n        switch (position) {\r\n            case 'top':\r\n                axis.translation.x = axisBound.x + ((_a = axisWidths.left) !== null && _a !== void 0 ? _a : 0);\r\n                axis.translation.y = this.clampToOutsideSeriesRect(seriesRect, axisBound.y + 1 + axisOffset + axisThickness, 'y', 1);\r\n                break;\r\n            case 'bottom':\r\n                axis.translation.x = axisBound.x + ((_b = axisWidths.left) !== null && _b !== void 0 ? _b : 0);\r\n                axis.translation.y = this.clampToOutsideSeriesRect(seriesRect, axisBound.y + axisBound.height + 1 - axisThickness - axisOffset, 'y', -1);\r\n                break;\r\n            case 'left':\r\n                axis.translation.y = axisBound.y + ((_c = axisWidths.top) !== null && _c !== void 0 ? _c : 0);\r\n                axis.translation.x = this.clampToOutsideSeriesRect(seriesRect, axisBound.x + axisOffset + axisThickness, 'x', 1);\r\n                break;\r\n            case 'right':\r\n                axis.translation.y = axisBound.y + ((_d = axisWidths.top) !== null && _d !== void 0 ? _d : 0);\r\n                axis.translation.x = this.clampToOutsideSeriesRect(seriesRect, axisBound.x + axisBound.width - axisThickness - axisOffset, 'x', -1);\r\n                break;\r\n        }\r\n        axis.updatePosition({ rotation: toRadians(axis.rotation), sideFlag: axis.label.getSideFlag() });\r\n    }\r\n    shouldFlipXY() {\r\n        // Only flip the xy axes if all the series agree on flipping\r\n        return !this.series.some((series) => !(series instanceof CartesianSeries && series.shouldFlipXY()));\r\n    }\r\n}\r\nCartesianChart.className = 'CartesianChart';\r\nCartesianChart.type = 'cartesian';\n\n/**\r\n * Proxy class, to allow library users to keep a stable reference to their chart, even if we need\r\n * to switch concrete class (e.g. when switching between CartesianChart vs. PolarChart).\r\n */\r\nclass AgChartInstanceProxy {\r\n    static isInstance(x) {\r\n        var _a;\r\n        if (x instanceof AgChartInstanceProxy) {\r\n            // Simple case.\r\n            return true;\r\n        }\r\n        if (((_a = x.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'AgChartInstanceProxy' && x.chart != null) {\r\n            // instanceof can fail if mixing bundles (e.g. grid all-modules vs. standalone).\r\n            return true;\r\n        }\r\n        return x.chart != null && this.validateImplementation(x);\r\n    }\r\n    static validateImplementation(x) {\r\n        var _a, _b;\r\n        const chartProps = ['getOptions', 'destroy'];\r\n        const signatureProps = Object.keys((_b = (_a = x.constructor) === null || _a === void 0 ? void 0 : _a.prototype) !== null && _b !== void 0 ? _b : {});\r\n        return chartProps.every((prop) => signatureProps.includes(prop));\r\n    }\r\n    constructor(chart) {\r\n        this.chart = chart;\r\n    }\r\n    getOptions() {\r\n        return this.chart.getOptions();\r\n    }\r\n    destroy() {\r\n        this.chart.destroy();\r\n    }\r\n}\n\nfunction calculateNiceSecondaryAxis(domain, primaryTickCount) {\r\n    // Make secondary axis domain nice using strict tick count, matching the tick count from the primary axis.\r\n    // This is to make the secondary axis grid lines/ tick positions align with the ones from the primary axis.\r\n    let start = Math.floor(domain[0]);\r\n    let stop = domain[1];\r\n    start = calculateNiceStart(start, stop, primaryTickCount);\r\n    const step = getTickStep(start, stop, primaryTickCount);\r\n    const segments = primaryTickCount - 1;\r\n    stop = start + segments * step;\r\n    const d = [start, stop];\r\n    const ticks = getTicks(start, step, primaryTickCount);\r\n    return [d, ticks];\r\n}\r\nfunction calculateNiceStart(a, b, count) {\r\n    const rawStep = Math.abs(b - a) / (count - 1);\r\n    const order = Math.floor(Math.log10(rawStep));\r\n    const magnitude = Math.pow(10, order);\r\n    return Math.floor(a / magnitude) * magnitude;\r\n}\r\nfunction getTicks(start, step, count) {\r\n    // power of the step will be negative if the step is a fraction (between 0 and 1)\r\n    const stepPower = Math.floor(Math.log10(step));\r\n    const fractionDigits = step > 0 && step < 1 ? Math.abs(stepPower) : 0;\r\n    const f = Math.pow(10, fractionDigits);\r\n    const ticks = new NumericTicks(fractionDigits);\r\n    for (let i = 0; i < count; i++) {\r\n        const tick = start + step * i;\r\n        ticks[i] = Math.round(tick * f) / f;\r\n    }\r\n    return ticks;\r\n}\r\nfunction getTickStep(start, stop, count) {\r\n    const segments = count - 1;\r\n    const rawStep = (stop - start) / segments;\r\n    return calculateNextNiceStep(rawStep);\r\n}\r\nfunction calculateNextNiceStep(rawStep) {\r\n    const order = Math.floor(Math.log10(rawStep));\r\n    const magnitude = Math.pow(10, order);\r\n    // Make order 1\r\n    const step = (rawStep / magnitude) * 10;\r\n    if (step > 0 && step <= 1) {\r\n        return magnitude / 10;\r\n    }\r\n    if (step > 1 && step <= 2) {\r\n        return (2 * magnitude) / 10;\r\n    }\r\n    if (step > 1 && step <= 5) {\r\n        return (5 * magnitude) / 10;\r\n    }\r\n    if (step > 5 && step <= 10) {\r\n        return (10 * magnitude) / 10;\r\n    }\r\n    if (step > 10 && step <= 20) {\r\n        return (20 * magnitude) / 10;\r\n    }\r\n    if (step > 20 && step <= 40) {\r\n        return (40 * magnitude) / 10;\r\n    }\r\n    if (step > 40 && step <= 50) {\r\n        return (50 * magnitude) / 10;\r\n    }\r\n    if (step > 50 && step <= 100) {\r\n        return (100 * magnitude) / 10;\r\n    }\r\n    return step;\r\n}\n\nclass NumberAxisTick extends AxisTick {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.maxSpacing = NaN;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(AND(NUMBER_OR_NAN(1), GREATER_THAN('minSpacing'))),\r\n    Default(NaN),\r\n    __metadata(\"design:type\", Number)\r\n], NumberAxisTick.prototype, \"maxSpacing\", void 0);\r\nclass NumberAxis extends CartesianAxis {\r\n    constructor(moduleCtx, scale = new LinearScale()) {\r\n        super(moduleCtx, scale);\r\n        this.min = NaN;\r\n        this.max = NaN;\r\n    }\r\n    normaliseDataDomain(d) {\r\n        const { min, max } = this;\r\n        const { extent, clipped } = normalisedExtentWithMetadata(d, min, max);\r\n        return { domain: extent, clipped };\r\n    }\r\n    formatDatum(datum) {\r\n        if (typeof datum === 'number') {\r\n            return datum.toFixed(2);\r\n        }\r\n        else {\r\n            Logger.warnOnce('data contains Date objects which are being plotted against a number axis, please only use a number axis for numbers.');\r\n            return String(datum);\r\n        }\r\n    }\r\n    createTick() {\r\n        return new NumberAxisTick();\r\n    }\r\n    updateSecondaryAxisTicks(primaryTickCount) {\r\n        if (this.dataDomain == null) {\r\n            throw new Error('AG Charts - dataDomain not calculated, cannot perform tick calculation.');\r\n        }\r\n        if (this.dataDomain.domain.length === 0)\r\n            return [];\r\n        const [d, ticks] = calculateNiceSecondaryAxis(this.dataDomain.domain, primaryTickCount !== null && primaryTickCount !== void 0 ? primaryTickCount : 0);\r\n        this.scale.nice = false;\r\n        this.scale.domain = d;\r\n        this.scale.update();\r\n        return ticks;\r\n    }\r\n}\r\nNumberAxis.className = 'NumberAxis';\r\nNumberAxis.type = 'number';\r\n__decorate([\r\n    Validate(AND(NUMBER_OR_NAN(), LESS_THAN('max'))),\r\n    Default(NaN),\r\n    __metadata(\"design:type\", Number)\r\n], NumberAxis.prototype, \"min\", void 0);\r\n__decorate([\r\n    Validate(AND(NUMBER_OR_NAN(), GREATER_THAN('min'))),\r\n    Default(NaN),\r\n    __metadata(\"design:type\", Number)\r\n], NumberAxis.prototype, \"max\", void 0);\n\nfunction NON_ZERO_NUMBER() {\r\n    // Cannot be 0\r\n    const message = `expecting a non-zero Number`;\r\n    return predicateWithMessage((v) => typeof v === 'number' && v !== 0, message);\r\n}\r\nclass LogAxis extends NumberAxis {\r\n    normaliseDataDomain(d) {\r\n        const { min, max } = this;\r\n        const { extent, clipped } = normalisedExtentWithMetadata(d, min, max);\r\n        const isInverted = extent[0] > extent[1];\r\n        const crossesZero = extent[0] < 0 && extent[1] > 0;\r\n        const hasZeroExtent = extent[0] === 0 && extent[1] === 0;\r\n        const invalidDomain = isInverted || crossesZero || hasZeroExtent;\r\n        if (invalidDomain) {\r\n            d = [];\r\n            if (crossesZero) {\r\n                Logger.warn(`the data domain crosses zero, the chart data cannot be rendered. See log axis documentation for more information.`);\r\n            }\r\n            else if (hasZeroExtent) {\r\n                Logger.warn(`the data domain has 0 extent, no data is rendered.`);\r\n            }\r\n        }\r\n        if (extent[0] === 0) {\r\n            extent[0] = 1;\r\n        }\r\n        if (extent[1] === 0) {\r\n            extent[1] = -1;\r\n        }\r\n        return { domain: extent, clipped };\r\n    }\r\n    set base(value) {\r\n        this.scale.base = value;\r\n    }\r\n    get base() {\r\n        return this.scale.base;\r\n    }\r\n    constructor(moduleCtx) {\r\n        super(moduleCtx, new LogScale());\r\n        this.min = NaN;\r\n        this.max = NaN;\r\n    }\r\n}\r\nLogAxis.className = 'LogAxis';\r\nLogAxis.type = 'log';\r\n__decorate([\r\n    Validate(AND(NUMBER_OR_NAN(), LESS_THAN('max'), NON_ZERO_NUMBER())),\r\n    Default(NaN),\r\n    __metadata(\"design:type\", Number)\r\n], LogAxis.prototype, \"min\", void 0);\r\n__decorate([\r\n    Validate(AND(NUMBER_OR_NAN(), GREATER_THAN('min'), NON_ZERO_NUMBER())),\r\n    Default(NaN),\r\n    __metadata(\"design:type\", Number)\r\n], LogAxis.prototype, \"max\", void 0);\n\nclass TimeAxisTick extends AxisTick {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.maxSpacing = NaN;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(AND(NUMBER_OR_NAN(1), GREATER_THAN('minSpacing'))),\r\n    Default(NaN),\r\n    __metadata(\"design:type\", Number)\r\n], TimeAxisTick.prototype, \"maxSpacing\", void 0);\r\nclass TimeAxis extends CartesianAxis {\r\n    constructor(moduleCtx) {\r\n        super(moduleCtx, new TimeScale());\r\n        this.datumFormat = '%m/%d/%y, %H:%M:%S';\r\n        this.min = undefined;\r\n        this.max = undefined;\r\n        const { scale } = this;\r\n        this.refreshScale();\r\n        this.datumFormatter = scale.tickFormat({\r\n            specifier: this.datumFormat,\r\n        });\r\n    }\r\n    normaliseDataDomain(d) {\r\n        var _a;\r\n        let { min, max } = this;\r\n        let clipped = false;\r\n        if (typeof min === 'number') {\r\n            min = new Date(min);\r\n        }\r\n        if (typeof max === 'number') {\r\n            max = new Date(max);\r\n        }\r\n        if (d.length > 2) {\r\n            d = ((_a = extent(d)) !== null && _a !== void 0 ? _a : [0, 1000]).map((x) => new Date(x));\r\n        }\r\n        if (min instanceof Date) {\r\n            clipped || (clipped = min > d[0]);\r\n            d = [min, d[1]];\r\n        }\r\n        if (max instanceof Date) {\r\n            clipped || (clipped = max < d[1]);\r\n            d = [d[0], max];\r\n        }\r\n        if (d[0] > d[1]) {\r\n            d = [];\r\n        }\r\n        return { domain: d, clipped };\r\n    }\r\n    createTick() {\r\n        return new TimeAxisTick();\r\n    }\r\n    onLabelFormatChange(ticks, format) {\r\n        if (format) {\r\n            super.onLabelFormatChange(ticks, format);\r\n        }\r\n        else {\r\n            // For time axis labels to look nice, even if date format wasn't set.\r\n            this.labelFormatter = this.scale.tickFormat({ ticks });\r\n        }\r\n    }\r\n    formatDatum(datum) {\r\n        var _a;\r\n        return (_a = this.moduleCtx.callbackCache.call(this.datumFormatter, datum)) !== null && _a !== void 0 ? _a : String(datum);\r\n    }\r\n    calculatePadding(_min, _max) {\r\n        // numbers in domain correspond to Unix timestamps\r\n        // automatically expand domain by 1 in forward direction\r\n        return [0, 1];\r\n    }\r\n}\r\nTimeAxis.className = 'TimeAxis';\r\nTimeAxis.type = 'time';\r\n__decorate([\r\n    Validate(AND(OPT_DATE_OR_DATETIME_MS, LESS_THAN('max'))),\r\n    __metadata(\"design:type\", Object)\r\n], TimeAxis.prototype, \"min\", void 0);\r\n__decorate([\r\n    Validate(AND(OPT_DATE_OR_DATETIME_MS, GREATER_THAN('min'))),\r\n    __metadata(\"design:type\", Object)\r\n], TimeAxis.prototype, \"max\", void 0);\n\nconst AXIS_CONSTRUCTORS = {\r\n    [NumberAxis.type]: NumberAxis,\r\n    [CategoryAxis.type]: CategoryAxis,\r\n    [TimeAxis.type]: TimeAxis,\r\n    [GroupedCategoryAxis.type]: GroupedCategoryAxis,\r\n    [LogAxis.type]: LogAxis,\r\n};\r\nfunction registerAxis(axisType, ctor) {\r\n    AXIS_CONSTRUCTORS[axisType] = ctor;\r\n}\r\nfunction getAxis(axisType, moduleCtx) {\r\n    const axisConstructor = AXIS_CONSTRUCTORS[axisType];\r\n    if (axisConstructor) {\r\n        return new axisConstructor(moduleCtx);\r\n    }\r\n    throw new Error(`AG Charts - unknown axis type: ${axisType}`);\r\n}\r\nconst AXIS_TYPES = {\r\n    has(axisType) {\r\n        return Object.prototype.hasOwnProperty.call(AXIS_CONSTRUCTORS, axisType);\r\n    },\r\n    get axesTypes() {\r\n        return Object.keys(AXIS_CONSTRUCTORS);\r\n    },\r\n};\r\nconst AXIS_THEME_TEMPLATES = {};\r\nfunction registerAxisThemeTemplate(axisType, theme) {\r\n    AXIS_THEME_TEMPLATES[axisType] = theme;\r\n}\r\nfunction getAxisThemeTemplate(axisType) {\r\n    var _a;\r\n    return (_a = AXIS_THEME_TEMPLATES[axisType]) !== null && _a !== void 0 ? _a : {};\r\n}\n\nconst EXPECTED_ENTERPRISE_MODULES = [\r\n    { type: 'root', optionsKey: 'animation', chartTypes: ['cartesian', 'polar', 'hierarchy'] },\r\n    {\r\n        type: 'root',\r\n        optionsKey: 'background',\r\n        chartTypes: ['cartesian', 'polar', 'hierarchy'],\r\n        optionsInnerKey: 'image',\r\n    },\r\n    { type: 'root', optionsKey: 'contextMenu', chartTypes: ['cartesian', 'polar', 'hierarchy'] },\r\n    { type: 'root', optionsKey: 'zoom', chartTypes: ['cartesian'] },\r\n    {\r\n        type: 'legend',\r\n        optionsKey: 'gradientLegend',\r\n        chartTypes: ['cartesian', 'polar', 'hierarchy'],\r\n        identifier: 'gradient',\r\n    },\r\n    { type: 'axis', optionsKey: 'axes[]', chartTypes: ['polar'], identifier: 'angle-category' },\r\n    { type: 'axis', optionsKey: 'axes[]', chartTypes: ['polar'], identifier: 'angle-number' },\r\n    { type: 'axis', optionsKey: 'axes[]', chartTypes: ['polar'], identifier: 'radius-category' },\r\n    { type: 'axis', optionsKey: 'axes[]', chartTypes: ['polar'], identifier: 'radius-number' },\r\n    { type: 'axis-option', optionsKey: 'crosshair', chartTypes: ['cartesian'] },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['cartesian'], identifier: 'box-plot' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['cartesian'], identifier: 'bullet' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['cartesian'], identifier: 'heatmap' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['polar'], identifier: 'nightingale' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['polar'], identifier: 'radar-area' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['polar'], identifier: 'radar-line' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['polar'], identifier: 'radial-bar' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['polar'], identifier: 'radial-column' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['cartesian'], identifier: 'range-area' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['cartesian'], identifier: 'range-bar' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['hierarchy'], identifier: 'sunburst' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['hierarchy'], identifier: 'treemap' },\r\n    { type: 'series', optionsKey: 'series[]', chartTypes: ['cartesian'], identifier: 'waterfall' },\r\n    { type: 'series-option', optionsKey: 'errorBar', chartTypes: ['cartesian'], identifier: 'error-bars' },\r\n];\r\nfunction isEnterpriseSeriesType(type) {\r\n    return EXPECTED_ENTERPRISE_MODULES.some((s) => s.type === 'series' && s.identifier === type);\r\n}\r\nfunction getEnterpriseSeriesChartTypes(type) {\r\n    var _a;\r\n    return (_a = EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === 'series' && s.identifier === type)) === null || _a === void 0 ? void 0 : _a.chartTypes;\r\n}\r\nfunction isEnterpriseSeriesTypeLoaded(type) {\r\n    var _a, _b;\r\n    return ((_b = (_a = EXPECTED_ENTERPRISE_MODULES.find((s) => s.type === 'series' && s.identifier === type)) === null || _a === void 0 ? void 0 : _a.useCount) !== null && _b !== void 0 ? _b : 0) > 0;\r\n}\r\nfunction isEnterpriseCartesian(seriesType) {\r\n    var _a;\r\n    const type = (_a = getEnterpriseSeriesChartTypes(seriesType)) === null || _a === void 0 ? void 0 : _a.find((v) => v === 'cartesian');\r\n    return type === 'cartesian';\r\n}\r\nfunction isEnterprisePolar(seriesType) {\r\n    var _a;\r\n    const type = (_a = getEnterpriseSeriesChartTypes(seriesType)) === null || _a === void 0 ? void 0 : _a.find((v) => v === 'polar');\r\n    return type === 'polar';\r\n}\r\nfunction isEnterpriseHierarchy(seriesType) {\r\n    var _a;\r\n    const type = (_a = getEnterpriseSeriesChartTypes(seriesType)) === null || _a === void 0 ? void 0 : _a.find((v) => v === 'hierarchy');\r\n    return type === 'hierarchy';\r\n}\r\nfunction verifyIfModuleExpected(module) {\r\n    var _a;\r\n    if (module.packageType !== 'enterprise') {\r\n        throw new Error('AG Charts - internal configuration error, only enterprise modules need verification.');\r\n    }\r\n    const stub = EXPECTED_ENTERPRISE_MODULES.find((s) => {\r\n        return (s.type === module.type &&\r\n            s.optionsKey === module.optionsKey &&\r\n            s.identifier === module.identifier &&\r\n            module.chartTypes.every((t) => s.chartTypes.includes(t)));\r\n    });\r\n    if (stub) {\r\n        (_a = stub.useCount) !== null && _a !== void 0 ? _a : (stub.useCount = 0);\r\n        stub.useCount++;\r\n    }\r\n    return stub != null;\r\n}\r\nfunction getUnusedExpectedModules() {\r\n    return EXPECTED_ENTERPRISE_MODULES.filter(({ useCount }) => useCount == null || useCount === 0);\r\n}\n\nconst LEGEND_KEYS = {\r\n    category: 'legend',\r\n};\r\nfunction registerLegend(type, key, ctr, theme) {\r\n    LEGEND_KEYS[type] = key;\r\n    LEGEND_THEME_TEMPLATES[key] = theme;\r\n}\r\nconst LEGEND_THEME_TEMPLATES = {};\r\nfunction getLegendThemeTemplates() {\r\n    return LEGEND_THEME_TEMPLATES;\r\n}\r\nfunction getLegendKeys() {\r\n    return LEGEND_KEYS;\r\n}\n\nclass Background extends BaseModuleInstance {\r\n    constructor(ctx) {\r\n        var _a;\r\n        super();\r\n        this.node = new Group({ name: 'background', zIndex: Layers.SERIES_BACKGROUND_ZINDEX });\r\n        this.rectNode = new Rect();\r\n        this.visible = true;\r\n        this.fill = 'white';\r\n        // placeholder for enterprise module\r\n        this.image = undefined;\r\n        this.node.appendChild(this.rectNode);\r\n        (_a = ctx.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(this.node);\r\n        this.destroyFns.push(() => { var _a; return (_a = ctx.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(this.node); }, ctx.layoutService.addListener('layout-complete', (e) => this.onLayoutComplete(e)));\r\n    }\r\n    onLayoutComplete(e) {\r\n        const { width, height } = e.chart;\r\n        this.rectNode.width = width;\r\n        this.rectNode.height = height;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    ProxyPropertyOnWrite('node', 'visible'),\r\n    __metadata(\"design:type\", Boolean)\r\n], Background.prototype, \"visible\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    ProxyPropertyOnWrite('rectNode', 'fill'),\r\n    __metadata(\"design:type\", String)\r\n], Background.prototype, \"fill\", void 0);\n\nconst BackgroundModule = {\r\n    type: 'root',\r\n    optionsKey: 'background',\r\n    packageType: 'community',\r\n    chartTypes: ['cartesian', 'polar', 'hierarchy'],\r\n    instanceConstructor: Background,\r\n};\n\nclass NavigatorHandle {\r\n    set fill(value) {\r\n        this.rh.fill = value;\r\n    }\r\n    get fill() {\r\n        return this.rh.fill;\r\n    }\r\n    set stroke(value) {\r\n        this.rh.stroke = value;\r\n    }\r\n    get stroke() {\r\n        return this.rh.stroke;\r\n    }\r\n    set strokeWidth(value) {\r\n        this.rh.strokeWidth = value;\r\n    }\r\n    get strokeWidth() {\r\n        return this.rh.strokeWidth;\r\n    }\r\n    set width(value) {\r\n        this.rh.width = value;\r\n    }\r\n    get width() {\r\n        return this.rh.width;\r\n    }\r\n    set height(value) {\r\n        this.rh.height = value;\r\n    }\r\n    get height() {\r\n        return this.rh.height;\r\n    }\r\n    set gripLineGap(value) {\r\n        this.rh.gripLineGap = value;\r\n    }\r\n    get gripLineGap() {\r\n        return this.rh.gripLineGap;\r\n    }\r\n    set gripLineLength(value) {\r\n        this.rh.gripLineLength = value;\r\n    }\r\n    get gripLineLength() {\r\n        return this.rh.gripLineLength;\r\n    }\r\n    constructor(rangeHandle) {\r\n        this.rh = rangeHandle;\r\n    }\r\n}\n\nclass NavigatorMask {\r\n    set fill(value) {\r\n        this.rm.fill = value;\r\n    }\r\n    get fill() {\r\n        return this.rm.fill;\r\n    }\r\n    set stroke(value) {\r\n        this.rm.stroke = value;\r\n    }\r\n    get stroke() {\r\n        return this.rm.stroke;\r\n    }\r\n    set strokeWidth(value) {\r\n        this.rm.strokeWidth = value;\r\n    }\r\n    get strokeWidth() {\r\n        return this.rm.strokeWidth;\r\n    }\r\n    set fillOpacity(value) {\r\n        this.rm.fillOpacity = value;\r\n    }\r\n    get fillOpacity() {\r\n        return this.rm.fillOpacity;\r\n    }\r\n    constructor(rangeMask) {\r\n        this.rm = rangeMask;\r\n    }\r\n}\n\nclass RangeHandle extends Path {\r\n    constructor() {\r\n        super(...arguments);\r\n        this._fill = '#f2f2f2';\r\n        this._stroke = '#999999';\r\n        this._strokeWidth = 1;\r\n        this._lineCap = 'square';\r\n        this._centerX = 0;\r\n        this._centerY = 0;\r\n        // Use an even number for better looking results.\r\n        this._width = 8;\r\n        // Use an even number for better looking results.\r\n        this._gripLineGap = 2;\r\n        // Use an even number for better looking results.\r\n        this._gripLineLength = 8;\r\n        this._height = 16;\r\n    }\r\n    set centerX(value) {\r\n        if (this._centerX !== value) {\r\n            this._centerX = value;\r\n            this.dirtyPath = true;\r\n        }\r\n    }\r\n    get centerX() {\r\n        return this._centerX;\r\n    }\r\n    set centerY(value) {\r\n        if (this._centerY !== value) {\r\n            this._centerY = value;\r\n            this.dirtyPath = true;\r\n        }\r\n    }\r\n    get centerY() {\r\n        return this._centerY;\r\n    }\r\n    set width(value) {\r\n        if (this._width !== value) {\r\n            this._width = value;\r\n            this.dirtyPath = true;\r\n        }\r\n    }\r\n    get width() {\r\n        return this._width;\r\n    }\r\n    set gripLineGap(value) {\r\n        if (this._gripLineGap !== value) {\r\n            this._gripLineGap = value;\r\n            this.dirtyPath = true;\r\n        }\r\n    }\r\n    get gripLineGap() {\r\n        return this._gripLineGap;\r\n    }\r\n    set gripLineLength(value) {\r\n        if (this._gripLineLength !== value) {\r\n            this._gripLineLength = value;\r\n            this.dirtyPath = true;\r\n        }\r\n    }\r\n    get gripLineLength() {\r\n        return this._gripLineLength;\r\n    }\r\n    set height(value) {\r\n        if (this._height !== value) {\r\n            this._height = value;\r\n            this.dirtyPath = true;\r\n        }\r\n    }\r\n    get height() {\r\n        return this._height;\r\n    }\r\n    computeBBox() {\r\n        const { centerX, centerY, width, height } = this;\r\n        const x = centerX - width / 2;\r\n        const y = centerY - height / 2;\r\n        return new BBox(x, y, width, height);\r\n    }\r\n    isPointInPath(x, y) {\r\n        const point = this.transformPoint(x, y);\r\n        const bbox = this.computeBBox();\r\n        return bbox.containsPoint(point.x, point.y);\r\n    }\r\n    updatePath() {\r\n        const { path, centerX, centerY, width, height } = this;\r\n        path.clear();\r\n        const x = centerX - width / 2;\r\n        const y = centerY - height / 2;\r\n        const ax = this.align(x);\r\n        const ay = this.align(y);\r\n        const axw = ax + this.align(x, width);\r\n        const ayh = ay + this.align(y, height);\r\n        // Handle.\r\n        path.moveTo(ax, ay);\r\n        path.lineTo(axw, ay);\r\n        path.lineTo(axw, ayh);\r\n        path.lineTo(ax, ayh);\r\n        path.lineTo(ax, ay);\r\n        // Grip lines.\r\n        const dx = this.gripLineGap / 2;\r\n        const dy = this.gripLineLength / 2;\r\n        path.moveTo(this.align(centerX - dx), this.align(centerY - dy));\r\n        path.lineTo(this.align(centerX - dx), this.align(centerY + dy));\r\n        path.moveTo(this.align(centerX + dx), this.align(centerY - dy));\r\n        path.lineTo(this.align(centerX + dx), this.align(centerY + dy));\r\n    }\r\n}\r\nRangeHandle.className = 'RangeHandle';\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    __metadata(\"design:type\", Object)\r\n], RangeHandle.prototype, \"_fill\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    __metadata(\"design:type\", Object)\r\n], RangeHandle.prototype, \"_stroke\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], RangeHandle.prototype, \"_strokeWidth\", void 0);\r\n__decorate([\r\n    Validate(LINE_CAP),\r\n    __metadata(\"design:type\", Object)\r\n], RangeHandle.prototype, \"_lineCap\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], RangeHandle.prototype, \"_width\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], RangeHandle.prototype, \"_gripLineGap\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], RangeHandle.prototype, \"_gripLineLength\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], RangeHandle.prototype, \"_height\", void 0);\n\nfunction markDirtyOnChange(newValue, oldValue) {\r\n    if (newValue !== oldValue) {\r\n        this.dirtyPath = true;\r\n    }\r\n}\r\nclass RangeMask extends Path {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.x = 0;\r\n        this.y = 0;\r\n        this.width = 200;\r\n        this.height = 30;\r\n        this.minRange = 0.05;\r\n        this._min = 0;\r\n        this._max = 1;\r\n    }\r\n    set min(value) {\r\n        var _a;\r\n        value = clamp(0, value, this.max - this.minRange);\r\n        if (this._min !== value && !isNaN(value)) {\r\n            this._min = value;\r\n            this.dirtyPath = true;\r\n            (_a = this.onRangeChange) === null || _a === void 0 ? void 0 : _a.call(this);\r\n        }\r\n    }\r\n    get min() {\r\n        return this._min;\r\n    }\r\n    set max(value) {\r\n        var _a;\r\n        value = clamp(this.min + this.minRange, value, 1);\r\n        if (this._max !== value && !isNaN(value)) {\r\n            this._max = value;\r\n            this.dirtyPath = true;\r\n            (_a = this.onRangeChange) === null || _a === void 0 ? void 0 : _a.call(this);\r\n        }\r\n    }\r\n    get max() {\r\n        return this._max;\r\n    }\r\n    computeBBox() {\r\n        const { x, y, width, height } = this;\r\n        return new BBox(x, y, width, height);\r\n    }\r\n    computeVisibleRangeBBox() {\r\n        const { x, y, width, height, min, max } = this;\r\n        const minX = x + width * min;\r\n        const maxX = x + width * max;\r\n        return new BBox(minX, y, maxX - minX, height);\r\n    }\r\n    updatePath() {\r\n        const { path, x, y, width, height, min, max } = this;\r\n        path.clear();\r\n        const ax = this.align(x);\r\n        const ay = this.align(y);\r\n        const axw = ax + this.align(x, width);\r\n        const ayh = ay + this.align(y, height);\r\n        // Whole range.\r\n        path.moveTo(ax, ay);\r\n        path.lineTo(axw, ay);\r\n        path.lineTo(axw, ayh);\r\n        path.lineTo(ax, ayh);\r\n        path.lineTo(ax, ay);\r\n        const minX = this.align(x + width * min);\r\n        const maxX = this.align(x + width * max);\r\n        // Visible range.\r\n        path.moveTo(minX, ay);\r\n        path.lineTo(minX, ayh);\r\n        path.lineTo(maxX, ayh);\r\n        path.lineTo(maxX, ay);\r\n        path.lineTo(minX, ay);\r\n    }\r\n}\r\nRangeMask.className = 'RangeMask';\r\n__decorate([\r\n    ActionOnSet({ changeValue: markDirtyOnChange }),\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], RangeMask.prototype, \"x\", void 0);\r\n__decorate([\r\n    ActionOnSet({ changeValue: markDirtyOnChange }),\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], RangeMask.prototype, \"y\", void 0);\r\n__decorate([\r\n    ActionOnSet({ changeValue: markDirtyOnChange }),\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], RangeMask.prototype, \"width\", void 0);\r\n__decorate([\r\n    ActionOnSet({ changeValue: markDirtyOnChange }),\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], RangeMask.prototype, \"height\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    __metadata(\"design:type\", Number)\r\n], RangeMask.prototype, \"_min\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1()),\r\n    __metadata(\"design:type\", Number)\r\n], RangeMask.prototype, \"_max\", void 0);\n\nclass RangeSelector extends Group {\r\n    set x(value) {\r\n        this.mask.x = value;\r\n        this.updateHandles();\r\n    }\r\n    get x() {\r\n        return this.mask.x;\r\n    }\r\n    set y(value) {\r\n        this.mask.y = value;\r\n        this.updateHandles();\r\n    }\r\n    get y() {\r\n        return this.mask.y;\r\n    }\r\n    set width(value) {\r\n        this.mask.width = value;\r\n        this.updateHandles();\r\n    }\r\n    get width() {\r\n        return this.mask.width;\r\n    }\r\n    set height(value) {\r\n        this.mask.height = value;\r\n        this.updateHandles();\r\n    }\r\n    get height() {\r\n        return this.mask.height;\r\n    }\r\n    set min(value) {\r\n        this.mask.min = value;\r\n    }\r\n    get min() {\r\n        return this.mask.min;\r\n    }\r\n    set max(value) {\r\n        this.mask.max = value;\r\n    }\r\n    get max() {\r\n        return this.mask.max;\r\n    }\r\n    constructor() {\r\n        super({ name: 'rangeSelectorGroup' });\r\n        this.minHandle = new RangeHandle();\r\n        this.maxHandle = new RangeHandle();\r\n        this.mask = (() => {\r\n            const { x, y, width, height, min, max } = RangeSelector.defaults;\r\n            const mask = new RangeMask();\r\n            mask.x = x;\r\n            mask.y = y;\r\n            mask.width = width;\r\n            mask.height = height;\r\n            mask.min = min;\r\n            mask.max = max;\r\n            const { minHandle, maxHandle } = this;\r\n            minHandle.centerX = x;\r\n            maxHandle.centerX = x + width;\r\n            minHandle.centerY = maxHandle.centerY = y + height / 2;\r\n            this.append([mask, minHandle, maxHandle]);\r\n            mask.onRangeChange = () => {\r\n                var _a;\r\n                this.updateHandles();\r\n                (_a = this.onRangeChange) === null || _a === void 0 ? void 0 : _a.call(this);\r\n            };\r\n            return mask;\r\n        })();\r\n        this._x = RangeSelector.defaults.x;\r\n        this._y = RangeSelector.defaults.y;\r\n        this._width = RangeSelector.defaults.width;\r\n        this._height = RangeSelector.defaults.height;\r\n        this._min = RangeSelector.defaults.min;\r\n        this._max = RangeSelector.defaults.max;\r\n        this.isContainerNode = true;\r\n    }\r\n    updateHandles() {\r\n        const { minHandle, maxHandle, x, y, width, height, mask } = this;\r\n        minHandle.centerX = x + width * mask.min;\r\n        maxHandle.centerX = x + width * mask.max;\r\n        minHandle.centerY = maxHandle.centerY = y + height / 2;\r\n    }\r\n    computeBBox() {\r\n        return this.mask.computeBBox();\r\n    }\r\n    computeVisibleRangeBBox() {\r\n        return this.mask.computeVisibleRangeBBox();\r\n    }\r\n    render(renderCtx) {\r\n        const { ctx, forceRender, stats } = renderCtx;\r\n        if (this.dirty === RedrawType.NONE && !forceRender) {\r\n            if (stats)\r\n                stats.nodesSkipped++;\r\n            return;\r\n        }\r\n        this.computeTransformMatrix();\r\n        this.matrix.toContext(ctx);\r\n        const { mask, minHandle, maxHandle } = this;\r\n        [mask, minHandle, maxHandle].forEach((child) => {\r\n            if (child.visible && (forceRender || child.dirty > RedrawType.NONE)) {\r\n                ctx.save();\r\n                child.render(Object.assign(Object.assign({}, renderCtx), { ctx, forceRender }));\r\n                ctx.restore();\r\n            }\r\n        });\r\n        this.markClean({ force: true });\r\n        if (stats)\r\n            stats.nodesRendered++;\r\n    }\r\n}\r\nRangeSelector.className = 'Range';\r\nRangeSelector.defaults = {\r\n    x: 0,\r\n    y: 0,\r\n    width: 200,\r\n    height: 30,\r\n    min: 0,\r\n    max: 1,\r\n};\n\nclass Navigator extends BaseModuleInstance {\r\n    set width(value) {\r\n        this.rs.width = value;\r\n    }\r\n    get width() {\r\n        return this.rs.width;\r\n    }\r\n    set height(value) {\r\n        this.rs.height = value;\r\n    }\r\n    get height() {\r\n        return this.rs.height;\r\n    }\r\n    set min(value) {\r\n        this.rs.min = value;\r\n    }\r\n    get min() {\r\n        return this.rs.min;\r\n    }\r\n    set max(value) {\r\n        this.rs.max = value;\r\n    }\r\n    get max() {\r\n        return this.rs.max;\r\n    }\r\n    set visible(value) {\r\n        this._visible = value;\r\n        this.updateGroupVisibility();\r\n    }\r\n    get visible() {\r\n        return this._visible;\r\n    }\r\n    updateGroupVisibility() {\r\n        const visible = this.enabled && this.visible;\r\n        this.rs.visible = visible;\r\n        if (visible) {\r\n            this.ctx.zoomManager.updateZoom('navigator', {\r\n                x: { min: this.rs.min, max: this.rs.max },\r\n                y: { min: 0, max: 1 },\r\n            });\r\n        }\r\n        else {\r\n            this.ctx.zoomManager.updateZoom('navigator');\r\n        }\r\n    }\r\n    constructor(ctx) {\r\n        var _a;\r\n        super();\r\n        this.ctx = ctx;\r\n        this.rs = new RangeSelector();\r\n        // Wrappers to allow option application to the scene graph nodes.\r\n        this.mask = new NavigatorMask(this.rs.mask);\r\n        this.minHandle = new NavigatorHandle(this.rs.minHandle);\r\n        this.maxHandle = new NavigatorHandle(this.rs.maxHandle);\r\n        this.minHandleDragging = false;\r\n        this.maxHandleDragging = false;\r\n        this.panHandleOffset = NaN;\r\n        this.enabled = false;\r\n        this.margin = 10;\r\n        this._visible = true;\r\n        this.rs.onRangeChange = () => ctx.zoomManager.updateZoom('navigator', {\r\n            x: { min: this.rs.min, max: this.rs.max },\r\n            y: { min: 0, max: 1 },\r\n        });\r\n        (_a = ctx.scene.root) === null || _a === void 0 ? void 0 : _a.appendChild(this.rs);\r\n        const interactionOpts = { bypassPause: ['animation'] };\r\n        this.destroyFns.push(ctx.interactionManager.addListener('drag-start', (event) => this.onDragStart(event), interactionOpts), ctx.interactionManager.addListener('drag', (event) => this.onDrag(event), interactionOpts), ctx.interactionManager.addListener('hover', (event) => this.onDrag(event), interactionOpts), ctx.interactionManager.addListener('drag-end', () => this.onDragStop(), interactionOpts), ctx.layoutService.addListener('before-series', (event) => this.layout(event)), ctx.layoutService.addListener('layout-complete', (event) => this.layoutComplete(event)), () => { var _a; return (_a = ctx.scene.root) === null || _a === void 0 ? void 0 : _a.removeChild(this.rs); }, () => this.ctx.zoomManager.updateZoom('navigator'));\r\n        this.updateGroupVisibility();\r\n    }\r\n    layout({ shrinkRect }) {\r\n        if (this.enabled) {\r\n            const navigatorTotalHeight = this.rs.height + this.margin;\r\n            shrinkRect.shrink(navigatorTotalHeight, 'bottom');\r\n            this.rs.y = shrinkRect.y + shrinkRect.height + this.margin;\r\n        }\r\n        return { shrinkRect };\r\n    }\r\n    layoutComplete({ series: { rect, visible } }) {\r\n        if (this.enabled && visible) {\r\n            this.rs.x = rect.x;\r\n            this.rs.width = rect.width;\r\n        }\r\n        this.visible = visible;\r\n    }\r\n    onDragStart(offset) {\r\n        if (!this.enabled) {\r\n            return;\r\n        }\r\n        const { offsetX, offsetY } = offset;\r\n        const { rs } = this;\r\n        const { minHandle, maxHandle, x, width, min } = rs;\r\n        const visibleRange = rs.computeVisibleRangeBBox();\r\n        if (!(this.minHandleDragging || this.maxHandleDragging)) {\r\n            if (minHandle.containsPoint(offsetX, offsetY)) {\r\n                this.minHandleDragging = true;\r\n            }\r\n            else if (maxHandle.containsPoint(offsetX, offsetY)) {\r\n                this.maxHandleDragging = true;\r\n            }\r\n            else if (visibleRange.containsPoint(offsetX, offsetY)) {\r\n                this.panHandleOffset = (offsetX - x) / width - min;\r\n            }\r\n        }\r\n    }\r\n    onDrag(offset) {\r\n        if (!this.enabled) {\r\n            return;\r\n        }\r\n        const { rs, panHandleOffset } = this;\r\n        const { x, y, width, height, minHandle, maxHandle } = rs;\r\n        const { offsetX, offsetY } = offset;\r\n        const minX = x + width * rs.min;\r\n        const maxX = x + width * rs.max;\r\n        const visibleRange = new BBox(minX, y, maxX - minX, height);\r\n        const getRatio = () => Math.min(Math.max((offsetX - x) / width, 0), 1);\r\n        if (minHandle.containsPoint(offsetX, offsetY) || maxHandle.containsPoint(offsetX, offsetY)) {\r\n            this.ctx.cursorManager.updateCursor('navigator', 'ew-resize');\r\n        }\r\n        else if (visibleRange.containsPoint(offsetX, offsetY)) {\r\n            this.ctx.cursorManager.updateCursor('navigator', 'grab');\r\n        }\r\n        else {\r\n            this.ctx.cursorManager.updateCursor('navigator');\r\n        }\r\n        if (this.minHandleDragging) {\r\n            rs.min = getRatio();\r\n        }\r\n        else if (this.maxHandleDragging) {\r\n            rs.max = getRatio();\r\n        }\r\n        else if (!isNaN(panHandleOffset)) {\r\n            const span = rs.max - rs.min;\r\n            const min = Math.min(getRatio() - panHandleOffset, 1 - span);\r\n            if (min <= rs.min) {\r\n                // pan left\r\n                rs.min = min;\r\n                rs.max = rs.min + span;\r\n            }\r\n            else {\r\n                // pan right\r\n                rs.max = min + span;\r\n                rs.min = rs.max - span;\r\n            }\r\n        }\r\n    }\r\n    onDragStop() {\r\n        this.stopHandleDragging();\r\n    }\r\n    stopHandleDragging() {\r\n        this.minHandleDragging = this.maxHandleDragging = false;\r\n        this.panHandleOffset = NaN;\r\n    }\r\n}\r\n__decorate([\r\n    ActionOnSet({\r\n        changeValue(newValue) {\r\n            if (newValue) {\r\n                this.min = 0;\r\n                this.max = 1;\r\n            }\r\n            this.updateGroupVisibility();\r\n        },\r\n    }),\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Object)\r\n], Navigator.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], Navigator.prototype, \"margin\", void 0);\n\nconst NavigatorModule = {\r\n    type: 'root',\r\n    optionsKey: 'navigator',\r\n    packageType: 'community',\r\n    chartTypes: ['cartesian'],\r\n    instanceConstructor: Navigator,\r\n    themeTemplate: {\r\n        navigator: {\r\n            enabled: false,\r\n            height: 30,\r\n            mask: {\r\n                fill: '#999999',\r\n                stroke: '#999999',\r\n                strokeWidth: 1,\r\n                fillOpacity: 0.2,\r\n            },\r\n            minHandle: {\r\n                fill: '#f2f2f2',\r\n                stroke: '#999999',\r\n                strokeWidth: 1,\r\n                width: 8,\r\n                height: 16,\r\n                gripLineGap: 2,\r\n                gripLineLength: 8,\r\n            },\r\n            maxHandle: {\r\n                fill: '#f2f2f2',\r\n                stroke: '#999999',\r\n                strokeWidth: 1,\r\n                width: 8,\r\n                height: 16,\r\n                gripLineGap: 2,\r\n                gripLineLength: 8,\r\n            },\r\n        },\r\n    },\r\n};\n\nconst singleSeriesPaletteFactory = ({ takeColors }) => {\r\n    const { fills: [fill], strokes: [stroke], } = takeColors(1);\r\n    return { fill, stroke };\r\n};\r\nconst markerPaletteFactory = (params) => {\r\n    const { fill, stroke } = singleSeriesPaletteFactory(params);\r\n    return { marker: { fill, stroke } };\r\n};\n\nconst FONT_SIZE = {\r\n    SMALL: 12,\r\n    MEDIUM: 13,\r\n    LARGE: 17,\r\n};\r\nconst BOLD = 'bold';\r\nconst NORMAL = 'normal';\r\nconst BOTTOM = 'bottom';\r\nconst LEFT = 'left';\r\nconst TOP = 'top';\r\nconst CARTESIAN_AXIS_POSITIONS = {\r\n    BOTTOM,\r\n    LEFT,\r\n    TOP,\r\n};\r\nconst CATEGORY = 'category';\r\nconst NUMBER = 'number';\r\nconst TIME = 'time';\r\nconst LOG = 'log';\r\nconst CARTESIAN_AXIS_TYPES = {\r\n    CATEGORY,\r\n    NUMBER,\r\n    TIME,\r\n    LOG,\r\n};\r\nconst ANGLE_CATEGORY = 'angle-category';\r\nconst ANGLE_NUMBER = 'angle-number';\r\nconst RADIUS_CATEGORY = 'radius-category';\r\nconst RADIUS_NUMBER = 'radius-number';\r\nconst POLAR_AXIS_TYPES = {\r\n    ANGLE_CATEGORY,\r\n    ANGLE_NUMBER,\r\n    RADIUS_CATEGORY,\r\n    RADIUS_NUMBER,\r\n};\r\nconst CIRCLE = 'circle';\n\nconst TYPES = {};\r\nconst DEFAULTS = {};\r\nconst CHART_TYPES = {\r\n    has(seriesType) {\r\n        return Object.prototype.hasOwnProperty.call(TYPES, seriesType);\r\n    },\r\n    isCartesian(seriesType) {\r\n        return TYPES[seriesType] === 'cartesian';\r\n    },\r\n    isPolar(seriesType) {\r\n        return TYPES[seriesType] === 'polar';\r\n    },\r\n    isHierarchy(seriesType) {\r\n        return TYPES[seriesType] === 'hierarchy';\r\n    },\r\n    get seriesTypes() {\r\n        return Object.keys(TYPES);\r\n    },\r\n    get cartesianTypes() {\r\n        return this.seriesTypes.filter((t) => this.isCartesian(t));\r\n    },\r\n    get polarTypes() {\r\n        return this.seriesTypes.filter((t) => this.isPolar(t));\r\n    },\r\n    get hierarchyTypes() {\r\n        return this.seriesTypes.filter((t) => this.isHierarchy(t));\r\n    },\r\n};\r\nfunction registerChartSeriesType(seriesType, chartType) {\r\n    TYPES[seriesType] = chartType;\r\n}\r\nfunction registerChartDefaults(chartType, defaults) {\r\n    var _a;\r\n    DEFAULTS[chartType] = jsonMerge([(_a = DEFAULTS[chartType]) !== null && _a !== void 0 ? _a : {}, defaults]);\r\n}\r\nfunction getChartDefaults(chartType) {\r\n    var _a;\r\n    return (_a = DEFAULTS[chartType]) !== null && _a !== void 0 ? _a : {};\r\n}\r\nfunction getChartType(seriesType) {\r\n    var _a;\r\n    return (_a = TYPES[seriesType]) !== null && _a !== void 0 ? _a : 'unknown';\r\n}\n\nfunction optionsType(input) {\r\n    var _a, _b, _c, _d;\r\n    return (_d = (_a = input.type) !== null && _a !== void 0 ? _a : (_c = (_b = input.series) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.type) !== null && _d !== void 0 ? _d : 'line';\r\n}\r\nfunction isAgCartesianChartOptions(input) {\r\n    const specifiedType = optionsType(input);\r\n    if (specifiedType == null) {\r\n        return true;\r\n    }\r\n    if (specifiedType === 'cartesian') {\r\n        Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\r\n        return true;\r\n    }\r\n    return CHART_TYPES.isCartesian(specifiedType) || isEnterpriseCartesian(specifiedType);\r\n}\r\nfunction isAgHierarchyChartOptions(input) {\r\n    const specifiedType = optionsType(input);\r\n    if (specifiedType == null) {\r\n        return false;\r\n    }\r\n    if (specifiedType === 'hierarchy') {\r\n        Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\r\n        return true;\r\n    }\r\n    return CHART_TYPES.isHierarchy(specifiedType) || isEnterpriseHierarchy(specifiedType);\r\n}\r\nfunction isAgPolarChartOptions(input) {\r\n    const specifiedType = optionsType(input);\r\n    if (specifiedType == null) {\r\n        return false;\r\n    }\r\n    if (specifiedType === 'polar') {\r\n        Logger.warnOnce(`type '${specifiedType}' is deprecated, use a series type instead`);\r\n        return true;\r\n    }\r\n    return CHART_TYPES.isPolar(specifiedType) || isEnterprisePolar(specifiedType);\r\n}\r\nfunction isSeriesOptionType(input) {\r\n    if (input == null) {\r\n        return false;\r\n    }\r\n    return CHART_TYPES.has(input);\r\n}\r\nfunction isAxisOptionType(input) {\r\n    if (input == null) {\r\n        return false;\r\n    }\r\n    return AXIS_TYPES.has(input);\r\n}\n\nconst DEFAULT_CARTESIAN_CHART_OVERRIDES = {\r\n    axes: [\r\n        {\r\n            type: CARTESIAN_AXIS_TYPES.NUMBER,\r\n            position: CARTESIAN_AXIS_POSITIONS.LEFT,\r\n        },\r\n        {\r\n            type: CARTESIAN_AXIS_TYPES.CATEGORY,\r\n            position: CARTESIAN_AXIS_POSITIONS.BOTTOM,\r\n        },\r\n    ],\r\n};\r\nfunction swapAxes(opts) {\r\n    var _a;\r\n    if (!isAgCartesianChartOptions(opts)) {\r\n        return opts;\r\n    }\r\n    const [axis0, axis1] = (_a = opts.axes) !== null && _a !== void 0 ? _a : [];\r\n    return Object.assign(Object.assign({}, opts), { axes: [\r\n            Object.assign(Object.assign({}, axis0), { position: axis1.position }),\r\n            Object.assign(Object.assign({}, axis1), { position: axis0.position }),\r\n        ] });\r\n}\r\nfunction resolveModuleConflicts(opts) {\r\n    var _a, _b, _c, _d;\r\n    const conflictOverrides = {};\r\n    for (const [source, conflicts] of MODULE_CONFLICTS.entries()) {\r\n        if (opts[source] == null || !conflicts.length) {\r\n            continue;\r\n        }\r\n        (_a = conflictOverrides[source]) !== null && _a !== void 0 ? _a : (conflictOverrides[source] = {});\r\n        for (const conflict of conflicts) {\r\n            if (((_b = opts[source]) === null || _b === void 0 ? void 0 : _b.enabled) && ((_c = opts[conflict]) === null || _c === void 0 ? void 0 : _c.enabled)) {\r\n                Logger.warnOnce(`the [${source}] module can not be used at the same time as [${conflict}], it will be disabled.`);\r\n                conflictOverrides[source].enabled = false;\r\n            }\r\n            else {\r\n                conflictOverrides[source].enabled = (_d = opts[source]) === null || _d === void 0 ? void 0 : _d.enabled;\r\n            }\r\n        }\r\n    }\r\n    return conflictOverrides;\r\n}\n\nconst EXTENDS_CHART_DEFAULTS = Symbol('extends-chart-defaults');\r\nconst EXTENDS_LEGEND_DEFAULTS = Symbol('extends-legend-defaults');\r\nconst EXTENDS_LEGEND_ITEM_DEFAULTS = Symbol('extends-legend-item-defaults');\r\nconst EXTENDS_LEGEND_ITEM_MARKER_DEFAULTS = Symbol('extends-legend-item-marker-defaults');\r\nconst EXTENDS_AXES_DEFAULTS = Symbol('extends-axes-defaults');\r\nconst EXTENDS_AXES_LABEL_DEFAULTS = Symbol('extends-axes-label-defaults');\r\nconst EXTENDS_AXES_LINE_DEFAULTS = Symbol('extends-axes-line-defaults');\r\nconst EXTENDS_AXES_TICK_DEFAULTS = Symbol('extends-axes-tick-defaults');\r\nconst EXTENDS_AXES_GRID_LINE_DEFAULTS = Symbol('extends-axes-grid-line-defaults');\r\nconst EXTENDS_SERIES_DEFAULTS = Symbol('extends-series-defaults');\r\nconst EXTENDS_CARTESIAN_MARKER_DEFAULTS = Symbol('extends-cartesian-marker-defaults');\r\nconst OVERRIDE_SERIES_LABEL_DEFAULTS = Symbol('override-series-label-defaults');\r\nconst DEFAULT_FONT_FAMILY = Symbol('default-font');\r\nconst DEFAULT_LABEL_COLOUR = Symbol('default-label-colour');\r\nconst DEFAULT_INVERTED_LABEL_COLOUR = Symbol('default-inverted-label-colour');\r\nconst DEFAULT_INSIDE_SERIES_LABEL_COLOUR = Symbol('default-inside-series-label-colour');\r\nconst DEFAULT_MUTED_LABEL_COLOUR = Symbol('default-muted-label-colour');\r\nconst DEFAULT_AXIS_GRID_COLOUR = Symbol('default-axis-grid-colour');\r\nconst DEFAULT_AXIS_LINE_COLOUR = Symbol('default-axis-line-colour');\r\nconst DEFAULT_CROSS_LINES_COLOUR = Symbol('default-cross-lines-colour');\r\nconst DEFAULT_BACKGROUND_COLOUR = Symbol('default-background-colour');\r\nconst DEFAULT_SHADOW_COLOUR = Symbol('default-shadow-colour');\r\nconst DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS = Symbol('default-waterfall-series-positive-colors');\r\nconst DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS = Symbol('default-waterfall-series-negative-colors');\r\nconst DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS = Symbol('default-waterfall-series-total-colors');\r\nconst DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE = Symbol('default-waterfall-series-connector-line-stroke');\r\nconst DEFAULT_POLAR_SERIES_STROKE = Symbol('default-polar-series-stroke');\r\nconst DEFAULT_DIVERGING_SERIES_COLOUR_RANGE = Symbol('default-diverging-series-colour-range');\r\nconst DEFAULT_HIERARCHY_FILLS = Symbol('default-hierarchy-fills');\r\nconst DEFAULT_HIERARCHY_STROKES = Symbol('default-hierarchy-strokes');\n\n/**\r\n * Implements a per-path \"to/from\" animation.\r\n *\r\n * @param id prefix for all animation ids generated by this call\r\n * @param animationManager used to schedule generated animations\r\n * @param paths contains paths to be animated\r\n * @param intermediateFn callback to update path\r\n * @param extraOpts optional additional animation properties to pass to AnimationManager#animate.\r\n */\r\nfunction pathMotion(groupId, subId, animationManager, paths, fns) {\r\n    const { defaultDuration } = animationManager;\r\n    const { addPhaseFn, updatePhaseFn, removePhaseFn } = fns;\r\n    const animate = (phase, path, updateFn) => {\r\n        animationManager.animate({\r\n            id: `${groupId}_${subId}_${path.id}_${phase}`,\r\n            groupId,\r\n            from: 0,\r\n            to: 1,\r\n            ease: easeOut,\r\n            onUpdate(ratio, preInit) {\r\n                if (preInit && phase !== 'removed')\r\n                    return;\r\n                path.path.clear({ trackChanges: true });\r\n                updateFn(ratio, path);\r\n                path.checkPathDirty();\r\n            },\r\n            onStop() {\r\n                if (phase !== 'added')\r\n                    return;\r\n                path.path.clear({ trackChanges: true });\r\n                updateFn(1, path);\r\n                path.checkPathDirty();\r\n            },\r\n            duration: FROM_TO_MIXINS[phase].animationDuration * defaultDuration,\r\n            delay: FROM_TO_MIXINS[phase].animationDelay * defaultDuration,\r\n        });\r\n    };\r\n    for (const path of paths) {\r\n        if (!animationManager.isSkipped()) {\r\n            animate('removed', path, removePhaseFn);\r\n            animate('updated', path, updatePhaseFn);\r\n        }\r\n        animate('added', path, addPhaseFn);\r\n    }\r\n}\n\nconst MARKER_SHAPE = predicateWithMessage((v) => isMarkerShape(v) || Object.getPrototypeOf(v) === Marker, `expecting a marker shape keyword such as 'circle', 'diamond' or 'square' or an object extending the Marker class`);\r\nclass SeriesMarker extends ChangeDetectable {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.enabled = true;\r\n        /** One of the predefined marker names, or a marker constructor function (for user-defined markers). */\r\n        this.shape = Circle;\r\n        this.size = 6;\r\n        this.fillOpacity = 1;\r\n        this.strokeWidth = 1;\r\n        this.strokeOpacity = 1;\r\n    }\r\n    getStyle() {\r\n        const { size, fill, fillOpacity, stroke, strokeWidth, strokeOpacity } = this;\r\n        return { size, fill, fillOpacity, stroke, strokeWidth, strokeOpacity };\r\n    }\r\n    getDiameter() {\r\n        return this.size + this.strokeWidth;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Object)\r\n], SeriesMarker.prototype, \"enabled\", void 0);\r\n__decorate([\r\n    Validate(MARKER_SHAPE),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Object)\r\n], SeriesMarker.prototype, \"shape\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesMarker.prototype, \"size\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", String)\r\n], SeriesMarker.prototype, \"fill\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesMarker.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", String)\r\n], SeriesMarker.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesMarker.prototype, \"strokeWidth\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0, 1)),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Number)\r\n], SeriesMarker.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Function)\r\n], SeriesMarker.prototype, \"formatter\", void 0);\n\nfunction markerFadeInAnimation({ id }, animationManager, markerSelections, status = 'unknown') {\r\n    const params = Object.assign({}, FROM_TO_MIXINS[status]);\r\n    staticFromToMotion(id, 'markers', animationManager, markerSelections, { opacity: 0 }, { opacity: 1 }, params);\r\n    markerSelections.forEach((s) => s.cleanup());\r\n}\r\nfunction markerScaleInAnimation({ id }, animationManager, markerSelections) {\r\n    staticFromToMotion(id, 'markers', animationManager, markerSelections, { scalingX: 0, scalingY: 0 }, { scalingX: 1, scalingY: 1 });\r\n    markerSelections.forEach((s) => s.cleanup());\r\n}\r\nfunction markerSwipeScaleInAnimation({ id }, animationManager, markerSelections, seriesWidth) {\r\n    // Improves consistency with matching parallel animations.\r\n    const tweakFactor = 0.1;\r\n    const fromFn = (_, datum) => {\r\n        var _a, _b;\r\n        const x = (_b = (_a = datum.midPoint) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : seriesWidth;\r\n        // Calculate a delay that depends on the X position of the datum, so that nodes appear\r\n        // gradually from left to right. Use easeInOut to match any parallel swipe animations.\r\n        const delayRatio = easeInOut(x / seriesWidth) - tweakFactor;\r\n        const delay = Math.max(Math.min(delayRatio, 1), 0);\r\n        return { scalingX: 0, scalingY: 0, animationDelay: delay, animationDuration: QUICK_TRANSITION };\r\n    };\r\n    const toFn = () => {\r\n        return { scalingX: 1, scalingY: 1 };\r\n    };\r\n    fromToMotion(id, 'markers', animationManager, markerSelections, { fromFn, toFn });\r\n}\r\nfunction resetMarkerFn(_node) {\r\n    return { opacity: 1, scalingX: 1, scalingY: 1 };\r\n}\r\nfunction resetMarkerPositionFn(_node, datum) {\r\n    var _a, _b, _c, _d;\r\n    return {\r\n        translationX: (_b = (_a = datum.point) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : NaN,\r\n        translationY: (_d = (_c = datum.point) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : NaN,\r\n    };\r\n}\r\nfunction prepareMarkerAnimation(pairMap, parentStatus) {\r\n    const readFirstPair = (xValue, type) => {\r\n        const val = pairMap[type][xValue];\r\n        return Array.isArray(val) ? val[0] : val;\r\n    };\r\n    const markerStatus = (datum) => {\r\n        const { xValue } = datum;\r\n        if (pairMap.moved[xValue]) {\r\n            return { point: readFirstPair(xValue, 'moved'), status: 'updated' };\r\n        }\r\n        else if (pairMap.removed[xValue]) {\r\n            return { point: readFirstPair(xValue, 'removed'), status: 'removed' };\r\n        }\r\n        else if (pairMap.added[xValue]) {\r\n            return { point: readFirstPair(xValue, 'added'), status: 'added' };\r\n        }\r\n        return { status: 'unknown' };\r\n    };\r\n    const fromFn = (marker, datum) => {\r\n        var _a, _b, _c, _d, _e, _f;\r\n        const { status, point } = markerStatus(datum);\r\n        if (status === 'unknown')\r\n            return { opacity: 0 };\r\n        const defaults = Object.assign({ translationX: (_b = (_a = point === null || point === void 0 ? void 0 : point.from) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : marker.translationX, translationY: (_d = (_c = point === null || point === void 0 ? void 0 : point.from) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : marker.translationY, opacity: marker.opacity }, FROM_TO_MIXINS[status]);\r\n        if (parentStatus === 'added') {\r\n            return Object.assign(Object.assign(Object.assign({}, defaults), { opacity: 0, translationX: (_e = point === null || point === void 0 ? void 0 : point.to) === null || _e === void 0 ? void 0 : _e.x, translationY: (_f = point === null || point === void 0 ? void 0 : point.to) === null || _f === void 0 ? void 0 : _f.y }), FROM_TO_MIXINS['added']);\r\n        }\r\n        if (status === 'added') {\r\n            defaults.opacity = 0;\r\n        }\r\n        return defaults;\r\n    };\r\n    const toFn = (_marker, datum) => {\r\n        var _a, _b;\r\n        const { status, point } = markerStatus(datum);\r\n        if (status === 'unknown')\r\n            return { opacity: 0 };\r\n        const defaults = Object.assign({ translationX: datum.point.x, translationY: datum.point.y, opacity: 1 }, FROM_TO_MIXINS[status]);\r\n        if (status === 'removed' || parentStatus === 'removed') {\r\n            return Object.assign(Object.assign(Object.assign({}, defaults), { translationX: (_a = point === null || point === void 0 ? void 0 : point.to) === null || _a === void 0 ? void 0 : _a.x, translationY: (_b = point === null || point === void 0 ? void 0 : point.to) === null || _b === void 0 ? void 0 : _b.y, opacity: 0 }), FROM_TO_MIXINS['removed']);\r\n        }\r\n        return defaults;\r\n    };\r\n    return { fromFn, toFn };\r\n}\n\nfunction minMax(nodeData) {\r\n    return nodeData.reduce(({ min, max }, node) => {\r\n        if (min == null || min.point.x > node.point.x) {\r\n            min = node;\r\n        }\r\n        if (max == null || max.point.x < node.point.x) {\r\n            max = node;\r\n        }\r\n        return { min, max };\r\n    }, {});\r\n}\r\nfunction intersectionOnLine(a, b, targetX) {\r\n    const m = (b.y - a.y) / (b.x - a.x);\r\n    // Find a point a distance along the line from `a` and `b`\r\n    const y = (targetX - a.x) * m + a.y;\r\n    return { x: targetX, y };\r\n}\r\nfunction backfillPathPoint(results, process, skip, processFn) {\r\n    let prevMarkerIdx = -1, nextMarkerIdx = 0;\r\n    const toProcess = [];\r\n    while (nextMarkerIdx < results.length) {\r\n        if (results[nextMarkerIdx].change === process) {\r\n            toProcess.push(results[nextMarkerIdx]);\r\n            nextMarkerIdx++;\r\n            continue;\r\n        }\r\n        if (results[nextMarkerIdx].change === skip) {\r\n            nextMarkerIdx++;\r\n            continue;\r\n        }\r\n        if (toProcess.length > 0) {\r\n            processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\r\n            toProcess.length = 0;\r\n        }\r\n        prevMarkerIdx = nextMarkerIdx;\r\n        nextMarkerIdx++;\r\n    }\r\n    if (toProcess.length > 0) {\r\n        processFn(toProcess, prevMarkerIdx, nextMarkerIdx);\r\n    }\r\n}\r\nfunction backfillPathPointData(result, splitMode) {\r\n    backfillPathPoint(result, 'out', 'in', (toProcess, sIdx, eIdx) => {\r\n        var _a, _b;\r\n        if (sIdx === -1 && result[eIdx]) {\r\n            toProcess.forEach((d) => (d.to = result[eIdx].from));\r\n        }\r\n        else if (eIdx === result.length && result[sIdx]) {\r\n            toProcess.forEach((d) => (d.to = result[sIdx].from));\r\n        }\r\n        else if (splitMode === 'intersect' && ((_a = result[sIdx]) === null || _a === void 0 ? void 0 : _a.from) && ((_b = result[eIdx]) === null || _b === void 0 ? void 0 : _b.from)) {\r\n            toProcess.forEach((d) => (d.to = intersectionOnLine(result[sIdx].from, result[eIdx].from, d.from.x)));\r\n        }\r\n        else {\r\n            toProcess.forEach((d) => (d.to = d.from));\r\n        }\r\n    });\r\n    backfillPathPoint(result, 'in', 'out', (toProcess, sIdx, eIdx) => {\r\n        var _a, _b;\r\n        if (sIdx === -1 && result[eIdx]) {\r\n            toProcess.forEach((d) => (d.from = result[eIdx].to));\r\n        }\r\n        else if (eIdx === result.length && result[sIdx]) {\r\n            toProcess.forEach((d) => (d.from = result[sIdx].to));\r\n        }\r\n        else if (splitMode === 'intersect' && ((_a = result[sIdx]) === null || _a === void 0 ? void 0 : _a.to) && ((_b = result[eIdx]) === null || _b === void 0 ? void 0 : _b.to)) {\r\n            toProcess.forEach((d) => (d.from = intersectionOnLine(result[sIdx].to, result[eIdx].to, d.to.x)));\r\n        }\r\n        else {\r\n            toProcess.forEach((d) => (d.from = d.to));\r\n        }\r\n    });\r\n}\r\nfunction calculatePoint(from, to, ratio) {\r\n    const x1 = isNaN(from.x) ? to.x : from.x;\r\n    const y1 = isNaN(from.y) ? to.y : from.y;\r\n    const xd = to.x - from.x;\r\n    const yd = to.y - from.y;\r\n    const xr = isNaN(xd) ? 0 : xd * ratio;\r\n    const yr = isNaN(yd) ? 0 : yd * ratio;\r\n    return {\r\n        x: x1 + xr,\r\n        y: y1 + yr,\r\n    };\r\n}\r\nfunction renderPartialPath(pairData, ratios, path) {\r\n    const { path: linePath } = path;\r\n    let previousTo;\r\n    for (const data of pairData) {\r\n        const ratio = ratios[data.change];\r\n        if (ratio == null)\r\n            continue;\r\n        const { from, to } = data;\r\n        if (from == null || to == null)\r\n            continue;\r\n        const { x, y } = calculatePoint(from, to, ratio);\r\n        if (data.moveTo === false) {\r\n            linePath.lineTo(x, y);\r\n        }\r\n        else if (data.moveTo === true || !previousTo) {\r\n            linePath.moveTo(x, y);\r\n        }\r\n        else if (previousTo) {\r\n            const moveToRatio = data.moveTo === 'in' ? ratio : 1 - ratio;\r\n            const { x: midPointX, y: midPointY } = calculatePoint(previousTo, { x, y }, moveToRatio);\r\n            linePath.lineTo(midPointX, midPointY);\r\n            linePath.moveTo(x, y);\r\n        }\r\n        previousTo = { x, y };\r\n    }\r\n}\r\nfunction pathSwipeInAnimation({ id }, animationManager, paths) {\r\n    staticFromToMotion(id, 'path_properties', animationManager, paths, { clipScalingX: 0 }, { clipScalingX: 1 }, {\r\n        start: { clipMode: 'normal' },\r\n        finish: { clipMode: undefined },\r\n    });\r\n}\r\nfunction pathFadeInAnimation({ id }, subId, animationManager, selection) {\r\n    staticFromToMotion(id, subId, animationManager, selection, { opacity: 0 }, { opacity: 1 }, LABEL_PHASE);\r\n}\r\nfunction pathFadeOutAnimation({ id }, subId, animationManager, selection) {\r\n    staticFromToMotion(id, subId, animationManager, selection, { opacity: 1 }, { opacity: 0 }, LABEL_PHASE);\r\n}\r\nfunction buildResetPathFn(opts) {\r\n    return (_node) => {\r\n        return { opacity: opts.getOpacity(), clipScalingX: 1, clipMode: undefined };\r\n    };\r\n}\n\nfunction scale(val, scaling) {\r\n    if (!scaling)\r\n        return NaN;\r\n    if (val instanceof Date) {\r\n        val = val.getTime();\r\n    }\r\n    if (scaling.type === 'continuous' && typeof val === 'number') {\r\n        const domainRatio = (val - scaling.domain[0]) / (scaling.domain[1] - scaling.domain[0]);\r\n        return domainRatio * (scaling.range[1] - scaling.range[0]) + scaling.range[0];\r\n    }\r\n    if (scaling.type === 'log' && typeof val === 'number') {\r\n        return scaling.convert(val);\r\n    }\r\n    // Category axis case.\r\n    const matchingIndex = scaling.domain.findIndex((d) => d === val);\r\n    if (matchingIndex >= 0) {\r\n        return scaling.range[matchingIndex];\r\n    }\r\n    // We failed to convert using the scale.\r\n    return NaN;\r\n}\r\nfunction closeMatch(a, b) {\r\n    const an = Number(a);\r\n    const bn = Number(b);\r\n    if (!isNaN(an) && !isNaN(bn)) {\r\n        return Math.abs(bn - an) < 0.25;\r\n    }\r\n    return a === b;\r\n}\r\nfunction calculateMoveTo(from = false, to = false) {\r\n    if (from === to) {\r\n        return !!from;\r\n    }\r\n    return from ? 'in' : 'out';\r\n}\r\nfunction pairContinuousData(newData, oldData, opts = {}) {\r\n    var _a, _b, _c, _d;\r\n    const { backfillSplitMode = 'intersect' } = opts;\r\n    const toNewScale = (oldDatum) => {\r\n        var _a, _b;\r\n        return {\r\n            x: scale((_a = oldDatum.xValue) !== null && _a !== void 0 ? _a : NaN, newData.scales.x),\r\n            y: scale((_b = oldDatum.yValue) !== null && _b !== void 0 ? _b : NaN, newData.scales.y),\r\n        };\r\n    };\r\n    const toOldScale = (newDatum) => {\r\n        var _a, _b;\r\n        return {\r\n            x: scale((_a = newDatum.xValue) !== null && _a !== void 0 ? _a : NaN, oldData.scales.x),\r\n            y: scale((_b = newDatum.yValue) !== null && _b !== void 0 ? _b : NaN, oldData.scales.y),\r\n        };\r\n    };\r\n    const result = [];\r\n    const resultMap = {\r\n        added: {},\r\n        moved: {},\r\n        removed: {},\r\n    };\r\n    const pairUp = (from, to, xValue, change = 'move') => {\r\n        if (from && (isNaN(from.point.x) || isNaN(from.point.y))) {\r\n            // Default to 'to' position if 'from' is invalid.\r\n            from = to;\r\n        }\r\n        const resultPoint = {\r\n            from: from === null || from === void 0 ? void 0 : from.point,\r\n            to: to === null || to === void 0 ? void 0 : to.point,\r\n            moveTo: calculateMoveTo(from === null || from === void 0 ? void 0 : from.point.moveTo, to === null || to === void 0 ? void 0 : to.point.moveTo),\r\n            change,\r\n        };\r\n        if (change === 'move') {\r\n            resultMap.moved[xValue] = resultPoint;\r\n            oldIdx++;\r\n            newIdx++;\r\n        }\r\n        else if (change === 'in') {\r\n            resultMap.added[xValue] = resultPoint;\r\n            newIdx++;\r\n        }\r\n        else if (change === 'out') {\r\n            resultMap.removed[xValue] = resultPoint;\r\n            oldIdx++;\r\n        }\r\n        result.push(resultPoint);\r\n    };\r\n    const { min: minFromNode, max: maxFromNode } = minMax(oldData.nodeData);\r\n    const { min: minToNode, max: maxToNode } = minMax(newData.nodeData);\r\n    let oldIdx = 0;\r\n    let newIdx = 0;\r\n    while (oldIdx < oldData.nodeData.length || newIdx < newData.nodeData.length) {\r\n        const from = oldData.nodeData[oldIdx];\r\n        const to = newData.nodeData[newIdx];\r\n        const fromShifted = from ? toNewScale(from) : undefined;\r\n        const toUnshifted = to ? toOldScale(to) : undefined;\r\n        const NA = undefined;\r\n        if (fromShifted && closeMatch(fromShifted.x, to === null || to === void 0 ? void 0 : to.point.x)) {\r\n            pairUp(from, to, to.xValue, 'move');\r\n        }\r\n        else if (fromShifted && fromShifted.x < ((_a = minToNode === null || minToNode === void 0 ? void 0 : minToNode.point.x) !== null && _a !== void 0 ? _a : -Infinity)) {\r\n            pairUp(from, NA, from.xValue, 'out');\r\n        }\r\n        else if (fromShifted && fromShifted.x > ((_b = maxToNode === null || maxToNode === void 0 ? void 0 : maxToNode.point.x) !== null && _b !== void 0 ? _b : Infinity)) {\r\n            pairUp(from, NA, from.xValue, 'out');\r\n        }\r\n        else if (toUnshifted && toUnshifted.x < ((_c = minFromNode === null || minFromNode === void 0 ? void 0 : minFromNode.point.x) !== null && _c !== void 0 ? _c : -Infinity)) {\r\n            pairUp(NA, to, to.xValue, 'in');\r\n        }\r\n        else if (toUnshifted && toUnshifted.x > ((_d = maxFromNode === null || maxFromNode === void 0 ? void 0 : maxFromNode.point.x) !== null && _d !== void 0 ? _d : Infinity)) {\r\n            pairUp(NA, to, to.xValue, 'in');\r\n        }\r\n        else if (fromShifted && fromShifted.x < (to === null || to === void 0 ? void 0 : to.point.x)) {\r\n            pairUp(from, NA, from.xValue, 'out');\r\n        }\r\n        else if (toUnshifted && toUnshifted.x < (from === null || from === void 0 ? void 0 : from.point.x)) {\r\n            pairUp(NA, to, to.xValue, 'in');\r\n        }\r\n        else if (from) {\r\n            pairUp(from, NA, from.xValue, 'out');\r\n        }\r\n        else if (to) {\r\n            pairUp(NA, to, to.xValue, 'in');\r\n        }\r\n        else {\r\n            throw new Error('Unable to process points');\r\n        }\r\n    }\r\n    backfillPathPointData(result, backfillSplitMode);\r\n    return { result, resultMap };\r\n}\r\nfunction pairCategoryData(newData, oldData, diff, opts = {}) {\r\n    var _a, _b, _c;\r\n    const { backfillSplitMode = 'intersect', multiDatum = false } = opts;\r\n    const result = [];\r\n    const resultMapSingle = {\r\n        added: {},\r\n        moved: {},\r\n        removed: {},\r\n    };\r\n    const resultMapMulti = {\r\n        added: {},\r\n        moved: {},\r\n        removed: {},\r\n    };\r\n    let previousResultPoint = undefined;\r\n    let previousXValue = undefined;\r\n    const addToResultMap = (xValue, result) => {\r\n        var _a;\r\n        var _b;\r\n        const type = result.change === 'move' ? 'moved' : result.change === 'in' ? 'added' : 'removed';\r\n        if (multiDatum) {\r\n            (_a = (_b = resultMapMulti[type])[xValue]) !== null && _a !== void 0 ? _a : (_b[xValue] = []);\r\n            resultMapMulti[type][xValue].push(result);\r\n        }\r\n        else {\r\n            resultMapSingle[type][xValue] = result;\r\n        }\r\n        previousResultPoint = result;\r\n        previousXValue = xValue;\r\n    };\r\n    let oldIndex = 0;\r\n    let newIndex = 0;\r\n    let isXUnordered = false;\r\n    while (oldIndex < oldData.nodeData.length || newIndex < newData.nodeData.length) {\r\n        const before = oldData.nodeData[oldIndex];\r\n        const after = newData.nodeData[newIndex];\r\n        let resultPoint;\r\n        if ((before === null || before === void 0 ? void 0 : before.xValue) === (after === null || after === void 0 ? void 0 : after.xValue)) {\r\n            resultPoint = {\r\n                change: 'move',\r\n                moveTo: calculateMoveTo((_a = before.point.moveTo) !== null && _a !== void 0 ? _a : false, after.point.moveTo),\r\n                from: before.point,\r\n                to: after.point,\r\n            };\r\n            addToResultMap(before.xValue, resultPoint);\r\n            oldIndex++;\r\n            newIndex++;\r\n        }\r\n        else if (diff.removed.indexOf(before === null || before === void 0 ? void 0 : before.xValue) >= 0) {\r\n            resultPoint = {\r\n                change: 'out',\r\n                moveTo: (_b = before.point.moveTo) !== null && _b !== void 0 ? _b : false,\r\n                from: before.point,\r\n            };\r\n            addToResultMap(before.xValue, resultPoint);\r\n            oldIndex++;\r\n        }\r\n        else if (diff.added.indexOf(after === null || after === void 0 ? void 0 : after.xValue) >= 0) {\r\n            resultPoint = {\r\n                change: 'in',\r\n                moveTo: (_c = after.point.moveTo) !== null && _c !== void 0 ? _c : false,\r\n                to: after.point,\r\n            };\r\n            addToResultMap(after.xValue, resultPoint);\r\n            newIndex++;\r\n        }\r\n        else if (multiDatum && previousResultPoint && previousXValue === (before === null || before === void 0 ? void 0 : before.xValue)) {\r\n            resultPoint = Object.assign({}, previousResultPoint);\r\n            addToResultMap(before.xValue, resultPoint);\r\n            oldIndex++;\r\n        }\r\n        else if (multiDatum && previousResultPoint && previousXValue === (after === null || after === void 0 ? void 0 : after.xValue)) {\r\n            resultPoint = Object.assign({}, previousResultPoint);\r\n            addToResultMap(after.xValue, resultPoint);\r\n            newIndex++;\r\n        }\r\n        else {\r\n            isXUnordered = true;\r\n            break;\r\n        }\r\n        result.push(resultPoint);\r\n    }\r\n    let previousX = -Infinity;\r\n    isXUnordered || (isXUnordered = result.some((pathPoint) => {\r\n        const { change: marker, to: { x = -Infinity } = {} } = pathPoint;\r\n        if (marker === 'out')\r\n            return;\r\n        const result = x < previousX;\r\n        previousX = x;\r\n        return result;\r\n    }));\r\n    if (isXUnordered) {\r\n        return { result: undefined, resultMap: undefined };\r\n    }\r\n    backfillPathPointData(result, backfillSplitMode);\r\n    if (multiDatum) {\r\n        return { result, resultMap: resultMapMulti };\r\n    }\r\n    return { result, resultMap: resultMapSingle };\r\n}\r\nfunction determinePathStatus(newData, oldData) {\r\n    let status = 'updated';\r\n    const visible = (data) => {\r\n        return data.visible;\r\n    };\r\n    if (!visible(oldData) && visible(newData)) {\r\n        status = 'added';\r\n    }\r\n    else if (visible(oldData) && !visible(newData)) {\r\n        status = 'removed';\r\n    }\r\n    return status;\r\n}\r\nfunction prepareLinePathPropertyAnimation(status, visibleToggleMode) {\r\n    const phase = visibleToggleMode === 'none' ? 'updated' : status;\r\n    const result = {\r\n        fromFn: (_path) => {\r\n            let mixin;\r\n            if (status === 'removed') {\r\n                mixin = { finish: { visible: false } };\r\n            }\r\n            else if (status === 'added') {\r\n                mixin = { start: { visible: true } };\r\n            }\r\n            else {\r\n                mixin = {};\r\n            }\r\n            return Object.assign(Object.assign({}, FROM_TO_MIXINS[phase]), mixin);\r\n        },\r\n        toFn: (_path) => {\r\n            return Object.assign({}, FROM_TO_MIXINS[phase]);\r\n        },\r\n    };\r\n    if (visibleToggleMode === 'fade') {\r\n        return {\r\n            fromFn: (path) => {\r\n                const opacity = status === 'added' ? 0 : path.opacity;\r\n                return Object.assign({ opacity }, result.fromFn(path));\r\n            },\r\n            toFn: (path) => {\r\n                const opacity = status === 'removed' ? 0 : 1;\r\n                return Object.assign({ opacity }, result.toFn(path));\r\n            },\r\n        };\r\n    }\r\n    return result;\r\n}\r\nfunction prepareLinePathAnimationFns(newData, oldData, pairData, visibleToggleMode, render) {\r\n    const status = determinePathStatus(newData, oldData);\r\n    const removePhaseFn = (ratio, path) => {\r\n        render(pairData, { move: 0, out: ratio }, path);\r\n    };\r\n    const updatePhaseFn = (ratio, path) => {\r\n        render(pairData, { move: ratio }, path);\r\n    };\r\n    const addPhaseFn = (ratio, path) => {\r\n        render(pairData, { move: 1, in: ratio }, path);\r\n    };\r\n    const pathProperties = prepareLinePathPropertyAnimation(status, visibleToggleMode);\r\n    return { status, path: { addPhaseFn, updatePhaseFn, removePhaseFn }, pathProperties };\r\n}\r\nfunction prepareLinePathAnimation(newData, oldData, diff) {\r\n    var _a;\r\n    const isCategoryBased = ((_a = newData.scales.x) === null || _a === void 0 ? void 0 : _a.type) === 'category';\r\n    const { result: pairData, resultMap: pairMap } = isCategoryBased && diff ? pairCategoryData(newData, oldData, diff) : pairContinuousData(newData, oldData);\r\n    let status = 'updated';\r\n    if (oldData.visible && !newData.visible) {\r\n        status = 'removed';\r\n    }\r\n    else if (!oldData.visible && newData.visible) {\r\n        status = 'added';\r\n    }\r\n    if (pairData === undefined || pairMap === undefined) {\r\n        return;\r\n    }\r\n    const pathFns = prepareLinePathAnimationFns(newData, oldData, pairData, 'fade', renderPartialPath);\r\n    const marker = prepareMarkerAnimation(pairMap, status);\r\n    return Object.assign(Object.assign({}, pathFns), { marker });\r\n}\n\nvar AreaSeriesTag;\r\n(function (AreaSeriesTag) {\r\n    AreaSeriesTag[AreaSeriesTag[\"Fill\"] = 0] = \"Fill\";\r\n    AreaSeriesTag[AreaSeriesTag[\"Stroke\"] = 1] = \"Stroke\";\r\n    AreaSeriesTag[AreaSeriesTag[\"Marker\"] = 2] = \"Marker\";\r\n    AreaSeriesTag[AreaSeriesTag[\"Label\"] = 3] = \"Label\";\r\n})(AreaSeriesTag || (AreaSeriesTag = {}));\r\nfunction splitFillPoints(context) {\r\n    const { points } = context.fillData;\r\n    return { top: points.slice(0, points.length / 2), bottom: points.slice(points.length / 2).reverse() };\r\n}\r\nfunction prepPoints(key, ctx, points) {\r\n    return {\r\n        scales: ctx.scales,\r\n        nodeData: points[key],\r\n        visible: ctx.visible,\r\n    };\r\n}\r\nfunction pairFillCategoryData(newData, oldData, diff) {\r\n    const oldPoints = splitFillPoints(oldData);\r\n    const newPoints = splitFillPoints(newData);\r\n    const pairOpts = { multiDatum: true };\r\n    return {\r\n        top: pairCategoryData(prepPoints('top', newData, newPoints), prepPoints('top', oldData, oldPoints), diff, pairOpts),\r\n        bottom: pairCategoryData(prepPoints('bottom', newData, newPoints), prepPoints('bottom', oldData, oldPoints), diff, pairOpts),\r\n    };\r\n}\r\nfunction pairFillContinuousData(newData, oldData) {\r\n    const oldPoints = splitFillPoints(oldData);\r\n    const newPoints = splitFillPoints(newData);\r\n    return {\r\n        top: pairContinuousData(prepPoints('top', newData, newPoints), prepPoints('top', oldData, oldPoints)),\r\n        bottom: pairContinuousData(prepPoints('bottom', newData, newPoints), prepPoints('bottom', oldData, oldPoints)),\r\n    };\r\n}\r\nfunction prepareAreaPathAnimation(newData, oldData, diff) {\r\n    var _a;\r\n    const isCategoryBased = ((_a = newData.scales.x) === null || _a === void 0 ? void 0 : _a.type) === 'category';\r\n    let status = 'updated';\r\n    if (oldData.visible && !newData.visible) {\r\n        status = 'removed';\r\n    }\r\n    else if (!oldData.visible && newData.visible) {\r\n        status = 'added';\r\n    }\r\n    const prepareMarkerPairs = () => {\r\n        if (isCategoryBased && diff) {\r\n            return pairCategoryData(newData, oldData, diff, { backfillSplitMode: 'static', multiDatum: true });\r\n        }\r\n        return pairContinuousData(newData, oldData, { backfillSplitMode: 'static' });\r\n    };\r\n    const prepareFillPairs = () => {\r\n        if (isCategoryBased && diff) {\r\n            return pairFillCategoryData(newData, oldData, diff);\r\n        }\r\n        return pairFillContinuousData(newData, oldData);\r\n    };\r\n    const { resultMap: markerPairMap } = prepareMarkerPairs();\r\n    const { top, bottom } = prepareFillPairs();\r\n    if (markerPairMap === undefined || top.result === undefined || bottom.result === undefined) {\r\n        return;\r\n    }\r\n    const pairData = [...top.result, ...bottom.result.reverse()];\r\n    const fill = prepareLinePathAnimationFns(newData, oldData, pairData, 'none', renderPartialPath);\r\n    const marker = prepareMarkerAnimation(markerPairMap, status);\r\n    return { fill, marker };\r\n}\n\nclass AreaSeries extends CartesianSeries {\r\n    constructor(moduleCtx) {\r\n        super({\r\n            moduleCtx,\r\n            pathsPerSeries: 2,\r\n            pathsZIndexSubOrderOffset: [0, 1000],\r\n            hasMarkers: true,\r\n            markerSelectionGarbageCollection: false,\r\n            pickModes: [SeriesNodePickMode.NEAREST_BY_MAIN_AXIS_FIRST, SeriesNodePickMode.EXACT_SHAPE_MATCH],\r\n            animationResetFns: {\r\n                path: buildResetPathFn({ getOpacity: () => this.getOpacity() }),\r\n                label: resetLabelFn,\r\n                marker: (node, datum) => (Object.assign(Object.assign({}, resetMarkerFn()), resetMarkerPositionFn(node, datum))),\r\n            },\r\n        });\r\n        this.tooltip = new SeriesTooltip();\r\n        this.marker = new SeriesMarker();\r\n        this.label = new Label();\r\n        this.fill = '#c16068';\r\n        this.stroke = '#874349';\r\n        this.fillOpacity = 1;\r\n        this.strokeOpacity = 1;\r\n        this.lineDash = [0];\r\n        this.lineDashOffset = 0;\r\n        this.xKey = undefined;\r\n        this.xName = undefined;\r\n        this.strokeWidth = 2;\r\n        this.shadow = undefined;\r\n    }\r\n    processData(dataController) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { xKey, yKey, normalizedTo, data, visible, seriesGrouping: { groupIndex = this.id } = {} } = this;\r\n            if (xKey == null || yKey == null || data == null)\r\n                return;\r\n            const animationEnabled = !this.ctx.animationManager.isSkipped();\r\n            const { isContinuousX, isContinuousY } = this.isContinuous();\r\n            const ids = [\r\n                `area-stack-${groupIndex}-yValues`,\r\n                `area-stack-${groupIndex}-yValues-trailing`,\r\n                `area-stack-${groupIndex}-yValues-prev`,\r\n                `area-stack-${groupIndex}-yValues-trailing-prev`,\r\n                `area-stack-${groupIndex}-yValues-marker`,\r\n            ];\r\n            const extraProps = [];\r\n            const normaliseTo = normalizedTo && isFinite(normalizedTo) ? normalizedTo : undefined;\r\n            if (normaliseTo) {\r\n                extraProps.push(normaliseGroupTo(this, [ids[0], ids[1], ids[4]], normaliseTo, 'range'));\r\n                extraProps.push(normaliseGroupTo(this, [ids[2], ids[3]], normaliseTo, 'range'));\r\n            }\r\n            // If two or more datums share an x-value, i.e. lined up vertically, they will have the same datum id.\r\n            // They must be identified this way when animated to ensure they can be tracked when their y-value\r\n            // is updated. If this is a static chart, we can instead not bother with identifying datums and\r\n            // automatically garbage collect the marker selection.\r\n            if (!isContinuousX && animationEnabled && this.processedData) {\r\n                extraProps.push(diff(this.processedData));\r\n            }\r\n            if (animationEnabled) {\r\n                extraProps.push(animationValidation(this));\r\n            }\r\n            const common = { invalidValue: null };\r\n            if (!visible) {\r\n                common.forceValue = 0;\r\n            }\r\n            yield this.requestDataModel(dataController, data, {\r\n                props: [\r\n                    keyProperty(this, xKey, isContinuousX, { id: 'xValue' }),\r\n                    valueProperty(this, yKey, isContinuousY, Object.assign({ id: `yValueRaw` }, common)),\r\n                    ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'window', 'current', Object.assign(Object.assign({ id: `yValueEnd` }, common), { groupId: ids[0] })),\r\n                    ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'window-trailing', 'current', Object.assign(Object.assign({ id: `yValueStart` }, common), { groupId: ids[1] })),\r\n                    ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'window', 'last', Object.assign(Object.assign({ id: `yValuePreviousEnd` }, common), { groupId: ids[2] })),\r\n                    ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'window-trailing', 'last', Object.assign(Object.assign({ id: `yValuePreviousStart` }, common), { groupId: ids[3] })),\r\n                    ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'normal', 'current', Object.assign(Object.assign({ id: `yValueCumulative` }, common), { groupId: ids[4] })),\r\n                    ...extraProps,\r\n                ],\r\n                groupByKeys: true,\r\n            });\r\n            this.animationState.transition('updateData');\r\n        });\r\n    }\r\n    getSeriesDomain(direction) {\r\n        const { processedData, dataModel, axes } = this;\r\n        if (!processedData || !dataModel)\r\n            return [];\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\r\n        const keys = dataModel.getDomain(this, `xValue`, 'key', processedData);\r\n        const yExtent = dataModel.getDomain(this, `yValueEnd`, 'value', processedData);\r\n        if (direction === ChartAxisDirection.X) {\r\n            if ((keyDef === null || keyDef === void 0 ? void 0 : keyDef.def.type) === 'key' && keyDef.def.valueType === 'category') {\r\n                return keys;\r\n            }\r\n            return fixNumericExtent(extent(keys), xAxis);\r\n        }\r\n        else if (yAxis instanceof LogAxis || yAxis instanceof TimeAxis) {\r\n            return fixNumericExtent(yExtent, yAxis);\r\n        }\r\n        else {\r\n            const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];\r\n            return fixNumericExtent(fixedYExtent, yAxis);\r\n        }\r\n    }\r\n    createNodeData() {\r\n        const _super = Object.create(null, {\r\n            calculateScaling: { get: () => super.calculateScaling }\r\n        });\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { axes, data, processedData: { data: groupedData } = {}, dataModel } = this;\r\n            const xAxis = axes[ChartAxisDirection.X];\r\n            const yAxis = axes[ChartAxisDirection.Y];\r\n            if (!xAxis || !yAxis || !data || !dataModel) {\r\n                return [];\r\n            }\r\n            const { yKey = '', xKey = '', marker, label, fill: seriesFill, stroke: seriesStroke } = this;\r\n            const { scale: xScale } = xAxis;\r\n            const { scale: yScale } = yAxis;\r\n            const continuousY = ContinuousScale.is(yScale);\r\n            const xOffset = ((_a = xScale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;\r\n            const defs = dataModel.resolveProcessedDataDefsByIds(this, [\r\n                `yValueStart`,\r\n                `yValueEnd`,\r\n                `yValueRaw`,\r\n                `yValuePreviousStart`,\r\n                `yValuePreviousEnd`,\r\n                `yValueCumulative`,\r\n            ]);\r\n            const createMovePoint = (plainPoint) => {\r\n                const { point } = plainPoint, stroke = __rest(plainPoint, [\"point\"]);\r\n                return Object.assign(Object.assign({}, stroke), { point: Object.assign(Object.assign({}, point), { moveTo: true }) });\r\n            };\r\n            const createPathCoordinates = (xValue, lastYEnd, yEnd) => {\r\n                const x = xScale.convert(xValue) + xOffset;\r\n                const prevYCoordinate = yScale.convert(lastYEnd);\r\n                const currYCoordinate = yScale.convert(yEnd);\r\n                return [\r\n                    { point: { x, y: currYCoordinate }, yValue: yEnd, xValue },\r\n                    { point: { x, y: prevYCoordinate }, yValue: lastYEnd, xValue },\r\n                ];\r\n            };\r\n            const createMarkerCoordinate = (xDatum, yEnd, rawYDatum) => {\r\n                let currY;\r\n                // if not normalized, the invalid data points will be processed as `undefined` in processData()\r\n                // if normalized, the invalid data points will be processed as 0 rather than `undefined`\r\n                // check if unprocessed datum is valid as we only want to show markers for valid points\r\n                const normalized = this.normalizedTo && isFinite(this.normalizedTo);\r\n                const normalizedAndValid = normalized && continuousY && isContinuous(rawYDatum);\r\n                const valid = (!normalized && !isNaN(rawYDatum)) || normalizedAndValid;\r\n                if (valid) {\r\n                    currY = yEnd;\r\n                }\r\n                const x = xScale.convert(xDatum) + xOffset;\r\n                const y = yScale.convert(currY);\r\n                return { x, y, size: marker.size };\r\n            };\r\n            const itemId = yKey;\r\n            const labelData = [];\r\n            const markerData = [];\r\n            const context = {\r\n                itemId,\r\n                fillData: { itemId, points: [] },\r\n                strokeData: { itemId, points: [] },\r\n                labelData,\r\n                nodeData: markerData,\r\n                scales: _super.calculateScaling.call(this),\r\n                visible: this.visible,\r\n            };\r\n            const fillPoints = context.fillData.points;\r\n            const fillPhantomPoints = [];\r\n            const strokePoints = context.strokeData.points;\r\n            let datumIdx = -1;\r\n            let lastXDatum;\r\n            let lastYDatum = -Infinity;\r\n            groupedData === null || groupedData === void 0 ? void 0 : groupedData.forEach((datumGroup) => {\r\n                const { keys, keys: [xDatum], datum: datumArray, values: valuesArray, } = datumGroup;\r\n                valuesArray.forEach((values, valueIdx) => {\r\n                    var _a, _b, _c;\r\n                    datumIdx++;\r\n                    const seriesDatum = datumArray[valueIdx];\r\n                    const dataValues = dataModel.resolveProcessedDataDefsValues(defs, { keys, values });\r\n                    const { yValueRaw: yDatum, yValueCumulative } = dataValues;\r\n                    let { yValueStart, yValueEnd, yValuePreviousStart, yValuePreviousEnd } = dataValues;\r\n                    const validPoint = yDatum != null;\r\n                    // marker data\r\n                    const point = createMarkerCoordinate(xDatum, +yValueCumulative, yDatum);\r\n                    if (validPoint && marker) {\r\n                        markerData.push({\r\n                            index: datumIdx,\r\n                            series: this,\r\n                            itemId,\r\n                            datum: seriesDatum,\r\n                            midPoint: { x: point.x, y: point.y },\r\n                            cumulativeValue: yValueEnd,\r\n                            yValue: yDatum,\r\n                            xValue: xDatum,\r\n                            yKey,\r\n                            xKey,\r\n                            point,\r\n                            fill: (_a = marker.fill) !== null && _a !== void 0 ? _a : seriesFill,\r\n                            stroke: (_b = marker.stroke) !== null && _b !== void 0 ? _b : seriesStroke,\r\n                            strokeWidth: (_c = marker.strokeWidth) !== null && _c !== void 0 ? _c : this.getStrokeWidth(this.strokeWidth),\r\n                        });\r\n                    }\r\n                    // label data\r\n                    if (validPoint && label) {\r\n                        const labelText = this.getLabelText(label, {\r\n                            value: yDatum,\r\n                            datum: seriesDatum,\r\n                            xKey,\r\n                            yKey,\r\n                            xName: this.xName,\r\n                            yName: this.yName,\r\n                        }, (value) => (isNumber(value) ? value.toFixed(2) : String(value)));\r\n                        labelData.push({\r\n                            index: datumIdx,\r\n                            series: this,\r\n                            itemId: yKey,\r\n                            datum: seriesDatum,\r\n                            x: point.x,\r\n                            y: point.y,\r\n                            label: labelText\r\n                                ? {\r\n                                    text: labelText,\r\n                                    fontStyle: label.fontStyle,\r\n                                    fontWeight: label.fontWeight,\r\n                                    fontSize: label.fontSize,\r\n                                    fontFamily: label.fontFamily,\r\n                                    textAlign: 'center',\r\n                                    textBaseline: 'bottom',\r\n                                    fill: label.color,\r\n                                }\r\n                                : undefined,\r\n                        });\r\n                    }\r\n                    // fill data\r\n                    if (lastYDatum == null || yDatum == null) {\r\n                        // Reset all coordinates to 'zero' value.\r\n                        yValueStart = yValueStart !== null && yValueStart !== void 0 ? yValueStart : 0;\r\n                        yValueEnd = yValueStart !== null && yValueStart !== void 0 ? yValueStart : 0;\r\n                        yValuePreviousStart = yValuePreviousStart !== null && yValuePreviousStart !== void 0 ? yValuePreviousStart : 0;\r\n                        yValuePreviousEnd = yValuePreviousStart !== null && yValuePreviousStart !== void 0 ? yValuePreviousStart : 0;\r\n                    }\r\n                    const [prevTop, prevBottom] = createPathCoordinates(lastXDatum, yValuePreviousStart, yValuePreviousEnd);\r\n                    const [top, bottom] = createPathCoordinates(xDatum, yValueStart, yValueEnd);\r\n                    const xValid = lastXDatum != null && xDatum != null;\r\n                    if (xValid) {\r\n                        fillPoints.push(prevTop);\r\n                        fillPhantomPoints.push(prevBottom);\r\n                        fillPoints.push(top);\r\n                        fillPhantomPoints.push(bottom);\r\n                    }\r\n                    // stroke data\r\n                    if (validPoint && lastYDatum != null && datumIdx > 0) {\r\n                        strokePoints.push(createMovePoint(prevTop));\r\n                        strokePoints.push(top);\r\n                    }\r\n                    lastXDatum = xDatum;\r\n                    lastYDatum = yDatum;\r\n                });\r\n            });\r\n            if (strokePoints.length > 0) {\r\n                strokePoints[0] = createMovePoint(strokePoints[0]);\r\n            }\r\n            fillPhantomPoints.reverse();\r\n            fillPoints.push(...fillPhantomPoints);\r\n            return [context];\r\n        });\r\n    }\r\n    isPathOrSelectionDirty() {\r\n        return this.marker.isDirty();\r\n    }\r\n    markerFactory() {\r\n        const { shape } = this.marker;\r\n        const MarkerShape = getMarker(shape);\r\n        return new MarkerShape();\r\n    }\r\n    updatePathNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { opacity, visible, animationEnabled } = opts;\r\n            const [fill, stroke] = opts.paths;\r\n            const { seriesRectHeight: height, seriesRectWidth: width } = this.nodeDataDependencies;\r\n            const strokeWidth = this.getStrokeWidth(this.strokeWidth);\r\n            stroke.setProperties({\r\n                tag: AreaSeriesTag.Stroke,\r\n                fill: undefined,\r\n                lineJoin: (stroke.lineCap = 'round'),\r\n                pointerEvents: PointerEvents.None,\r\n                stroke: this.stroke,\r\n                strokeWidth,\r\n                strokeOpacity: this.strokeOpacity,\r\n                lineDash: this.lineDash,\r\n                lineDashOffset: this.lineDashOffset,\r\n                opacity,\r\n                visible,\r\n            });\r\n            fill.setProperties({\r\n                tag: AreaSeriesTag.Fill,\r\n                stroke: undefined,\r\n                lineJoin: 'round',\r\n                pointerEvents: PointerEvents.None,\r\n                fill: this.fill,\r\n                fillOpacity: this.fillOpacity,\r\n                lineDash: this.lineDash,\r\n                lineDashOffset: this.lineDashOffset,\r\n                strokeOpacity: this.strokeOpacity,\r\n                fillShadow: this.shadow,\r\n                opacity,\r\n                visible: visible || animationEnabled,\r\n                strokeWidth,\r\n            });\r\n            const updateClipPath = (path) => {\r\n                var _a, _b;\r\n                if (path.clipPath == null) {\r\n                    path.clipPath = new Path2D();\r\n                    path.clipScalingX = 1;\r\n                    path.clipScalingY = 1;\r\n                }\r\n                (_a = path.clipPath) === null || _a === void 0 ? void 0 : _a.clear({ trackChanges: true });\r\n                (_b = path.clipPath) === null || _b === void 0 ? void 0 : _b.rect(-25, -25, (width !== null && width !== void 0 ? width : 0) + 50, (height !== null && height !== void 0 ? height : 0) + 50);\r\n            };\r\n            updateClipPath(stroke);\r\n            updateClipPath(fill);\r\n        });\r\n    }\r\n    updatePaths(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.updateAreaPaths([opts.paths], [opts.contextData]);\r\n        });\r\n    }\r\n    updateAreaPaths(paths, contextData) {\r\n        this.updateFillPath(paths, contextData);\r\n        this.updateStrokePath(paths, contextData);\r\n    }\r\n    updateFillPath(paths, contextData) {\r\n        contextData.forEach(({ fillData }, contextDataIndex) => {\r\n            const [fill] = paths[contextDataIndex];\r\n            const { path: fillPath } = fill;\r\n            fillPath.clear({ trackChanges: true });\r\n            for (const { point } of fillData.points) {\r\n                if (point.moveTo) {\r\n                    fillPath.moveTo(point.x, point.y);\r\n                }\r\n                else {\r\n                    fillPath.lineTo(point.x, point.y);\r\n                }\r\n            }\r\n            fillPath.closePath();\r\n            fill.checkPathDirty();\r\n        });\r\n    }\r\n    updateStrokePath(paths, contextData) {\r\n        contextData.forEach(({ strokeData }, contextDataIndex) => {\r\n            const [, stroke] = paths[contextDataIndex];\r\n            const { path: strokePath } = stroke;\r\n            strokePath.clear({ trackChanges: true });\r\n            for (const { point } of strokeData.points) {\r\n                if (point.moveTo) {\r\n                    strokePath.moveTo(point.x, point.y);\r\n                }\r\n                else {\r\n                    strokePath.lineTo(point.x, point.y);\r\n                }\r\n            }\r\n            stroke.checkPathDirty();\r\n        });\r\n    }\r\n    updateMarkerSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { nodeData, markerSelection } = opts;\r\n            const { marker: { enabled }, } = this;\r\n            const data = enabled && nodeData ? nodeData : [];\r\n            if (this.marker.isDirty()) {\r\n                markerSelection.clear();\r\n                markerSelection.cleanup();\r\n            }\r\n            return markerSelection.update(data);\r\n        });\r\n    }\r\n    updateMarkerNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { markerSelection, isHighlight: highlighted } = opts;\r\n            const { xKey = '', yKey = '', marker, fill, stroke, strokeWidth, fillOpacity, strokeOpacity } = this;\r\n            const baseStyle = mergeDefaults(highlighted && this.highlightStyle.item, marker.getStyle(), {\r\n                fill,\r\n                stroke,\r\n                strokeWidth,\r\n                fillOpacity,\r\n                strokeOpacity,\r\n            });\r\n            markerSelection.each((node, datum) => {\r\n                this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle);\r\n            });\r\n            if (!highlighted) {\r\n                this.marker.markClean();\r\n            }\r\n        });\r\n    }\r\n    updateLabelSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelData, labelSelection } = opts;\r\n            return labelSelection.update(labelData, (text) => {\r\n                text.tag = AreaSeriesTag.Label;\r\n            });\r\n        });\r\n    }\r\n    updateLabelNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelSelection } = opts;\r\n            const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.label;\r\n            labelSelection.each((text, datum) => {\r\n                const { x, y, label } = datum;\r\n                if (label && labelEnabled && this.visible) {\r\n                    text.fontStyle = fontStyle;\r\n                    text.fontWeight = fontWeight;\r\n                    text.fontSize = fontSize;\r\n                    text.fontFamily = fontFamily;\r\n                    text.textAlign = label.textAlign;\r\n                    text.textBaseline = label.textBaseline;\r\n                    text.text = label.text;\r\n                    text.x = x;\r\n                    text.y = y - 10;\r\n                    text.fill = color;\r\n                    text.visible = true;\r\n                }\r\n                else {\r\n                    text.visible = false;\r\n                }\r\n            });\r\n        });\r\n    }\r\n    getTooltipHtml(nodeDatum) {\r\n        const { xKey, id: seriesId, axes, xName, yName, tooltip, marker, dataModel } = this;\r\n        const { yKey, xValue, yValue, datum } = nodeDatum;\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        if (!(xKey && yKey) || !(xAxis && yAxis && isNumber(yValue)) || !dataModel) {\r\n            return '';\r\n        }\r\n        const xString = xAxis.formatDatum(xValue);\r\n        const yString = yAxis.formatDatum(yValue);\r\n        const title = sanitizeHtml(yName);\r\n        const content = sanitizeHtml(xString + ': ' + yString);\r\n        const baseStyle = mergeDefaults({ fill: this.fill }, marker.getStyle(), {\r\n            stroke: this.stroke,\r\n            strokeWidth: this.strokeWidth,\r\n        });\r\n        const { fill: color } = this.getMarkerStyle(marker, { datum: nodeDatum, xKey, yKey, highlighted: false }, baseStyle);\r\n        return tooltip.toTooltipHtml({ title, content, backgroundColor: color }, {\r\n            datum,\r\n            xKey,\r\n            xName,\r\n            yKey,\r\n            yName,\r\n            color,\r\n            title,\r\n            seriesId,\r\n        });\r\n    }\r\n    getLegendData(legendType) {\r\n        var _a, _b, _c, _d, _e;\r\n        const { data, id, xKey, yKey, yName, marker, fill, stroke, fillOpacity, strokeOpacity, visible } = this;\r\n        if (!(data === null || data === void 0 ? void 0 : data.length) || !xKey || !yKey || legendType !== 'category') {\r\n            return [];\r\n        }\r\n        return [\r\n            {\r\n                legendType,\r\n                id,\r\n                itemId: yKey,\r\n                seriesId: id,\r\n                enabled: visible,\r\n                label: {\r\n                    text: yName !== null && yName !== void 0 ? yName : yKey,\r\n                },\r\n                marker: {\r\n                    shape: marker.shape,\r\n                    fill: (_a = marker.fill) !== null && _a !== void 0 ? _a : fill,\r\n                    stroke: (_b = marker.stroke) !== null && _b !== void 0 ? _b : stroke,\r\n                    fillOpacity: (_c = marker.fillOpacity) !== null && _c !== void 0 ? _c : fillOpacity,\r\n                    strokeOpacity: (_d = marker.strokeOpacity) !== null && _d !== void 0 ? _d : strokeOpacity,\r\n                    strokeWidth: (_e = marker.strokeWidth) !== null && _e !== void 0 ? _e : 0,\r\n                },\r\n            },\r\n        ];\r\n    }\r\n    animateEmptyUpdateReady(animationData) {\r\n        const { markerSelections, labelSelections, contextData, paths } = animationData;\r\n        const { animationManager } = this.ctx;\r\n        const { seriesRectWidth: width = 0 } = this.nodeDataDependencies;\r\n        this.updateAreaPaths(paths, contextData);\r\n        pathSwipeInAnimation(this, animationManager, paths.flat());\r\n        resetMotion(markerSelections, resetMarkerPositionFn);\r\n        markerSwipeScaleInAnimation(this, animationManager, markerSelections, width);\r\n        seriesLabelFadeInAnimation(this, 'labels', animationManager, labelSelections);\r\n    }\r\n    animateReadyResize(animationData) {\r\n        const { contextData, paths } = animationData;\r\n        this.updateAreaPaths(paths, contextData);\r\n        super.animateReadyResize(animationData);\r\n    }\r\n    animateWaitingUpdateReady(animationData) {\r\n        var _a, _b;\r\n        const { animationManager } = this.ctx;\r\n        const { markerSelections, labelSelections, contextData, paths, previousContextData } = animationData;\r\n        super.resetAllAnimation(animationData);\r\n        if (contextData.length === 0 || !previousContextData || previousContextData.length === 0) {\r\n            animationManager.skipCurrentBatch();\r\n            this.updateAreaPaths(paths, contextData);\r\n            return;\r\n        }\r\n        const [[fill, stroke]] = paths;\r\n        const [newData] = contextData;\r\n        const [oldData] = previousContextData;\r\n        const fns = prepareAreaPathAnimation(newData, oldData, (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.diff);\r\n        if (fns === undefined) {\r\n            animationManager.skipCurrentBatch();\r\n            this.updateAreaPaths(paths, contextData);\r\n            return;\r\n        }\r\n        fromToMotion(this.id, 'marker_update', animationManager, markerSelections, fns.marker);\r\n        fromToMotion(this.id, 'fill_path_properties', animationManager, [fill], fns.fill.pathProperties);\r\n        pathMotion(this.id, 'fill_path_update', animationManager, [fill], fns.fill.path);\r\n        this.updateStrokePath(paths, contextData);\r\n        pathFadeInAnimation(this, 'stroke', animationManager, [stroke]);\r\n        seriesLabelFadeInAnimation(this, 'labels', animationManager, labelSelections);\r\n    }\r\n    isLabelEnabled() {\r\n        return this.label.enabled;\r\n    }\r\n    nodeFactory() {\r\n        return new Group();\r\n    }\r\n}\r\nAreaSeries.className = 'AreaSeries';\r\nAreaSeries.type = 'area';\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AreaSeries.prototype, \"fill\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AreaSeries.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], AreaSeries.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], AreaSeries.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_LINE_DASH),\r\n    __metadata(\"design:type\", Array)\r\n], AreaSeries.prototype, \"lineDash\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AreaSeries.prototype, \"lineDashOffset\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AreaSeries.prototype, \"xKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AreaSeries.prototype, \"xName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AreaSeries.prototype, \"yKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], AreaSeries.prototype, \"yName\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], AreaSeries.prototype, \"normalizedTo\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Object)\r\n], AreaSeries.prototype, \"strokeWidth\", void 0);\n\nconst AreaSeriesModule = {\r\n    type: 'series',\r\n    optionsKey: 'series[]',\r\n    packageType: 'community',\r\n    chartTypes: ['cartesian'],\r\n    identifier: 'area',\r\n    instanceConstructor: AreaSeries,\r\n    stackable: true,\r\n    seriesDefaults: DEFAULT_CARTESIAN_CHART_OVERRIDES,\r\n    themeTemplate: {\r\n        __extends__: EXTENDS_SERIES_DEFAULTS,\r\n        nodeClickRange: 'nearest',\r\n        tooltip: {\r\n            position: {\r\n                type: 'node',\r\n            },\r\n        },\r\n        fillOpacity: 0.8,\r\n        strokeOpacity: 1,\r\n        strokeWidth: 0,\r\n        lineDash: [0],\r\n        lineDashOffset: 0,\r\n        shadow: {\r\n            enabled: false,\r\n            color: DEFAULT_SHADOW_COLOUR,\r\n            xOffset: 3,\r\n            yOffset: 3,\r\n            blur: 5,\r\n        },\r\n        marker: {\r\n            __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,\r\n            enabled: false,\r\n            fillOpacity: 1,\r\n            strokeOpacity: 1,\r\n            strokeWidth: 0,\r\n        },\r\n        label: {\r\n            enabled: false,\r\n            fontStyle: undefined,\r\n            fontWeight: undefined,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_LABEL_COLOUR,\r\n            formatter: undefined,\r\n        },\r\n    },\r\n    paletteFactory: (params) => {\r\n        const { marker } = markerPaletteFactory(params);\r\n        return {\r\n            fill: marker.fill,\r\n            stroke: marker.stroke,\r\n            marker,\r\n        };\r\n    },\r\n};\n\nclass AbstractBarSeries extends CartesianSeries {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.direction = 'vertical';\r\n    }\r\n    getBandScalePadding() {\r\n        return { inner: 0.2, outer: 0.1 };\r\n    }\r\n    shouldFlipXY() {\r\n        return this.direction === 'horizontal';\r\n    }\r\n    getBarDirection() {\r\n        return this.shouldFlipXY() ? ChartAxisDirection.X : ChartAxisDirection.Y;\r\n    }\r\n    getCategoryDirection() {\r\n        return this.shouldFlipXY() ? ChartAxisDirection.Y : ChartAxisDirection.X;\r\n    }\r\n    getValueAxis() {\r\n        const direction = this.getBarDirection();\r\n        return this.axes[direction];\r\n    }\r\n    getCategoryAxis() {\r\n        const direction = this.getCategoryDirection();\r\n        return this.axes[direction];\r\n    }\r\n}\r\n__decorate([\r\n    Validate(DIRECTION),\r\n    __metadata(\"design:type\", String)\r\n], AbstractBarSeries.prototype, \"direction\", void 0);\n\nfunction updateRect({ rect, config }) {\r\n    const { crisp = true, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, lineDash, lineDashOffset, fillShadow, visible = true, } = config;\r\n    rect.crisp = crisp;\r\n    rect.fill = fill;\r\n    rect.stroke = stroke;\r\n    rect.strokeWidth = strokeWidth;\r\n    rect.fillOpacity = fillOpacity;\r\n    rect.strokeOpacity = strokeOpacity;\r\n    rect.lineDash = lineDash;\r\n    rect.lineDashOffset = lineDashOffset;\r\n    rect.fillShadow = fillShadow;\r\n    rect.visible = visible;\r\n}\r\nfunction getRectConfig(_a) {\r\n    var _b, _c, _d, _e, _f;\r\n    var { datum, isHighlighted, style, highlightStyle, formatter, seriesId, ctx: { callbackCache } } = _a, opts = __rest(_a, [\"datum\", \"isHighlighted\", \"style\", \"highlightStyle\", \"formatter\", \"seriesId\", \"ctx\"]);\r\n    const { fill, fillOpacity, stroke, strokeWidth } = mergeDefaults(isHighlighted && highlightStyle, style);\r\n    const { strokeOpacity, fillShadow, lineDash, lineDashOffset } = style;\r\n    let format;\r\n    if (formatter) {\r\n        format = callbackCache.call(formatter, Object.assign({ datum: datum.datum, xKey: datum.xKey, fill,\r\n            stroke,\r\n            strokeWidth, highlighted: isHighlighted, seriesId }, opts));\r\n    }\r\n    return {\r\n        fill: (_b = format === null || format === void 0 ? void 0 : format.fill) !== null && _b !== void 0 ? _b : fill,\r\n        stroke: (_c = format === null || format === void 0 ? void 0 : format.stroke) !== null && _c !== void 0 ? _c : stroke,\r\n        strokeWidth: (_d = format === null || format === void 0 ? void 0 : format.strokeWidth) !== null && _d !== void 0 ? _d : strokeWidth,\r\n        fillOpacity: (_e = format === null || format === void 0 ? void 0 : format.fillOpacity) !== null && _e !== void 0 ? _e : fillOpacity,\r\n        strokeOpacity: (_f = format === null || format === void 0 ? void 0 : format.strokeOpacity) !== null && _f !== void 0 ? _f : strokeOpacity,\r\n        lineDash,\r\n        lineDashOffset,\r\n        fillShadow,\r\n    };\r\n}\r\nfunction checkCrisp(visibleRange = []) {\r\n    const [visibleMin, visibleMax] = visibleRange;\r\n    const isZoomed = visibleMin !== 0 || visibleMax !== 1;\r\n    return !isZoomed;\r\n}\r\nfunction collapsedStartingBarPosition(isVertical, axes) {\r\n    const { startingX, startingY } = getStartingValues(isVertical, axes);\r\n    const isDatumNegative = (datum) => {\r\n        var _a;\r\n        return isNegative((_a = datum['yValue']) !== null && _a !== void 0 ? _a : 0);\r\n    };\r\n    const calculate = (datum, prevDatum) => {\r\n        let x = isVertical ? datum.x : startingX;\r\n        let y = isVertical ? startingY : datum.y;\r\n        let width = isVertical ? datum.width : 0;\r\n        let height = isVertical ? 0 : datum.height;\r\n        if (prevDatum && (isNaN(x) || isNaN(y))) {\r\n            // Fallback\r\n            ({ x, y } = prevDatum);\r\n            width = isVertical ? prevDatum.width : 0;\r\n            height = isVertical ? 0 : prevDatum.height;\r\n            if (isVertical && !isDatumNegative(prevDatum)) {\r\n                y += prevDatum.height;\r\n            }\r\n            else if (!isVertical && isDatumNegative(prevDatum)) {\r\n                x += prevDatum.width;\r\n            }\r\n        }\r\n        return { x, y, width, height };\r\n    };\r\n    return { isVertical, calculate };\r\n}\r\nfunction midpointStartingBarPosition(isVertical) {\r\n    return {\r\n        isVertical,\r\n        calculate: (datum) => {\r\n            return {\r\n                x: isVertical ? datum.x : datum.x + datum.width / 2,\r\n                y: isVertical ? datum.y + datum.height / 2 : datum.y,\r\n                width: isVertical ? datum.width : 0,\r\n                height: isVertical ? 0 : datum.height,\r\n            };\r\n        },\r\n    };\r\n}\r\nfunction prepareBarAnimationFunctions(initPos) {\r\n    const isRemoved = (datum) => datum == null || isNaN(datum.x) || isNaN(datum.y);\r\n    const fromFn = (rect, datum, status) => {\r\n        if (status === 'updated' && isRemoved(datum)) {\r\n            status = 'removed';\r\n        }\r\n        else if (status === 'updated' && isRemoved(rect.previousDatum)) {\r\n            status = 'added';\r\n        }\r\n        // Continue from current rendering location.\r\n        let source = { x: rect.x, y: rect.y, width: rect.width, height: rect.height };\r\n        if (status === 'unknown' || status === 'added') {\r\n            source = initPos.calculate(datum, rect.previousDatum);\r\n        }\r\n        return Object.assign(Object.assign({}, source), FROM_TO_MIXINS[status]);\r\n    };\r\n    const toFn = (rect, datum, status) => {\r\n        if (status === 'removed' || isRemoved(datum)) {\r\n            return initPos.calculate(datum, rect.previousDatum);\r\n        }\r\n        return { x: datum.x, y: datum.y, width: datum.width, height: datum.height };\r\n    };\r\n    return { toFn, fromFn };\r\n}\r\nfunction getStartingValues(isVertical, axes) {\r\n    const axis = axes[isVertical ? ChartAxisDirection.Y : ChartAxisDirection.X];\r\n    let startingX = Infinity;\r\n    let startingY = 0;\r\n    if (!axis) {\r\n        return { startingX, startingY };\r\n    }\r\n    if (isVertical) {\r\n        startingY = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.max(...axis.range));\r\n    }\r\n    else {\r\n        startingX = axis.scale.convert(ContinuousScale.is(axis.scale) ? 0 : Math.min(...axis.range));\r\n    }\r\n    return { startingX, startingY };\r\n}\r\nfunction resetBarSelectionsFn(_node, { x, y, width, height }) {\r\n    return { x, y, width, height };\r\n}\n\nfunction updateLabelNode(textNode, label, labelDatum) {\r\n    if (label.enabled && labelDatum) {\r\n        const { x, y, text, textAlign, textBaseline } = labelDatum;\r\n        const { color: fill, fontStyle, fontWeight, fontSize, fontFamily } = label;\r\n        textNode.setProperties({\r\n            visible: true,\r\n            x,\r\n            y,\r\n            text,\r\n            fill,\r\n            fontStyle,\r\n            fontWeight,\r\n            fontSize,\r\n            fontFamily,\r\n            textAlign,\r\n            textBaseline,\r\n        });\r\n    }\r\n    else {\r\n        textNode.visible = false;\r\n    }\r\n}\r\nfunction adjustLabelPlacement({ isPositive, isVertical, placement, padding = 0, rect, }) {\r\n    let x = rect.x + rect.width / 2;\r\n    let y = rect.y + rect.height / 2;\r\n    let textAlign = 'center';\r\n    let textBaseline = 'middle';\r\n    switch (placement) {\r\n        case 'start': {\r\n            if (isVertical) {\r\n                y = isPositive ? rect.y + rect.height + padding : rect.y - padding;\r\n                textBaseline = isPositive ? 'top' : 'bottom';\r\n            }\r\n            else {\r\n                x = isPositive ? rect.x - padding : rect.x + rect.width + padding;\r\n                textAlign = isPositive ? 'start' : 'end';\r\n            }\r\n            break;\r\n        }\r\n        case 'outside':\r\n        case 'end': {\r\n            if (isVertical) {\r\n                y = isPositive ? rect.y - padding : rect.y + rect.height + padding;\r\n                textBaseline = isPositive ? 'bottom' : 'top';\r\n            }\r\n            else {\r\n                x = isPositive ? rect.x + rect.width + padding : rect.x - padding;\r\n                textAlign = isPositive ? 'start' : 'end';\r\n            }\r\n            break;\r\n        }\r\n    }\r\n    return { x, y, textAlign, textBaseline };\r\n}\n\nvar BarSeriesNodeTag;\r\n(function (BarSeriesNodeTag) {\r\n    BarSeriesNodeTag[BarSeriesNodeTag[\"Bar\"] = 0] = \"Bar\";\r\n    BarSeriesNodeTag[BarSeriesNodeTag[\"Label\"] = 1] = \"Label\";\r\n})(BarSeriesNodeTag || (BarSeriesNodeTag = {}));\r\nclass BarSeriesLabel extends Label {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.placement = 'inside';\r\n    }\r\n}\r\n__decorate([\r\n    Validate(STRING_UNION('inside', 'outside')),\r\n    __metadata(\"design:type\", String)\r\n], BarSeriesLabel.prototype, \"placement\", void 0);\r\nclass BarSeries extends AbstractBarSeries {\r\n    constructor(moduleCtx) {\r\n        super({\r\n            moduleCtx,\r\n            pickModes: [SeriesNodePickMode.EXACT_SHAPE_MATCH],\r\n            pathsPerSeries: 0,\r\n            hasHighlightedLabels: true,\r\n            datumSelectionGarbageCollection: false,\r\n            animationResetFns: {\r\n                datum: resetBarSelectionsFn,\r\n                label: resetLabelFn,\r\n            },\r\n        });\r\n        this.label = new BarSeriesLabel();\r\n        this.tooltip = new SeriesTooltip();\r\n        this.fill = '#c16068';\r\n        this.stroke = '#874349';\r\n        this.fillOpacity = 1;\r\n        this.strokeOpacity = 1;\r\n        this.lineDash = [0];\r\n        this.lineDashOffset = 0;\r\n        this.formatter = undefined;\r\n        this.xKey = undefined;\r\n        this.xName = undefined;\r\n        this.yKey = undefined;\r\n        this.yName = undefined;\r\n        this.stackGroup = undefined;\r\n        this.strokeWidth = 1;\r\n        this.shadow = undefined;\r\n        /**\r\n         * Used to get the position of bars within each group.\r\n         */\r\n        this.groupScale = new BandScale();\r\n        this.smallestDataInterval = undefined;\r\n    }\r\n    resolveKeyDirection(direction) {\r\n        if (this.getBarDirection() === ChartAxisDirection.X) {\r\n            if (direction === ChartAxisDirection.X) {\r\n                return ChartAxisDirection.Y;\r\n            }\r\n            return ChartAxisDirection.X;\r\n        }\r\n        return direction;\r\n    }\r\n    processData(dataController) {\r\n        var _a, _b, _c, _d;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { xKey, yKey, normalizedTo, seriesGrouping: { groupIndex = this.id } = {}, data = [] } = this;\r\n            if (xKey == null || yKey == null || data == null)\r\n                return;\r\n            const animationEnabled = !this.ctx.animationManager.isSkipped();\r\n            const normalizedToAbs = Math.abs(normalizedTo !== null && normalizedTo !== void 0 ? normalizedTo : NaN);\r\n            const isContinuousX = ContinuousScale.is((_a = this.getCategoryAxis()) === null || _a === void 0 ? void 0 : _a.scale);\r\n            const isContinuousY = ContinuousScale.is((_b = this.getValueAxis()) === null || _b === void 0 ? void 0 : _b.scale);\r\n            const stackGroupName = `bar-stack-${groupIndex}-yValues`;\r\n            const stackGroupTrailingName = `${stackGroupName}-trailing`;\r\n            const normaliseTo = normalizedToAbs && isFinite(normalizedToAbs) ? normalizedToAbs : undefined;\r\n            const extraProps = [];\r\n            if (normaliseTo) {\r\n                extraProps.push(normaliseGroupTo(this, [stackGroupName, stackGroupTrailingName], normaliseTo, 'range'));\r\n            }\r\n            if (animationEnabled && this.processedData) {\r\n                extraProps.push(diff(this.processedData));\r\n            }\r\n            if (animationEnabled) {\r\n                extraProps.push(animationValidation(this));\r\n            }\r\n            const visibleProps = !this.visible ? { forceValue: 0 } : {};\r\n            const { processedData } = yield this.requestDataModel(dataController, data, {\r\n                props: [\r\n                    keyProperty(this, xKey, isContinuousX, { id: 'xValue' }),\r\n                    valueProperty(this, yKey, isContinuousY, Object.assign({ id: `yValue-raw`, invalidValue: null }, visibleProps)),\r\n                    ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'normal', 'current', Object.assign({ id: `yValue-end`, invalidValue: null, missingValue: 0, groupId: stackGroupName, separateNegative: true }, visibleProps)),\r\n                    ...groupAccumulativeValueProperty(this, yKey, isContinuousY, 'trailing', 'current', Object.assign({ id: `yValue-start`, invalidValue: null, missingValue: 0, groupId: stackGroupTrailingName, separateNegative: true }, visibleProps)),\r\n                    ...(isContinuousX ? [SMALLEST_KEY_INTERVAL] : []),\r\n                    ...extraProps,\r\n                ],\r\n                groupByKeys: true,\r\n            });\r\n            this.smallestDataInterval = {\r\n                x: (_d = (_c = processedData.reduced) === null || _c === void 0 ? void 0 : _c.smallestKeyInterval) !== null && _d !== void 0 ? _d : Infinity,\r\n                y: Infinity,\r\n            };\r\n            this.animationState.transition('updateData');\r\n        });\r\n    }\r\n    getSeriesDomain(direction) {\r\n        var _a;\r\n        const { processedData, dataModel } = this;\r\n        if (!processedData || !dataModel)\r\n            return [];\r\n        const { reduced: { [SMALLEST_KEY_INTERVAL.property]: smallestX } = {} } = processedData;\r\n        const categoryAxis = this.getCategoryAxis();\r\n        const valueAxis = this.getValueAxis();\r\n        const keyDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\r\n        const keys = dataModel.getDomain(this, `xValue`, 'key', processedData);\r\n        const yExtent = dataModel.getDomain(this, `yValue-end`, 'value', processedData);\r\n        if (direction === this.getCategoryDirection()) {\r\n            if ((keyDef === null || keyDef === void 0 ? void 0 : keyDef.def.type) === 'key' && (keyDef === null || keyDef === void 0 ? void 0 : keyDef.def.valueType) === 'category') {\r\n                return keys;\r\n            }\r\n            const scalePadding = smallestX != null && isFinite(smallestX) ? smallestX : 0;\r\n            const keysExtent = (_a = extent(keys)) !== null && _a !== void 0 ? _a : [NaN, NaN];\r\n            if (direction === ChartAxisDirection.Y) {\r\n                return fixNumericExtent([keysExtent[0] + -scalePadding, keysExtent[1]], categoryAxis);\r\n            }\r\n            return fixNumericExtent([keysExtent[0], keysExtent[1] + scalePadding], categoryAxis);\r\n        }\r\n        else if (this.getValueAxis() instanceof LogAxis) {\r\n            return fixNumericExtent(yExtent, valueAxis);\r\n        }\r\n        else {\r\n            const fixedYExtent = [yExtent[0] > 0 ? 0 : yExtent[0], yExtent[1] < 0 ? 0 : yExtent[1]];\r\n            return fixNumericExtent(fixedYExtent, valueAxis);\r\n        }\r\n    }\r\n    createNodeData() {\r\n        const _super = Object.create(null, {\r\n            calculateScaling: { get: () => super.calculateScaling }\r\n        });\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { dataModel } = this;\r\n            const xAxis = this.getCategoryAxis();\r\n            const yAxis = this.getValueAxis();\r\n            if (!(dataModel && xAxis && yAxis)) {\r\n                return [];\r\n            }\r\n            const xScale = xAxis.scale;\r\n            const yScale = yAxis.scale;\r\n            const { groupScale, yKey = '', xKey = '', fill, stroke, strokeWidth, label, processedData, ctx: { seriesStateManager }, smallestDataInterval, } = this;\r\n            const xBandWidth = ContinuousScale.is(xScale)\r\n                ? xScale.calcBandwidth(smallestDataInterval === null || smallestDataInterval === void 0 ? void 0 : smallestDataInterval.x)\r\n                : xScale.bandwidth;\r\n            const domain = [];\r\n            const { index: groupIndex, visibleGroupCount } = seriesStateManager.getVisiblePeerGroupIndex(this);\r\n            for (let groupIdx = 0; groupIdx < visibleGroupCount; groupIdx++) {\r\n                domain.push(String(groupIdx));\r\n            }\r\n            groupScale.domain = domain;\r\n            groupScale.range = [0, xBandWidth !== null && xBandWidth !== void 0 ? xBandWidth : 0];\r\n            if (xAxis instanceof CategoryAxis) {\r\n                groupScale.paddingInner = xAxis.groupPaddingInner;\r\n            }\r\n            else if (xAxis instanceof GroupedCategoryAxis) {\r\n                groupScale.padding = 0.1;\r\n            }\r\n            else {\r\n                // Number or Time axis\r\n                groupScale.padding = 0;\r\n            }\r\n            // To get exactly `0` padding we need to turn off rounding\r\n            groupScale.round = groupScale.padding !== 0;\r\n            const barWidth = groupScale.bandwidth >= 1\r\n                ? // Pixel-rounded value for low-volume bar charts.\r\n                    groupScale.bandwidth\r\n                : // Handle high-volume bar charts gracefully.\r\n                    groupScale.rawBandwidth;\r\n            const xIndex = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;\r\n            const yRawIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-raw`).index;\r\n            const yStartIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-start`).index;\r\n            const yEndIndex = dataModel.resolveProcessedDataIndexById(this, `yValue-end`).index;\r\n            const animationEnabled = !this.ctx.animationManager.isSkipped();\r\n            const context = {\r\n                itemId: yKey,\r\n                nodeData: [],\r\n                labelData: [],\r\n                scales: _super.calculateScaling.call(this),\r\n                visible: this.visible || animationEnabled,\r\n            };\r\n            processedData === null || processedData === void 0 ? void 0 : processedData.data.forEach(({ keys, datum: seriesDatum, values }) => {\r\n                const xValue = keys[xIndex];\r\n                const x = xScale.convert(xValue);\r\n                const currY = +values[0][yEndIndex];\r\n                const prevY = +values[0][yStartIndex];\r\n                const yRawValue = values[0][yRawIndex];\r\n                const barX = x + groupScale.convert(String(groupIndex));\r\n                if (isNaN(currY)) {\r\n                    return;\r\n                }\r\n                const y = yScale.convert(currY);\r\n                const bottomY = yScale.convert(prevY);\r\n                const barAlongX = this.getBarDirection() === ChartAxisDirection.X;\r\n                const rect = {\r\n                    x: barAlongX ? Math.min(y, bottomY) : barX,\r\n                    y: barAlongX ? barX : Math.min(y, bottomY),\r\n                    width: barAlongX ? Math.abs(bottomY - y) : barWidth,\r\n                    height: barAlongX ? barWidth : Math.abs(bottomY - y),\r\n                };\r\n                const { fontStyle: labelFontStyle, fontWeight: labelFontWeight, fontSize: labelFontSize, fontFamily: labelFontFamily, color: labelColor, placement, } = label;\r\n                const labelText = this.getLabelText(this.label, {\r\n                    datum: seriesDatum[0],\r\n                    value: yRawValue,\r\n                    xKey,\r\n                    yKey,\r\n                    xName: this.xName,\r\n                    yName: this.yName,\r\n                    legendItemName: this.legendItemName,\r\n                }, (value) => (isNumber(value) ? value.toFixed(2) : ''));\r\n                const labelDatum = labelText\r\n                    ? Object.assign({ text: labelText, fill: labelColor, fontStyle: labelFontStyle, fontWeight: labelFontWeight, fontSize: labelFontSize, fontFamily: labelFontFamily }, adjustLabelPlacement({\r\n                        isPositive: yRawValue >= 0,\r\n                        isVertical: !barAlongX,\r\n                        placement,\r\n                        rect,\r\n                    })) : undefined;\r\n                const lengthRatioMultiplier = this.shouldFlipXY() ? rect.height : rect.width;\r\n                const nodeData = {\r\n                    series: this,\r\n                    itemId: yKey,\r\n                    datum: seriesDatum[0],\r\n                    cumulativeValue: currY,\r\n                    xValue,\r\n                    yValue: yRawValue,\r\n                    yKey,\r\n                    xKey,\r\n                    capDefaults: {\r\n                        lengthRatioMultiplier: lengthRatioMultiplier,\r\n                        lengthMax: lengthRatioMultiplier,\r\n                    },\r\n                    x: rect.x,\r\n                    y: rect.y,\r\n                    width: rect.width,\r\n                    height: rect.height,\r\n                    midPoint: { x: rect.x + rect.width / 2, y: rect.y + rect.height / 2 },\r\n                    fill,\r\n                    stroke,\r\n                    strokeWidth,\r\n                    label: labelDatum,\r\n                };\r\n                context.nodeData.push(nodeData);\r\n                context.labelData.push(nodeData);\r\n            });\r\n            return [context];\r\n        });\r\n    }\r\n    nodeFactory() {\r\n        return new Rect();\r\n    }\r\n    updateDatumSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            return opts.datumSelection.update(opts.nodeData, (rect) => {\r\n                rect.tag = BarSeriesNodeTag.Bar;\r\n            }, (datum) => datum.xValue);\r\n        });\r\n    }\r\n    updateDatumNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { datumSelection, isHighlight } = opts;\r\n            const { yKey = '', fill, stroke, fillOpacity, strokeOpacity, lineDash, lineDashOffset, shadow, formatter, id: seriesId, highlightStyle: { item: itemHighlightStyle }, ctx, stackGroup, } = this;\r\n            const xAxis = this.axes[ChartAxisDirection.X];\r\n            const crisp = checkCrisp(xAxis === null || xAxis === void 0 ? void 0 : xAxis.visibleRange);\r\n            const categoryAlongX = this.getCategoryDirection() === ChartAxisDirection.X;\r\n            datumSelection.each((rect, datum) => {\r\n                const style = {\r\n                    fill,\r\n                    stroke,\r\n                    fillOpacity,\r\n                    strokeOpacity,\r\n                    lineDash,\r\n                    lineDashOffset,\r\n                    fillShadow: shadow,\r\n                    strokeWidth: this.getStrokeWidth(this.strokeWidth),\r\n                };\r\n                const visible = categoryAlongX ? datum.width > 0 : datum.height > 0;\r\n                const config = getRectConfig({\r\n                    datum,\r\n                    isHighlighted: isHighlight,\r\n                    style,\r\n                    highlightStyle: itemHighlightStyle,\r\n                    formatter,\r\n                    seriesId,\r\n                    stackGroup,\r\n                    ctx,\r\n                    yKey,\r\n                });\r\n                config.crisp = crisp;\r\n                config.visible = visible;\r\n                updateRect({ rect, config });\r\n            });\r\n        });\r\n    }\r\n    updateLabelSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const data = this.label.enabled ? opts.labelData : [];\r\n            return opts.labelSelection.update(data, (text) => {\r\n                text.tag = BarSeriesNodeTag.Label;\r\n                text.pointerEvents = PointerEvents.None;\r\n            });\r\n        });\r\n    }\r\n    updateLabelNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            opts.labelSelection.each((textNode, datum) => {\r\n                updateLabelNode(textNode, this.label, datum.label);\r\n            });\r\n        });\r\n    }\r\n    getTooltipHtml(nodeDatum) {\r\n        var _a;\r\n        const { xKey, yKey, processedData, ctx: { callbackCache }, } = this;\r\n        const xAxis = this.getCategoryAxis();\r\n        const yAxis = this.getValueAxis();\r\n        const { xValue, yValue, datum } = nodeDatum;\r\n        if (!processedData || !xKey || !yKey || !xAxis || !yAxis) {\r\n            return '';\r\n        }\r\n        const { xName, yName, fill, stroke, tooltip, formatter, id: seriesId, stackGroup } = this;\r\n        const strokeWidth = this.getStrokeWidth(this.strokeWidth);\r\n        const xString = xAxis.formatDatum(xValue);\r\n        const yString = yAxis.formatDatum(yValue);\r\n        const title = sanitizeHtml(yName);\r\n        const content = sanitizeHtml(xString + ': ' + yString);\r\n        let format;\r\n        if (formatter) {\r\n            format = callbackCache.call(formatter, {\r\n                datum,\r\n                fill,\r\n                stroke,\r\n                strokeWidth,\r\n                highlighted: false,\r\n                xKey,\r\n                yKey,\r\n                seriesId,\r\n                stackGroup,\r\n            });\r\n        }\r\n        const color = (_a = format === null || format === void 0 ? void 0 : format.fill) !== null && _a !== void 0 ? _a : fill;\r\n        return tooltip.toTooltipHtml({ title, content, backgroundColor: color }, Object.assign({ datum,\r\n            xKey,\r\n            xName,\r\n            yKey,\r\n            yName,\r\n            color,\r\n            title,\r\n            seriesId,\r\n            stackGroup }, this.getModuleTooltipParams(datum)));\r\n    }\r\n    getLegendData(legendType) {\r\n        var _a;\r\n        const { id, data, xKey, yKey, yName, legendItemName, fill, stroke, strokeWidth, fillOpacity, strokeOpacity, visible, showInLegend, } = this;\r\n        if (legendType !== 'category' || !showInLegend || !(data === null || data === void 0 ? void 0 : data.length) || !xKey || !yKey) {\r\n            return [];\r\n        }\r\n        return [\r\n            {\r\n                legendType: 'category',\r\n                id,\r\n                itemId: yKey,\r\n                seriesId: id,\r\n                enabled: visible,\r\n                label: { text: (_a = legendItemName !== null && legendItemName !== void 0 ? legendItemName : yName) !== null && _a !== void 0 ? _a : yKey },\r\n                marker: { fill, stroke, fillOpacity, strokeOpacity, strokeWidth },\r\n                legendItemName,\r\n            },\r\n        ];\r\n    }\r\n    animateEmptyUpdateReady({ datumSelections, labelSelections, annotationSelections }) {\r\n        const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.direction === 'vertical', this.axes));\r\n        fromToMotion(this.id, 'nodes', this.ctx.animationManager, datumSelections, fns);\r\n        seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, labelSelections);\r\n        seriesLabelFadeInAnimation(this, 'annotations', this.ctx.animationManager, annotationSelections);\r\n    }\r\n    animateWaitingUpdateReady(data) {\r\n        var _a, _b;\r\n        const { datumSelections, labelSelections, annotationSelections } = data;\r\n        this.ctx.animationManager.stopByAnimationGroupId(this.id);\r\n        const diff = (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.diff;\r\n        const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(this.direction === 'vertical', this.axes));\r\n        fromToMotion(this.id, 'nodes', this.ctx.animationManager, datumSelections, fns, (_, datum) => String(datum.xValue), diff);\r\n        seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, labelSelections);\r\n        seriesLabelFadeInAnimation(this, 'annotations', this.ctx.animationManager, annotationSelections);\r\n    }\r\n    isLabelEnabled() {\r\n        return this.label.enabled;\r\n    }\r\n}\r\nBarSeries.className = 'BarSeries';\r\nBarSeries.type = 'bar';\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BarSeries.prototype, \"fill\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BarSeries.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], BarSeries.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], BarSeries.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_LINE_DASH),\r\n    __metadata(\"design:type\", Array)\r\n], BarSeries.prototype, \"lineDash\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], BarSeries.prototype, \"lineDashOffset\", void 0);\r\n__decorate([\r\n    Validate(OPT_FUNCTION),\r\n    __metadata(\"design:type\", Function)\r\n], BarSeries.prototype, \"formatter\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BarSeries.prototype, \"xKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BarSeries.prototype, \"xName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BarSeries.prototype, \"yKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BarSeries.prototype, \"yName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BarSeries.prototype, \"stackGroup\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER()),\r\n    __metadata(\"design:type\", Number)\r\n], BarSeries.prototype, \"normalizedTo\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], BarSeries.prototype, \"strokeWidth\", void 0);\n\nconst BarSeriesModule = {\r\n    type: 'series',\r\n    optionsKey: 'series[]',\r\n    packageType: 'community',\r\n    chartTypes: ['cartesian'],\r\n    identifier: 'bar',\r\n    instanceConstructor: BarSeries,\r\n    stackable: true,\r\n    groupable: true,\r\n    seriesDefaults: {\r\n        axes: [\r\n            {\r\n                type: CARTESIAN_AXIS_TYPES.NUMBER,\r\n                position: CARTESIAN_AXIS_POSITIONS.LEFT,\r\n            },\r\n            {\r\n                type: CARTESIAN_AXIS_TYPES.CATEGORY,\r\n                position: CARTESIAN_AXIS_POSITIONS.BOTTOM,\r\n            },\r\n        ],\r\n    },\r\n    swapDefaultAxesCondition: (series) => (series === null || series === void 0 ? void 0 : series.direction) === 'horizontal',\r\n    themeTemplate: {\r\n        __extends__: EXTENDS_SERIES_DEFAULTS,\r\n        fillOpacity: 1,\r\n        strokeWidth: 0,\r\n        lineDash: [0],\r\n        lineDashOffset: 0,\r\n        label: {\r\n            enabled: false,\r\n            fontStyle: undefined,\r\n            fontWeight: NORMAL,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\r\n            formatter: undefined,\r\n            placement: 'inside',\r\n        },\r\n        shadow: {\r\n            enabled: false,\r\n            color: DEFAULT_SHADOW_COLOUR,\r\n            xOffset: 3,\r\n            yOffset: 3,\r\n            blur: 5,\r\n        },\r\n    },\r\n    enterpriseThemeTemplate: {\r\n        errorBar: {\r\n            cap: {\r\n                lengthRatio: 0.3,\r\n            },\r\n        },\r\n    },\r\n    paletteFactory: singleSeriesPaletteFactory,\r\n};\n\nclass BubbleSeriesNodeClickEvent extends CartesianSeriesNodeClickEvent {\r\n    constructor(type, nativeEvent, datum, series) {\r\n        super(type, nativeEvent, datum, series);\r\n        this.sizeKey = series.sizeKey;\r\n    }\r\n}\r\nclass BubbleSeriesMarker extends SeriesMarker {\r\n    constructor() {\r\n        super(...arguments);\r\n        /**\r\n         * The series `sizeKey` values along with the `size` and `maxSize` configs will be used to\r\n         * determine the size of the marker. All values will be mapped to a marker size within the\r\n         * `[size, maxSize]` range, where the largest values will correspond to the `maxSize` and the\r\n         * lowest to the `size`.\r\n         */\r\n        this.maxSize = 30;\r\n        this.domain = undefined;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Object)\r\n], BubbleSeriesMarker.prototype, \"maxSize\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER_ARRAY),\r\n    SceneChangeDetection({ redraw: RedrawType.MAJOR }),\r\n    __metadata(\"design:type\", Array)\r\n], BubbleSeriesMarker.prototype, \"domain\", void 0);\r\nclass BubbleSeries extends CartesianSeries {\r\n    constructor(moduleCtx) {\r\n        super({\r\n            moduleCtx,\r\n            pickModes: [\r\n                SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST,\r\n                SeriesNodePickMode.NEAREST_NODE,\r\n                SeriesNodePickMode.EXACT_SHAPE_MATCH,\r\n            ],\r\n            pathsPerSeries: 0,\r\n            hasMarkers: true,\r\n            markerSelectionGarbageCollection: false,\r\n            animationResetFns: {\r\n                label: resetLabelFn,\r\n                marker: resetMarkerFn,\r\n            },\r\n        });\r\n        this.NodeClickEvent = BubbleSeriesNodeClickEvent;\r\n        this.sizeScale = new LinearScale();\r\n        this.marker = new BubbleSeriesMarker();\r\n        this.label = new Label();\r\n        this.title = undefined;\r\n        this.labelKey = undefined;\r\n        this.xName = undefined;\r\n        this.yName = undefined;\r\n        this.sizeName = 'Size';\r\n        this.labelName = 'Label';\r\n        this.xKey = undefined;\r\n        this.yKey = undefined;\r\n        this.sizeKey = undefined;\r\n        this.colorKey = undefined;\r\n        this.colorName = 'Color';\r\n        this.colorRange = ['#ffff00', '#00ff00', '#0000ff'];\r\n        this.colorScale = new ColorScale();\r\n        this.tooltip = new SeriesTooltip();\r\n    }\r\n    processData(dataController) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { xKey, yKey, sizeKey, labelKey, colorScale, colorDomain, colorRange, colorKey, marker, data } = this;\r\n            if (xKey == null || yKey == null || sizeKey == null || data == null)\r\n                return;\r\n            const { isContinuousX, isContinuousY } = this.isContinuous();\r\n            const { dataModel, processedData } = yield this.requestDataModel(dataController, data, {\r\n                props: [\r\n                    keyProperty(this, xKey, isContinuousX, { id: 'xKey-raw' }),\r\n                    keyProperty(this, yKey, isContinuousY, { id: 'yKey-raw' }),\r\n                    ...(labelKey ? [keyProperty(this, labelKey, false, { id: `labelKey-raw` })] : []),\r\n                    valueProperty(this, xKey, isContinuousX, { id: `xValue` }),\r\n                    valueProperty(this, yKey, isContinuousY, { id: `yValue` }),\r\n                    valueProperty(this, sizeKey, true, { id: `sizeValue` }),\r\n                    ...(colorKey ? [valueProperty(this, colorKey, true, { id: `colorValue` })] : []),\r\n                    ...(labelKey ? [valueProperty(this, labelKey, false, { id: `labelValue` })] : []),\r\n                ],\r\n                dataVisible: this.visible,\r\n            });\r\n            const sizeKeyIdx = dataModel.resolveProcessedDataIndexById(this, `sizeValue`).index;\r\n            const processedSize = (_a = processedData.domain.values[sizeKeyIdx]) !== null && _a !== void 0 ? _a : [];\r\n            this.sizeScale.domain = marker.domain ? marker.domain : processedSize;\r\n            if (colorKey) {\r\n                const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`).index;\r\n                colorScale.domain = (_b = colorDomain !== null && colorDomain !== void 0 ? colorDomain : processedData.domain.values[colorKeyIdx]) !== null && _b !== void 0 ? _b : [];\r\n                colorScale.range = colorRange;\r\n                colorScale.update();\r\n            }\r\n            this.animationState.transition('updateData');\r\n        });\r\n    }\r\n    getSeriesDomain(direction) {\r\n        const { dataModel, processedData } = this;\r\n        if (!processedData || !dataModel)\r\n            return [];\r\n        const id = direction === ChartAxisDirection.X ? `xValue` : `yValue`;\r\n        const dataDef = dataModel.resolveProcessedDataDefById(this, id);\r\n        const domain = dataModel.getDomain(this, id, 'value', processedData);\r\n        if ((dataDef === null || dataDef === void 0 ? void 0 : dataDef.def.type) === 'value' && (dataDef === null || dataDef === void 0 ? void 0 : dataDef.def.valueType) === 'category') {\r\n            return domain;\r\n        }\r\n        const axis = this.axes[direction];\r\n        return fixNumericExtent(extent(domain), axis);\r\n    }\r\n    createNodeData() {\r\n        const _super = Object.create(null, {\r\n            calculateScaling: { get: () => super.calculateScaling }\r\n        });\r\n        var _a, _b, _c, _d;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { visible, axes, yKey = '', xKey = '', label, labelKey, dataModel, processedData, colorScale, sizeKey = '', colorKey, } = this;\r\n            const xAxis = axes[ChartAxisDirection.X];\r\n            const yAxis = axes[ChartAxisDirection.Y];\r\n            if (!(dataModel && processedData && visible && xAxis && yAxis))\r\n                return [];\r\n            const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;\r\n            const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`).index;\r\n            const sizeDataIdx = sizeKey ? dataModel.resolveProcessedDataIndexById(this, `sizeValue`).index : -1;\r\n            const colorDataIdx = colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`).index : -1;\r\n            const labelDataIdx = labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`).index : -1;\r\n            const xScale = xAxis.scale;\r\n            const yScale = yAxis.scale;\r\n            const xOffset = ((_a = xScale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;\r\n            const yOffset = ((_b = yScale.bandwidth) !== null && _b !== void 0 ? _b : 0) / 2;\r\n            const { sizeScale, marker } = this;\r\n            const nodeData = [];\r\n            sizeScale.range = [marker.size, marker.maxSize];\r\n            const font = label.getFont();\r\n            for (const { values, datum } of (_c = processedData.data) !== null && _c !== void 0 ? _c : []) {\r\n                const xDatum = values[xDataIdx];\r\n                const yDatum = values[yDataIdx];\r\n                const x = xScale.convert(xDatum) + xOffset;\r\n                const y = yScale.convert(yDatum) + yOffset;\r\n                const labelText = this.getLabelText(label, {\r\n                    value: labelKey ? values[labelDataIdx] : yDatum,\r\n                    datum,\r\n                    xKey,\r\n                    yKey,\r\n                    sizeKey,\r\n                    labelKey,\r\n                    xName: this.xName,\r\n                    yName: this.yName,\r\n                    sizeName: this.sizeName,\r\n                    labelName: this.labelName,\r\n                });\r\n                const size = HdpiCanvas.getTextSize(String(labelText), font);\r\n                const markerSize = sizeKey ? sizeScale.convert(values[sizeDataIdx]) : marker.size;\r\n                const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : undefined;\r\n                nodeData.push({\r\n                    series: this,\r\n                    itemId: yKey,\r\n                    yKey,\r\n                    xKey,\r\n                    datum,\r\n                    xValue: xDatum,\r\n                    yValue: yDatum,\r\n                    sizeValue: values[sizeDataIdx],\r\n                    point: { x, y, size: markerSize },\r\n                    midPoint: { x, y },\r\n                    fill,\r\n                    label: Object.assign({ text: labelText }, size),\r\n                });\r\n            }\r\n            return [\r\n                {\r\n                    itemId: (_d = this.yKey) !== null && _d !== void 0 ? _d : this.id,\r\n                    nodeData,\r\n                    labelData: nodeData,\r\n                    scales: _super.calculateScaling.call(this),\r\n                    visible: this.visible,\r\n                },\r\n            ];\r\n        });\r\n    }\r\n    isPathOrSelectionDirty() {\r\n        return this.marker.isDirty();\r\n    }\r\n    getLabelData() {\r\n        var _a;\r\n        return (_a = this.contextNodeData) === null || _a === void 0 ? void 0 : _a.reduce((r, n) => r.concat(n.labelData), []);\r\n    }\r\n    markerFactory() {\r\n        const { shape } = this.marker;\r\n        const MarkerShape = getMarker(shape);\r\n        return new MarkerShape();\r\n    }\r\n    updateMarkerSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { nodeData, markerSelection } = opts;\r\n            if (this.marker.isDirty()) {\r\n                markerSelection.clear();\r\n                markerSelection.cleanup();\r\n            }\r\n            const data = this.marker.enabled ? nodeData : [];\r\n            return markerSelection.update(data, undefined, (datum) => this.getDatumId(datum));\r\n        });\r\n    }\r\n    updateMarkerNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { markerSelection, isHighlight: highlighted } = opts;\r\n            const { xKey = '', yKey = '', sizeKey = '', labelKey, marker } = this;\r\n            const baseStyle = mergeDefaults(highlighted && this.highlightStyle.item, marker.getStyle());\r\n            this.sizeScale.range = [marker.size, marker.maxSize];\r\n            markerSelection.each((node, datum) => {\r\n                this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, sizeKey, labelKey }, baseStyle);\r\n            });\r\n            if (!highlighted) {\r\n                this.marker.markClean();\r\n            }\r\n        });\r\n    }\r\n    updateLabelSelection(opts) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelSelection } = opts;\r\n            const { label: { enabled }, } = this;\r\n            const placedLabels = enabled ? (_b = (_a = this.chart) === null || _a === void 0 ? void 0 : _a.placeLabels().get(this)) !== null && _b !== void 0 ? _b : [] : [];\r\n            const placedNodeDatum = placedLabels.map((v) => (Object.assign(Object.assign({}, v.datum), { point: {\r\n                    x: v.x,\r\n                    y: v.y,\r\n                    size: v.datum.point.size,\r\n                } })));\r\n            return labelSelection.update(placedNodeDatum);\r\n        });\r\n    }\r\n    updateLabelNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelSelection } = opts;\r\n            const { label } = this;\r\n            labelSelection.each((text, datum) => {\r\n                var _a, _b, _c, _d;\r\n                text.text = datum.label.text;\r\n                text.fill = label.color;\r\n                text.x = (_b = (_a = datum.point) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;\r\n                text.y = (_d = (_c = datum.point) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0;\r\n                text.fontStyle = label.fontStyle;\r\n                text.fontWeight = label.fontWeight;\r\n                text.fontSize = label.fontSize;\r\n                text.fontFamily = label.fontFamily;\r\n                text.textAlign = 'left';\r\n                text.textBaseline = 'top';\r\n            });\r\n        });\r\n    }\r\n    getTooltipHtml(nodeDatum) {\r\n        var _a;\r\n        const { xKey, yKey, sizeKey, axes } = this;\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        if (!xKey || !yKey || !xAxis || !yAxis || !sizeKey) {\r\n            return '';\r\n        }\r\n        const { marker, tooltip, xName, yName, sizeName, labelKey, labelName, id: seriesId } = this;\r\n        const baseStyle = mergeDefaults({ fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) }, marker.getStyle());\r\n        const { fill: color = 'gray' } = this.getMarkerStyle(marker, { datum: nodeDatum, highlighted: false, xKey, yKey, sizeKey, labelKey }, baseStyle);\r\n        const title = (_a = this.title) !== null && _a !== void 0 ? _a : yName;\r\n        const { datum, xValue, yValue, sizeValue, label: { text: labelText }, } = nodeDatum;\r\n        const xString = sanitizeHtml(xAxis.formatDatum(xValue));\r\n        const yString = sanitizeHtml(yAxis.formatDatum(yValue));\r\n        let content = `<b>${sanitizeHtml(xName !== null && xName !== void 0 ? xName : xKey)}</b>: ${xString}<br>` +\r\n            `<b>${sanitizeHtml(yName !== null && yName !== void 0 ? yName : yKey)}</b>: ${yString}`;\r\n        if (sizeKey) {\r\n            content += `<br><b>${sanitizeHtml(sizeName !== null && sizeName !== void 0 ? sizeName : sizeKey)}</b>: ${sanitizeHtml(String(sizeValue))}`;\r\n        }\r\n        if (labelKey) {\r\n            content = `<b>${sanitizeHtml(labelName !== null && labelName !== void 0 ? labelName : labelKey)}</b>: ${sanitizeHtml(labelText)}<br>` + content;\r\n        }\r\n        return tooltip.toTooltipHtml({ title, content, backgroundColor: color }, {\r\n            datum,\r\n            xKey,\r\n            xName,\r\n            yKey,\r\n            yName,\r\n            sizeKey,\r\n            sizeName,\r\n            labelKey,\r\n            labelName,\r\n            title,\r\n            color,\r\n            seriesId,\r\n        });\r\n    }\r\n    getLegendData() {\r\n        var _a;\r\n        const { id, data, xKey, yKey, sizeKey, yName, title, visible, marker } = this;\r\n        const { shape, fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;\r\n        if (!((data === null || data === void 0 ? void 0 : data.length) && xKey && yKey && sizeKey)) {\r\n            return [];\r\n        }\r\n        return [\r\n            {\r\n                legendType: 'category',\r\n                id,\r\n                itemId: yKey,\r\n                seriesId: id,\r\n                enabled: visible,\r\n                label: {\r\n                    text: (_a = title !== null && title !== void 0 ? title : yName) !== null && _a !== void 0 ? _a : yKey,\r\n                },\r\n                marker: {\r\n                    shape,\r\n                    fill: fill !== null && fill !== void 0 ? fill : 'rgba(0, 0, 0, 0)',\r\n                    stroke: stroke !== null && stroke !== void 0 ? stroke : 'rgba(0, 0, 0, 0)',\r\n                    fillOpacity: fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1,\r\n                    strokeOpacity: strokeOpacity !== null && strokeOpacity !== void 0 ? strokeOpacity : 1,\r\n                    strokeWidth: strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 0,\r\n                },\r\n            },\r\n        ];\r\n    }\r\n    animateEmptyUpdateReady({ markerSelections, labelSelections }) {\r\n        markerScaleInAnimation(this, this.ctx.animationManager, markerSelections);\r\n        seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, labelSelections);\r\n    }\r\n    getDatumId(datum) {\r\n        return createDatumId([`${datum.xValue}`, `${datum.yValue}`, datum.label.text]);\r\n    }\r\n    isLabelEnabled() {\r\n        return this.label.enabled;\r\n    }\r\n    nodeFactory() {\r\n        return new Group();\r\n    }\r\n}\r\nBubbleSeries.className = 'BubbleSeries';\r\nBubbleSeries.type = 'bubble';\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"title\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"labelKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"xName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"yName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"sizeName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"labelName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"xKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"yKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"sizeKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"colorKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], BubbleSeries.prototype, \"colorName\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], BubbleSeries.prototype, \"colorDomain\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], BubbleSeries.prototype, \"colorRange\", void 0);\n\nconst BubbleSeriesModule = {\r\n    type: 'series',\r\n    optionsKey: 'series[]',\r\n    packageType: 'community',\r\n    chartTypes: ['cartesian'],\r\n    identifier: 'bubble',\r\n    instanceConstructor: BubbleSeries,\r\n    seriesDefaults: {\r\n        axes: [\r\n            { type: CARTESIAN_AXIS_TYPES.NUMBER, position: CARTESIAN_AXIS_POSITIONS.BOTTOM },\r\n            { type: CARTESIAN_AXIS_TYPES.NUMBER, position: CARTESIAN_AXIS_POSITIONS.LEFT },\r\n        ],\r\n    },\r\n    themeTemplate: {\r\n        __extends__: EXTENDS_SERIES_DEFAULTS,\r\n        tooltip: {\r\n            position: {\r\n                type: 'node',\r\n            },\r\n        },\r\n        marker: {\r\n            __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,\r\n            maxSize: 30,\r\n            fillOpacity: 0.8,\r\n        },\r\n        label: {\r\n            enabled: false,\r\n            fontStyle: undefined,\r\n            fontWeight: undefined,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_LABEL_COLOUR,\r\n        },\r\n    },\r\n    paletteFactory: markerPaletteFactory,\r\n};\n\nconst HISTOGRAM_AGGREGATIONS = ['count', 'sum', 'mean'];\r\nconst HISTOGRAM_AGGREGATION = predicateWithMessage((v) => HISTOGRAM_AGGREGATIONS.includes(v), `expecting a histogram aggregation keyword such as 'count', 'sum' or 'mean`);\r\nvar HistogramSeriesNodeTag;\r\n(function (HistogramSeriesNodeTag) {\r\n    HistogramSeriesNodeTag[HistogramSeriesNodeTag[\"Bin\"] = 0] = \"Bin\";\r\n    HistogramSeriesNodeTag[HistogramSeriesNodeTag[\"Label\"] = 1] = \"Label\";\r\n})(HistogramSeriesNodeTag || (HistogramSeriesNodeTag = {}));\r\nconst defaultBinCount = 10;\r\nclass HistogramSeries extends CartesianSeries {\r\n    constructor(moduleCtx) {\r\n        super({\r\n            moduleCtx,\r\n            pickModes: [SeriesNodePickMode.EXACT_SHAPE_MATCH],\r\n            datumSelectionGarbageCollection: false,\r\n            animationResetFns: {\r\n                datum: resetBarSelectionsFn,\r\n                label: resetLabelFn,\r\n            },\r\n        });\r\n        this.label = new Label();\r\n        this.tooltip = new SeriesTooltip();\r\n        this.fill = undefined;\r\n        this.stroke = undefined;\r\n        this.fillOpacity = 1;\r\n        this.strokeOpacity = 1;\r\n        this.lineDash = [0];\r\n        this.lineDashOffset = 0;\r\n        this.xKey = undefined;\r\n        this.areaPlot = false;\r\n        this.aggregation = 'sum';\r\n        this.binCount = undefined;\r\n        this.xName = undefined;\r\n        this.yKey = undefined;\r\n        this.yName = undefined;\r\n        this.strokeWidth = 1;\r\n        this.shadow = undefined;\r\n        this.calculatedBins = [];\r\n    }\r\n    // During processData phase, used to unify different ways of the user specifying\r\n    // the bins. Returns bins in format[[min1, max1], [min2, max2], ... ].\r\n    deriveBins(xDomain) {\r\n        if (this.binCount === undefined) {\r\n            const binStarts = ticks(xDomain[0], xDomain[1], defaultBinCount);\r\n            const binSize = tickStep(xDomain[0], xDomain[1], defaultBinCount);\r\n            const firstBinEnd = binStarts[0];\r\n            const expandStartToBin = (n) => [n, n + binSize];\r\n            return [[firstBinEnd - binSize, firstBinEnd], ...binStarts.map(expandStartToBin)];\r\n        }\r\n        else {\r\n            return this.calculateNiceBins(xDomain, this.binCount);\r\n        }\r\n    }\r\n    calculateNiceBins(domain, binCount) {\r\n        const startGuess = Math.floor(domain[0]);\r\n        const stop = domain[1];\r\n        const segments = binCount || 1;\r\n        const { start, binSize } = this.calculateNiceStart(startGuess, stop, segments);\r\n        return this.getBins(start, stop, binSize, segments);\r\n    }\r\n    getBins(start, stop, step, count) {\r\n        const bins = [];\r\n        for (let i = 0; i < count; i++) {\r\n            const a = Math.round((start + i * step) * 10) / 10;\r\n            let b = Math.round((start + (i + 1) * step) * 10) / 10;\r\n            if (i === count - 1) {\r\n                b = Math.max(b, stop);\r\n            }\r\n            bins[i] = [a, b];\r\n        }\r\n        return bins;\r\n    }\r\n    calculateNiceStart(a, b, segments) {\r\n        const binSize = Math.abs(b - a) / segments;\r\n        const order = Math.floor(Math.log10(binSize));\r\n        const magnitude = Math.pow(10, order);\r\n        const start = Math.floor(a / magnitude) * magnitude;\r\n        return {\r\n            start,\r\n            binSize,\r\n        };\r\n    }\r\n    processData(dataController) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { xKey, yKey, data, areaPlot, aggregation } = this;\r\n            const props = [keyProperty(this, xKey, true), SORT_DOMAIN_GROUPS];\r\n            if (yKey) {\r\n                let aggProp = groupCount(this, 'groupCount');\r\n                if (aggregation === 'count') ;\r\n                else if (aggregation === 'sum') {\r\n                    aggProp = groupSum(this, 'groupAgg');\r\n                }\r\n                else if (aggregation === 'mean') {\r\n                    aggProp = groupAverage(this, 'groupAgg');\r\n                }\r\n                if (areaPlot) {\r\n                    aggProp = area(this, 'groupAgg', aggProp);\r\n                }\r\n                props.push(valueProperty(this, yKey, true, { invalidValue: undefined }), aggProp);\r\n            }\r\n            else {\r\n                let aggProp = groupCount(this, 'groupAgg');\r\n                if (areaPlot) {\r\n                    aggProp = area(this, 'groupAgg', aggProp);\r\n                }\r\n                props.push(aggProp);\r\n            }\r\n            const groupByFn = (dataSet) => {\r\n                var _a;\r\n                const xExtent = fixNumericExtent(dataSet.domain.keys[0]);\r\n                if (xExtent.length === 0) {\r\n                    // No buckets can be calculated.\r\n                    dataSet.domain.groups = [];\r\n                    return () => [];\r\n                }\r\n                const bins = (_a = this.bins) !== null && _a !== void 0 ? _a : this.deriveBins(xExtent);\r\n                const binCount = bins.length;\r\n                this.calculatedBins = [...bins];\r\n                return (item) => {\r\n                    const xValue = item.keys[0];\r\n                    for (let i = 0; i < binCount; i++) {\r\n                        const nextBin = bins[i];\r\n                        if (xValue >= nextBin[0] && xValue < nextBin[1]) {\r\n                            return nextBin;\r\n                        }\r\n                        if (i === binCount - 1 && xValue <= nextBin[1]) {\r\n                            // Handle edge case of a value being at the maximum extent, and the\r\n                            // final bin aligning with it.\r\n                            return nextBin;\r\n                        }\r\n                    }\r\n                    return [];\r\n                };\r\n            };\r\n            if (!this.ctx.animationManager.isSkipped() && this.processedData) {\r\n                props.push(diff(this.processedData, false));\r\n            }\r\n            yield this.requestDataModel(dataController, data !== null && data !== void 0 ? data : [], {\r\n                props,\r\n                dataVisible: this.visible,\r\n                groupByFn,\r\n            });\r\n            this.animationState.transition('updateData');\r\n        });\r\n    }\r\n    getSeriesDomain(direction) {\r\n        var _a, _b, _c, _d;\r\n        const { processedData, dataModel } = this;\r\n        if (!processedData || !dataModel || !this.calculatedBins.length)\r\n            return [];\r\n        const yDomain = dataModel.getDomain(this, `groupAgg`, 'aggregate', processedData);\r\n        const xDomainMin = (_a = this.calculatedBins) === null || _a === void 0 ? void 0 : _a[0][0];\r\n        const xDomainMax = (_b = this.calculatedBins) === null || _b === void 0 ? void 0 : _b[((_d = (_c = this.calculatedBins) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0) - 1][1];\r\n        if (direction === ChartAxisDirection.X) {\r\n            return fixNumericExtent([xDomainMin, xDomainMax]);\r\n        }\r\n        return fixNumericExtent(yDomain);\r\n    }\r\n    createNodeData() {\r\n        const _super = Object.create(null, {\r\n            calculateScaling: { get: () => super.calculateScaling }\r\n        });\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { axes, processedData, ctx: { callbackCache }, } = this;\r\n            const xAxis = axes[ChartAxisDirection.X];\r\n            const yAxis = axes[ChartAxisDirection.Y];\r\n            if (!this.visible || !xAxis || !yAxis || !processedData || processedData.type !== 'grouped') {\r\n                return [];\r\n            }\r\n            const { scale: xScale } = xAxis;\r\n            const { scale: yScale } = yAxis;\r\n            const { fill, stroke, strokeWidth, id: seriesId, yKey = '', xKey = '' } = this;\r\n            const nodeData = [];\r\n            const { label: { formatter: labelFormatter = (params) => String(params.value), fontStyle: labelFontStyle, fontWeight: labelFontWeight, fontSize: labelFontSize, fontFamily: labelFontFamily, color: labelColor, }, } = this;\r\n            processedData.data.forEach((group) => {\r\n                var _a;\r\n                const { aggValues: [[negativeAgg, positiveAgg]] = [[0, 0]], datum, datum: { length: frequency }, keys: domain, keys: [xDomainMin, xDomainMax], } = group;\r\n                const xMinPx = xScale.convert(xDomainMin);\r\n                const xMaxPx = xScale.convert(xDomainMax);\r\n                const total = negativeAgg + positiveAgg;\r\n                const yZeroPx = yScale.convert(0);\r\n                const yMaxPx = yScale.convert(total);\r\n                const w = xMaxPx - xMinPx;\r\n                const h = Math.abs(yMaxPx - yZeroPx);\r\n                const selectionDatumLabel = total !== 0\r\n                    ? {\r\n                        text: (_a = callbackCache.call(labelFormatter, {\r\n                            value: total,\r\n                            datum,\r\n                            seriesId,\r\n                            xKey,\r\n                            yKey,\r\n                            xName: this.xName,\r\n                            yName: this.yName,\r\n                        })) !== null && _a !== void 0 ? _a : String(total),\r\n                        fontStyle: labelFontStyle,\r\n                        fontWeight: labelFontWeight,\r\n                        fontSize: labelFontSize,\r\n                        fontFamily: labelFontFamily,\r\n                        fill: labelColor,\r\n                        x: xMinPx + w / 2,\r\n                        y: yMaxPx + h / 2,\r\n                    }\r\n                    : undefined;\r\n                const nodeMidPoint = {\r\n                    x: xMinPx + w / 2,\r\n                    y: yMaxPx + h / 2,\r\n                };\r\n                nodeData.push({\r\n                    series: this,\r\n                    datum,\r\n                    // since each selection is an aggregation of multiple data.\r\n                    aggregatedValue: total,\r\n                    frequency,\r\n                    domain: domain,\r\n                    yKey,\r\n                    xKey,\r\n                    x: xMinPx,\r\n                    y: yMaxPx,\r\n                    xValue: xMinPx,\r\n                    yValue: yMaxPx,\r\n                    width: w,\r\n                    height: h,\r\n                    midPoint: nodeMidPoint,\r\n                    fill: fill,\r\n                    stroke: stroke,\r\n                    strokeWidth: strokeWidth,\r\n                    label: selectionDatumLabel,\r\n                });\r\n            });\r\n            return [\r\n                {\r\n                    itemId: (_a = this.yKey) !== null && _a !== void 0 ? _a : this.id,\r\n                    nodeData,\r\n                    labelData: nodeData,\r\n                    scales: _super.calculateScaling.call(this),\r\n                    animationValid: true,\r\n                    visible: this.visible,\r\n                },\r\n            ];\r\n        });\r\n    }\r\n    nodeFactory() {\r\n        return new Rect();\r\n    }\r\n    updateDatumSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { nodeData, datumSelection } = opts;\r\n            return datumSelection.update(nodeData, (rect) => {\r\n                rect.tag = HistogramSeriesNodeTag.Bin;\r\n                rect.crisp = true;\r\n            }, (datum) => datum.domain.join('_'));\r\n        });\r\n    }\r\n    updateDatumNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { datumSelection, isHighlight: isDatumHighlighted } = opts;\r\n            const { fillOpacity: seriesFillOpacity, strokeOpacity, shadow, highlightStyle: { item: { fill: highlightedFill, fillOpacity: highlightFillOpacity = seriesFillOpacity, stroke: highlightedStroke, strokeWidth: highlightedDatumStrokeWidth, }, }, } = this;\r\n            datumSelection.each((rect, datum, index) => {\r\n                var _a, _b;\r\n                const strokeWidth = isDatumHighlighted && highlightedDatumStrokeWidth !== undefined\r\n                    ? highlightedDatumStrokeWidth\r\n                    : datum.strokeWidth;\r\n                const fillOpacity = isDatumHighlighted ? highlightFillOpacity : seriesFillOpacity;\r\n                rect.fill = (_a = (isDatumHighlighted ? highlightedFill : undefined)) !== null && _a !== void 0 ? _a : datum.fill;\r\n                rect.stroke = (_b = (isDatumHighlighted ? highlightedStroke : undefined)) !== null && _b !== void 0 ? _b : datum.stroke;\r\n                rect.fillOpacity = fillOpacity;\r\n                rect.strokeOpacity = strokeOpacity;\r\n                rect.strokeWidth = strokeWidth;\r\n                rect.lineDash = this.lineDash;\r\n                rect.lineDashOffset = this.lineDashOffset;\r\n                rect.fillShadow = shadow;\r\n                rect.zIndex = isDatumHighlighted ? Series.highlightedZIndex : index;\r\n                rect.visible = datum.height > 0; // prevent stroke from rendering for zero height columns\r\n            });\r\n        });\r\n    }\r\n    updateLabelSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelData, labelSelection } = opts;\r\n            return labelSelection.update(labelData, (text) => {\r\n                text.tag = HistogramSeriesNodeTag.Label;\r\n                text.pointerEvents = PointerEvents.None;\r\n                text.textAlign = 'center';\r\n                text.textBaseline = 'middle';\r\n            });\r\n        });\r\n    }\r\n    updateLabelNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelSelection } = opts;\r\n            const labelEnabled = this.label.enabled;\r\n            labelSelection.each((text, datum) => {\r\n                const label = datum.label;\r\n                if (label && labelEnabled) {\r\n                    text.text = label.text;\r\n                    text.x = label.x;\r\n                    text.y = label.y;\r\n                    text.fontStyle = label.fontStyle;\r\n                    text.fontWeight = label.fontWeight;\r\n                    text.fontSize = label.fontSize;\r\n                    text.fontFamily = label.fontFamily;\r\n                    text.fill = label.fill;\r\n                    text.visible = true;\r\n                }\r\n                else {\r\n                    text.visible = false;\r\n                }\r\n            });\r\n        });\r\n    }\r\n    getTooltipHtml(nodeDatum) {\r\n        const { xKey, yKey = '', axes } = this;\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        if (!xKey || !xAxis || !yAxis) {\r\n            return '';\r\n        }\r\n        const { xName, yName, fill: color, tooltip, aggregation, id: seriesId } = this;\r\n        const { aggregatedValue, frequency, domain: [rangeMin, rangeMax], } = nodeDatum;\r\n        const title = `${sanitizeHtml(xName !== null && xName !== void 0 ? xName : xKey)}: ${xAxis.formatDatum(rangeMin)} - ${xAxis.formatDatum(rangeMax)}`;\r\n        let content = yKey\r\n            ? `<b>${sanitizeHtml(yName !== null && yName !== void 0 ? yName : yKey)} (${aggregation})</b>: ${yAxis.formatDatum(aggregatedValue)}<br>`\r\n            : '';\r\n        content += `<b>Frequency</b>: ${frequency}`;\r\n        const defaults = {\r\n            title,\r\n            backgroundColor: color,\r\n            content,\r\n        };\r\n        return tooltip.toTooltipHtml(defaults, {\r\n            datum: {\r\n                data: nodeDatum.datum,\r\n                aggregatedValue: nodeDatum.aggregatedValue,\r\n                domain: nodeDatum.domain,\r\n                frequency: nodeDatum.frequency,\r\n            },\r\n            xKey,\r\n            xName,\r\n            yKey,\r\n            yName,\r\n            color,\r\n            title,\r\n            seriesId,\r\n        });\r\n    }\r\n    getLegendData(legendType) {\r\n        var _a;\r\n        const { id, data, xKey, yName, visible, fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = this;\r\n        if (!data || data.length === 0 || legendType !== 'category') {\r\n            return [];\r\n        }\r\n        return [\r\n            {\r\n                legendType: 'category',\r\n                id,\r\n                itemId: xKey,\r\n                seriesId: id,\r\n                enabled: visible,\r\n                label: {\r\n                    text: (_a = yName !== null && yName !== void 0 ? yName : xKey) !== null && _a !== void 0 ? _a : 'Frequency',\r\n                },\r\n                marker: {\r\n                    fill: fill !== null && fill !== void 0 ? fill : 'rgba(0, 0, 0, 0)',\r\n                    stroke: stroke !== null && stroke !== void 0 ? stroke : 'rgba(0, 0, 0, 0)',\r\n                    fillOpacity: fillOpacity,\r\n                    strokeOpacity: strokeOpacity,\r\n                    strokeWidth,\r\n                },\r\n            },\r\n        ];\r\n    }\r\n    animateEmptyUpdateReady({ datumSelections, labelSelections }) {\r\n        const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes));\r\n        fromToMotion(this.id, 'datums', this.ctx.animationManager, datumSelections, fns);\r\n        seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, labelSelections);\r\n    }\r\n    animateWaitingUpdateReady(data) {\r\n        var _a, _b;\r\n        const diff = (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.diff;\r\n        const fns = prepareBarAnimationFunctions(collapsedStartingBarPosition(true, this.axes));\r\n        fromToMotion(this.id, 'datums', this.ctx.animationManager, data.datumSelections, fns, (_, datum) => this.getDatumId(datum), diff);\r\n        seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, data.labelSelections);\r\n    }\r\n    getDatumId(datum) {\r\n        return createDatumId(datum.domain.map((d) => `${d}`));\r\n    }\r\n    isLabelEnabled() {\r\n        return this.label.enabled;\r\n    }\r\n}\r\nHistogramSeries.className = 'HistogramSeries';\r\nHistogramSeries.type = 'histogram';\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HistogramSeries.prototype, \"fill\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HistogramSeries.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], HistogramSeries.prototype, \"fillOpacity\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Object)\r\n], HistogramSeries.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_LINE_DASH),\r\n    __metadata(\"design:type\", Array)\r\n], HistogramSeries.prototype, \"lineDash\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], HistogramSeries.prototype, \"lineDashOffset\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HistogramSeries.prototype, \"xKey\", void 0);\r\n__decorate([\r\n    Validate(BOOLEAN),\r\n    __metadata(\"design:type\", Boolean)\r\n], HistogramSeries.prototype, \"areaPlot\", void 0);\r\n__decorate([\r\n    Validate(OPT_ARRAY()),\r\n    __metadata(\"design:type\", Array)\r\n], HistogramSeries.prototype, \"bins\", void 0);\r\n__decorate([\r\n    Validate(HISTOGRAM_AGGREGATION),\r\n    __metadata(\"design:type\", String)\r\n], HistogramSeries.prototype, \"aggregation\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER(0)),\r\n    __metadata(\"design:type\", Number)\r\n], HistogramSeries.prototype, \"binCount\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HistogramSeries.prototype, \"xName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HistogramSeries.prototype, \"yKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HistogramSeries.prototype, \"yName\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], HistogramSeries.prototype, \"strokeWidth\", void 0);\n\nconst HistogramSeriesModule = {\r\n    type: 'series',\r\n    optionsKey: 'series[]',\r\n    packageType: 'community',\r\n    chartTypes: ['cartesian'],\r\n    identifier: 'histogram',\r\n    instanceConstructor: HistogramSeries,\r\n    seriesDefaults: {\r\n        axes: [\r\n            { type: CARTESIAN_AXIS_TYPES.NUMBER, position: CARTESIAN_AXIS_POSITIONS.BOTTOM },\r\n            { type: CARTESIAN_AXIS_TYPES.NUMBER, position: CARTESIAN_AXIS_POSITIONS.LEFT },\r\n        ],\r\n    },\r\n    themeTemplate: {\r\n        __extends__: EXTENDS_SERIES_DEFAULTS,\r\n        strokeWidth: 1,\r\n        fillOpacity: 1,\r\n        strokeOpacity: 1,\r\n        lineDash: [0],\r\n        lineDashOffset: 0,\r\n        label: {\r\n            enabled: false,\r\n            fontStyle: undefined,\r\n            fontWeight: undefined,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\r\n            formatter: undefined,\r\n        },\r\n        shadow: {\r\n            enabled: false,\r\n            color: DEFAULT_SHADOW_COLOUR,\r\n            xOffset: 3,\r\n            yOffset: 3,\r\n            blur: 5,\r\n        },\r\n    },\r\n    paletteFactory: ({ takeColors }) => {\r\n        const { fills: [fill], strokes: [stroke], } = takeColors(1);\r\n        return { fill, stroke };\r\n    },\r\n};\n\nclass LineSeries extends CartesianSeries {\r\n    constructor(moduleCtx) {\r\n        super({\r\n            moduleCtx,\r\n            hasMarkers: true,\r\n            pickModes: [\r\n                SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST,\r\n                SeriesNodePickMode.NEAREST_NODE,\r\n                SeriesNodePickMode.EXACT_SHAPE_MATCH,\r\n            ],\r\n            markerSelectionGarbageCollection: false,\r\n            animationResetFns: {\r\n                path: buildResetPathFn({ getOpacity: () => this.getOpacity() }),\r\n                label: resetLabelFn,\r\n                marker: (node, datum) => (Object.assign(Object.assign({}, resetMarkerFn()), resetMarkerPositionFn(node, datum))),\r\n            },\r\n        });\r\n        this.label = new Label();\r\n        this.marker = new SeriesMarker();\r\n        this.tooltip = new SeriesTooltip();\r\n        this.title = undefined;\r\n        this.stroke = '#874349';\r\n        this.lineDash = [0];\r\n        this.lineDashOffset = 0;\r\n        this.strokeWidth = 2;\r\n        this.strokeOpacity = 1;\r\n        this.xKey = undefined;\r\n        this.xName = undefined;\r\n        this.yKey = undefined;\r\n        this.yName = undefined;\r\n    }\r\n    processData(dataController) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { xKey, yKey, data } = this;\r\n            if (xKey == null || yKey == null || data == null)\r\n                return;\r\n            const animationEnabled = !this.ctx.animationManager.isSkipped();\r\n            const { isContinuousX, isContinuousY } = this.isContinuous();\r\n            const props = [];\r\n            // If two or more datums share an x-value, i.e. lined up vertically, they will have the same datum id.\r\n            // They must be identified this way when animated to ensure they can be tracked when their y-value\r\n            // is updated. If this is a static chart, we can instead not bother with identifying datums and\r\n            // automatically garbage collect the marker selection.\r\n            if (!isContinuousX) {\r\n                props.push(keyProperty(this, xKey, isContinuousX, { id: 'xKey' }));\r\n                if (animationEnabled && this.processedData) {\r\n                    props.push(diff(this.processedData));\r\n                }\r\n            }\r\n            if (animationEnabled) {\r\n                props.push(animationValidation(this, isContinuousX ? ['xValue'] : []));\r\n            }\r\n            props.push(valueProperty(this, xKey, isContinuousX, { id: 'xValue' }), valueProperty(this, yKey, isContinuousY, { id: 'yValue', invalidValue: undefined }));\r\n            yield this.requestDataModel(dataController, data, { props });\r\n            this.animationState.transition('updateData');\r\n        });\r\n    }\r\n    getSeriesDomain(direction) {\r\n        const { axes, dataModel, processedData } = this;\r\n        if (!processedData || !dataModel)\r\n            return [];\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        const xDef = dataModel.resolveProcessedDataDefById(this, `xValue`);\r\n        if (direction === ChartAxisDirection.X) {\r\n            const domain = dataModel.getDomain(this, `xValue`, 'value', processedData);\r\n            if ((xDef === null || xDef === void 0 ? void 0 : xDef.def.type) === 'value' && xDef.def.valueType === 'category') {\r\n                return domain;\r\n            }\r\n            return fixNumericExtent(extent(domain), xAxis);\r\n        }\r\n        else {\r\n            const domain = dataModel.getDomain(this, `yValue`, 'value', processedData);\r\n            return fixNumericExtent(domain, yAxis);\r\n        }\r\n    }\r\n    createNodeData() {\r\n        const _super = Object.create(null, {\r\n            calculateScaling: { get: () => super.calculateScaling }\r\n        });\r\n        var _a, _b, _c;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { processedData, dataModel, axes } = this;\r\n            const xAxis = axes[ChartAxisDirection.X];\r\n            const yAxis = axes[ChartAxisDirection.Y];\r\n            if (!processedData || !dataModel || !xAxis || !yAxis) {\r\n                return [];\r\n            }\r\n            const { label, yKey = '', xKey = '' } = this;\r\n            const xScale = xAxis.scale;\r\n            const yScale = yAxis.scale;\r\n            const xOffset = ((_a = xScale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;\r\n            const yOffset = ((_b = yScale.bandwidth) !== null && _b !== void 0 ? _b : 0) / 2;\r\n            const nodeData = [];\r\n            const size = this.marker.enabled ? this.marker.size : 0;\r\n            const xIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;\r\n            const yIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`).index;\r\n            let moveTo = true;\r\n            let nextPoint;\r\n            for (let i = 0; i < processedData.data.length; i++) {\r\n                const { datum, values } = nextPoint !== null && nextPoint !== void 0 ? nextPoint : processedData.data[i];\r\n                const xDatum = values[xIdx];\r\n                const yDatum = values[yIdx];\r\n                if (yDatum === undefined) {\r\n                    moveTo = true;\r\n                }\r\n                else {\r\n                    const x = xScale.convert(xDatum) + xOffset;\r\n                    if (isNaN(x)) {\r\n                        moveTo = true;\r\n                        nextPoint = undefined;\r\n                        continue;\r\n                    }\r\n                    nextPoint =\r\n                        ((_c = processedData.data[i + 1]) === null || _c === void 0 ? void 0 : _c.values[yIdx]) === undefined ? undefined : processedData.data[i + 1];\r\n                    const y = yScale.convert(yDatum) + yOffset;\r\n                    const labelText = this.getLabelText(label, {\r\n                        value: yDatum,\r\n                        datum,\r\n                        xKey,\r\n                        yKey,\r\n                        xName: this.xName,\r\n                        yName: this.yName,\r\n                    }, (value) => (isNumber(value) ? value.toFixed(2) : String(value)));\r\n                    nodeData.push({\r\n                        series: this,\r\n                        datum,\r\n                        yKey,\r\n                        xKey,\r\n                        point: { x, y, moveTo, size },\r\n                        midPoint: { x, y },\r\n                        yValue: yDatum,\r\n                        xValue: xDatum,\r\n                        capDefaults: { lengthRatioMultiplier: this.marker.getDiameter(), lengthMax: Infinity },\r\n                        label: labelText\r\n                            ? {\r\n                                text: labelText,\r\n                                fontStyle: label.fontStyle,\r\n                                fontWeight: label.fontWeight,\r\n                                fontSize: label.fontSize,\r\n                                fontFamily: label.fontFamily,\r\n                                textAlign: 'center',\r\n                                textBaseline: 'bottom',\r\n                                fill: label.color,\r\n                            }\r\n                            : undefined,\r\n                    });\r\n                    moveTo = false;\r\n                }\r\n            }\r\n            return [\r\n                {\r\n                    itemId: yKey,\r\n                    nodeData,\r\n                    labelData: nodeData,\r\n                    scales: _super.calculateScaling.call(this),\r\n                    visible: this.visible,\r\n                },\r\n            ];\r\n        });\r\n    }\r\n    isPathOrSelectionDirty() {\r\n        return this.marker.isDirty();\r\n    }\r\n    markerFactory() {\r\n        const { shape } = this.marker;\r\n        const MarkerShape = getMarker(shape);\r\n        return new MarkerShape();\r\n    }\r\n    updatePathNodes(opts) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { paths: [lineNode], opacity, visible, animationEnabled, } = opts;\r\n            const { seriesRectHeight: height, seriesRectWidth: width } = this.nodeDataDependencies;\r\n            lineNode.setProperties({\r\n                fill: undefined,\r\n                lineJoin: 'round',\r\n                pointerEvents: PointerEvents.None,\r\n                opacity,\r\n                stroke: this.stroke,\r\n                strokeWidth: this.getStrokeWidth(this.strokeWidth),\r\n                strokeOpacity: this.strokeOpacity,\r\n                lineDash: this.lineDash,\r\n                lineDashOffset: this.lineDashOffset,\r\n            });\r\n            if (!animationEnabled) {\r\n                lineNode.visible = visible;\r\n            }\r\n            if (lineNode.clipPath == null) {\r\n                lineNode.clipPath = new Path2D();\r\n                lineNode.clipScalingX = 1;\r\n                lineNode.clipScalingY = 1;\r\n            }\r\n            (_a = lineNode.clipPath) === null || _a === void 0 ? void 0 : _a.clear({ trackChanges: true });\r\n            (_b = lineNode.clipPath) === null || _b === void 0 ? void 0 : _b.rect(-25, -25, (width !== null && width !== void 0 ? width : 0) + 50, (height !== null && height !== void 0 ? height : 0) + 50);\r\n        });\r\n    }\r\n    updateMarkerSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let { nodeData } = opts;\r\n            const { markerSelection } = opts;\r\n            const { shape, enabled } = this.marker;\r\n            nodeData = shape && enabled ? nodeData : [];\r\n            if (this.marker.isDirty()) {\r\n                markerSelection.clear();\r\n                markerSelection.cleanup();\r\n            }\r\n            return markerSelection.update(nodeData, undefined, (datum) => this.getDatumId(datum));\r\n        });\r\n    }\r\n    updateMarkerNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { markerSelection, isHighlight: highlighted } = opts;\r\n            const { xKey = '', yKey = '', marker, stroke, strokeWidth, strokeOpacity } = this;\r\n            const baseStyle = mergeDefaults(highlighted && this.highlightStyle.item, marker.getStyle(), {\r\n                stroke,\r\n                strokeWidth,\r\n                strokeOpacity,\r\n            });\r\n            const applyTranslation = this.ctx.animationManager.isSkipped();\r\n            markerSelection.each((node, datum) => {\r\n                this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey }, baseStyle, { applyTranslation });\r\n            });\r\n            if (!highlighted) {\r\n                this.marker.markClean();\r\n            }\r\n        });\r\n    }\r\n    updateLabelSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            let { labelData } = opts;\r\n            const { labelSelection } = opts;\r\n            const { shape, enabled } = this.marker;\r\n            labelData = shape && enabled ? labelData : [];\r\n            return labelSelection.update(labelData);\r\n        });\r\n    }\r\n    updateLabelNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelSelection } = opts;\r\n            const { enabled: labelEnabled, fontStyle, fontWeight, fontSize, fontFamily, color } = this.label;\r\n            labelSelection.each((text, datum) => {\r\n                const { point, label } = datum;\r\n                if (datum && label && labelEnabled) {\r\n                    text.fontStyle = fontStyle;\r\n                    text.fontWeight = fontWeight;\r\n                    text.fontSize = fontSize;\r\n                    text.fontFamily = fontFamily;\r\n                    text.textAlign = label.textAlign;\r\n                    text.textBaseline = label.textBaseline;\r\n                    text.text = label.text;\r\n                    text.x = point.x;\r\n                    text.y = point.y - 10;\r\n                    text.fill = color;\r\n                    text.visible = true;\r\n                }\r\n                else {\r\n                    text.visible = false;\r\n                }\r\n            });\r\n        });\r\n    }\r\n    getTooltipHtml(nodeDatum) {\r\n        var _a;\r\n        const { xKey, yKey, axes } = this;\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        if (!xKey || !yKey || !xAxis || !yAxis) {\r\n            return '';\r\n        }\r\n        const { xName, yName, tooltip, marker, id: seriesId } = this;\r\n        const { datum, xValue, yValue } = nodeDatum;\r\n        const xString = xAxis.formatDatum(xValue);\r\n        const yString = yAxis.formatDatum(yValue);\r\n        const title = sanitizeHtml((_a = this.title) !== null && _a !== void 0 ? _a : yName);\r\n        const content = sanitizeHtml(xString + ': ' + yString);\r\n        const baseStyle = mergeDefaults({ fill: marker.stroke }, marker.getStyle(), { strokeWidth: this.strokeWidth });\r\n        const { fill: color } = this.getMarkerStyle(marker, { datum: nodeDatum, xKey, yKey, highlighted: false }, baseStyle);\r\n        return tooltip.toTooltipHtml({ title, content, backgroundColor: color }, Object.assign({ datum,\r\n            xKey,\r\n            xName,\r\n            yKey,\r\n            yName,\r\n            title,\r\n            color,\r\n            seriesId }, this.getModuleTooltipParams(datum)));\r\n    }\r\n    getLegendData(legendType) {\r\n        var _a, _b, _c, _d, _e, _f, _g, _h;\r\n        const { id, data, xKey, yKey, yName, visible, title, marker, stroke, strokeOpacity } = this;\r\n        if (!((data === null || data === void 0 ? void 0 : data.length) && xKey && yKey && legendType === 'category')) {\r\n            return [];\r\n        }\r\n        return [\r\n            {\r\n                legendType: 'category',\r\n                id: id,\r\n                itemId: yKey,\r\n                seriesId: id,\r\n                enabled: visible,\r\n                label: {\r\n                    text: (_a = title !== null && title !== void 0 ? title : yName) !== null && _a !== void 0 ? _a : yKey,\r\n                },\r\n                marker: {\r\n                    shape: marker.shape,\r\n                    fill: (_b = marker.fill) !== null && _b !== void 0 ? _b : 'rgba(0, 0, 0, 0)',\r\n                    stroke: (_d = (_c = marker.stroke) !== null && _c !== void 0 ? _c : stroke) !== null && _d !== void 0 ? _d : 'rgba(0, 0, 0, 0)',\r\n                    fillOpacity: (_e = marker.fillOpacity) !== null && _e !== void 0 ? _e : 1,\r\n                    strokeOpacity: (_g = (_f = marker.strokeOpacity) !== null && _f !== void 0 ? _f : strokeOpacity) !== null && _g !== void 0 ? _g : 1,\r\n                    strokeWidth: (_h = marker.strokeWidth) !== null && _h !== void 0 ? _h : 0,\r\n                },\r\n            },\r\n        ];\r\n    }\r\n    updatePaths(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            this.updateLinePaths([opts.paths], [opts.contextData]);\r\n        });\r\n    }\r\n    updateLinePaths(paths, contextData) {\r\n        contextData.forEach(({ nodeData }, contextDataIndex) => {\r\n            const [lineNode] = paths[contextDataIndex];\r\n            const { path: linePath } = lineNode;\r\n            linePath.clear({ trackChanges: true });\r\n            for (const data of nodeData) {\r\n                if (data.point.moveTo) {\r\n                    linePath.moveTo(data.point.x, data.point.y);\r\n                }\r\n                else {\r\n                    linePath.lineTo(data.point.x, data.point.y);\r\n                }\r\n            }\r\n            lineNode.checkPathDirty();\r\n        });\r\n    }\r\n    animateEmptyUpdateReady(animationData) {\r\n        const { markerSelections, labelSelections, annotationSelections, contextData, paths } = animationData;\r\n        const { animationManager } = this.ctx;\r\n        const { seriesRectWidth: width = 0 } = this.nodeDataDependencies;\r\n        this.updateLinePaths(paths, contextData);\r\n        pathSwipeInAnimation(this, animationManager, paths.flat());\r\n        resetMotion(markerSelections, resetMarkerPositionFn);\r\n        markerSwipeScaleInAnimation(this, animationManager, markerSelections, width);\r\n        seriesLabelFadeInAnimation(this, 'labels', animationManager, labelSelections);\r\n        seriesLabelFadeInAnimation(this, 'annotations', animationManager, annotationSelections);\r\n    }\r\n    animateReadyResize(animationData) {\r\n        const { contextData, paths } = animationData;\r\n        this.updateLinePaths(paths, contextData);\r\n        super.animateReadyResize(animationData);\r\n    }\r\n    animateWaitingUpdateReady(animationData) {\r\n        var _a, _b;\r\n        const { animationManager } = this.ctx;\r\n        const { markerSelections, labelSelections, annotationSelections, contextData, paths, previousContextData } = animationData;\r\n        super.resetAllAnimation(animationData);\r\n        if (contextData.length === 0 || !previousContextData || previousContextData.length === 0) {\r\n            animationManager.skipCurrentBatch();\r\n            this.updateLinePaths(paths, contextData);\r\n            return;\r\n        }\r\n        const [path] = paths;\r\n        const [newData] = contextData;\r\n        const [oldData] = previousContextData;\r\n        const fns = prepareLinePathAnimation(newData, oldData, (_b = (_a = this.processedData) === null || _a === void 0 ? void 0 : _a.reduced) === null || _b === void 0 ? void 0 : _b.diff);\r\n        if (fns === undefined) {\r\n            animationManager.skipCurrentBatch();\r\n            this.updateLinePaths(paths, contextData);\r\n            return;\r\n        }\r\n        fromToMotion(this.id, 'marker', animationManager, markerSelections, fns.marker);\r\n        fromToMotion(this.id, 'path_properties', animationManager, path, fns.pathProperties);\r\n        pathMotion(this.id, 'path_update', animationManager, path, fns.path);\r\n        seriesLabelFadeInAnimation(this, 'labels', animationManager, labelSelections);\r\n        seriesLabelFadeInAnimation(this, 'annotations', animationManager, annotationSelections);\r\n    }\r\n    getDatumId(datum) {\r\n        return createDatumId([`${datum.xValue}`]);\r\n    }\r\n    isLabelEnabled() {\r\n        return this.label.enabled;\r\n    }\r\n    getBandScalePadding() {\r\n        return { inner: 1, outer: 0.1 };\r\n    }\r\n    nodeFactory() {\r\n        return new Group();\r\n    }\r\n}\r\nLineSeries.className = 'LineSeries';\r\nLineSeries.type = 'line';\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], LineSeries.prototype, \"title\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING),\r\n    __metadata(\"design:type\", String)\r\n], LineSeries.prototype, \"stroke\", void 0);\r\n__decorate([\r\n    Validate(OPT_LINE_DASH),\r\n    __metadata(\"design:type\", Array)\r\n], LineSeries.prototype, \"lineDash\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], LineSeries.prototype, \"lineDashOffset\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0)),\r\n    __metadata(\"design:type\", Number)\r\n], LineSeries.prototype, \"strokeWidth\", void 0);\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], LineSeries.prototype, \"strokeOpacity\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], LineSeries.prototype, \"xKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], LineSeries.prototype, \"xName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], LineSeries.prototype, \"yKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], LineSeries.prototype, \"yName\", void 0);\n\nconst LineSeriesModule = {\r\n    type: 'series',\r\n    optionsKey: 'series[]',\r\n    packageType: 'community',\r\n    chartTypes: ['cartesian'],\r\n    identifier: 'line',\r\n    instanceConstructor: LineSeries,\r\n    seriesDefaults: DEFAULT_CARTESIAN_CHART_OVERRIDES,\r\n    themeTemplate: {\r\n        __extends__: EXTENDS_SERIES_DEFAULTS,\r\n        tooltip: {\r\n            position: {\r\n                type: 'node',\r\n            },\r\n        },\r\n        strokeWidth: 2,\r\n        strokeOpacity: 1,\r\n        lineDash: [0],\r\n        lineDashOffset: 0,\r\n        marker: {\r\n            __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,\r\n            fillOpacity: 1,\r\n            strokeOpacity: 1,\r\n            strokeWidth: 0,\r\n        },\r\n        label: {\r\n            enabled: false,\r\n            fontStyle: undefined,\r\n            fontWeight: undefined,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_LABEL_COLOUR,\r\n            formatter: undefined,\r\n        },\r\n    },\r\n    enterpriseThemeTemplate: {\r\n        errorBar: {\r\n            cap: {\r\n                lengthRatio: 1,\r\n            },\r\n        },\r\n    },\r\n    paletteFactory: (params) => {\r\n        const { marker } = markerPaletteFactory(params);\r\n        return {\r\n            stroke: marker.fill,\r\n            marker,\r\n        };\r\n    },\r\n};\n\nclass ScatterSeries extends CartesianSeries {\r\n    constructor(moduleCtx) {\r\n        super({\r\n            moduleCtx,\r\n            pickModes: [\r\n                SeriesNodePickMode.NEAREST_BY_MAIN_CATEGORY_AXIS_FIRST,\r\n                SeriesNodePickMode.NEAREST_NODE,\r\n                SeriesNodePickMode.EXACT_SHAPE_MATCH,\r\n            ],\r\n            pathsPerSeries: 0,\r\n            hasMarkers: true,\r\n            markerSelectionGarbageCollection: false,\r\n            animationResetFns: {\r\n                marker: resetMarkerFn,\r\n                label: resetLabelFn,\r\n            },\r\n        });\r\n        this.marker = new SeriesMarker();\r\n        this.label = new Label();\r\n        this.title = undefined;\r\n        this.labelKey = undefined;\r\n        this.xName = undefined;\r\n        this.yName = undefined;\r\n        this.labelName = 'Label';\r\n        this.xKey = undefined;\r\n        this.yKey = undefined;\r\n        this.colorKey = undefined;\r\n        this.colorName = 'Color';\r\n        this.colorRange = ['#ffff00', '#00ff00', '#0000ff'];\r\n        this.colorScale = new ColorScale();\r\n        this.tooltip = new SeriesTooltip();\r\n    }\r\n    processData(dataController) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { xKey, yKey, labelKey, data } = this;\r\n            if (xKey == null || yKey == null || data == null)\r\n                return;\r\n            const { isContinuousX, isContinuousY } = this.isContinuous();\r\n            const { colorScale, colorDomain, colorRange, colorKey } = this;\r\n            const { dataModel, processedData } = yield this.requestDataModel(dataController, data, {\r\n                props: [\r\n                    keyProperty(this, xKey, isContinuousX, { id: 'xKey-raw' }),\r\n                    keyProperty(this, yKey, isContinuousY, { id: 'yKey-raw' }),\r\n                    ...(labelKey ? [keyProperty(this, labelKey, false, { id: `labelKey-raw` })] : []),\r\n                    valueProperty(this, xKey, isContinuousX, { id: `xValue` }),\r\n                    valueProperty(this, yKey, isContinuousY, { id: `yValue` }),\r\n                    ...(colorKey ? [valueProperty(this, colorKey, true, { id: `colorValue` })] : []),\r\n                    ...(labelKey ? [valueProperty(this, labelKey, false, { id: `labelValue` })] : []),\r\n                ],\r\n                dataVisible: this.visible,\r\n            });\r\n            if (colorKey) {\r\n                const colorKeyIdx = dataModel.resolveProcessedDataIndexById(this, `colorValue`).index;\r\n                colorScale.domain = (_a = colorDomain !== null && colorDomain !== void 0 ? colorDomain : processedData.domain.values[colorKeyIdx]) !== null && _a !== void 0 ? _a : [];\r\n                colorScale.range = colorRange;\r\n                colorScale.update();\r\n            }\r\n            this.animationState.transition('updateData');\r\n        });\r\n    }\r\n    getSeriesDomain(direction) {\r\n        const { dataModel, processedData } = this;\r\n        if (!processedData || !dataModel)\r\n            return [];\r\n        const id = direction === ChartAxisDirection.X ? `xValue` : `yValue`;\r\n        const dataDef = dataModel.resolveProcessedDataDefById(this, id);\r\n        const domain = dataModel.getDomain(this, id, 'value', processedData);\r\n        if ((dataDef === null || dataDef === void 0 ? void 0 : dataDef.def.type) === 'value' && (dataDef === null || dataDef === void 0 ? void 0 : dataDef.def.valueType) === 'category') {\r\n            return domain;\r\n        }\r\n        const axis = this.axes[direction];\r\n        return fixNumericExtent(extent(domain), axis);\r\n    }\r\n    createNodeData() {\r\n        const _super = Object.create(null, {\r\n            calculateScaling: { get: () => super.calculateScaling }\r\n        });\r\n        var _a, _b, _c, _d;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { visible, axes, yKey = '', xKey = '', label, labelKey, dataModel, processedData } = this;\r\n            const xAxis = axes[ChartAxisDirection.X];\r\n            const yAxis = axes[ChartAxisDirection.Y];\r\n            if (!(dataModel && processedData && visible && xAxis && yAxis))\r\n                return [];\r\n            const xDataIdx = dataModel.resolveProcessedDataIndexById(this, `xValue`).index;\r\n            const yDataIdx = dataModel.resolveProcessedDataIndexById(this, `yValue`).index;\r\n            const colorDataIdx = this.colorKey ? dataModel.resolveProcessedDataIndexById(this, `colorValue`).index : -1;\r\n            const labelDataIdx = this.labelKey ? dataModel.resolveProcessedDataIndexById(this, `labelValue`).index : -1;\r\n            const { colorScale, colorKey } = this;\r\n            const xScale = xAxis.scale;\r\n            const yScale = yAxis.scale;\r\n            const xOffset = ((_a = xScale.bandwidth) !== null && _a !== void 0 ? _a : 0) / 2;\r\n            const yOffset = ((_b = yScale.bandwidth) !== null && _b !== void 0 ? _b : 0) / 2;\r\n            const { marker } = this;\r\n            const nodeData = [];\r\n            const font = label.getFont();\r\n            for (const { values, datum } of (_c = processedData.data) !== null && _c !== void 0 ? _c : []) {\r\n                const xDatum = values[xDataIdx];\r\n                const yDatum = values[yDataIdx];\r\n                const x = xScale.convert(xDatum) + xOffset;\r\n                const y = yScale.convert(yDatum) + yOffset;\r\n                const labelText = this.getLabelText(this.label, {\r\n                    value: labelKey ? values[labelDataIdx] : yDatum,\r\n                    datum,\r\n                    xKey,\r\n                    yKey,\r\n                    labelKey,\r\n                    xName: this.xName,\r\n                    yName: this.yName,\r\n                    labelName: this.labelName,\r\n                });\r\n                const size = HdpiCanvas.getTextSize(labelText, font);\r\n                const fill = colorKey ? colorScale.convert(values[colorDataIdx]) : undefined;\r\n                nodeData.push({\r\n                    series: this,\r\n                    itemId: yKey,\r\n                    yKey,\r\n                    xKey,\r\n                    datum,\r\n                    xValue: xDatum,\r\n                    yValue: yDatum,\r\n                    capDefaults: { lengthRatioMultiplier: this.marker.getDiameter(), lengthMax: Infinity },\r\n                    point: { x, y, size: marker.size },\r\n                    midPoint: { x, y },\r\n                    fill,\r\n                    label: Object.assign({ text: labelText }, size),\r\n                });\r\n            }\r\n            return [\r\n                {\r\n                    itemId: (_d = this.yKey) !== null && _d !== void 0 ? _d : this.id,\r\n                    nodeData,\r\n                    labelData: nodeData,\r\n                    scales: _super.calculateScaling.call(this),\r\n                    visible: this.visible,\r\n                },\r\n            ];\r\n        });\r\n    }\r\n    isPathOrSelectionDirty() {\r\n        return this.marker.isDirty();\r\n    }\r\n    getLabelData() {\r\n        var _a;\r\n        return (_a = this.contextNodeData) === null || _a === void 0 ? void 0 : _a.reduce((r, n) => r.concat(n.labelData), []);\r\n    }\r\n    markerFactory() {\r\n        const { shape } = this.marker;\r\n        const MarkerShape = getMarker(shape);\r\n        return new MarkerShape();\r\n    }\r\n    updateMarkerSelection(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { nodeData, markerSelection } = opts;\r\n            const { marker: { enabled }, } = this;\r\n            if (this.marker.isDirty()) {\r\n                markerSelection.clear();\r\n                markerSelection.cleanup();\r\n            }\r\n            const data = enabled ? nodeData : [];\r\n            return markerSelection.update(data);\r\n        });\r\n    }\r\n    updateMarkerNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { xKey = '', yKey = '', labelKey, marker } = this;\r\n            const { markerSelection, isHighlight: highlighted } = opts;\r\n            const baseStyle = mergeDefaults(highlighted && this.highlightStyle.item, marker.getStyle());\r\n            markerSelection.each((node, datum) => {\r\n                this.updateMarkerStyle(node, marker, { datum, highlighted, xKey, yKey, labelKey }, baseStyle);\r\n            });\r\n            if (!highlighted) {\r\n                this.marker.markClean();\r\n            }\r\n        });\r\n    }\r\n    updateLabelSelection(opts) {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelSelection } = opts;\r\n            const { label: { enabled }, } = this;\r\n            const placedLabels = enabled ? (_b = (_a = this.chart) === null || _a === void 0 ? void 0 : _a.placeLabels().get(this)) !== null && _b !== void 0 ? _b : [] : [];\r\n            const placedNodeDatum = placedLabels.map((v) => (Object.assign(Object.assign({}, v.datum), { point: {\r\n                    x: v.x,\r\n                    y: v.y,\r\n                    size: v.datum.point.size,\r\n                } })));\r\n            return labelSelection.update(placedNodeDatum);\r\n        });\r\n    }\r\n    updateLabelNodes(opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { labelSelection } = opts;\r\n            const { label } = this;\r\n            labelSelection.each((text, datum) => {\r\n                var _a, _b, _c, _d;\r\n                text.text = datum.label.text;\r\n                text.fill = label.color;\r\n                text.x = (_b = (_a = datum.point) === null || _a === void 0 ? void 0 : _a.x) !== null && _b !== void 0 ? _b : 0;\r\n                text.y = (_d = (_c = datum.point) === null || _c === void 0 ? void 0 : _c.y) !== null && _d !== void 0 ? _d : 0;\r\n                text.fontStyle = label.fontStyle;\r\n                text.fontWeight = label.fontWeight;\r\n                text.fontSize = label.fontSize;\r\n                text.fontFamily = label.fontFamily;\r\n                text.textAlign = 'left';\r\n                text.textBaseline = 'top';\r\n            });\r\n        });\r\n    }\r\n    getTooltipHtml(nodeDatum) {\r\n        const { xKey, yKey, axes } = this;\r\n        const xAxis = axes[ChartAxisDirection.X];\r\n        const yAxis = axes[ChartAxisDirection.Y];\r\n        if (!xKey || !yKey || !xAxis || !yAxis) {\r\n            return '';\r\n        }\r\n        const { marker, tooltip, xName, yName, labelKey, labelName, id: seriesId, title = yName } = this;\r\n        const baseStyle = mergeDefaults({ fill: nodeDatum.fill, strokeWidth: this.getStrokeWidth(marker.strokeWidth) }, marker.getStyle());\r\n        const { fill: color = 'gray' } = this.getMarkerStyle(marker, { datum: nodeDatum, highlighted: false, xKey, yKey, labelKey }, baseStyle);\r\n        const { datum, xValue, yValue, label } = nodeDatum;\r\n        const xString = sanitizeHtml(xAxis.formatDatum(xValue));\r\n        const yString = sanitizeHtml(yAxis.formatDatum(yValue));\r\n        let content = `<b>${sanitizeHtml(xName !== null && xName !== void 0 ? xName : xKey)}</b>: ${xString}<br>` +\r\n            `<b>${sanitizeHtml(yName !== null && yName !== void 0 ? yName : yKey)}</b>: ${yString}`;\r\n        if (labelKey) {\r\n            content = `<b>${sanitizeHtml(labelName !== null && labelName !== void 0 ? labelName : labelKey)}</b>: ${sanitizeHtml(label.text)}<br>` + content;\r\n        }\r\n        return tooltip.toTooltipHtml({ title, content, backgroundColor: color }, Object.assign({ datum,\r\n            xKey,\r\n            xName,\r\n            yKey,\r\n            yName,\r\n            labelKey,\r\n            labelName,\r\n            title,\r\n            color,\r\n            seriesId }, this.getModuleTooltipParams(datum)));\r\n    }\r\n    getLegendData(legendType) {\r\n        var _a, _b, _c, _d, _e;\r\n        const { id, data, xKey, yKey, yName, title, visible, marker } = this;\r\n        const { fill, stroke, fillOpacity, strokeOpacity, strokeWidth } = marker;\r\n        if (!((data === null || data === void 0 ? void 0 : data.length) && xKey && yKey && legendType === 'category')) {\r\n            return [];\r\n        }\r\n        return [\r\n            {\r\n                legendType: 'category',\r\n                id,\r\n                itemId: yKey,\r\n                seriesId: id,\r\n                enabled: visible,\r\n                label: {\r\n                    text: (_a = title !== null && title !== void 0 ? title : yName) !== null && _a !== void 0 ? _a : yKey,\r\n                },\r\n                marker: {\r\n                    shape: marker.shape,\r\n                    fill: (_c = (_b = marker.fill) !== null && _b !== void 0 ? _b : fill) !== null && _c !== void 0 ? _c : 'rgba(0, 0, 0, 0)',\r\n                    stroke: (_e = (_d = marker.stroke) !== null && _d !== void 0 ? _d : stroke) !== null && _e !== void 0 ? _e : 'rgba(0, 0, 0, 0)',\r\n                    fillOpacity: fillOpacity !== null && fillOpacity !== void 0 ? fillOpacity : 1,\r\n                    strokeOpacity: strokeOpacity !== null && strokeOpacity !== void 0 ? strokeOpacity : 1,\r\n                    strokeWidth: strokeWidth !== null && strokeWidth !== void 0 ? strokeWidth : 0,\r\n                },\r\n            },\r\n        ];\r\n    }\r\n    animateEmptyUpdateReady(data) {\r\n        const { markerSelections, labelSelections, annotationSelections } = data;\r\n        markerScaleInAnimation(this, this.ctx.animationManager, markerSelections);\r\n        seriesLabelFadeInAnimation(this, 'labels', this.ctx.animationManager, labelSelections);\r\n        seriesLabelFadeInAnimation(this, 'annotations', this.ctx.animationManager, annotationSelections);\r\n    }\r\n    isLabelEnabled() {\r\n        return this.label.enabled;\r\n    }\r\n    nodeFactory() {\r\n        return new Group();\r\n    }\r\n}\r\nScatterSeries.className = 'ScatterSeries';\r\nScatterSeries.type = 'scatter';\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"title\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"labelKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"xName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"yName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"labelName\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"xKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"yKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"colorKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], ScatterSeries.prototype, \"colorName\", void 0);\r\n__decorate([\r\n    Validate(OPT_NUMBER_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], ScatterSeries.prototype, \"colorDomain\", void 0);\r\n__decorate([\r\n    Validate(COLOR_STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], ScatterSeries.prototype, \"colorRange\", void 0);\n\nconst ScatterSeriesModule = {\r\n    type: 'series',\r\n    optionsKey: 'series[]',\r\n    packageType: 'community',\r\n    chartTypes: ['cartesian'],\r\n    identifier: 'scatter',\r\n    instanceConstructor: ScatterSeries,\r\n    seriesDefaults: {\r\n        axes: [\r\n            { type: CARTESIAN_AXIS_TYPES.NUMBER, position: CARTESIAN_AXIS_POSITIONS.BOTTOM },\r\n            { type: CARTESIAN_AXIS_TYPES.NUMBER, position: CARTESIAN_AXIS_POSITIONS.LEFT },\r\n        ],\r\n    },\r\n    themeTemplate: {\r\n        __extends__: EXTENDS_SERIES_DEFAULTS,\r\n        tooltip: {\r\n            position: {\r\n                type: 'node',\r\n            },\r\n        },\r\n        marker: {\r\n            __extends__: EXTENDS_CARTESIAN_MARKER_DEFAULTS,\r\n            fillOpacity: 0.8,\r\n        },\r\n        label: {\r\n            enabled: false,\r\n            fontStyle: undefined,\r\n            fontWeight: undefined,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_LABEL_COLOUR,\r\n        },\r\n    },\r\n    enterpriseThemeTemplate: {\r\n        errorBar: {\r\n            cap: {\r\n                lengthRatio: 1,\r\n            },\r\n        },\r\n    },\r\n    paletteFactory: markerPaletteFactory,\r\n};\n\nconst PieSeriesModule = {\r\n    type: 'series',\r\n    optionsKey: 'series[]',\r\n    packageType: 'community',\r\n    chartTypes: ['polar'],\r\n    identifier: 'pie',\r\n    instanceConstructor: PieSeries,\r\n    seriesDefaults: {},\r\n    themeTemplate: {\r\n        __extends__: EXTENDS_SERIES_DEFAULTS,\r\n        title: {\r\n            enabled: true,\r\n            fontStyle: undefined,\r\n            fontWeight: NORMAL,\r\n            fontSize: 14,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_MUTED_LABEL_COLOUR,\r\n            spacing: 5,\r\n        },\r\n        calloutLabel: {\r\n            enabled: true,\r\n            fontStyle: undefined,\r\n            fontWeight: undefined,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_LABEL_COLOUR,\r\n            offset: 3,\r\n            minAngle: 0,\r\n        },\r\n        sectorLabel: {\r\n            enabled: true,\r\n            fontStyle: undefined,\r\n            fontWeight: NORMAL,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\r\n            positionOffset: 0,\r\n            positionRatio: 0.5,\r\n        },\r\n        calloutLine: {\r\n            length: 10,\r\n            strokeWidth: 2,\r\n        },\r\n        fillOpacity: 1,\r\n        strokeOpacity: 1,\r\n        strokeWidth: 1,\r\n        lineDash: [0],\r\n        lineDashOffset: 0,\r\n        rotation: 0,\r\n        outerRadiusOffset: 0,\r\n        innerRadiusOffset: 0,\r\n        shadow: {\r\n            enabled: false,\r\n            color: DEFAULT_SHADOW_COLOUR,\r\n            xOffset: 3,\r\n            yOffset: 3,\r\n            blur: 5,\r\n        },\r\n        innerLabels: {\r\n            fontStyle: undefined,\r\n            fontWeight: undefined,\r\n            fontSize: 12,\r\n            fontFamily: DEFAULT_FONT_FAMILY,\r\n            color: DEFAULT_LABEL_COLOUR,\r\n            margin: 2,\r\n        },\r\n    },\r\n    paletteFactory: ({ takeColors, colorsCount, userPalette }) => {\r\n        const { fills, strokes } = takeColors(colorsCount);\r\n        return {\r\n            fills,\r\n            strokes: userPalette ? strokes : [DEFAULT_POLAR_SERIES_STROKE],\r\n            calloutLine: {\r\n                colors: strokes,\r\n            },\r\n        };\r\n    },\r\n};\n\nfunction registerInbuiltModules() {\r\n    registerModule(BackgroundModule);\r\n    registerModule(NavigatorModule);\r\n    registerModule(AreaSeriesModule);\r\n    registerModule(BarSeriesModule);\r\n    registerModule(BubbleSeriesModule);\r\n    registerModule(LineSeriesModule);\r\n    registerModule(ScatterSeriesModule);\r\n    registerModule(PieSeriesModule);\r\n    registerModule(HistogramSeriesModule);\r\n}\n\nfunction invertShapeDirection(...supportedShapes) {\r\n    for (const shape of supportedShapes) {\r\n        if (shape instanceof Rect) {\r\n            const { x, y, width, height } = shape;\r\n            shape.setProperties({ x: y, y: x, width: height, height: width });\r\n        }\r\n        else if (shape instanceof Line) {\r\n            const { x1, y1, x2, y2 } = shape;\r\n            shape.setProperties({ x1: y1, y1: x1, x2: y2, y2: x2 });\r\n        }\r\n    }\r\n}\n\nclass HierarchyNode {\r\n    constructor(series, index, datum, size, colorValue, fill, stroke, sumSize, depth, parent, children) {\r\n        this.series = series;\r\n        this.index = index;\r\n        this.datum = datum;\r\n        this.size = size;\r\n        this.colorValue = colorValue;\r\n        this.fill = fill;\r\n        this.stroke = stroke;\r\n        this.sumSize = sumSize;\r\n        this.depth = depth;\r\n        this.parent = parent;\r\n        this.children = children;\r\n        this.midPoint = { x: 0, y: 0 };\r\n    }\r\n    contains(other) {\r\n        let current = other;\r\n        // Index check is a performance optimization - it does not affect correctness\r\n        while (current != null && current.index >= this.index) {\r\n            if (current === this) {\r\n                return true;\r\n            }\r\n            current = current.parent;\r\n        }\r\n        return false;\r\n    }\r\n    walk(callback, order = HierarchyNode.Walk.PreOrder) {\r\n        if (order === HierarchyNode.Walk.PreOrder) {\r\n            callback(this);\r\n        }\r\n        this.children.forEach((child) => {\r\n            child.walk(callback, order);\r\n        });\r\n        if (order === HierarchyNode.Walk.PostOrder) {\r\n            callback(this);\r\n        }\r\n    }\r\n    *[Symbol.iterator]() {\r\n        yield this;\r\n        for (const child of this.children) {\r\n            yield* child;\r\n        }\r\n    }\r\n}\r\nHierarchyNode.Walk = {\r\n    PreOrder: 0,\r\n    PostOrder: 1,\r\n};\r\nclass HierarchySeries extends Series {\r\n    constructor(moduleCtx) {\r\n        super({\r\n            moduleCtx,\r\n            pickModes: [SeriesNodePickMode.EXACT_SHAPE_MATCH],\r\n            contentGroupVirtual: false,\r\n        });\r\n        this.childrenKey = 'children';\r\n        this.sizeKey = undefined;\r\n        this.colorKey = undefined;\r\n        this.colorName = undefined;\r\n        this.fills = Object.values(DEFAULT_FILLS);\r\n        this.strokes = Object.values(DEFAULT_STROKES);\r\n        this.colorRange = undefined;\r\n        this.rootNode = new HierarchyNode(this, 0, undefined, 0, undefined, undefined, undefined, 0, undefined, undefined, []);\r\n        this.colorDomain = [0, 0];\r\n        this.maxDepth = 0;\r\n        this.animationState = new StateMachine('empty', {\r\n            empty: {\r\n                update: {\r\n                    target: 'ready',\r\n                    action: (data) => this.animateEmptyUpdateReady(data),\r\n                },\r\n            },\r\n            ready: {\r\n                updateData: 'waiting',\r\n                clear: 'clearing',\r\n                highlight: (data) => this.animateReadyHighlight(data),\r\n                resize: (data) => this.animateReadyResize(data),\r\n            },\r\n            waiting: {\r\n                update: {\r\n                    target: 'ready',\r\n                    action: (data) => this.animateWaitingUpdateReady(data),\r\n                },\r\n            },\r\n            clearing: {\r\n                update: {\r\n                    target: 'empty',\r\n                    action: (data) => this.animateClearingUpdateEmpty(data),\r\n                },\r\n            },\r\n        }, () => this.checkProcessedDataAnimatable());\r\n    }\r\n    hasData() {\r\n        return Array.isArray(this.data) && this.data.length > 0;\r\n    }\r\n    processData() {\r\n        var _a, _b;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { childrenKey, sizeKey, colorKey, fills, strokes, colorRange } = this;\r\n            let index = 0;\r\n            const getIndex = () => {\r\n                index += 1;\r\n                return index;\r\n            };\r\n            let maxDepth = 0;\r\n            let minColor = Infinity;\r\n            let maxColor = -Infinity;\r\n            const colors = new Array(((_b = (_a = this.data) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) + 1).fill(undefined);\r\n            const createNode = (datum, parent) => {\r\n                const index = getIndex();\r\n                const depth = parent.depth != null ? parent.depth + 1 : 0;\r\n                const children = childrenKey != null ? datum[childrenKey] : undefined;\r\n                const isLeaf = children == null || children.length === 0;\r\n                let size = sizeKey != null ? datum[sizeKey] : undefined;\r\n                if (Number.isFinite(size)) {\r\n                    size = Math.max(size, 0);\r\n                }\r\n                else {\r\n                    size = isLeaf ? 1 : 0;\r\n                }\r\n                const sumSize = size;\r\n                maxDepth = Math.max(maxDepth, depth);\r\n                const color = colorKey != null ? datum[colorKey] : undefined;\r\n                if (typeof color === 'number') {\r\n                    colors[index] = color;\r\n                    minColor = Math.min(minColor, color);\r\n                    maxColor = Math.max(maxColor, color);\r\n                }\r\n                return appendChildren(new HierarchyNode(this, index, datum, size, color, undefined, undefined, sumSize, depth, parent, []), children);\r\n            };\r\n            const appendChildren = (node, data) => {\r\n                data === null || data === void 0 ? void 0 : data.forEach((datum) => {\r\n                    const child = createNode(datum, node);\r\n                    node.children.push(child);\r\n                    node.sumSize += child.sumSize;\r\n                });\r\n                return node;\r\n            };\r\n            const rootNode = appendChildren(new HierarchyNode(this, 0, undefined, 0, undefined, undefined, undefined, 0, undefined, undefined, []), this.data);\r\n            const colorDomain = [minColor, maxColor];\r\n            let colorScale;\r\n            if (colorRange != null && Number.isFinite(minColor) && Number.isFinite(maxColor)) {\r\n                colorScale = new ColorScale();\r\n                colorScale.domain = colorDomain;\r\n                colorScale.range = colorRange;\r\n                colorScale.update();\r\n            }\r\n            rootNode.children.forEach((child, index) => {\r\n                child.walk((node) => {\r\n                    let fill;\r\n                    const color = colors[node.index];\r\n                    if (color != null) {\r\n                        fill = colorScale === null || colorScale === void 0 ? void 0 : colorScale.convert(color);\r\n                    }\r\n                    fill !== null && fill !== void 0 ? fill : (fill = fills === null || fills === void 0 ? void 0 : fills[index % fills.length]);\r\n                    node.fill = fill;\r\n                    // FIXME: If there's a color scale, the strokes won't make sense. For now, just hard-code this default\r\n                    node.stroke = colorScale == null ? strokes === null || strokes === void 0 ? void 0 : strokes[index % strokes.length] : 'rgba(0, 0, 0, 0.2)';\r\n                });\r\n            });\r\n            this.rootNode = rootNode;\r\n            this.maxDepth = maxDepth;\r\n            this.colorDomain = colorDomain;\r\n        });\r\n    }\r\n    update({ seriesRect }) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            yield this.updateSelections();\r\n            yield this.updateNodes();\r\n            const animationData = this.getAnimationData();\r\n            const resize = this.checkResize(seriesRect);\r\n            if (resize) {\r\n                this.animationState.transition('resize', animationData);\r\n            }\r\n            this.animationState.transition('update', animationData);\r\n        });\r\n    }\r\n    resetAllAnimation(data) {\r\n        var _a;\r\n        const datum = (_a = this.animationResetFns) === null || _a === void 0 ? void 0 : _a.datum;\r\n        // Stop any running animations by prefix convention.\r\n        this.ctx.animationManager.stopByAnimationGroupId(this.id);\r\n        if (datum != null) {\r\n            resetMotion(data.datumSelections, datum);\r\n        }\r\n    }\r\n    animateEmptyUpdateReady(data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation(data);\r\n    }\r\n    animateWaitingUpdateReady(data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation(data);\r\n    }\r\n    animateReadyHighlight(data) {\r\n        var _a;\r\n        const datum = (_a = this.animationResetFns) === null || _a === void 0 ? void 0 : _a.datum;\r\n        if (datum != null) {\r\n            resetMotion([data], datum);\r\n        }\r\n    }\r\n    animateReadyResize(data) {\r\n        this.resetAllAnimation(data);\r\n    }\r\n    animateClearingUpdateEmpty(data) {\r\n        this.ctx.animationManager.skipCurrentBatch();\r\n        this.resetAllAnimation(data);\r\n    }\r\n    animationTransitionClear() {\r\n        this.animationState.transition('clear', this.getAnimationData());\r\n    }\r\n    getAnimationData() {\r\n        const animationData = {\r\n            datumSelections: [this.groupSelection],\r\n        };\r\n        return animationData;\r\n    }\r\n    isProcessedDataAnimatable() {\r\n        return true;\r\n    }\r\n    checkProcessedDataAnimatable() {\r\n        if (!this.isProcessedDataAnimatable()) {\r\n            this.ctx.animationManager.skipCurrentBatch();\r\n        }\r\n    }\r\n    getLabelData() {\r\n        return [];\r\n    }\r\n    getSeriesDomain() {\r\n        return [NaN, NaN];\r\n    }\r\n    getLegendData(legendType) {\r\n        return legendType === 'gradient' && this.colorKey != null && this.colorRange != null\r\n            ? [\r\n                {\r\n                    legendType: 'gradient',\r\n                    enabled: this.visible,\r\n                    seriesId: this.id,\r\n                    colorName: this.colorName,\r\n                    colorDomain: this.colorDomain,\r\n                    colorRange: this.colorRange,\r\n                },\r\n            ]\r\n            : [];\r\n    }\r\n    getDatumIdFromData(node) {\r\n        return `${node.index}`;\r\n    }\r\n    getDatumId(node) {\r\n        return this.getDatumIdFromData(node);\r\n    }\r\n}\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HierarchySeries.prototype, \"childrenKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HierarchySeries.prototype, \"sizeKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HierarchySeries.prototype, \"colorKey\", void 0);\r\n__decorate([\r\n    Validate(OPT_STRING),\r\n    __metadata(\"design:type\", String)\r\n], HierarchySeries.prototype, \"colorName\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], HierarchySeries.prototype, \"fills\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], HierarchySeries.prototype, \"strokes\", void 0);\r\n__decorate([\r\n    Validate(OPT_COLOR_STRING_ARRAY),\r\n    __metadata(\"design:type\", Array)\r\n], HierarchySeries.prototype, \"colorRange\", void 0);\n\nclass PolarAxis extends Axis {\r\n    constructor() {\r\n        super(...arguments);\r\n        this.shape = 'polygon';\r\n        this.innerRadiusRatio = 0;\r\n        this.defaultTickMinSpacing = 20;\r\n    }\r\n    computeLabelsBBox(_options, _seriesRect) {\r\n        return null;\r\n    }\r\n}\r\n__decorate([\r\n    Validate(NUMBER$1(0, 1)),\r\n    __metadata(\"design:type\", Number)\r\n], PolarAxis.prototype, \"innerRadiusRatio\", void 0);\n\n/**\r\n * Internal Use Only: Used to ensure this file is treated as a module until we can use moduleDetection flag in Ts v4.7\r\n */\r\nconst __FORCE_MODULE_DETECTION = 0;\n\nvar moduleSupport = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    extractDecoratedProperties: extractDecoratedProperties,\n    isDecoratedObject: isDecoratedObject,\n    listDecoratedProperties: listDecoratedProperties,\n    assignJsonApplyConstructedArray: assignJsonApplyConstructedArray,\n    Motion: easing,\n    resetIds: resetIds,\n    get ChartUpdateType () { return ChartUpdateType; },\n    extent: extent,\n    normalisedExtent: normalisedExtent,\n    normalisedExtentWithMetadata: normalisedExtentWithMetadata,\n    arraysEqual: arraysEqual,\n    toArray: toArray,\n    Validate: Validate,\n    predicateWithMessage: predicateWithMessage,\n    OPTIONAL: OPTIONAL,\n    ARRAY: ARRAY,\n    OPT_ARRAY: OPT_ARRAY,\n    NON_EMPTY_ARRAY: NON_EMPTY_ARRAY,\n    OPT_NON_EMPTY_ARRAY: OPT_NON_EMPTY_ARRAY,\n    AND: AND,\n    OR: OR,\n    LESS_THAN: LESS_THAN,\n    GREATER_THAN: GREATER_THAN,\n    FUNCTION: FUNCTION,\n    OPT_FUNCTION: OPT_FUNCTION,\n    BOOLEAN: BOOLEAN,\n    OPT_BOOLEAN: OPT_BOOLEAN,\n    STRING: STRING,\n    OPT_STRING: OPT_STRING,\n    DATE: DATE,\n    OPT_DATE: OPT_DATE,\n    DATE_ARRAY: DATE_ARRAY,\n    DATETIME_MS: DATETIME_MS,\n    OPT_DATETIME_MS: OPT_DATETIME_MS,\n    OPT_DATE_OR_DATETIME_MS: OPT_DATE_OR_DATETIME_MS,\n    COLOR_STRING: COLOR_STRING,\n    OPT_COLOR_STRING: OPT_COLOR_STRING,\n    COLOR_STRING_ARRAY: COLOR_STRING_ARRAY,\n    OPT_COLOR_STRING_ARRAY: OPT_COLOR_STRING_ARRAY,\n    NUMBER: NUMBER$1,\n    OPT_NUMBER: OPT_NUMBER,\n    NUMBER_OR_NAN: NUMBER_OR_NAN,\n    NUMBER_ARRAY: NUMBER_ARRAY,\n    OPT_NUMBER_ARRAY: OPT_NUMBER_ARRAY,\n    STRING_ARRAY: STRING_ARRAY,\n    OPT_STRING_ARRAY: OPT_STRING_ARRAY,\n    STRING_UNION: STRING_UNION,\n    BOOLEAN_ARRAY: BOOLEAN_ARRAY,\n    OPT_BOOLEAN_ARRAY: OPT_BOOLEAN_ARRAY,\n    FONT_STYLE: FONT_STYLE,\n    OPT_FONT_STYLE: OPT_FONT_STYLE,\n    FONT_WEIGHT: FONT_WEIGHT,\n    OPT_FONT_WEIGHT: OPT_FONT_WEIGHT,\n    LINE_DASH: LINE_DASH,\n    OPT_LINE_DASH: OPT_LINE_DASH,\n    LINE_CAP: LINE_CAP,\n    OPT_LINE_CAP: OPT_LINE_CAP,\n    LINE_JOIN: LINE_JOIN,\n    OPT_LINE_JOIN: OPT_LINE_JOIN,\n    POSITION: POSITION,\n    INTERACTION_RANGE: INTERACTION_RANGE,\n    TEXT_WRAP: TEXT_WRAP,\n    OVERFLOW_STRATEGY: OVERFLOW_STRATEGY,\n    TEXT_ALIGN: TEXT_ALIGN,\n    VERTICAL_ALIGN: VERTICAL_ALIGN,\n    DIRECTION: DIRECTION,\n    OPT_DIRECTION: OPT_DIRECTION,\n    Default: Default,\n    injectStyle: injectStyle,\n    clamp: clamp,\n    isEqual: isEqual,\n    isNegative: isNegative,\n    round: round$1,\n    toFixed: toFixed,\n    mod: mod,\n    deepMerge: deepMerge,\n    mergeDefaults: mergeDefaults,\n    partialAssign: partialAssign,\n    ProxyOnWrite: ProxyOnWrite,\n    ProxyPropertyOnWrite: ProxyPropertyOnWrite,\n    ActionOnSet: ActionOnSet,\n    invertShapeDirection: invertShapeDirection,\n    singleSeriesPaletteFactory: singleSeriesPaletteFactory,\n    markerPaletteFactory: markerPaletteFactory,\n    BaseModuleInstance: BaseModuleInstance,\n    REGISTERED_MODULES: REGISTERED_MODULES,\n    registerModule: registerModule,\n    hasRegisteredEnterpriseModules: hasRegisteredEnterpriseModules,\n    MODULE_CONFLICTS: MODULE_CONFLICTS,\n    registerModuleConflicts: registerModuleConflicts,\n    enterpriseModule: enterpriseModule,\n    Background: Background,\n    BackgroundModule: BackgroundModule,\n    get ChartAxisDirection () { return ChartAxisDirection; },\n    prepareAxisAnimationContext: prepareAxisAnimationContext,\n    prepareAxisAnimationFunctions: prepareAxisAnimationFunctions,\n    resetAxisGroupFn: resetAxisGroupFn,\n    resetAxisSelectionFn: resetAxisSelectionFn,\n    resetAxisLabelSelectionFn: resetAxisLabelSelectionFn,\n    resetAxisLineSelectionFn: resetAxisLineSelectionFn,\n    fixNumericExtent: fixNumericExtent,\n    DataModel: DataModel,\n    DataController: DataController,\n    SMALLEST_KEY_INTERVAL: SMALLEST_KEY_INTERVAL,\n    AGG_VALUES_EXTENT: AGG_VALUES_EXTENT,\n    SORT_DOMAIN_GROUPS: SORT_DOMAIN_GROUPS,\n    normaliseGroupTo: normaliseGroupTo,\n    normalisePropertyTo: normalisePropertyTo,\n    animationValidation: animationValidation,\n    accumulateGroup: accumulateGroup,\n    diff: diff,\n    createDatumId: createDatumId,\n    sum: sum,\n    groupSum: groupSum,\n    range: range,\n    count: count,\n    groupCount: groupCount,\n    average: average,\n    groupAverage: groupAverage,\n    area: area,\n    accumulatedValue: accumulatedValue,\n    trailingAccumulatedValue: trailingAccumulatedValue,\n    UpdateService: UpdateService,\n    LayoutService: LayoutService,\n    AnimationManager: AnimationManager,\n    ChartEventManager: ChartEventManager,\n    CursorManager: CursorManager,\n    HighlightManager: HighlightManager,\n    InteractionManager: InteractionManager,\n    TooltipManager: TooltipManager,\n    ZoomManager: ZoomManager,\n    get Layers () { return Layers; },\n    get SeriesNodePickMode () { return SeriesNodePickMode; },\n    keyProperty: keyProperty,\n    valueProperty: valueProperty,\n    rangedValueProperty: rangedValueProperty,\n    trailingValueProperty: trailingValueProperty,\n    trailingValue: trailingValue,\n    accumulativeValueProperty: accumulativeValueProperty,\n    trailingAccumulatedValueProperty: trailingAccumulatedValueProperty,\n    groupAccumulativeValueProperty: groupAccumulativeValueProperty,\n    SeriesNodeClickEvent: SeriesNodeClickEvent,\n    SeriesItemHighlightStyle: SeriesItemHighlightStyle,\n    HighlightStyle: HighlightStyle,\n    Series: Series,\n    seriesLabelFadeInAnimation: seriesLabelFadeInAnimation,\n    seriesLabelFadeOutAnimation: seriesLabelFadeOutAnimation,\n    resetLabelFn: resetLabelFn,\n    SeriesMarker: SeriesMarker,\n    SeriesTooltip: SeriesTooltip,\n    AbstractBarSeries: AbstractBarSeries,\n    CartesianSeriesNodeClickEvent: CartesianSeriesNodeClickEvent,\n    CartesianSeries: CartesianSeries,\n    pairContinuousData: pairContinuousData,\n    pairCategoryData: pairCategoryData,\n    determinePathStatus: determinePathStatus,\n    prepareLinePathAnimationFns: prepareLinePathAnimationFns,\n    prepareLinePathAnimation: prepareLinePathAnimation,\n    updateRect: updateRect,\n    getRectConfig: getRectConfig,\n    checkCrisp: checkCrisp,\n    collapsedStartingBarPosition: collapsedStartingBarPosition,\n    midpointStartingBarPosition: midpointStartingBarPosition,\n    prepareBarAnimationFunctions: prepareBarAnimationFunctions,\n    resetBarSelectionsFn: resetBarSelectionsFn,\n    get AreaSeriesTag () { return AreaSeriesTag; },\n    prepareAreaPathAnimation: prepareAreaPathAnimation,\n    markerFadeInAnimation: markerFadeInAnimation,\n    markerScaleInAnimation: markerScaleInAnimation,\n    markerSwipeScaleInAnimation: markerSwipeScaleInAnimation,\n    resetMarkerFn: resetMarkerFn,\n    resetMarkerPositionFn: resetMarkerPositionFn,\n    prepareMarkerAnimation: prepareMarkerAnimation,\n    updateLabelNode: updateLabelNode,\n    adjustLabelPlacement: adjustLabelPlacement,\n    minMax: minMax,\n    backfillPathPointData: backfillPathPointData,\n    renderPartialPath: renderPartialPath,\n    pathSwipeInAnimation: pathSwipeInAnimation,\n    pathFadeInAnimation: pathFadeInAnimation,\n    pathFadeOutAnimation: pathFadeOutAnimation,\n    buildResetPathFn: buildResetPathFn,\n    PolarSeries: PolarSeries,\n    HierarchyNode: HierarchyNode,\n    HierarchySeries: HierarchySeries,\n    get Tags () { return Tags; },\n    Axis: Axis,\n    AxisLabel: AxisLabel,\n    AxisTick: AxisTick,\n    PolarAxis: PolarAxis,\n    CategoryAxis: CategoryAxis,\n    __FORCE_MODULE_DETECTION: __FORCE_MODULE_DETECTION,\n    QUICK_TRANSITION: QUICK_TRANSITION,\n    INITIAL_LOAD: INITIAL_LOAD,\n    REMOVE_PHASE: REMOVE_PHASE,\n    UPDATE_PHASE: UPDATE_PHASE,\n    ADD_PHASE: ADD_PHASE,\n    LABEL_PHASE: LABEL_PHASE,\n    get RepeatType () { return RepeatType; },\n    isNodeArray: isNodeArray,\n    Animation: Animation,\n    StateMachine: StateMachine,\n    resetMotion: resetMotion,\n    NODE_UPDATE_PHASES: NODE_UPDATE_PHASES,\n    FROM_TO_MIXINS: FROM_TO_MIXINS,\n    fromToMotion: fromToMotion,\n    staticFromToMotion: staticFromToMotion\n});\n\nconst SERIES_FACTORIES = {};\r\nconst SERIES_DEFAULTS = {};\r\nconst SERIES_THEME_TEMPLATES = {};\r\nconst ENTERPRISE_SERIES_THEME_TEMPLATES = {};\r\nconst SERIES_PALETTE_FACTORIES = {};\r\nconst SOLO_SERIES_TYPES = new Set();\r\nconst STACKABLE_SERIES_TYPES = new Set();\r\nconst GROUPABLE_SERIES_TYPES = new Set();\r\nconst STACKED_BY_DEFAULT_SERIES_TYPES = new Set();\r\nconst SWAP_DEFAULT_AXES_CONDITIONS = {};\r\nconst CUSTOM_DEFAULTS_FUNCTIONS = {};\r\nfunction registerSeries(seriesType, chartType, cstr, defaults, theme, enterpriseTheme, paletteFactory, solo, stackable, groupable, stackedByDefault, swapDefaultAxesCondition, customDefaultsFunction) {\r\n    SERIES_FACTORIES[seriesType] = cstr;\r\n    SERIES_DEFAULTS[seriesType] = defaults;\r\n    registerSeriesThemeTemplate(seriesType, theme, enterpriseTheme);\r\n    if (paletteFactory) {\r\n        addSeriesPaletteFactory(seriesType, paletteFactory);\r\n    }\r\n    if (solo) {\r\n        addSoloSeriesType(seriesType);\r\n    }\r\n    if (stackable) {\r\n        addStackableSeriesType(seriesType);\r\n    }\r\n    if (groupable) {\r\n        addGroupableSeriesType(seriesType);\r\n    }\r\n    if (stackedByDefault) {\r\n        addStackedByDefaultSeriesType(seriesType);\r\n    }\r\n    if (swapDefaultAxesCondition) {\r\n        addSwapDefaultAxesCondition(seriesType, swapDefaultAxesCondition);\r\n    }\r\n    if (customDefaultsFunction) {\r\n        addCustomDefaultsFunctions(seriesType, customDefaultsFunction);\r\n    }\r\n    registerChartSeriesType(seriesType, chartType);\r\n}\r\nfunction registerSeriesThemeTemplate(seriesType, themeTemplate, enterpriseThemeTemplate = {}) {\r\n    const existingTemplate = SERIES_THEME_TEMPLATES[seriesType];\r\n    SERIES_THEME_TEMPLATES[seriesType] = jsonMerge([existingTemplate, themeTemplate]);\r\n    ENTERPRISE_SERIES_THEME_TEMPLATES[seriesType] = jsonMerge([\r\n        existingTemplate,\r\n        themeTemplate,\r\n        enterpriseThemeTemplate,\r\n    ]);\r\n}\r\nfunction getSeries(chartType, moduleCtx) {\r\n    const seriesConstructor = SERIES_FACTORIES[chartType];\r\n    if (seriesConstructor) {\r\n        return new seriesConstructor(moduleCtx);\r\n    }\r\n    throw new Error(`AG Charts - unknown series type: ${chartType}`);\r\n}\r\nfunction getSeriesDefaults(chartType) {\r\n    return SERIES_DEFAULTS[chartType];\r\n}\r\nfunction getSeriesThemeTemplate(chartType) {\r\n    if (hasRegisteredEnterpriseModules()) {\r\n        return ENTERPRISE_SERIES_THEME_TEMPLATES[chartType];\r\n    }\r\n    return SERIES_THEME_TEMPLATES[chartType];\r\n}\r\nfunction addSeriesPaletteFactory(seriesType, factory) {\r\n    SERIES_PALETTE_FACTORIES[seriesType] = factory;\r\n}\r\nfunction getSeriesPaletteFactory(seriesType) {\r\n    return SERIES_PALETTE_FACTORIES[seriesType];\r\n}\r\nfunction isSoloSeries(seriesType) {\r\n    return SOLO_SERIES_TYPES.has(seriesType);\r\n}\r\nfunction isStackableSeries(seriesType) {\r\n    return STACKABLE_SERIES_TYPES.has(seriesType);\r\n}\r\nfunction isGroupableSeries(seriesType) {\r\n    return GROUPABLE_SERIES_TYPES.has(seriesType);\r\n}\r\nfunction isSeriesStackedByDefault(seriesType) {\r\n    return STACKED_BY_DEFAULT_SERIES_TYPES.has(seriesType);\r\n}\r\nfunction addGroupableSeriesType(seriesType) {\r\n    GROUPABLE_SERIES_TYPES.add(seriesType);\r\n}\r\nfunction addSoloSeriesType(seriesType) {\r\n    SOLO_SERIES_TYPES.add(seriesType);\r\n}\r\nfunction addStackableSeriesType(seriesType) {\r\n    STACKABLE_SERIES_TYPES.add(seriesType);\r\n}\r\nfunction addStackedByDefaultSeriesType(seriesType) {\r\n    STACKED_BY_DEFAULT_SERIES_TYPES.add(seriesType);\r\n}\r\nfunction addSwapDefaultAxesCondition(seriesType, predicate) {\r\n    SWAP_DEFAULT_AXES_CONDITIONS[seriesType] = predicate;\r\n}\r\nfunction addCustomDefaultsFunctions(seriesType, predicate) {\r\n    CUSTOM_DEFAULTS_FUNCTIONS[seriesType] = predicate;\r\n}\r\nfunction isDefaultAxisSwapNeeded(opts) {\r\n    var _a, _b;\r\n    let result;\r\n    for (const series of (_a = opts.series) !== null && _a !== void 0 ? _a : []) {\r\n        const { type = 'line' } = series;\r\n        const isDefaultAxisSwapped = (_b = SWAP_DEFAULT_AXES_CONDITIONS[type]) === null || _b === void 0 ? void 0 : _b.call(SWAP_DEFAULT_AXES_CONDITIONS, series);\r\n        if (isDefaultAxisSwapped != null) {\r\n            if (result != null && result != isDefaultAxisSwapped) {\r\n                throw new Error('AG Charts - The provided series have incompatible directions');\r\n            }\r\n            result = isDefaultAxisSwapped;\r\n        }\r\n    }\r\n    return result;\r\n}\r\nfunction executeCustomDefaultsFunctions(opts, initialDefaults) {\r\n    var _a;\r\n    let result = initialDefaults;\r\n    for (const series of (_a = opts.series) !== null && _a !== void 0 ? _a : []) {\r\n        const { type } = series;\r\n        const fn = type != null ? CUSTOM_DEFAULTS_FUNCTIONS[type] : undefined;\r\n        if (fn !== undefined) {\r\n            result = Object.assign(Object.assign({}, result), fn(series));\r\n        }\r\n    }\r\n    return result;\r\n}\n\nfunction setupModules() {\r\n    var _a;\r\n    for (const m of REGISTERED_MODULES) {\r\n        if (m.packageType === 'enterprise' && !verifyIfModuleExpected(m)) {\r\n            Logger.errorOnce('Unexpected enterprise module registered: ' + m.identifier);\r\n        }\r\n        if (JSON_APPLY_PLUGINS.constructors != null && m.optionConstructors != null) {\r\n            Object.assign(JSON_APPLY_PLUGINS.constructors, m.optionConstructors);\r\n        }\r\n        if (m.type === 'root' && m.themeTemplate) {\r\n            for (const chartType of m.chartTypes) {\r\n                registerChartDefaults(chartType, m.themeTemplate);\r\n            }\r\n        }\r\n        if (m.type === 'root' && ((_a = m.conflicts) === null || _a === void 0 ? void 0 : _a.length)) {\r\n            registerModuleConflicts(m.optionsKey, m.conflicts);\r\n        }\r\n        if (m.type === 'series') {\r\n            if (m.chartTypes.length > 1)\r\n                throw new Error('AG Charts - Module definition error: ' + m.identifier);\r\n            registerSeries(m.identifier, m.chartTypes[0], m.instanceConstructor, m.seriesDefaults, m.themeTemplate, m.enterpriseThemeTemplate, m.paletteFactory, m.solo, m.stackable, m.groupable, m.stackedByDefault, m.swapDefaultAxesCondition, m.customDefaultsFunction);\r\n        }\r\n        if (m.type === 'series-option' && m.themeTemplate) {\r\n            for (const seriesType of m.seriesTypes) {\r\n                registerSeriesThemeTemplate(seriesType, m.themeTemplate);\r\n            }\r\n        }\r\n        if (m.type === 'axis-option' && m.themeTemplate) {\r\n            for (const axisType of m.axisTypes) {\r\n                const axisTypeTheme = m.themeTemplate[axisType];\r\n                const theme = Object.assign(Object.assign({}, m.themeTemplate), (typeof axisTypeTheme === 'object' ? axisTypeTheme : {}));\r\n                for (const axisType of m.axisTypes) {\r\n                    delete theme[axisType];\r\n                }\r\n                registerAxisThemeTemplate(axisType, theme);\r\n            }\r\n        }\r\n        if (m.type === 'axis') {\r\n            registerAxis(m.identifier, m.instanceConstructor);\r\n            if (m.themeTemplate) {\r\n                registerAxisThemeTemplate(m.identifier, m.themeTemplate);\r\n            }\r\n        }\r\n        if (m.type === 'legend') {\r\n            registerLegend(m.identifier, m.optionsKey, m.instanceConstructor, m.themeTemplate);\r\n        }\r\n    }\r\n    if (hasRegisteredEnterpriseModules()) {\r\n        const expectedButUnused = getUnusedExpectedModules();\r\n        if (expectedButUnused.length > 0) {\r\n            Logger.errorOnce('Enterprise modules expected but not registered: ', expectedButUnused);\r\n        }\r\n    }\r\n}\n\nclass HierarchyChart extends Chart {\r\n    constructor(specialOverrides, resources) {\r\n        super(specialOverrides, resources);\r\n        this._data = {};\r\n    }\r\n    performLayout() {\r\n        const _super = Object.create(null, {\r\n            performLayout: { get: () => super.performLayout }\r\n        });\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const shrinkRect = yield _super.performLayout.call(this);\r\n            const { seriesArea: { padding }, seriesRoot, } = this;\r\n            const fullSeriesRect = shrinkRect.clone();\r\n            shrinkRect.shrink(padding.left, 'left');\r\n            shrinkRect.shrink(padding.top, 'top');\r\n            shrinkRect.shrink(padding.right, 'right');\r\n            shrinkRect.shrink(padding.bottom, 'bottom');\r\n            this.seriesRect = shrinkRect;\r\n            this.animationRect = shrinkRect;\r\n            this.hoverRect = shrinkRect;\r\n            seriesRoot.translationX = Math.floor(shrinkRect.x);\r\n            seriesRoot.translationY = Math.floor(shrinkRect.y);\r\n            yield Promise.all(this.series.map((series) => __awaiter(this, void 0, void 0, function* () {\r\n                yield series.update({ seriesRect: shrinkRect }); // this has to happen after the `updateAxes` call\r\n            })));\r\n            seriesRoot.visible = this.series[0].visible;\r\n            seriesRoot.setClipRectInGroupCoordinateSpace(new BBox(shrinkRect.x, shrinkRect.y, shrinkRect.width, shrinkRect.height));\r\n            this.layoutService.dispatchLayoutComplete({\r\n                type: 'layout-complete',\r\n                chart: { width: this.scene.width, height: this.scene.height },\r\n                clipSeries: false,\r\n                series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: true },\r\n                axes: [],\r\n            });\r\n            return shrinkRect;\r\n        });\r\n    }\r\n}\r\nHierarchyChart.className = 'HierarchyChart';\r\nHierarchyChart.type = 'hierarchy';\n\nfunction removeUsedEnterpriseOptions(options) {\r\n    var _a, _b, _c, _d;\r\n    const usedOptions = [];\r\n    const optionsChartType = getChartType(optionsType(options));\r\n    for (const { type, chartTypes, optionsKey, optionsInnerKey, identifier } of EXPECTED_ENTERPRISE_MODULES) {\r\n        if (optionsChartType !== 'unknown' && !chartTypes.includes(optionsChartType))\r\n            continue;\r\n        if (type === 'root' || type === 'legend') {\r\n            const optionValue = options[optionsKey];\r\n            if (optionValue == null)\r\n                continue;\r\n            if (!optionsInnerKey) {\r\n                usedOptions.push(optionsKey);\r\n                delete options[optionsKey];\r\n            }\r\n            else if (optionValue[optionsInnerKey]) {\r\n                usedOptions.push(`${optionsKey}.${optionsInnerKey}`);\r\n                delete optionValue[optionsInnerKey];\r\n            }\r\n        }\r\n        else if (type === 'axis') {\r\n            if (!('axes' in options) || !((_a = options.axes) === null || _a === void 0 ? void 0 : _a.some((axis) => axis.type === identifier)))\r\n                continue;\r\n            usedOptions.push(`axis[type=${identifier}]`);\r\n            options.axes = options.axes.filter((axis) => axis.type !== identifier);\r\n        }\r\n        else if (type === 'axis-option') {\r\n            if (!('axes' in options) || !((_b = options.axes) === null || _b === void 0 ? void 0 : _b.some((axis) => axis[optionsKey])))\r\n                continue;\r\n            usedOptions.push(`axis.${optionsKey}`);\r\n            options.axes.forEach((axis) => {\r\n                if (axis[optionsKey]) {\r\n                    delete axis[optionsKey];\r\n                }\r\n            });\r\n        }\r\n        else if (type === 'series') {\r\n            if (!((_c = options.series) === null || _c === void 0 ? void 0 : _c.some((series) => series.type === identifier)))\r\n                continue;\r\n            usedOptions.push(`series[type=${identifier}]`);\r\n            options.series = options.series.filter((series) => series.type !== identifier);\r\n        }\r\n        else if (type === 'series-option') {\r\n            if (!((_d = options.series) === null || _d === void 0 ? void 0 : _d.some((series) => series[optionsKey])))\r\n                continue;\r\n            usedOptions.push(`series.${optionsKey}`);\r\n            options.series.forEach((series) => {\r\n                if (series[optionsKey]) {\r\n                    delete series[optionsKey];\r\n                }\r\n            });\r\n        }\r\n    }\r\n    if (usedOptions.length > 0) {\r\n        Logger.warnOnce([\r\n            `unable to use these enterprise features as 'ag-charts-enterprise' has not been loaded:`,\r\n            ``,\r\n            ...usedOptions,\r\n            ``,\r\n            'See: https://charts.ag-grid.com/javascript/installation/',\r\n        ].join('\\n'));\r\n    }\r\n}\n\n/**\r\n * Groups the series options objects if they are of type `column` or `bar` and places them in an array at the index where the first instance of this series type was found.\r\n * Returns an array of arrays containing the ordered and grouped series options objects.\r\n */\r\nfunction groupSeriesByType(seriesOptions) {\r\n    var _a, _b, _c, _d;\r\n    const groupMap = {};\r\n    const stackMap = {};\r\n    const anyStacked = {};\r\n    const defaultUnstackedGroup = 'default-ag-charts-group';\r\n    const result = [];\r\n    for (const s of seriesOptions) {\r\n        const type = (_a = s.type) !== null && _a !== void 0 ? _a : 'line';\r\n        const stackable = isStackableSeries(type);\r\n        const groupable = isGroupableSeries(type);\r\n        if (!stackable && !groupable) {\r\n            // No need to use index for these cases.\r\n            result.push({ type: 'ungrouped', opts: [s] });\r\n            continue;\r\n        }\r\n        const { stacked: sStacked, stackGroup: sStackGroup, grouped: sGrouped = undefined, xKey } = s;\r\n        const stacked = sStackGroup != null || sStacked === true;\r\n        (_b = anyStacked[type]) !== null && _b !== void 0 ? _b : (anyStacked[type] = false);\r\n        anyStacked[type] || (anyStacked[type] = stacked && stackable);\r\n        const grouped = sGrouped === true;\r\n        let groupingKey = [sStackGroup !== null && sStackGroup !== void 0 ? sStackGroup : (sStacked === true ? 'stacked' : undefined), grouped ? 'grouped' : undefined]\r\n            .filter((v) => v != null)\r\n            .join('-');\r\n        if (!groupingKey) {\r\n            groupingKey = defaultUnstackedGroup;\r\n        }\r\n        const indexKey = `${type}-${xKey}-${groupingKey}`;\r\n        if (stacked && stackable) {\r\n            const updated = ((_c = stackMap[indexKey]) !== null && _c !== void 0 ? _c : (stackMap[indexKey] = { type: 'stack', opts: [] }));\r\n            if (updated.opts.length === 0)\r\n                result.push(updated);\r\n            updated.opts.push(s);\r\n        }\r\n        else if (grouped && groupable) {\r\n            const updated = ((_d = groupMap[indexKey]) !== null && _d !== void 0 ? _d : (groupMap[indexKey] = { type: 'group', opts: [] }));\r\n            if (updated.opts.length === 0)\r\n                result.push(updated);\r\n            updated.opts.push(s);\r\n        }\r\n        else {\r\n            result.push({ type: 'ungrouped', opts: [s] });\r\n        }\r\n    }\r\n    if (!Object.values(anyStacked).some((v) => v)) {\r\n        return result;\r\n    }\r\n    return result;\r\n}\r\n/**\r\n * Transforms provided series options array into an array containing series options which are compatible with standalone charts series options.\r\n */\r\nfunction processSeriesOptions(_opts, seriesOptions) {\r\n    var _a;\r\n    const result = [];\r\n    const preprocessed = seriesOptions.map((series) => {\r\n        var _a;\r\n        // Change the default for bar/columns when yKey is used to be grouped rather than stacked.\r\n        const sType = (_a = series.type) !== null && _a !== void 0 ? _a : 'line';\r\n        const groupable = isGroupableSeries(sType);\r\n        const stackable = isStackableSeries(sType);\r\n        const stackedByDefault = isSeriesStackedByDefault(sType);\r\n        if (series.grouped && !groupable) {\r\n            Logger.warnOnce(`unsupported grouping of series type: ${sType}`);\r\n        }\r\n        if (series.stacked && !stackable) {\r\n            Logger.warnOnce(`unsupported stacking of series type: ${sType}`);\r\n        }\r\n        if (!groupable && !stackable) {\r\n            return series;\r\n        }\r\n        let stacked = false;\r\n        let grouped = false;\r\n        if (series.stacked === undefined && series.grouped === undefined) {\r\n            stacked = stackable && stackedByDefault;\r\n            grouped = groupable && !stacked;\r\n        }\r\n        else if (series.stacked === undefined) {\r\n            stacked = stackable && stackedByDefault && !(series.grouped && groupable);\r\n            grouped = groupable && !stacked && !!series.grouped;\r\n        }\r\n        else if (series.grouped === undefined) {\r\n            stacked = stackable && series.stacked;\r\n            grouped = groupable && !stacked;\r\n        }\r\n        else {\r\n            stacked = stackable && series.stacked;\r\n            grouped = groupable && !stacked && series.grouped;\r\n        }\r\n        return Object.assign(Object.assign({}, series), { stacked, grouped });\r\n    });\r\n    const grouped = groupSeriesByType(preprocessed);\r\n    const groupCount = grouped.reduce((result, next) => {\r\n        var _a, _b;\r\n        if (next.type === 'ungrouped')\r\n            return result;\r\n        const seriesType = (_a = next.opts[0].type) !== null && _a !== void 0 ? _a : 'line';\r\n        (_b = result[seriesType]) !== null && _b !== void 0 ? _b : (result[seriesType] = 0);\r\n        result[seriesType] += next.type === 'stack' ? 1 : next.opts.length;\r\n        return result;\r\n    }, {});\r\n    const groupIdx = {};\r\n    const addSeriesGroupingMeta = (group) => {\r\n        var _a, _b;\r\n        let stackIdx = 0;\r\n        const seriesType = (_a = group.opts[0].type) !== null && _a !== void 0 ? _a : 'line';\r\n        (_b = groupIdx[seriesType]) !== null && _b !== void 0 ? _b : (groupIdx[seriesType] = 0);\r\n        if (group.type === 'stack') {\r\n            for (const opts of group.opts) {\r\n                opts.seriesGrouping = {\r\n                    groupIndex: groupIdx[seriesType],\r\n                    groupCount: groupCount[seriesType],\r\n                    stackIndex: stackIdx++,\r\n                    stackCount: group.opts.length,\r\n                };\r\n            }\r\n            groupIdx[seriesType]++;\r\n        }\r\n        else if (group.type === 'group') {\r\n            for (const opts of group.opts) {\r\n                opts.seriesGrouping = {\r\n                    groupIndex: groupIdx[seriesType],\r\n                    groupCount: groupCount[seriesType],\r\n                    stackIndex: 0,\r\n                    stackCount: 0,\r\n                };\r\n                groupIdx[seriesType]++;\r\n            }\r\n        }\r\n        else {\r\n            for (const opts of group.opts) {\r\n                opts.seriesGrouping = undefined;\r\n            }\r\n        }\r\n        return group.opts;\r\n    };\r\n    Debug.create(true, 'opts')('processSeriesOptions() - series grouping: ', grouped);\r\n    for (const group of grouped) {\r\n        const seriesType = (_a = group.opts[0].type) !== null && _a !== void 0 ? _a : 'line';\r\n        if (isGroupableSeries(seriesType) || isStackableSeries(seriesType)) {\r\n            result.push(...addSeriesGroupingMeta(group));\r\n        }\r\n        else {\r\n            result.push(...group.opts);\r\n        }\r\n    }\r\n    return result;\r\n}\n\nconst DEFAULT_BACKGROUND_FILL = 'white';\r\nconst palette$9 = {\r\n    fills: Array.from(Object.values(DEFAULT_FILLS)),\r\n    strokes: Array.from(Object.values(DEFAULT_STROKES)),\r\n};\r\nconst CHART_TYPE_CONFIG = {\r\n    get cartesian() {\r\n        return { seriesTypes: CHART_TYPES.cartesianTypes, commonOptions: ['zoom', 'navigator'] };\r\n    },\r\n    get polar() {\r\n        return { seriesTypes: CHART_TYPES.polarTypes, commonOptions: [] };\r\n    },\r\n    get hierarchy() {\r\n        return { seriesTypes: CHART_TYPES.hierarchyTypes, commonOptions: [] };\r\n    },\r\n};\r\nconst CHART_TYPE_SPECIFIC_COMMON_OPTIONS = Object.values(CHART_TYPE_CONFIG).reduce((r, { commonOptions }) => [...r, ...commonOptions], []);\r\nclass ChartTheme {\r\n    getPalette() {\r\n        return palette$9;\r\n    }\r\n    static getAxisDefaults() {\r\n        return {\r\n            top: {},\r\n            right: {},\r\n            bottom: {},\r\n            left: {},\r\n            title: {\r\n                enabled: false,\r\n                text: 'Axis Title',\r\n                spacing: 25,\r\n                fontStyle: undefined,\r\n                fontWeight: NORMAL,\r\n                fontSize: FONT_SIZE.MEDIUM,\r\n                fontFamily: DEFAULT_FONT_FAMILY,\r\n                color: DEFAULT_LABEL_COLOUR,\r\n            },\r\n            label: {\r\n                fontStyle: undefined,\r\n                fontWeight: undefined,\r\n                fontSize: FONT_SIZE.SMALL,\r\n                fontFamily: DEFAULT_FONT_FAMILY,\r\n                padding: 5,\r\n                rotation: undefined,\r\n                color: DEFAULT_LABEL_COLOUR,\r\n                formatter: undefined,\r\n                avoidCollisions: true,\r\n            },\r\n            line: {\r\n                enabled: true,\r\n                width: 1,\r\n                color: DEFAULT_AXIS_LINE_COLOUR,\r\n            },\r\n            tick: {\r\n                enabled: false,\r\n                width: 1,\r\n                color: DEFAULT_AXIS_LINE_COLOUR,\r\n            },\r\n            gridLine: {\r\n                enabled: true,\r\n                style: [\r\n                    {\r\n                        stroke: DEFAULT_AXIS_GRID_COLOUR,\r\n                        lineDash: [],\r\n                    },\r\n                ],\r\n            },\r\n            crossLines: {\r\n                enabled: false,\r\n                fill: DEFAULT_CROSS_LINES_COLOUR,\r\n                stroke: DEFAULT_CROSS_LINES_COLOUR,\r\n                fillOpacity: 0.1,\r\n                strokeWidth: 1,\r\n                label: {\r\n                    enabled: false,\r\n                    fontStyle: undefined,\r\n                    fontWeight: undefined,\r\n                    fontSize: FONT_SIZE.SMALL,\r\n                    fontFamily: DEFAULT_FONT_FAMILY,\r\n                    padding: 5,\r\n                    color: DEFAULT_LABEL_COLOUR,\r\n                },\r\n            },\r\n        };\r\n    }\r\n    static getSeriesDefaults() {\r\n        return {\r\n            tooltip: {\r\n                enabled: true,\r\n                renderer: undefined,\r\n            },\r\n            visible: true,\r\n            showInLegend: true,\r\n            highlightStyle: {\r\n                item: {\r\n                    fill: 'rgba(255,255,255, 0.33)',\r\n                    stroke: `rgba(0, 0, 0, 0.4)`,\r\n                    strokeWidth: 2,\r\n                },\r\n                series: {\r\n                    dimOpacity: 1,\r\n                },\r\n                text: {\r\n                    color: 'black',\r\n                },\r\n            },\r\n            nodeClickRange: 'exact',\r\n        };\r\n    }\r\n    static getCartesianSeriesMarkerDefaults() {\r\n        return {\r\n            enabled: true,\r\n            shape: 'circle',\r\n            size: 7,\r\n            strokeWidth: 1,\r\n            formatter: undefined,\r\n        };\r\n    }\r\n    static getLegendItemMarkerDefaults() {\r\n        return {\r\n            shape: undefined,\r\n            size: 15,\r\n            padding: 8,\r\n        };\r\n    }\r\n    static getCaptionWrappingDefaults() {\r\n        return 'hyphenate';\r\n    }\r\n    static getChartDefaults() {\r\n        return {\r\n            background: {\r\n                visible: true,\r\n                fill: DEFAULT_BACKGROUND_COLOUR,\r\n            },\r\n            padding: {\r\n                top: 20,\r\n                right: 20,\r\n                bottom: 20,\r\n                left: 20,\r\n            },\r\n            title: {\r\n                enabled: false,\r\n                text: 'Title',\r\n                fontStyle: undefined,\r\n                fontWeight: NORMAL,\r\n                fontSize: FONT_SIZE.LARGE,\r\n                fontFamily: DEFAULT_FONT_FAMILY,\r\n                color: DEFAULT_LABEL_COLOUR,\r\n                wrapping: ChartTheme.getCaptionWrappingDefaults(),\r\n            },\r\n            subtitle: {\r\n                enabled: false,\r\n                text: 'Subtitle',\r\n                spacing: 20,\r\n                fontStyle: undefined,\r\n                fontWeight: undefined,\r\n                fontSize: FONT_SIZE.MEDIUM,\r\n                fontFamily: DEFAULT_FONT_FAMILY,\r\n                color: DEFAULT_MUTED_LABEL_COLOUR,\r\n                wrapping: ChartTheme.getCaptionWrappingDefaults(),\r\n            },\r\n            footnote: {\r\n                enabled: false,\r\n                text: 'Footnote',\r\n                spacing: 20,\r\n                fontStyle: undefined,\r\n                fontWeight: undefined,\r\n                fontSize: FONT_SIZE.MEDIUM,\r\n                fontFamily: DEFAULT_FONT_FAMILY,\r\n                color: 'rgb(140, 140, 140)',\r\n                wrapping: ChartTheme.getCaptionWrappingDefaults(),\r\n            },\r\n            legend: {\r\n                position: BOTTOM,\r\n                spacing: 30,\r\n                listeners: {},\r\n                item: {\r\n                    paddingX: 16,\r\n                    paddingY: 8,\r\n                    marker: ChartTheme.getLegendItemMarkerDefaults(),\r\n                    label: {\r\n                        color: DEFAULT_LABEL_COLOUR,\r\n                        fontStyle: undefined,\r\n                        fontWeight: undefined,\r\n                        fontSize: FONT_SIZE.SMALL,\r\n                        fontFamily: DEFAULT_FONT_FAMILY,\r\n                        formatter: undefined,\r\n                    },\r\n                },\r\n                reverseOrder: false,\r\n                pagination: {\r\n                    marker: {\r\n                        size: 12,\r\n                    },\r\n                    activeStyle: {\r\n                        fill: DEFAULT_LABEL_COLOUR,\r\n                    },\r\n                    inactiveStyle: {\r\n                        fill: DEFAULT_MUTED_LABEL_COLOUR,\r\n                    },\r\n                    highlightStyle: {\r\n                        fill: DEFAULT_LABEL_COLOUR,\r\n                    },\r\n                    label: {\r\n                        color: DEFAULT_LABEL_COLOUR,\r\n                    },\r\n                },\r\n            },\r\n            tooltip: {\r\n                enabled: true,\r\n                range: 'nearest',\r\n                delay: 0,\r\n            },\r\n            listeners: {},\r\n        };\r\n    }\r\n    constructor(options) {\r\n        options = deepMerge({}, options !== null && options !== void 0 ? options : {});\r\n        const { overrides = null, palette = null } = options;\r\n        const defaults = this.createChartConfigPerChartType(this.getDefaults());\r\n        if (overrides) {\r\n            const { common } = overrides;\r\n            const applyOverrides = (seriesTypes, overrideOpts) => {\r\n                if (!overrideOpts)\r\n                    return;\r\n                for (const s of seriesTypes) {\r\n                    const seriesType = s;\r\n                    defaults[seriesType] = deepMerge(defaults[seriesType], overrideOpts);\r\n                }\r\n            };\r\n            for (const [, { seriesTypes, commonOptions }] of Object.entries(CHART_TYPE_CONFIG)) {\r\n                const cleanedCommon = Object.assign({}, common);\r\n                for (const commonKey of CHART_TYPE_SPECIFIC_COMMON_OPTIONS) {\r\n                    if (!commonOptions.includes(commonKey)) {\r\n                        delete cleanedCommon[commonKey];\r\n                    }\r\n                }\r\n                applyOverrides(seriesTypes, cleanedCommon);\r\n            }\r\n            CHART_TYPES.seriesTypes.forEach((s) => {\r\n                const seriesType = s;\r\n                if (overrides[seriesType]) {\r\n                    defaults[seriesType] = deepMerge(defaults[seriesType], overrides[seriesType]);\r\n                }\r\n            });\r\n        }\r\n        this.palette = palette !== null && palette !== void 0 ? palette : this.getPalette();\r\n        this.config = Object.freeze(this.templateTheme(defaults));\r\n    }\r\n    createChartConfigPerChartType(config) {\r\n        Object.entries(CHART_TYPE_CONFIG).forEach(([nextType, { seriesTypes }]) => {\r\n            const typeDefaults = getChartDefaults(nextType);\r\n            seriesTypes.forEach((next) => {\r\n                const alias = next;\r\n                if (!config[alias]) {\r\n                    config[alias] = {};\r\n                    deepMerge(config[alias], typeDefaults);\r\n                }\r\n            });\r\n        });\r\n        return config;\r\n    }\r\n    getDefaults() {\r\n        let defaults = {};\r\n        const getChartTypeDefaults = (chartType) => {\r\n            return Object.assign(Object.assign(Object.assign({}, getLegendThemeTemplates()), ChartTheme.getChartDefaults()), getChartDefaults(chartType));\r\n        };\r\n        const getOverridesByType = (chartType, seriesTypes) => {\r\n            var _a, _b, _c;\r\n            var _d;\r\n            const chartDefaults = getChartTypeDefaults(chartType);\r\n            const result = {};\r\n            for (const seriesType of seriesTypes) {\r\n                (_a = result[seriesType]) !== null && _a !== void 0 ? _a : (result[seriesType] = deepMerge({}, chartDefaults));\r\n                const axes = ((_b = (_d = result[seriesType]).axes) !== null && _b !== void 0 ? _b : (_d.axes = {}));\r\n                const template = getSeriesThemeTemplate(seriesType);\r\n                if (template) {\r\n                    result[seriesType].series = deepMerge(result[seriesType].series, template);\r\n                }\r\n                for (const axisType of AXIS_TYPES.axesTypes) {\r\n                    const template = getAxisThemeTemplate(axisType);\r\n                    if (chartType === 'cartesian') {\r\n                        axes[axisType] = deepMerge(axes[axisType], (_c = ChartTheme.cartesianAxisDefault[axisType]) !== null && _c !== void 0 ? _c : {});\r\n                    }\r\n                    if (template) {\r\n                        axes[axisType] = deepMerge(axes[axisType], template);\r\n                    }\r\n                }\r\n            }\r\n            return result;\r\n        };\r\n        defaults = deepMerge(defaults, getOverridesByType('cartesian', CHART_TYPES.cartesianTypes));\r\n        defaults = deepMerge(defaults, getOverridesByType('polar', CHART_TYPES.polarTypes));\r\n        defaults = deepMerge(defaults, getOverridesByType('hierarchy', CHART_TYPES.hierarchyTypes));\r\n        return defaults;\r\n    }\r\n    templateTheme(themeTemplate) {\r\n        const themeInstance = jsonMerge([themeTemplate]);\r\n        const { extensions, properties } = this.getTemplateParameters();\r\n        jsonWalk(themeInstance, (_, node) => {\r\n            if (node['__extends__']) {\r\n                const key = node['__extends__'];\r\n                const source = extensions.get(key);\r\n                if (source == null) {\r\n                    throw new Error('AG Charts - no template variable provided for: ' + key);\r\n                }\r\n                Object.keys(source).forEach((key) => {\r\n                    if (!(key in node)) {\r\n                        node[key] = source[key];\r\n                    }\r\n                });\r\n                delete node['__extends__'];\r\n            }\r\n            if (node['__overrides__']) {\r\n                const key = node['__overrides__'];\r\n                const source = extensions.get(key);\r\n                if (source == null) {\r\n                    throw new Error('AG Charts - no template variable provided for: ' + key);\r\n                }\r\n                Object.assign(node, source);\r\n                delete node['__overrides__'];\r\n            }\r\n            if (Array.isArray(node)) {\r\n                for (let i = 0; i < node.length; i++) {\r\n                    const symbol = node[i];\r\n                    if (properties.has(symbol)) {\r\n                        node[i] = properties.get(symbol);\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                for (const [name, value] of Object.entries(node)) {\r\n                    if (properties.has(value)) {\r\n                        node[name] = properties.get(value);\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        return themeInstance;\r\n    }\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: DEFAULT_FILLS.BLUE,\r\n            stroke: DEFAULT_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: DEFAULT_FILLS.ORANGE,\r\n            stroke: DEFAULT_STROKES.ORANGE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: DEFAULT_FILLS.GRAY,\r\n            stroke: DEFAULT_STROKES.GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const extensions = new Map();\r\n        extensions.set(EXTENDS_CHART_DEFAULTS, ChartTheme.getChartDefaults());\r\n        extensions.set(EXTENDS_AXES_DEFAULTS, ChartTheme.getAxisDefaults());\r\n        extensions.set(EXTENDS_LEGEND_DEFAULTS, ChartTheme.getChartDefaults().legend);\r\n        extensions.set(EXTENDS_LEGEND_ITEM_DEFAULTS, ChartTheme.getChartDefaults().legend.item);\r\n        extensions.set(EXTENDS_LEGEND_ITEM_MARKER_DEFAULTS, ChartTheme.getLegendItemMarkerDefaults());\r\n        extensions.set(EXTENDS_AXES_LABEL_DEFAULTS, ChartTheme.getAxisDefaults().label);\r\n        extensions.set(EXTENDS_AXES_LINE_DEFAULTS, ChartTheme.getAxisDefaults().line);\r\n        extensions.set(EXTENDS_AXES_TICK_DEFAULTS, ChartTheme.getAxisDefaults().tick);\r\n        extensions.set(EXTENDS_AXES_GRID_LINE_DEFAULTS, ChartTheme.getAxisDefaults().gridLine);\r\n        extensions.set(EXTENDS_SERIES_DEFAULTS, ChartTheme.getSeriesDefaults());\r\n        extensions.set(OVERRIDE_SERIES_LABEL_DEFAULTS, {});\r\n        extensions.set(EXTENDS_CARTESIAN_MARKER_DEFAULTS, ChartTheme.getCartesianSeriesMarkerDefaults());\r\n        const properties = new Map();\r\n        properties.set(DEFAULT_FONT_FAMILY, 'Verdana, sans-serif');\r\n        properties.set(DEFAULT_LABEL_COLOUR, 'rgb(70, 70, 70)');\r\n        properties.set(DEFAULT_INVERTED_LABEL_COLOUR, 'white');\r\n        properties.set(DEFAULT_MUTED_LABEL_COLOUR, 'rgb(140, 140, 140)');\r\n        properties.set(DEFAULT_AXIS_GRID_COLOUR, 'rgb(224,234,241)');\r\n        properties.set(DEFAULT_AXIS_LINE_COLOUR, 'rgb(195, 195, 195)');\r\n        properties.set(DEFAULT_CROSS_LINES_COLOUR, 'rgb(70, 70, 70)');\r\n        properties.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_BACKGROUND_FILL);\r\n        properties.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_BACKGROUND_FILL);\r\n        properties.set(DEFAULT_SHADOW_COLOUR, 'rgba(0, 0, 0, 0.5)');\r\n        properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            DEFAULT_FILLS.ORANGE,\r\n            DEFAULT_FILLS.YELLOW,\r\n            DEFAULT_FILLS.GREEN,\r\n        ]);\r\n        properties.set(DEFAULT_HIERARCHY_FILLS, ['#ffffff', '#e0e5ea', '#c1ccd5', '#a3b4c1', '#859cad']);\r\n        properties.set(DEFAULT_HIERARCHY_STROKES, ['#ffffff', '#c5cbd1', '#a4b1bd', '#8498a9', '#648096']);\r\n        properties.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_BACKGROUND_FILL);\r\n        properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, ChartTheme.getWaterfallSeriesDefaultPositiveColors());\r\n        properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, ChartTheme.getWaterfallSeriesDefaultNegativeColors());\r\n        properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, ChartTheme.getWaterfallSeriesDefaultTotalColors());\r\n        properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, ChartTheme.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return {\r\n            extensions,\r\n            properties,\r\n        };\r\n    }\r\n}\r\nChartTheme.cartesianAxisDefault = {\r\n    number: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults()), { line: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults().line), { enabled: false }) }),\r\n    log: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults()), { base: 10, line: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults().line), { enabled: false }) }),\r\n    category: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults()), { groupPaddingInner: 0.1, label: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults().label), { autoRotate: true }), gridLine: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults().gridLine), { enabled: false }) }),\r\n    'grouped-category': Object.assign({}, ChartTheme.getAxisDefaults()),\r\n    time: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults()), { gridLine: Object.assign(Object.assign({}, ChartTheme.getAxisDefaults().gridLine), { enabled: false }) }),\r\n};\n\nconst DEFAULT_DARK_BACKGROUND_FILL = '#182732';\r\nconst DEFAULT_DARK_FILLS = {\r\n    BLUE: '#5090dc',\r\n    ORANGE: '#ffa03a',\r\n    GREEN: '#459d55',\r\n    CYAN: '#34bfe1',\r\n    YELLOW: '#e1cc00',\r\n    VIOLET: '#9669cb',\r\n    GRAY: '#b5b5b5',\r\n    MAGENTA: '#bd5aa7',\r\n    BROWN: '#8a6224',\r\n    RED: '#ef5452',\r\n};\r\nconst DEFAULT_DARK_STROKES = {\r\n    BLUE: '#74a8e6',\r\n    ORANGE: '#ffbe70',\r\n    GREEN: '#6cb176',\r\n    CYAN: '#75d4ef',\r\n    YELLOW: '#f6e559',\r\n    VIOLET: '#aa86d8',\r\n    GRAY: '#a1a1a1',\r\n    MAGENTA: '#ce7ab9',\r\n    BROWN: '#997b52',\r\n    RED: '#ff7872',\r\n};\r\nconst palette$8 = {\r\n    fills: Array.from(Object.values(DEFAULT_DARK_FILLS)),\r\n    strokes: Array.from(Object.values(DEFAULT_DARK_STROKES)),\r\n};\r\nclass DarkTheme extends ChartTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: DEFAULT_DARK_FILLS.BLUE,\r\n            stroke: DEFAULT_DARK_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: DEFAULT_DARK_FILLS.ORANGE,\r\n            stroke: DEFAULT_DARK_STROKES.ORANGE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: DEFAULT_DARK_FILLS.GRAY,\r\n            stroke: DEFAULT_DARK_STROKES.GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, DarkTheme.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, DarkTheme.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, DarkTheme.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, DarkTheme.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        result.properties.set(DEFAULT_POLAR_SERIES_STROKE, DEFAULT_DARK_BACKGROUND_FILL);\r\n        result.properties.set(DEFAULT_LABEL_COLOUR, 'white');\r\n        result.properties.set(DEFAULT_MUTED_LABEL_COLOUR, '#7D91A0');\r\n        result.properties.set(DEFAULT_AXIS_GRID_COLOUR, '#545A6E');\r\n        result.properties.set(DEFAULT_CROSS_LINES_COLOUR, 'white');\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            DEFAULT_DARK_FILLS.ORANGE,\r\n            DEFAULT_DARK_FILLS.YELLOW,\r\n            DEFAULT_DARK_FILLS.GREEN,\r\n        ]);\r\n        result.properties.set(DEFAULT_HIERARCHY_FILLS, ['#192834', '#253746', '#324859', '#3f596c', '#4d6a80']);\r\n        result.properties.set(DEFAULT_HIERARCHY_STROKES, ['#192834', '#3b5164', '#496275', '#577287', '#668399']);\r\n        result.properties.set(DEFAULT_BACKGROUND_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\r\n        result.properties.set(DEFAULT_INSIDE_SERIES_LABEL_COLOUR, DEFAULT_DARK_BACKGROUND_FILL);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette$8;\r\n    }\r\n    constructor(options) {\r\n        super(options);\r\n    }\r\n}\n\nconst MATERIAL_DARK_FILLS = {\r\n    BLUE: '#2196F3',\r\n    ORANGE: '#FF9800',\r\n    GREEN: '#4CAF50',\r\n    CYAN: '#00BCD4',\r\n    YELLOW: '#FFEB3B',\r\n    VIOLET: '#7E57C2',\r\n    GRAY: '#9E9E9E',\r\n    MAGENTA: '#F06292',\r\n    BROWN: '#795548',\r\n    RED: '#F44336',\r\n};\r\nconst MATERIAL_DARK_STROKES = {\r\n    BLUE: '#90CAF9',\r\n    ORANGE: '#FFCC80',\r\n    GREEN: '#A5D6A7',\r\n    CYAN: '#80DEEA',\r\n    YELLOW: '#FFF9C4',\r\n    VIOLET: '#B39DDB',\r\n    GRAY: '#E0E0E0',\r\n    MAGENTA: '#F48FB1',\r\n    BROWN: '#A1887F',\r\n    RED: '#EF9A9A',\r\n};\r\nconst palette$7 = {\r\n    fills: Array.from(Object.values(MATERIAL_DARK_FILLS)),\r\n    strokes: Array.from(Object.values(MATERIAL_DARK_STROKES)),\r\n};\r\nclass MaterialDark extends DarkTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: MATERIAL_DARK_FILLS.BLUE,\r\n            stroke: MATERIAL_DARK_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: MATERIAL_DARK_FILLS.RED,\r\n            stroke: MATERIAL_DARK_STROKES.RED,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: MATERIAL_DARK_FILLS.GRAY,\r\n            stroke: MATERIAL_DARK_STROKES.GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, MaterialDark.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, MaterialDark.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, MaterialDark.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            MATERIAL_DARK_FILLS.ORANGE,\r\n            MATERIAL_DARK_FILLS.YELLOW,\r\n            MATERIAL_DARK_FILLS.GREEN,\r\n        ]);\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, MaterialDark.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette$7;\r\n    }\r\n}\n\nconst MATERIAL_LIGHT_FILLS = {\r\n    BLUE: '#2196F3',\r\n    ORANGE: '#FF9800',\r\n    GREEN: '#4CAF50',\r\n    CYAN: '#00BCD4',\r\n    YELLOW: '#FFEB3B',\r\n    VIOLET: '#7E57C2',\r\n    GRAY: '#9E9E9E',\r\n    MAGENTA: '#F06292',\r\n    BROWN: '#795548',\r\n    RED: '#F44336',\r\n};\r\nconst MATERIAL_LIGHT_STROKES = {\r\n    BLUE: '#1565C0',\r\n    ORANGE: '#E65100',\r\n    GREEN: '#2E7D32',\r\n    CYAN: '#00838F',\r\n    YELLOW: '#F9A825',\r\n    VIOLET: '#4527A0',\r\n    GRAY: '#616161',\r\n    MAGENTA: '#C2185B',\r\n    BROWN: '#4E342E',\r\n    RED: '#B71C1C',\r\n};\r\nconst palette$6 = {\r\n    fills: Array.from(Object.values(MATERIAL_LIGHT_FILLS)),\r\n    strokes: Array.from(Object.values(MATERIAL_LIGHT_STROKES)),\r\n};\r\nclass MaterialLight extends ChartTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: MATERIAL_LIGHT_FILLS.BLUE,\r\n            stroke: MATERIAL_LIGHT_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: MATERIAL_LIGHT_FILLS.RED,\r\n            stroke: MATERIAL_LIGHT_STROKES.RED,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: MATERIAL_LIGHT_FILLS.GRAY,\r\n            stroke: MATERIAL_LIGHT_STROKES.GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, MaterialLight.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, MaterialLight.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, MaterialLight.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            MATERIAL_LIGHT_FILLS.ORANGE,\r\n            MATERIAL_LIGHT_FILLS.YELLOW,\r\n            MATERIAL_LIGHT_FILLS.GREEN,\r\n        ]);\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, MaterialLight.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette$6;\r\n    }\r\n}\n\nconst POLYCHROMA_DARK_FILLS = {\r\n    BLUE: '#436ff4',\r\n    PURPLE: '#9a7bff',\r\n    MAGENTA: '#d165d2',\r\n    PINK: '#f0598b',\r\n    RED: '#f47348',\r\n    ORANGE: '#f2a602',\r\n    YELLOW: '#e9e201',\r\n    GREEN: '#21b448',\r\n    CYAN: '#00b9a2',\r\n    MODERATE_BLUE: '#00aee4',\r\n};\r\nconst POLYCHROMA_DARK_STROKES = {\r\n    BLUE: '#6698ff',\r\n    PURPLE: '#c0a3ff',\r\n    MAGENTA: '#fc8dfc',\r\n    PINK: '#ff82b1',\r\n    RED: '#ff9b70',\r\n    ORANGE: '#ffcf4e',\r\n    YELLOW: '#ffff58',\r\n    GREEN: '#58dd70',\r\n    CYAN: '#51e2c9',\r\n    MODERATE_BLUE: '#4fd7ff',\r\n};\r\nconst POLYCHROMA_DARK_FILL_GRAY = '#bbbbbb';\r\nconst POLYCHROMA_DARK_STROKE_GRAY = '#eeeeee';\r\nconst palette$5 = {\r\n    fills: Array.from(Object.values(POLYCHROMA_DARK_FILLS)),\r\n    strokes: Array.from(Object.values(POLYCHROMA_DARK_STROKES)),\r\n};\r\nclass PolychromaDark extends DarkTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: POLYCHROMA_DARK_FILLS.BLUE,\r\n            stroke: POLYCHROMA_DARK_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: POLYCHROMA_DARK_FILLS.RED,\r\n            stroke: POLYCHROMA_DARK_STROKES.RED,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: POLYCHROMA_DARK_FILL_GRAY,\r\n            stroke: POLYCHROMA_DARK_STROKE_GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, PolychromaDark.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, PolychromaDark.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, PolychromaDark.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            POLYCHROMA_DARK_FILLS.BLUE,\r\n            POLYCHROMA_DARK_FILLS.RED,\r\n        ]);\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, PolychromaDark.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette$5;\r\n    }\r\n}\n\nconst POLYCHROMA_LIGHT_FILLS = {\r\n    BLUE: '#436ff4',\r\n    PURPLE: '#9a7bff',\r\n    MAGENTA: '#d165d2',\r\n    PINK: '#f0598b',\r\n    RED: '#f47348',\r\n    ORANGE: '#f2a602',\r\n    YELLOW: '#e9e201',\r\n    GREEN: '#21b448',\r\n    CYAN: '#00b9a2',\r\n    MODERATE_BLUE: '#00aee4',\r\n};\r\nconst POLYCHROMA_LIGHT_STROKES = {\r\n    BLUE: '#2346c9',\r\n    PURPLE: '#7653d4',\r\n    MAGENTA: '#a73da9',\r\n    PINK: '#c32d66',\r\n    RED: '#c84b1c',\r\n    ORANGE: '#c87f00',\r\n    YELLOW: '#c1b900',\r\n    GREEN: '#008c1c',\r\n    CYAN: '#00927c',\r\n    MODERATE_BLUE: '#0087bb',\r\n};\r\nconst POLYCHROMA_LIGHT_FILL_GRAY = '#bbbbbb';\r\nconst POLYCHROMA_LIGHT_STROKE_GRAY = '#888888';\r\nconst palette$4 = {\r\n    fills: Array.from(Object.values(POLYCHROMA_LIGHT_FILLS)),\r\n    strokes: Array.from(Object.values(POLYCHROMA_LIGHT_STROKES)),\r\n};\r\nclass PolychromaLight extends ChartTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: POLYCHROMA_LIGHT_FILLS.BLUE,\r\n            stroke: POLYCHROMA_LIGHT_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: POLYCHROMA_LIGHT_FILLS.RED,\r\n            stroke: POLYCHROMA_LIGHT_STROKES.RED,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: POLYCHROMA_LIGHT_FILL_GRAY,\r\n            stroke: POLYCHROMA_LIGHT_STROKE_GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, PolychromaLight.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, PolychromaLight.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, PolychromaLight.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            POLYCHROMA_LIGHT_FILLS.BLUE,\r\n            POLYCHROMA_LIGHT_FILLS.RED,\r\n        ]);\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, PolychromaLight.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette$4;\r\n    }\r\n}\n\nconst SHEETS_DARK_FILLS = {\r\n    BLUE: '#4472C4',\r\n    ORANGE: '#ED7D31',\r\n    GRAY: '#A5A5A5',\r\n    YELLOW: '#FFC000',\r\n    MODERATE_BLUE: '#5B9BD5',\r\n    GREEN: '#70AD47',\r\n    DARK_GRAY: '#7B7B7B',\r\n    DARK_BLUE: '#264478',\r\n    VERY_DARK_GRAY: '#636363',\r\n    DARK_YELLOW: '#997300',\r\n};\r\nconst SHEETS_DARK_STROKES = {\r\n    BLUE: '#6899ee',\r\n    ORANGE: '#ffa55d',\r\n    GRAY: '#cdcdcd',\r\n    YELLOW: '#ffea53',\r\n    MODERATE_BLUE: '#82c3ff',\r\n    GREEN: '#96d56f',\r\n    DARK_GRAY: '#a1a1a1',\r\n    DARK_BLUE: '#47689f',\r\n    VERY_DARK_GRAY: '#878787',\r\n    DARK_YELLOW: '#c0993d',\r\n};\r\nconst palette$3 = {\r\n    fills: Array.from(Object.values(SHEETS_DARK_FILLS)),\r\n    strokes: Array.from(Object.values(SHEETS_DARK_STROKES)),\r\n};\r\nclass SheetsDark extends DarkTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: SHEETS_DARK_FILLS.BLUE,\r\n            stroke: SHEETS_DARK_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: SHEETS_DARK_FILLS.ORANGE,\r\n            stroke: SHEETS_DARK_STROKES.ORANGE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: SHEETS_DARK_FILLS.GRAY,\r\n            stroke: SHEETS_DARK_STROKES.GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, SheetsDark.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, SheetsDark.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, SheetsDark.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            SHEETS_DARK_FILLS.ORANGE,\r\n            SHEETS_DARK_FILLS.YELLOW,\r\n            SHEETS_DARK_FILLS.GREEN,\r\n        ]);\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, SheetsDark.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette$3;\r\n    }\r\n}\n\nconst SHEETS_LIGHT_FILLS = {\r\n    BLUE: '#5281d5',\r\n    ORANGE: '#ff8d44',\r\n    GRAY: '#b5b5b5',\r\n    YELLOW: '#ffd02f',\r\n    MODERATE_BLUE: '#6aabe6',\r\n    GREEN: '#7fbd57',\r\n    DARK_GRAY: '#8a8a8a',\r\n    DARK_BLUE: '#335287',\r\n    VERY_DARK_GRAY: '#717171',\r\n    DARK_YELLOW: '#a98220',\r\n};\r\nconst SHEETS_LIGHT_STROKES = {\r\n    BLUE: '#214d9b',\r\n    ORANGE: '#c25600',\r\n    GRAY: '#7f7f7f',\r\n    YELLOW: '#d59800',\r\n    MODERATE_BLUE: '#3575ac',\r\n    GREEN: '#4b861a',\r\n    DARK_GRAY: '#575757',\r\n    DARK_BLUE: '#062253',\r\n    VERY_DARK_GRAY: '#414141',\r\n    DARK_YELLOW: '#734f00',\r\n};\r\nconst palette$2 = {\r\n    fills: Array.from(Object.values(SHEETS_LIGHT_FILLS)),\r\n    strokes: Array.from(Object.values(SHEETS_LIGHT_STROKES)),\r\n};\r\nclass SheetsLight extends ChartTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: SHEETS_LIGHT_FILLS.BLUE,\r\n            stroke: SHEETS_LIGHT_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: SHEETS_LIGHT_FILLS.ORANGE,\r\n            stroke: SHEETS_LIGHT_STROKES.ORANGE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: SHEETS_LIGHT_FILLS.GRAY,\r\n            stroke: SHEETS_LIGHT_STROKES.GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, SheetsLight.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, SheetsLight.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, SheetsLight.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            SHEETS_LIGHT_FILLS.ORANGE,\r\n            SHEETS_LIGHT_FILLS.YELLOW,\r\n            SHEETS_LIGHT_FILLS.GREEN,\r\n        ]);\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, SheetsLight.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette$2;\r\n    }\r\n}\n\nconst VIVID_DARK_FILLS = {\r\n    BLUE: '#0083ff',\r\n    ORANGE: '#ff6600',\r\n    GREEN: '#00af00',\r\n    CYAN: '#00ccff',\r\n    YELLOW: '#f7c700',\r\n    VIOLET: '#ac26ff',\r\n    GRAY: '#a7a7b7',\r\n    MAGENTA: '#e800c5',\r\n    BROWN: '#b54300',\r\n    RED: '#ff0000',\r\n};\r\nconst VIVID_DARK_STROKES = {\r\n    BLUE: '#67b7ff',\r\n    ORANGE: '#ffc24d',\r\n    GREEN: '#5cc86f',\r\n    CYAN: '#54ebff',\r\n    VIOLET: '#c18aff',\r\n    YELLOW: '#fff653',\r\n    GRAY: '#aeaeae',\r\n    MAGENTA: '#f078d4',\r\n    BROWN: '#ba8438',\r\n    RED: '#ff726e',\r\n};\r\nconst palette$1 = {\r\n    fills: Array.from(Object.values(VIVID_DARK_FILLS)),\r\n    strokes: Array.from(Object.values(VIVID_DARK_STROKES)),\r\n};\r\nclass VividDark extends DarkTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: VIVID_DARK_FILLS.BLUE,\r\n            stroke: VIVID_DARK_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: VIVID_DARK_FILLS.ORANGE,\r\n            stroke: VIVID_DARK_STROKES.ORANGE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: VIVID_DARK_FILLS.GRAY,\r\n            stroke: VIVID_DARK_STROKES.GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, VividDark.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, VividDark.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, VividDark.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            VIVID_DARK_FILLS.ORANGE,\r\n            VIVID_DARK_FILLS.YELLOW,\r\n            VIVID_DARK_FILLS.GREEN,\r\n        ]);\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, VividDark.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette$1;\r\n    }\r\n}\n\nconst VIVID_FILLS = {\r\n    BLUE: '#0083ff',\r\n    ORANGE: '#ff6600',\r\n    GREEN: '#00af00',\r\n    CYAN: '#00ccff',\r\n    YELLOW: '#f7c700',\r\n    VIOLET: '#ac26ff',\r\n    GRAY: '#a7a7b7',\r\n    MAGENTA: '#e800c5',\r\n    BROWN: '#b54300',\r\n    RED: '#ff0000',\r\n};\r\nconst VIVID_STROKES = {\r\n    BLUE: '#0f68c0',\r\n    ORANGE: '#d47100',\r\n    GREEN: '#007922',\r\n    CYAN: '#009ac2',\r\n    VIOLET: '#bca400',\r\n    YELLOW: '#753cac',\r\n    GRAY: '#646464',\r\n    MAGENTA: '#9b2685',\r\n    BROWN: '#6c3b00',\r\n    RED: '#cb0021',\r\n};\r\nconst palette = {\r\n    fills: Array.from(Object.values(VIVID_FILLS)),\r\n    strokes: Array.from(Object.values(VIVID_STROKES)),\r\n};\r\nclass VividLight extends ChartTheme {\r\n    static getWaterfallSeriesDefaultPositiveColors() {\r\n        return {\r\n            fill: VIVID_FILLS.BLUE,\r\n            stroke: VIVID_STROKES.BLUE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultNegativeColors() {\r\n        return {\r\n            fill: VIVID_FILLS.ORANGE,\r\n            stroke: VIVID_STROKES.ORANGE,\r\n        };\r\n    }\r\n    static getWaterfallSeriesDefaultTotalColors() {\r\n        return {\r\n            fill: VIVID_FILLS.GRAY,\r\n            stroke: VIVID_STROKES.GRAY,\r\n        };\r\n    }\r\n    getTemplateParameters() {\r\n        const result = super.getTemplateParameters();\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS, VividLight.getWaterfallSeriesDefaultPositiveColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS, VividLight.getWaterfallSeriesDefaultNegativeColors());\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS, VividLight.getWaterfallSeriesDefaultTotalColors());\r\n        result.properties.set(DEFAULT_DIVERGING_SERIES_COLOUR_RANGE, [\r\n            VIVID_FILLS.ORANGE,\r\n            VIVID_FILLS.YELLOW,\r\n            VIVID_FILLS.GREEN,\r\n        ]);\r\n        result.properties.set(DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE, VividLight.getWaterfallSeriesDefaultTotalColors().stroke);\r\n        return result;\r\n    }\r\n    getPalette() {\r\n        return palette;\r\n    }\r\n}\n\nconst lightTheme = () => new ChartTheme();\r\nconst darkTheme = () => new DarkTheme();\r\nconst lightThemes = {\r\n    undefined: lightTheme,\r\n    null: lightTheme,\r\n    'ag-default': lightTheme,\r\n    'ag-sheets': () => new SheetsLight(),\r\n    'ag-polychroma': () => new PolychromaLight(),\r\n    'ag-vivid': () => new VividLight(),\r\n    'ag-material': () => new MaterialLight(),\r\n};\r\nconst darkThemes = {\r\n    undefined: darkTheme,\r\n    null: darkTheme,\r\n    'ag-default-dark': darkTheme,\r\n    'ag-sheets-dark': () => new SheetsDark(),\r\n    'ag-polychroma-dark': () => new PolychromaDark(),\r\n    'ag-vivid-dark': () => new VividDark(),\r\n    'ag-material-dark': () => new MaterialDark(),\r\n};\r\nconst themes$1 = Object.assign(Object.assign({}, darkThemes), lightThemes);\r\nfunction validateChartThemeObject(unknownObject) {\r\n    if (unknownObject === null) {\r\n        return undefined;\r\n    }\r\n    let valid = true;\r\n    const { baseTheme, palette, overrides } = unknownObject;\r\n    if (baseTheme !== undefined && typeof baseTheme !== 'string' && typeof baseTheme !== 'object') {\r\n        Logger.warn(`invalid theme.baseTheme type ${typeof baseTheme}, expected (string | object).`);\r\n        valid = false;\r\n    }\r\n    if (overrides !== undefined && typeof overrides !== 'object') {\r\n        Logger.warn(`invalid theme.overrides type ${typeof overrides}, expected object.`);\r\n        valid = false;\r\n    }\r\n    if (typeof palette === 'object') {\r\n        if (palette !== null) {\r\n            const { fills, strokes } = palette;\r\n            if (!Array.isArray(fills)) {\r\n                Logger.warn(`theme.overrides.fills must be a defined array`);\r\n                valid = false;\r\n            }\r\n            if (!Array.isArray(strokes)) {\r\n                Logger.warn(`theme.overrides.strokes must be a defined array`);\r\n                valid = false;\r\n            }\r\n        }\r\n    }\r\n    else if (palette !== undefined) {\r\n        Logger.warn(`invalid theme.palette type ${typeof palette}, expected object.`);\r\n        valid = false;\r\n    }\r\n    if (valid) {\r\n        return unknownObject;\r\n    }\r\n    return undefined;\r\n}\r\nfunction validateChartTheme(value) {\r\n    if (value === undefined || typeof value === 'string' || value instanceof ChartTheme) {\r\n        return value;\r\n    }\r\n    if (typeof value === 'object') {\r\n        return validateChartThemeObject(value);\r\n    }\r\n    Logger.warn(`invalid theme value type ${typeof value}, expected object.`);\r\n    return undefined;\r\n}\r\nfunction getChartTheme(unvalidatedValue) {\r\n    var _a;\r\n    // unvalidatedValue is either a built-in theme (`string | ChartTheme`) or a user defined\r\n    // theme (`AgChartTheme`). In the latter case, we can't make any assumption about the\r\n    // property types, hence why the input parameter is `unknown`. This abnormal validation\r\n    // is tech debt; the ideal solution would be to integrate user themes with the @Validate\r\n    // decorator like other chart options.\r\n    let value = validateChartTheme(unvalidatedValue);\r\n    if (value instanceof ChartTheme) {\r\n        return value;\r\n    }\r\n    if (value === undefined || typeof value === 'string') {\r\n        const stockTheme = themes$1[value];\r\n        if (stockTheme) {\r\n            return stockTheme();\r\n        }\r\n        Logger.warnOnce(`the theme [${value}] is invalid, using [ag-default] instead.`);\r\n        return lightTheme();\r\n    }\r\n    // Flatten recursive themes.\r\n    const overrides = [];\r\n    let palette;\r\n    while (typeof value === 'object') {\r\n        overrides.push((_a = value.overrides) !== null && _a !== void 0 ? _a : {});\r\n        // Use first palette found, they can't be merged.\r\n        if (value.palette && palette == null) {\r\n            palette = value.palette;\r\n        }\r\n        value = value.baseTheme;\r\n    }\r\n    overrides.reverse();\r\n    const flattenedTheme = Object.assign({ baseTheme: value, overrides: jsonMerge(overrides) }, (palette ? { palette } : {}));\r\n    const baseTheme = flattenedTheme.baseTheme ? getChartTheme(flattenedTheme.baseTheme) : lightTheme();\r\n    return new baseTheme.constructor(flattenedTheme);\r\n}\n\nfunction takeColours(context, colours, maxCount) {\r\n    const result = [];\r\n    for (let count = 0; count < maxCount; count++) {\r\n        result.push(colours[(count + context.colourIndex) % colours.length]);\r\n    }\r\n    return result;\r\n}\r\nconst noDataCloneMergeOptions = {\r\n    avoidDeepClone: ['data'],\r\n};\r\nfunction getGlobalTooltipPositionOptions(position) {\r\n    // Note: we do not need to show a warning message if the validation fails. These global tooltip options\r\n    // are already processed at the root of the chart options. Logging a message here would trigger duplicate\r\n    // validation warnings.\r\n    if (position === undefined || typeof position !== 'object' || position === null) {\r\n        return {};\r\n    }\r\n    const { type, xOffset, yOffset } = position;\r\n    const result = {};\r\n    const AgTooltipPositionTypeMap = { pointer: true, node: true };\r\n    const isTooltipPositionType = (value) => Object.keys(AgTooltipPositionTypeMap).includes(value);\r\n    if (typeof type === 'string' && isTooltipPositionType(type)) {\r\n        result.type = type;\r\n    }\r\n    if (typeof xOffset === 'number' && !isNaN(xOffset) && isFinite(xOffset)) {\r\n        result.xOffset = xOffset;\r\n    }\r\n    if (typeof yOffset === 'number' && !isNaN(yOffset) && isFinite(yOffset)) {\r\n        result.yOffset = yOffset;\r\n    }\r\n    return result;\r\n}\r\nfunction prepareOptions(options) {\r\n    var _a, _b, _c, _d;\r\n    sanityCheckOptions(options);\r\n    // Determine type and ensure it's explicit in the options config.\r\n    const type = optionsType(options);\r\n    const globalTooltipPositionOptions = getGlobalTooltipPositionOptions((_a = options.tooltip) === null || _a === void 0 ? void 0 : _a.position);\r\n    const checkSeriesType = (type) => {\r\n        if (type != null && !(isSeriesOptionType(type) || isEnterpriseSeriesType(type) || getSeriesDefaults(type))) {\r\n            throw new Error(`AG Charts - unknown series type: ${type}; expected one of: ${CHART_TYPES.seriesTypes}`);\r\n        }\r\n    };\r\n    checkSeriesType(type);\r\n    for (const { type: seriesType } of (_b = options.series) !== null && _b !== void 0 ? _b : []) {\r\n        if (seriesType == null)\r\n            continue;\r\n        checkSeriesType(seriesType);\r\n    }\r\n    options = validateSoloSeries(Object.assign(Object.assign({}, options), { type }));\r\n    let defaultSeriesType = 'line';\r\n    if (isAgCartesianChartOptions(options)) {\r\n        defaultSeriesType = 'line';\r\n    }\r\n    else if (isAgHierarchyChartOptions(options)) {\r\n        defaultSeriesType = 'treemap';\r\n    }\r\n    else if (isAgPolarChartOptions(options)) {\r\n        defaultSeriesType = 'pie';\r\n    }\r\n    let defaultOverrides = getSeriesDefaults(type);\r\n    if (isDefaultAxisSwapNeeded(options)) {\r\n        defaultOverrides = swapAxes(defaultOverrides);\r\n    }\r\n    defaultOverrides = executeCustomDefaultsFunctions(options, defaultOverrides);\r\n    const conflictOverrides = resolveModuleConflicts(options);\r\n    removeDisabledOptions(options);\r\n    const { context, mergedOptions, axesThemes, seriesThemes, theme } = prepareMainOptions(defaultOverrides, options, conflictOverrides);\r\n    // Special cases where we have arrays of elements which need their own defaults.\r\n    // Apply series themes before calling processSeriesOptions() as it reduces and renames some\r\n    // properties, and in that case then cannot correctly have themes applied.\r\n    mergedOptions.series = processSeriesOptions(mergedOptions, ((_c = mergedOptions.series) !== null && _c !== void 0 ? _c : []).map((s) => {\r\n        var _a;\r\n        const type = (_a = s.type) !== null && _a !== void 0 ? _a : defaultSeriesType;\r\n        const mergedSeries = mergeSeriesOptions(s, type, seriesThemes, globalTooltipPositionOptions);\r\n        if (type === 'pie') {\r\n            preparePieOptions(seriesThemes.pie, s, mergedSeries);\r\n        }\r\n        return mergedSeries;\r\n    }))\r\n        .map((s) => prepareSeries(context, s))\r\n        .map((s) => theme.templateTheme(s));\r\n    const checkAxisType = (type) => {\r\n        const isAxisType = isAxisOptionType(type);\r\n        if (!isAxisType) {\r\n            Logger.warnOnce(`unknown axis type: ${type}; expected one of: ${AXIS_TYPES.axesTypes}, ignoring.`);\r\n        }\r\n        return isAxisType;\r\n    };\r\n    if ('axes' in mergedOptions) {\r\n        let validAxesTypes = true;\r\n        for (const { type: axisType } of (_d = mergedOptions.axes) !== null && _d !== void 0 ? _d : []) {\r\n            validAxesTypes && (validAxesTypes = checkAxisType(axisType));\r\n        }\r\n        const axisSource = validAxesTypes ? mergedOptions.axes : defaultOverrides.axes;\r\n        mergedOptions.axes = axisSource === null || axisSource === void 0 ? void 0 : axisSource.map((axis) => {\r\n            var _a, _b, _c, _d, _e;\r\n            const axisType = axis.type;\r\n            let axisDefaults;\r\n            if (validAxesTypes) {\r\n                axisDefaults = (_a = defaultOverrides.axes) === null || _a === void 0 ? void 0 : _a.find(({ type }) => type === axisType);\r\n            }\r\n            const axesTheme = jsonMerge([\r\n                (_b = axesThemes[axisType]) !== null && _b !== void 0 ? _b : {},\r\n                (_e = (_c = axesThemes[axisType]) === null || _c === void 0 ? void 0 : _c[(_d = axis.position) !== null && _d !== void 0 ? _d : 'unknown']) !== null && _e !== void 0 ? _e : {},\r\n                axisDefaults,\r\n            ]);\r\n            return prepareAxis(axis, axesTheme);\r\n        });\r\n        prepareLegendEnabledOption(options, mergedOptions);\r\n    }\r\n    prepareEnabledOptions(options, mergedOptions);\r\n    return mergedOptions;\r\n}\r\nfunction sanityCheckOptions(options) {\r\n    const deprecatedArrayProps = {\r\n        yKeys: 'yKey',\r\n        yNames: 'yName',\r\n    };\r\n    Object.entries(deprecatedArrayProps).forEach(([oldProp, newProp]) => {\r\n        var _a;\r\n        if ((_a = options.series) === null || _a === void 0 ? void 0 : _a.some((s) => s[oldProp] != null)) {\r\n            Logger.warnOnce(`Property [series.${oldProp}] is deprecated, please use [series.${newProp}] and multiple series instead.`);\r\n        }\r\n    });\r\n}\r\nfunction hasSoloSeries(options) {\r\n    for (const series of options) {\r\n        if (isSoloSeries(series.type))\r\n            return true;\r\n    }\r\n    return false;\r\n}\r\nfunction validateSoloSeries(options) {\r\n    if (options.series === undefined || options.series.length <= 1 || !hasSoloSeries(options.series)) {\r\n        return options;\r\n    }\r\n    // If the first series is a solo-series, remove all trailing series.\r\n    // If the frist series is not a solo-series, remove all solo-series.\r\n    let series = [...options.series];\r\n    if (isSoloSeries(series[0].type)) {\r\n        Logger.warn(`series[0] of type '${series[0].type}' is incompatible with other series types. Only processing series[0]`);\r\n        series = series.slice(0, 1);\r\n    }\r\n    else {\r\n        const rejects = Array.from(new Set(series.filter((s) => isSoloSeries(s.type)).map((s) => s.type)));\r\n        Logger.warnOnce(`Unable to mix these series types with the lead series type: ${rejects}`);\r\n        series = series.filter((s) => !isSoloSeries(s.type));\r\n    }\r\n    return Object.assign(Object.assign({}, options), { series });\r\n}\r\nfunction mergeSeriesOptions(series, type, seriesThemes, globalTooltipPositionOptions) {\r\n    var _a, _b;\r\n    const mergedTooltipPosition = jsonMerge([Object.assign({}, globalTooltipPositionOptions), (_a = series.tooltip) === null || _a === void 0 ? void 0 : _a.position], noDataCloneMergeOptions);\r\n    return jsonMerge([\r\n        (_b = seriesThemes[type]) !== null && _b !== void 0 ? _b : {},\r\n        Object.assign(Object.assign({}, series), { type, tooltip: Object.assign(Object.assign({}, series.tooltip), { position: mergedTooltipPosition }) }),\r\n    ], noDataCloneMergeOptions);\r\n}\r\nfunction prepareMainOptions(defaultOverrides, options, conflictOverrides) {\r\n    const { theme, cleanedTheme, axesThemes, seriesThemes, userPalette } = prepareTheme(options);\r\n    const context = { colourIndex: 0, palette: theme.palette, userPalette, theme };\r\n    defaultOverrides = theme.templateTheme(defaultOverrides);\r\n    const mergedOptions = jsonMerge([defaultOverrides, cleanedTheme, options, conflictOverrides], noDataCloneMergeOptions);\r\n    if (!enterpriseModule.isEnterprise) {\r\n        removeUsedEnterpriseOptions(mergedOptions);\r\n    }\r\n    return { context, mergedOptions, axesThemes, seriesThemes, theme };\r\n}\r\nfunction prepareTheme(options) {\r\n    var _a;\r\n    const theme = getChartTheme(options.theme);\r\n    const themeConfig = theme.config[optionsType(options)];\r\n    const seriesThemes = Object.entries(theme.config).reduce((result, [seriesType, { series }]) => {\r\n        result[seriesType] = series;\r\n        return result;\r\n    }, {});\r\n    const userTheme = options.theme;\r\n    const userPalette = typeof userTheme === 'object' && userTheme.palette ? userTheme.palette : null;\r\n    return {\r\n        theme,\r\n        axesThemes: (_a = themeConfig === null || themeConfig === void 0 ? void 0 : themeConfig['axes']) !== null && _a !== void 0 ? _a : {},\r\n        seriesThemes: seriesThemes,\r\n        cleanedTheme: jsonMerge([themeConfig !== null && themeConfig !== void 0 ? themeConfig : {}, { axes: DELETE, series: DELETE }]),\r\n        userPalette,\r\n    };\r\n}\r\nfunction prepareSeries(context, input, ...defaults) {\r\n    const paletteOptions = calculateSeriesPalette(context, input);\r\n    // Part of the options interface, but not directly consumed by the series implementations.\r\n    const removeOptions = { stacked: DELETE, grouped: DELETE };\r\n    return jsonMerge([...defaults, paletteOptions, input, removeOptions], noDataCloneMergeOptions);\r\n}\r\nfunction calculateSeriesPalette(context, input) {\r\n    const paletteFactory = getSeriesPaletteFactory(input.type);\r\n    if (!paletteFactory) {\r\n        return {};\r\n    }\r\n    const { palette: { fills, strokes }, userPalette, theme, } = context;\r\n    const colorsCount = Math.max(fills.length, strokes.length);\r\n    return paletteFactory({\r\n        userPalette,\r\n        themeTemplateParameters: theme.getTemplateParameters(),\r\n        colorsCount,\r\n        takeColors: (count) => {\r\n            const colors = {\r\n                fills: takeColours(context, fills, count),\r\n                strokes: takeColours(context, strokes, count),\r\n            };\r\n            context.colourIndex += count;\r\n            return colors;\r\n        },\r\n    });\r\n}\r\nfunction prepareAxis(axis, axisTheme) {\r\n    // Remove redundant theme overload keys.\r\n    const removeOptions = { top: DELETE, bottom: DELETE, left: DELETE, right: DELETE };\r\n    // Special cross lines case where we have an array of cross line elements which need their own defaults.\r\n    if (axis.crossLines) {\r\n        if (!Array.isArray(axis.crossLines)) {\r\n            Logger.warn('axis[].crossLines should be an array.');\r\n            axis.crossLines = [];\r\n        }\r\n        const { crossLines: crossLinesTheme } = axisTheme;\r\n        axis.crossLines = axis.crossLines.map((crossLine) => jsonMerge([crossLinesTheme, crossLine]));\r\n    }\r\n    const cleanTheme = { crossLines: DELETE };\r\n    return jsonMerge([axisTheme, cleanTheme, axis, removeOptions], noDataCloneMergeOptions);\r\n}\r\nfunction removeDisabledOptions(options) {\r\n    // Remove configurations from all option objects with a `false` value for the `enabled` property.\r\n    jsonWalk(options, (_, visitingUserOpts) => {\r\n        if (visitingUserOpts.enabled === false) {\r\n            Object.keys(visitingUserOpts).forEach((key) => {\r\n                if (key === 'enabled')\r\n                    return;\r\n                delete visitingUserOpts[key];\r\n            });\r\n        }\r\n    }, { skip: ['data', 'theme'] });\r\n}\r\nfunction prepareLegendEnabledOption(options, mergedOptions) {\r\n    var _a, _b, _c, _d;\r\n    // Disable legend by default for single series cartesian charts\r\n    if (((_a = options.legend) === null || _a === void 0 ? void 0 : _a.enabled) !== undefined || ((_b = mergedOptions.legend) === null || _b === void 0 ? void 0 : _b.enabled) !== undefined) {\r\n        return;\r\n    }\r\n    (_c = mergedOptions.legend) !== null && _c !== void 0 ? _c : (mergedOptions.legend = {});\r\n    if (((_d = options.series) !== null && _d !== void 0 ? _d : []).length > 1) {\r\n        mergedOptions.legend.enabled = true;\r\n        return;\r\n    }\r\n    mergedOptions.legend.enabled = false;\r\n}\r\nfunction prepareEnabledOptions(options, mergedOptions) {\r\n    // Set `enabled: true` for all option objects where the user has provided values.\r\n    jsonWalk(options, (_, visitingUserOpts, visitingMergedOpts) => {\r\n        if (!visitingMergedOpts)\r\n            return;\r\n        const { _enabledFromTheme } = visitingMergedOpts;\r\n        if (_enabledFromTheme != null) {\r\n            // Do not apply special handling, base enablement on theme.\r\n            delete visitingMergedOpts._enabledFromTheme;\r\n        }\r\n        if (!('enabled' in visitingMergedOpts))\r\n            return;\r\n        if (_enabledFromTheme)\r\n            return;\r\n        if (visitingUserOpts.enabled == null) {\r\n            visitingMergedOpts.enabled = true;\r\n        }\r\n    }, { skip: ['data', 'theme'] }, mergedOptions);\r\n    // Cleanup any special properties.\r\n    jsonWalk(mergedOptions, (_, visitingMergedOpts) => {\r\n        if (visitingMergedOpts._enabledFromTheme != null) {\r\n            // Do not apply special handling, base enablement on theme.\r\n            delete visitingMergedOpts._enabledFromTheme;\r\n        }\r\n    }, { skip: ['data', 'theme'] });\r\n}\r\nfunction preparePieOptions(pieSeriesTheme, seriesOptions, mergedSeries) {\r\n    if (Array.isArray(seriesOptions.innerLabels)) {\r\n        mergedSeries.innerLabels = seriesOptions.innerLabels.map((ln) => {\r\n            return jsonMerge([pieSeriesTheme.innerLabels, ln]);\r\n        });\r\n    }\r\n    else {\r\n        mergedSeries.innerLabels = DELETE;\r\n    }\r\n}\n\nclass PolarChart extends Chart {\r\n    constructor(specialOverrides, resources) {\r\n        super(specialOverrides, resources);\r\n        this.padding = new Padding(40);\r\n        this.axisGroup.zIndex = Layers.AXIS_FOREGROUND_ZINDEX;\r\n    }\r\n    performLayout() {\r\n        const _super = Object.create(null, {\r\n            performLayout: { get: () => super.performLayout }\r\n        });\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const shrinkRect = yield _super.performLayout.call(this);\r\n            const fullSeriesRect = shrinkRect.clone();\r\n            this.computeSeriesRect(shrinkRect);\r\n            yield this.computeCircle(shrinkRect);\r\n            this.axes.forEach((axis) => axis.update());\r\n            this.hoverRect = shrinkRect;\r\n            this.layoutService.dispatchLayoutComplete({\r\n                type: 'layout-complete',\r\n                chart: { width: this.scene.width, height: this.scene.height },\r\n                clipSeries: false,\r\n                series: { rect: fullSeriesRect, paddedRect: shrinkRect, visible: true },\r\n                axes: [],\r\n            });\r\n            return shrinkRect;\r\n        });\r\n    }\r\n    updateAxes(cx, cy, radius) {\r\n        var _a, _b;\r\n        const angleAxis = this.axes.find((axis) => axis.direction === ChartAxisDirection.X);\r\n        const radiusAxis = this.axes.find((axis) => axis.direction === ChartAxisDirection.Y);\r\n        if (!(angleAxis instanceof PolarAxis) || !(radiusAxis instanceof PolarAxis)) {\r\n            return;\r\n        }\r\n        const angleScale = angleAxis.scale;\r\n        const angles = (_a = angleScale.ticks) === null || _a === void 0 ? void 0 : _a.call(angleScale).map((value) => angleScale.convert(value));\r\n        const innerRadiusRatio = radiusAxis.innerRadiusRatio;\r\n        angleAxis.innerRadiusRatio = innerRadiusRatio;\r\n        (_b = angleAxis.computeRange) === null || _b === void 0 ? void 0 : _b.call(angleAxis);\r\n        angleAxis.gridLength = radius;\r\n        radiusAxis.gridAngles = angles;\r\n        radiusAxis.gridRange = angleAxis.range;\r\n        radiusAxis.range = [radius, radius * innerRadiusRatio];\r\n        [angleAxis, radiusAxis].forEach((axis) => {\r\n            axis.translation.x = cx;\r\n            axis.translation.y = cy;\r\n            axis.calculateLayout();\r\n        });\r\n    }\r\n    computeSeriesRect(shrinkRect) {\r\n        const { seriesArea: { padding }, } = this;\r\n        shrinkRect.shrink(padding.left, 'left');\r\n        shrinkRect.shrink(padding.top, 'top');\r\n        shrinkRect.shrink(padding.right, 'right');\r\n        shrinkRect.shrink(padding.bottom, 'bottom');\r\n        this.seriesRect = shrinkRect;\r\n        this.animationRect = shrinkRect;\r\n    }\r\n    computeCircle(seriesBox) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const polarSeries = this.series.filter((series) => {\r\n                return series instanceof PolarSeries;\r\n            });\r\n            const polarAxes = this.axes.filter((axis) => {\r\n                return axis instanceof PolarAxis;\r\n            });\r\n            const setSeriesCircle = (cx, cy, r) => {\r\n                this.updateAxes(cx, cy, r);\r\n                polarSeries.forEach((series) => {\r\n                    series.centerX = cx;\r\n                    series.centerY = cy;\r\n                    series.radius = r;\r\n                });\r\n                const pieSeries = polarSeries.filter((s) => s instanceof PieSeries);\r\n                if (pieSeries.length > 1) {\r\n                    const innerRadii = pieSeries\r\n                        .map((series) => {\r\n                        const innerRadius = series.getInnerRadius();\r\n                        return { series, innerRadius };\r\n                    })\r\n                        .sort((a, b) => a.innerRadius - b.innerRadius);\r\n                    innerRadii[innerRadii.length - 1].series.surroundingRadius = undefined;\r\n                    for (let i = 0; i < innerRadii.length - 1; i++) {\r\n                        innerRadii[i].series.surroundingRadius = innerRadii[i + 1].innerRadius;\r\n                    }\r\n                }\r\n            };\r\n            const centerX = seriesBox.x + seriesBox.width / 2;\r\n            const centerY = seriesBox.y + seriesBox.height / 2;\r\n            const initialRadius = Math.max(0, Math.min(seriesBox.width, seriesBox.height) / 2);\r\n            let radius = initialRadius;\r\n            setSeriesCircle(centerX, centerY, radius);\r\n            const shake = ({ hideWhenNecessary = false } = {}) => __awaiter(this, void 0, void 0, function* () {\r\n                const labelBoxes = [];\r\n                for (const series of [...polarAxes, ...polarSeries]) {\r\n                    const box = yield series.computeLabelsBBox({ hideWhenNecessary }, seriesBox);\r\n                    if (box) {\r\n                        labelBoxes.push(box);\r\n                    }\r\n                }\r\n                if (labelBoxes.length === 0) {\r\n                    setSeriesCircle(centerX, centerY, initialRadius);\r\n                    return;\r\n                }\r\n                const labelBox = BBox.merge(labelBoxes);\r\n                const refined = this.refineCircle(labelBox, radius, seriesBox);\r\n                setSeriesCircle(refined.centerX, refined.centerY, refined.radius);\r\n                if (refined.radius === radius) {\r\n                    return;\r\n                }\r\n                radius = refined.radius;\r\n            });\r\n            yield shake(); // Initial attempt\r\n            yield shake(); // Precise attempt\r\n            yield shake(); // Just in case\r\n            yield shake({ hideWhenNecessary: true }); // Hide unnecessary labels\r\n            yield shake({ hideWhenNecessary: true }); // Final result\r\n            return { radius, centerX, centerY };\r\n        });\r\n    }\r\n    refineCircle(labelsBox, radius, seriesBox) {\r\n        const minCircleRatio = 0.5; // Prevents reduced circle to be too small\r\n        const circleLeft = -radius;\r\n        const circleTop = -radius;\r\n        const circleRight = radius;\r\n        const circleBottom = radius;\r\n        // Label padding around the circle\r\n        let padLeft = Math.max(0, circleLeft - labelsBox.x);\r\n        let padTop = Math.max(0, circleTop - labelsBox.y);\r\n        let padRight = Math.max(0, labelsBox.x + labelsBox.width - circleRight);\r\n        let padBottom = Math.max(0, labelsBox.y + labelsBox.height - circleBottom);\r\n        padLeft = padRight = Math.max(padLeft, padRight);\r\n        padTop = padBottom = Math.max(padTop, padBottom);\r\n        // Available area for the circle (after the padding will be applied)\r\n        const availCircleWidth = seriesBox.width - padLeft - padRight;\r\n        const availCircleHeight = seriesBox.height - padTop - padBottom;\r\n        let newRadius = Math.min(availCircleWidth, availCircleHeight) / 2;\r\n        const minHorizontalRadius = (minCircleRatio * seriesBox.width) / 2;\r\n        const minVerticalRadius = (minCircleRatio * seriesBox.height) / 2;\r\n        const minRadius = Math.min(minHorizontalRadius, minVerticalRadius);\r\n        if (newRadius < minRadius) {\r\n            // If the radius is too small, reduce the label padding\r\n            newRadius = minRadius;\r\n            const horizontalPadding = padLeft + padRight;\r\n            const verticalPadding = padTop + padBottom;\r\n            if (2 * newRadius + verticalPadding > seriesBox.height) {\r\n                const padHeight = seriesBox.height - 2 * newRadius;\r\n                if (Math.min(padTop, padBottom) * 2 > padHeight) {\r\n                    padTop = padHeight / 2;\r\n                    padBottom = padHeight / 2;\r\n                }\r\n                else if (padTop > padBottom) {\r\n                    padTop = padHeight - padBottom;\r\n                }\r\n                else {\r\n                    padBottom = padHeight - padTop;\r\n                }\r\n            }\r\n            if (2 * newRadius + horizontalPadding > seriesBox.width) {\r\n                const padWidth = seriesBox.width - 2 * newRadius;\r\n                if (Math.min(padLeft, padRight) * 2 > padWidth) {\r\n                    padLeft = padWidth / 2;\r\n                    padRight = padWidth / 2;\r\n                }\r\n                else if (padLeft > padRight) {\r\n                    padLeft = padWidth - padRight;\r\n                }\r\n                else {\r\n                    padRight = padWidth - padLeft;\r\n                }\r\n            }\r\n        }\r\n        const newWidth = padLeft + 2 * newRadius + padRight;\r\n        const newHeight = padTop + 2 * newRadius + padBottom;\r\n        return {\r\n            centerX: seriesBox.x + (seriesBox.width - newWidth) / 2 + padLeft + newRadius,\r\n            centerY: seriesBox.y + (seriesBox.height - newHeight) / 2 + padTop + newRadius,\r\n            radius: newRadius,\r\n        };\r\n    }\r\n}\r\nPolarChart.className = 'PolarChart';\r\nPolarChart.type = 'polar';\n\nconst debug = Debug.create(true, 'opts');\r\nfunction chartType(options) {\r\n    if (isAgCartesianChartOptions(options)) {\r\n        return 'cartesian';\r\n    }\r\n    else if (isAgPolarChartOptions(options)) {\r\n        return 'polar';\r\n    }\r\n    else if (isAgHierarchyChartOptions(options)) {\r\n        return 'hierarchy';\r\n    }\r\n    throw new Error(`AG Chart - unknown type of chart for options with type: ${options.type}`);\r\n}\r\n/**\r\n * Factory for creating and updating instances of AgChartInstance.\r\n *\r\n * @docsInterface\r\n */\r\nclass AgCharts {\r\n    static licenseCheck(options) {\r\n        var _a, _b, _c;\r\n        if (this.licenseChecked)\r\n            return;\r\n        this.licenseManager = (_a = enterpriseModule.licenseManager) === null || _a === void 0 ? void 0 : _a.call(enterpriseModule, options);\r\n        (_b = this.licenseManager) === null || _b === void 0 ? void 0 : _b.setLicenseKey(this.licenseKey);\r\n        (_c = this.licenseManager) === null || _c === void 0 ? void 0 : _c.validateLicense();\r\n        this.licenseChecked = true;\r\n    }\r\n    static setLicenseKey(licenseKey) {\r\n        this.licenseKey = licenseKey;\r\n    }\r\n    /**\r\n     * Create a new `AgChartInstance` based upon the given configuration options.\r\n     */\r\n    static create(options) {\r\n        var _a, _b, _c;\r\n        this.licenseCheck(options);\r\n        const chart = AgChartsInternal.createOrUpdate(options);\r\n        if ((_a = this.licenseManager) === null || _a === void 0 ? void 0 : _a.isDisplayWatermark()) {\r\n            (_b = enterpriseModule.injectWatermark) === null || _b === void 0 ? void 0 : _b.call(enterpriseModule, (_c = options.document) !== null && _c !== void 0 ? _c : document, chart.chart.element, this.licenseManager.getWatermarkMessage());\r\n        }\r\n        return chart;\r\n    }\r\n    /**\r\n     * Update an existing `AgChartInstance`. Options provided should be complete and not\r\n     * partial.\r\n     *\r\n     * __NOTE__: As each call could trigger a chart redraw, multiple calls to update options in\r\n     * quick succession could result in undesirable flickering, so callers should batch up and/or\r\n     * debounce changes to avoid unintended partial update renderings.\r\n     */\r\n    static update(chart, options) {\r\n        if (!AgChartInstanceProxy.isInstance(chart)) {\r\n            throw new Error(AgCharts.INVALID_CHART_REF_MESSAGE);\r\n        }\r\n        AgChartsInternal.createOrUpdate(options, chart);\r\n    }\r\n    /**\r\n     * Update an existing `AgChartInstance` by applying a partial set of option changes.\r\n     *\r\n     * __NOTE__: As each call could trigger a chart redraw, each individual delta options update\r\n     * should leave the chart in a valid options state. Also, multiple calls to update options in\r\n     * quick succession could result in undesirable flickering, so callers should batch up and/or\r\n     * debounce changes to avoid unintended partial update renderings.\r\n     */\r\n    static updateDelta(chart, deltaOptions) {\r\n        if (!AgChartInstanceProxy.isInstance(chart)) {\r\n            throw new Error(AgCharts.INVALID_CHART_REF_MESSAGE);\r\n        }\r\n        AgChartsInternal.updateUserDelta(chart, deltaOptions);\r\n    }\r\n    /**\r\n     * Starts a browser-based image download for the given `AgChartInstance`.\r\n     */\r\n    static download(chart, options) {\r\n        if (!(chart instanceof AgChartInstanceProxy)) {\r\n            throw new Error(AgCharts.INVALID_CHART_REF_MESSAGE);\r\n        }\r\n        AgChartsInternal.download(chart, options);\r\n    }\r\n    /**\r\n     * Returns a base64-encoded image data URL for the given `AgChartInstance`.\r\n     */\r\n    static getImageDataURL(chart, options) {\r\n        if (!(chart instanceof AgChartInstanceProxy)) {\r\n            throw new Error(AgCharts.INVALID_CHART_REF_MESSAGE);\r\n        }\r\n        return AgChartsInternal.getImageDataURL(chart, options);\r\n    }\r\n}\r\nAgCharts.INVALID_CHART_REF_MESSAGE = 'AG Charts - invalid chart reference passed';\r\nAgCharts.licenseChecked = false;\r\n/** @deprecated use AgCharts instead */\r\nclass AgChart {\r\n    static warnDeprecated(memberName) {\r\n        const warnDeprecated = createDeprecationWarning();\r\n        warnDeprecated(`AgChart.${memberName}`, `Use AgCharts.${memberName} instead`);\r\n    }\r\n    static create(options) {\r\n        AgChart.warnDeprecated('create');\r\n        return AgCharts.create(options);\r\n    }\r\n    static update(chart, options) {\r\n        AgChart.warnDeprecated('update');\r\n        return AgCharts.update(chart, options);\r\n    }\r\n    static updateDelta(chart, deltaOptions) {\r\n        AgChart.warnDeprecated('updateDelta');\r\n        return AgCharts.updateDelta(chart, deltaOptions);\r\n    }\r\n    static download(chart, options) {\r\n        AgChart.warnDeprecated('download');\r\n        return AgCharts.download(chart, options);\r\n    }\r\n    static getImageDataURL(chart, options) {\r\n        AgChart.warnDeprecated('getImageDataURL');\r\n        return AgCharts.getImageDataURL(chart, options);\r\n    }\r\n}\r\nclass AgChartsInternal {\r\n    static initialiseModules() {\r\n        if (AgChartsInternal.initialised)\r\n            return;\r\n        registerInbuiltModules();\r\n        setupModules();\r\n        AgChartsInternal.initialised = true;\r\n    }\r\n    static createOrUpdate(userOptions, proxy) {\r\n        var _a;\r\n        var _b;\r\n        AgChartsInternal.initialiseModules();\r\n        debug('>>> AgChartV2.createOrUpdate() user options', userOptions);\r\n        const { overrideDevicePixelRatio, document, window: userWindow } = userOptions, chartOptions = __rest(userOptions, [\"overrideDevicePixelRatio\", \"document\", \"window\"]);\r\n        const specialOverrides = { overrideDevicePixelRatio, document, window: userWindow };\r\n        const processedOptions = prepareOptions(chartOptions);\r\n        let chart = proxy === null || proxy === void 0 ? void 0 : proxy.chart;\r\n        if (chart == null || chartType(chartOptions) !== chartType(chart.processedOptions)) {\r\n            chart = AgChartsInternal.createChartInstance(processedOptions, specialOverrides, chart);\r\n        }\r\n        if (proxy == null) {\r\n            proxy = new AgChartInstanceProxy(chart);\r\n        }\r\n        else {\r\n            proxy.chart = chart;\r\n        }\r\n        if (Debug.check() && typeof window !== 'undefined') {\r\n            (_a = (_b = window).agChartInstances) !== null && _a !== void 0 ? _a : (_b.agChartInstances = {});\r\n            window.agChartInstances[chart.id] = chart;\r\n        }\r\n        const chartToUpdate = chart;\r\n        chartToUpdate.queuedUserOptions.push(chartOptions);\r\n        const dequeue = () => {\r\n            // If there are a lot of update calls, `requestFactoryUpdate()` may skip callbacks,\r\n            // so we need to remove all queue items up to the last successfully applied item.\r\n            const queuedOptionsIdx = chartToUpdate.queuedUserOptions.indexOf(chartOptions);\r\n            chartToUpdate.queuedUserOptions.splice(0, queuedOptionsIdx);\r\n        };\r\n        chartToUpdate.requestFactoryUpdate(() => __awaiter(this, void 0, void 0, function* () {\r\n            // Chart destroyed, skip processing.\r\n            if (chartToUpdate.destroyed)\r\n                return;\r\n            const deltaOptions = jsonDiff(chartToUpdate.processedOptions, processedOptions);\r\n            if (deltaOptions == null) {\r\n                dequeue();\r\n                return;\r\n            }\r\n            yield AgChartsInternal.updateDelta(chartToUpdate, deltaOptions, chartOptions);\r\n            dequeue();\r\n        }));\r\n        return proxy;\r\n    }\r\n    static updateUserDelta(proxy, deltaOptions) {\r\n        var _a;\r\n        const { chart, chart: { queuedUserOptions }, } = proxy;\r\n        const lastUpdateOptions = (_a = queuedUserOptions[queuedUserOptions.length - 1]) !== null && _a !== void 0 ? _a : chart.userOptions;\r\n        const userOptions = jsonMerge([lastUpdateOptions, deltaOptions]);\r\n        debug('>>> AgChartV2.updateUserDelta() user delta', deltaOptions);\r\n        debug('AgChartV2.updateUserDelta() - base options', lastUpdateOptions);\r\n        AgChartsInternal.createOrUpdate(userOptions, proxy);\r\n    }\r\n    /**\r\n     * Returns the content of the current canvas as an image.\r\n     * @param opts The download options including `width` and `height` of the image as well as `fileName` and `fileFormat`.\r\n     */\r\n    static download(proxy, opts) {\r\n        const asyncDownload = () => __awaiter(this, void 0, void 0, function* () {\r\n            const maybeClone = yield AgChartsInternal.prepareResizedChart(proxy, opts);\r\n            const { chart } = maybeClone;\r\n            chart.scene.download(opts === null || opts === void 0 ? void 0 : opts.fileName, opts === null || opts === void 0 ? void 0 : opts.fileFormat);\r\n            if (maybeClone !== proxy) {\r\n                maybeClone.destroy();\r\n            }\r\n        });\r\n        asyncDownload().catch((e) => Logger.errorOnce(e));\r\n    }\r\n    static getImageDataURL(proxy, opts) {\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const maybeClone = yield AgChartsInternal.prepareResizedChart(proxy, opts);\r\n            const { chart } = maybeClone;\r\n            const result = chart.scene.canvas.getDataURL(opts === null || opts === void 0 ? void 0 : opts.fileFormat);\r\n            if (maybeClone !== proxy) {\r\n                maybeClone.destroy();\r\n            }\r\n            return result;\r\n        });\r\n    }\r\n    static prepareResizedChart(proxy, opts) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            const { chart } = proxy;\r\n            let { width, height } = opts !== null && opts !== void 0 ? opts : {};\r\n            const currentWidth = chart.width;\r\n            const currentHeight = chart.height;\r\n            const unchanged = (width === undefined && height === undefined) ||\r\n                (chart.scene.canvas.pixelRatio === 1 && currentWidth === width && currentHeight === height);\r\n            if (unchanged) {\r\n                return proxy;\r\n            }\r\n            width !== null && width !== void 0 ? width : (width = currentWidth);\r\n            height !== null && height !== void 0 ? height : (height = currentHeight);\r\n            const options = Object.assign(Object.assign({}, chart.userOptions), { container: document.createElement('div'), width,\r\n                height, autoSize: false, overrideDevicePixelRatio: 1 });\r\n            if (hasRegisteredEnterpriseModules()) {\r\n                // Disable enterprise features that may interfere with image generation.\r\n                (_a = options.animation) !== null && _a !== void 0 ? _a : (options.animation = {});\r\n                options.animation.enabled = false;\r\n            }\r\n            const clonedChart = AgChartsInternal.createOrUpdate(options);\r\n            yield clonedChart.chart.waitForUpdate();\r\n            return clonedChart;\r\n        });\r\n    }\r\n    static createChartInstance(options, specialOverrides, oldChart) {\r\n        const transferableResource = oldChart === null || oldChart === void 0 ? void 0 : oldChart.destroy({ keepTransferableResources: true });\r\n        if (isAgCartesianChartOptions(options)) {\r\n            return new CartesianChart(specialOverrides, transferableResource);\r\n        }\r\n        else if (isAgHierarchyChartOptions(options)) {\r\n            return new HierarchyChart(specialOverrides, transferableResource);\r\n        }\r\n        else if (isAgPolarChartOptions(options)) {\r\n            return new PolarChart(specialOverrides, transferableResource);\r\n        }\r\n        throw new Error(`AG Charts - couldn't apply configuration, check options are correctly structured and series types are specified`);\r\n    }\r\n    static updateDelta(chart, processedOptions, userOptions) {\r\n        var _a;\r\n        return __awaiter(this, void 0, void 0, function* () {\r\n            if (processedOptions.type == null) {\r\n                processedOptions = Object.assign(Object.assign({}, processedOptions), { type: (_a = chart.processedOptions.type) !== null && _a !== void 0 ? _a : optionsType(processedOptions) });\r\n            }\r\n            if (chart.destroyed)\r\n                return;\r\n            debug('AgChartV2.updateDelta() - applying delta', processedOptions);\r\n            applyChartOptions(chart, processedOptions, userOptions);\r\n        });\r\n    }\r\n}\r\nAgChartsInternal.initialised = false;\r\nfunction applyChartOptions(chart, processedOptions, userOptions) {\r\n    var _a, _b, _c, _d;\r\n    const completeOptions = jsonMerge([(_a = chart.processedOptions) !== null && _a !== void 0 ? _a : {}, processedOptions], noDataCloneMergeOptions);\r\n    const modulesChanged = applyModules(chart, completeOptions);\r\n    const skip = ['type', 'data', 'series', 'listeners', 'theme', 'legend.listeners'];\r\n    if (isAgCartesianChartOptions(processedOptions) || isAgPolarChartOptions(processedOptions)) {\r\n        // Append axes to defaults.\r\n        skip.push('axes');\r\n    }\r\n    else if (isAgHierarchyChartOptions(processedOptions)) ;\r\n    else {\r\n        throw new Error(`AG Charts - couldn't apply configuration, check type of options and chart: ${processedOptions['type']}`);\r\n    }\r\n    // Needs to be done before applying the series to detect if a seriesNode[Double]Click listener has been added\r\n    if (processedOptions.listeners) {\r\n        registerListeners(chart, processedOptions.listeners);\r\n    }\r\n    applyOptionValues(chart, processedOptions, { skip });\r\n    let forceNodeDataRefresh = false;\r\n    let seriesRecreated = false;\r\n    if (processedOptions.series && processedOptions.series.length > 0) {\r\n        seriesRecreated = applySeries(chart, processedOptions);\r\n        forceNodeDataRefresh = true;\r\n    }\r\n    if ('axes' in completeOptions && Array.isArray(completeOptions.axes)) {\r\n        const axesPresent = applyAxes(chart, completeOptions, seriesRecreated);\r\n        if (axesPresent) {\r\n            forceNodeDataRefresh = true;\r\n        }\r\n    }\r\n    const seriesOpts = processedOptions.series;\r\n    const seriesDataUpdate = !!processedOptions.data || (seriesOpts === null || seriesOpts === void 0 ? void 0 : seriesOpts.some((s) => s.data != null));\r\n    const legendKeys = getLegendKeys();\r\n    const optionsHaveLegend = Object.values(legendKeys).some((legendKey) => processedOptions[legendKey] != null);\r\n    const otherRefreshUpdate = processedOptions.title != null && processedOptions.subtitle != null;\r\n    forceNodeDataRefresh = forceNodeDataRefresh || seriesDataUpdate || optionsHaveLegend || otherRefreshUpdate;\r\n    if (processedOptions.data) {\r\n        chart.data = processedOptions.data;\r\n    }\r\n    if ((_b = processedOptions.legend) === null || _b === void 0 ? void 0 : _b.listeners) {\r\n        Object.assign(chart.legend.listeners, (_c = processedOptions.legend.listeners) !== null && _c !== void 0 ? _c : {});\r\n    }\r\n    if (processedOptions.listeners) {\r\n        chart.updateAllSeriesListeners();\r\n    }\r\n    chart.processedOptions = completeOptions;\r\n    chart.userOptions = jsonMerge([(_d = chart.userOptions) !== null && _d !== void 0 ? _d : {}, userOptions], noDataCloneMergeOptions);\r\n    const majorChange = forceNodeDataRefresh || modulesChanged;\r\n    const updateType = majorChange ? ChartUpdateType.PROCESS_DATA : ChartUpdateType.PERFORM_LAYOUT;\r\n    debug('AgChartV2.applyChartOptions() - update type', ChartUpdateType[updateType]);\r\n    chart.update(updateType, { forceNodeDataRefresh, newAnimationBatch: true });\r\n}\r\nfunction applyModules(chart, options) {\r\n    const matchingChartType = (module) => {\r\n        return ((chart instanceof CartesianChart && module.chartTypes.includes('cartesian')) ||\r\n            (chart instanceof PolarChart && module.chartTypes.includes('polar')) ||\r\n            (chart instanceof HierarchyChart && module.chartTypes.includes('hierarchy')));\r\n    };\r\n    let modulesChanged = false;\r\n    const processModules = (moduleType, add, remove) => {\r\n        const modules = REGISTERED_MODULES.filter((m) => m.type === moduleType);\r\n        for (const next of modules) {\r\n            const shouldBeEnabled = matchingChartType(next) && options[next.optionsKey] != null;\r\n            const isEnabled = chart.isModuleEnabled(next);\r\n            if (shouldBeEnabled === isEnabled)\r\n                continue;\r\n            modulesChanged = true;\r\n            if (shouldBeEnabled) {\r\n                add(next);\r\n            }\r\n            else {\r\n                remove(next);\r\n            }\r\n        }\r\n    };\r\n    processModules('root', (next) => chart.addModule(next), (next) => chart.removeModule(next));\r\n    processModules('legend', (next) => chart.addLegendModule(next), (next) => chart.removeLegendModule(next));\r\n    return modulesChanged;\r\n}\r\nfunction applySeries(chart, options) {\r\n    const optSeries = options.series;\r\n    if (!optSeries) {\r\n        return false;\r\n    }\r\n    const keysToConsider = ['type', 'direction', 'xKey', 'yKey', 'sizeKey', 'angleKey', 'stacked', 'stackGroup'];\r\n    let matchingTypes = chart.series.length === optSeries.length;\r\n    for (let i = 0; i < chart.series.length && matchingTypes; i++) {\r\n        for (const key of keysToConsider) {\r\n            matchingTypes && (matchingTypes = chart.series[i][key] === optSeries[i][key]);\r\n        }\r\n    }\r\n    // Try to optimise series updates if series count and types didn't change.\r\n    if (matchingTypes) {\r\n        chart.series.forEach((s, i) => {\r\n            var _a, _b, _c, _d;\r\n            const previousOpts = (_c = (_b = (_a = chart.processedOptions) === null || _a === void 0 ? void 0 : _a.series) === null || _b === void 0 ? void 0 : _b[i]) !== null && _c !== void 0 ? _c : {};\r\n            const seriesDiff = jsonDiff(previousOpts, (_d = optSeries[i]) !== null && _d !== void 0 ? _d : {});\r\n            if (!seriesDiff) {\r\n                return;\r\n            }\r\n            debug(`AgChartV2.applySeries() - applying series diff idx ${i}`, seriesDiff);\r\n            applySeriesValues(s, seriesDiff, { path: `series[${i}]`, index: i });\r\n            s.markNodeDataDirty();\r\n        });\r\n        return false;\r\n    }\r\n    debug(`AgChartV2.applySeries() - creating new series instances`);\r\n    chart.series = createSeries(chart, optSeries);\r\n    return true;\r\n}\r\nfunction applyAxes(chart, options, forceRecreate) {\r\n    const optAxes = options.axes;\r\n    if (!optAxes) {\r\n        return false;\r\n    }\r\n    const matchingTypes = !forceRecreate &&\r\n        chart.axes.length === optAxes.length &&\r\n        chart.axes.every((a, i) => a.type === optAxes[i].type);\r\n    // Try to optimise series updates if series count and types didn't change.\r\n    if (matchingTypes) {\r\n        const oldOpts = chart.processedOptions;\r\n        if (isAgCartesianChartOptions(oldOpts)) {\r\n            chart.axes.forEach((a, i) => {\r\n                var _a, _b;\r\n                const previousOpts = (_b = (_a = oldOpts.axes) === null || _a === void 0 ? void 0 : _a[i]) !== null && _b !== void 0 ? _b : {};\r\n                const axisDiff = jsonDiff(previousOpts, optAxes[i]);\r\n                debug(`AgChartV2.applyAxes() - applying axis diff idx ${i}`, axisDiff);\r\n                const path = `axes[${i}]`;\r\n                const skip = ['axes[].type'];\r\n                applyOptionValues(a, axisDiff, { path, skip });\r\n            });\r\n            return true;\r\n        }\r\n    }\r\n    chart.axes = createAxis(chart, optAxes);\r\n    return true;\r\n}\r\nfunction createSeries(chart, options) {\r\n    var _a;\r\n    const series = [];\r\n    const moduleContext = chart.getModuleContext();\r\n    let index = 0;\r\n    for (const seriesOptions of options !== null && options !== void 0 ? options : []) {\r\n        const path = `series[${index++}]`;\r\n        const type = (_a = seriesOptions.type) !== null && _a !== void 0 ? _a : 'unknown';\r\n        if (isEnterpriseSeriesType(type) && !isEnterpriseSeriesTypeLoaded(type)) {\r\n            continue;\r\n        }\r\n        const seriesInstance = getSeries(type, moduleContext);\r\n        applySeriesOptionModules(seriesInstance, seriesOptions);\r\n        applySeriesValues(seriesInstance, seriesOptions, { path, index });\r\n        series.push(seriesInstance);\r\n    }\r\n    return series;\r\n}\r\nfunction applySeriesOptionModules(series, options) {\r\n    const seriesOptionModules = REGISTERED_MODULES.filter((m) => m.type === 'series-option');\r\n    for (const mod of seriesOptionModules) {\r\n        const supportedSeriesTypes = mod.seriesTypes;\r\n        if (mod.optionsKey in options && supportedSeriesTypes.includes(series.type)) {\r\n            series.getModuleMap().addModule(mod);\r\n        }\r\n    }\r\n}\r\nfunction createAxis(chart, options) {\r\n    const axes = [];\r\n    const skip = ['axes[].type'];\r\n    const moduleContext = chart.getModuleContext();\r\n    let index = 0;\r\n    for (const axisOptions of options !== null && options !== void 0 ? options : []) {\r\n        const axis = getAxis(axisOptions.type, moduleContext);\r\n        const path = `axes[${index++}]`;\r\n        applyAxisModules(axis, axisOptions);\r\n        applyOptionValues(axis, axisOptions, { path, skip });\r\n        axes.push(axis);\r\n    }\r\n    return axes;\r\n}\r\nfunction applyAxisModules(axis, options) {\r\n    let modulesChanged = false;\r\n    const rootModules = REGISTERED_MODULES.filter((m) => m.type === 'axis-option');\r\n    for (const next of rootModules) {\r\n        const shouldBeEnabled = options[next.optionsKey] != null;\r\n        const moduleMap = axis.getModuleMap();\r\n        const isEnabled = moduleMap.isModuleEnabled(next);\r\n        if (shouldBeEnabled === isEnabled)\r\n            continue;\r\n        modulesChanged = true;\r\n        if (shouldBeEnabled) {\r\n            moduleMap.addModule(next);\r\n        }\r\n        else {\r\n            moduleMap.removeModule(next);\r\n        }\r\n    }\r\n    return modulesChanged;\r\n}\r\nfunction registerListeners(source, listeners) {\r\n    source.clearEventListeners();\r\n    const entries = Object.entries(listeners !== null && listeners !== void 0 ? listeners : {});\r\n    for (const [property, listener] of entries) {\r\n        if (typeof listener !== 'function')\r\n            continue;\r\n        source.addEventListener(property, listener);\r\n    }\r\n}\r\nfunction applyOptionValues(target, options, { skip, path } = {}) {\r\n    const applyOpts = Object.assign(Object.assign(Object.assign({}, getJsonApplyOptions()), { skip }), (path ? { path } : {}));\r\n    return jsonApply(target, options, applyOpts);\r\n}\r\nfunction applySeriesValues(target, options, { path, index } = {}) {\r\n    var _a, _b;\r\n    const skip = ['series[].listeners', 'series[].seriesGrouping'];\r\n    const jsonApplyOptions = getJsonApplyOptions();\r\n    const ctrs = (_a = jsonApplyOptions.constructors) !== null && _a !== void 0 ? _a : {};\r\n    const seriesTypeOverrides = {\r\n        constructors: Object.assign(Object.assign({}, ctrs), { title: target.type === 'pie' ? PieTitle : ctrs['title'] }),\r\n    };\r\n    const applyOpts = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, jsonApplyOptions), seriesTypeOverrides), { skip: ['series[].type', ...(skip !== null && skip !== void 0 ? skip : [])] }), (path ? { path } : {})), { idx: index !== null && index !== void 0 ? index : -1 });\r\n    const result = jsonApply(target, options, applyOpts);\r\n    if ((options === null || options === void 0 ? void 0 : options.listeners) != null) {\r\n        registerListeners(target, options.listeners);\r\n    }\r\n    const { seriesGrouping } = options;\r\n    if ('seriesGrouping' in (options !== null && options !== void 0 ? options : {})) {\r\n        if (seriesGrouping) {\r\n            target.seriesGrouping = Object.freeze(Object.assign(Object.assign({}, ((_b = target.seriesGrouping) !== null && _b !== void 0 ? _b : {})), seriesGrouping));\r\n        }\r\n        else {\r\n            target.seriesGrouping = seriesGrouping;\r\n        }\r\n    }\r\n    return result;\r\n}\n\n// DO NOT UPDATE MANUALLY: Generated from script during build time\r\nconst VERSION = '9.0.1';\n\nconst themes = Object.entries(themes$1).reduce((obj, [name, factory]) => {\r\n    obj[name] = factory();\r\n    return obj;\r\n}, {});\n\nvar integratedChartsTheme = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    themes: themes,\n    getChartTheme: getChartTheme,\n    ChartTheme: ChartTheme,\n    EXTENDS_CHART_DEFAULTS: EXTENDS_CHART_DEFAULTS,\n    EXTENDS_LEGEND_DEFAULTS: EXTENDS_LEGEND_DEFAULTS,\n    EXTENDS_LEGEND_ITEM_DEFAULTS: EXTENDS_LEGEND_ITEM_DEFAULTS,\n    EXTENDS_LEGEND_ITEM_MARKER_DEFAULTS: EXTENDS_LEGEND_ITEM_MARKER_DEFAULTS,\n    EXTENDS_AXES_DEFAULTS: EXTENDS_AXES_DEFAULTS,\n    EXTENDS_AXES_LABEL_DEFAULTS: EXTENDS_AXES_LABEL_DEFAULTS,\n    EXTENDS_AXES_LINE_DEFAULTS: EXTENDS_AXES_LINE_DEFAULTS,\n    EXTENDS_AXES_TICK_DEFAULTS: EXTENDS_AXES_TICK_DEFAULTS,\n    EXTENDS_AXES_GRID_LINE_DEFAULTS: EXTENDS_AXES_GRID_LINE_DEFAULTS,\n    EXTENDS_SERIES_DEFAULTS: EXTENDS_SERIES_DEFAULTS,\n    EXTENDS_CARTESIAN_MARKER_DEFAULTS: EXTENDS_CARTESIAN_MARKER_DEFAULTS,\n    OVERRIDE_SERIES_LABEL_DEFAULTS: OVERRIDE_SERIES_LABEL_DEFAULTS,\n    DEFAULT_FONT_FAMILY: DEFAULT_FONT_FAMILY,\n    DEFAULT_LABEL_COLOUR: DEFAULT_LABEL_COLOUR,\n    DEFAULT_INVERTED_LABEL_COLOUR: DEFAULT_INVERTED_LABEL_COLOUR,\n    DEFAULT_INSIDE_SERIES_LABEL_COLOUR: DEFAULT_INSIDE_SERIES_LABEL_COLOUR,\n    DEFAULT_MUTED_LABEL_COLOUR: DEFAULT_MUTED_LABEL_COLOUR,\n    DEFAULT_AXIS_GRID_COLOUR: DEFAULT_AXIS_GRID_COLOUR,\n    DEFAULT_AXIS_LINE_COLOUR: DEFAULT_AXIS_LINE_COLOUR,\n    DEFAULT_CROSS_LINES_COLOUR: DEFAULT_CROSS_LINES_COLOUR,\n    DEFAULT_BACKGROUND_COLOUR: DEFAULT_BACKGROUND_COLOUR,\n    DEFAULT_SHADOW_COLOUR: DEFAULT_SHADOW_COLOUR,\n    DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS: DEFAULT_WATERFALL_SERIES_POSITIVE_COLOURS,\n    DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS: DEFAULT_WATERFALL_SERIES_NEGATIVE_COLOURS,\n    DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS: DEFAULT_WATERFALL_SERIES_TOTAL_COLOURS,\n    DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE: DEFAULT_WATERFALL_SERIES_CONNECTOR_LINE_STROKE,\n    DEFAULT_POLAR_SERIES_STROKE: DEFAULT_POLAR_SERIES_STROKE,\n    DEFAULT_DIVERGING_SERIES_COLOUR_RANGE: DEFAULT_DIVERGING_SERIES_COLOUR_RANGE,\n    DEFAULT_HIERARCHY_FILLS: DEFAULT_HIERARCHY_FILLS,\n    DEFAULT_HIERARCHY_STROKES: DEFAULT_HIERARCHY_STROKES,\n    FONT_SIZE: FONT_SIZE,\n    BOLD: BOLD,\n    NORMAL: NORMAL,\n    BOTTOM: BOTTOM,\n    CARTESIAN_AXIS_POSITIONS: CARTESIAN_AXIS_POSITIONS,\n    CARTESIAN_AXIS_TYPES: CARTESIAN_AXIS_TYPES,\n    POLAR_AXIS_TYPES: POLAR_AXIS_TYPES,\n    CIRCLE: CIRCLE\n});\n\nvar sparklinesScale = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    TimeScale: TimeScale,\n    BandScale: BandScale,\n    ContinuousScale: ContinuousScale,\n    ColorScale: ColorScale,\n    LinearScale: LinearScale\n});\n\nexport { AgChart, AgCharts, AgErrorBarSupportedSeriesTypes, Marker, VERSION, moduleSupport as _ModuleSupport, sparklinesScale as _Scale, integratedChartsScene as _Scene, integratedChartsTheme as _Theme, sparklinesUtil as _Util, __FORCE_MODULE_DETECTION$1 as __FORCE_MODULE_DETECTION, index as time };\n"],"mappings":"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C,QAAQ,EAAEmjC,QAAQ,EAAE;EACrC,MAAMC,YAAY,GAAGpjC,QAAQ,CAACG,aAAa,CAAC,OAAO,CAAC;EACpDijC,YAAY,CAAC7Y,SAAS,GAAG4Y,QAAQ;EACjC;EACAnjC,QAAQ,CAACqjC,IAAI,CAACC,YAAY,CAACF,YAAY,EAAEpjC,QAAQ,CAACqjC,IAAI,CAACE,aAAa,CAAC,OAAO,CAAC,CAAC;AAClF;AAEA,MAAMC,qBAAqB,GAAG,kBAAkB;AAChD,MAAMC,0BAA0B,GAAG,uBAAuB;AAC1D,MAAMC,iBAAiB,GAAI;AAC3B,GAAGF,qBAAsB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAGA,qBAAsB;AACzB;AACA;AACA;AACA;AACA,GAAGA,qBAAsB;AACzB;AACA;AACA;AACA,GAAGA,qBAAsB;AACzB;AACA;AACA;AACA,GAAGA,qBAAsB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAGA,qBAAsB;AACzB;AACA;AACA;AACA;AACA,GAAGA,qBAAsB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAGA,qBAAsB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAGA,qBAAsB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAGA,qBAAsB,IAAGC,0BAA2B;AACvD;AACA;AACA;AACA;AACA,GAAGD,qBAAsB,IAAGC,0BAA2B,KAAID,qBAAsB;AACjF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,SAASG,aAAaA,CAAC9iD,KAAK,EAAE+iD,QAAQ,EAAE;EACpC,IAAIj8D,EAAE,EAAEwO,EAAE,EAAE6D,EAAE;EACd,IAAI,OAAO6G,KAAK,KAAK,QAAQ,EAAE;IAC3B,OAAOA,KAAK;EAChB;EACA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}